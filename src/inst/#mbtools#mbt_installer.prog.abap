REPORT /mbtools/mbt_installer.

************************************************************************
* Marc Bernard Tools - Installer
*
* Copyright (c) 2014 abapGit Contributors
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* SPDX-License-Identifier: MIT
************************************************************************

CONSTANTS:
  c_version TYPE string VALUE '1.4.7',
  c_home    TYPE string VALUE 'https://marcbernardtools.com/' ##NO_TEXT,
  c_github  TYPE string VALUE 'github.com' ##NO_TEXT.

****** INTERFACES DEFERRED ******

INTERFACE zif_abapgit_aff_types_v1 DEFERRED.
INTERFACE zif_abapgit_git_definitions DEFERRED.
INTERFACE zif_abapgit_definitions DEFERRED.
INTERFACE zif_abapgit_ajson_types DEFERRED.
INTERFACE zif_abapgit_ajson DEFERRED.
INTERFACE zif_abapgit_ajson_filter DEFERRED.
INTERFACE zif_abapgit_ajson_mapping DEFERRED.
INTERFACE zif_abapgit_cts_api DEFERRED.
INTERFACE zif_abapgit_data_config DEFERRED.
INTERFACE zif_abapgit_data_deserializer DEFERRED.
INTERFACE zif_abapgit_data_serializer DEFERRED.
INTERFACE zif_abapgit_data_supporter DEFERRED.
INTERFACE zif_abapgit_default_transport DEFERRED.
INTERFACE zif_abapgit_sap_package DEFERRED.
INTERFACE zif_abapinst_dot_abapgit DEFERRED.
INTERFACE zif_abapgit_dot_abapgit DEFERRED.
INTERFACE zif_abapgit_environment DEFERRED.
INTERFACE zif_abapgit_persistence DEFERRED.
INTERFACE zif_abapgit_objects DEFERRED.
INTERFACE zif_abapgit_exit DEFERRED.
INTERFACE zif_abapgit_frontend_services DEFERRED.
INTERFACE zif_abapgit_gui_jumper DEFERRED.
INTERFACE zif_abapgit_log DEFERRED.
INTERFACE zif_abapgit_longtexts DEFERRED.
INTERFACE zif_abapgit_lxe_texts DEFERRED.
INTERFACE zif_abapgit_i18n_file DEFERRED.
INTERFACE zif_abapgit_object DEFERRED.
INTERFACE zif_abapgit_xml_input DEFERRED.
INTERFACE zif_abapgit_sap_report DEFERRED.
INTERFACE zif_abapgit_xml_output DEFERRED.
INTERFACE zif_abapgit_lang_definitions DEFERRED.
INTERFACE zif_abapgit_oo_object_fnc DEFERRED.
INTERFACE zif_abapgit_object_enho DEFERRED.
INTERFACE zif_abapgit_aff_oo_types_v1 DEFERRED.
INTERFACE zif_abapgit_aff_intf_v1 DEFERRED.
INTERFACE zif_abapgit_object_tabl DEFERRED.
INTERFACE zif_abapgit_comparator DEFERRED.
INTERFACE zif_abapgit_progress DEFERRED.
INTERFACE zif_abapgit_sap_namespace DEFERRED.
INTERFACE zif_abapgit_tadir DEFERRED.
INTERFACE zif_abapinst_definitions DEFERRED.
INTERFACE zif_abapgit_apack_definitions DEFERRED.
INTERFACE zif_abapgit_function_module DEFERRED.
INTERFACE zif_abapgit_object_enhs DEFERRED.
INTERFACE zif_abapgit_version DEFERRED.

****** EXCEPTIONS ******

CLASS zcx_abapgit_not_found DEFINITION

  INHERITING FROM cx_static_check
  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !textid   LIKE textid OPTIONAL
        !previous LIKE previous OPTIONAL.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcx_abapgit_not_found IMPLEMENTATION.

  METHOD constructor ##ADT_SUPPRESS_GENERATION.
    super->constructor(
      textid   = textid
      previous = previous ).
  ENDMETHOD.
ENDCLASS.

class zcx_abapgit_ajson_error definition

  inheriting from CX_STATIC_CHECK
  final
  create public .

public section.

  interfaces IF_T100_MESSAGE .

  types:
    ty_rc type c length 4 .

  constants:
    begin of ZCX_AJSON_ERROR,
      msgid type symsgid value '00',
      msgno type symsgno value '001',
      attr1 type scx_attrname value 'A1',
      attr2 type scx_attrname value 'A2',
      attr3 type scx_attrname value 'A3',
      attr4 type scx_attrname value 'A4',
    end of ZCX_AJSON_ERROR .
  data RC type TY_RC read-only .
  data MESSAGE type STRING read-only .
  data LOCATION type STRING read-only .
  data A1 type SYMSGV read-only .
  data A2 type SYMSGV read-only .
  data A3 type SYMSGV read-only .
  data A4 type SYMSGV read-only .

  methods CONSTRUCTOR
    importing
      !TEXTID like IF_T100_MESSAGE=>T100KEY optional
      !PREVIOUS like PREVIOUS optional
      !RC type TY_RC optional
      !MESSAGE type STRING optional
      !LOCATION type STRING optional
      !A1 type SYMSGV optional
      !A2 type SYMSGV optional
      !A3 type SYMSGV optional
      !A4 type SYMSGV optional .
  class-methods RAISE
    importing
      !IV_MSG type STRING
      !IV_LOCATION type STRING optional
      !IS_NODE type ANY optional
    raising
      zcx_abapgit_ajson_error .
  methods SET_LOCATION
    importing
      !IV_LOCATION type STRING optional
      !IS_NODE type ANY optional
    preferred parameter IV_LOCATION .
protected section.
private section.
  types:
    begin of ty_message_parts,
      a1 like a1,
      a2 like a1,
      a3 like a1,
      a4 like a1,
    end of ty_message_parts.
ENDCLASS.

CLASS zcx_abapgit_ajson_error IMPLEMENTATION.

method CONSTRUCTOR.
CALL METHOD SUPER->CONSTRUCTOR
EXPORTING
PREVIOUS = PREVIOUS
.
me->RC = RC .
me->MESSAGE = MESSAGE .
me->LOCATION = LOCATION .
me->A1 = A1 .
me->A2 = A2 .
me->A3 = A3 .
me->A4 = A4 .
clear me->textid.
if textid is initial.
  IF_T100_MESSAGE~T100KEY = ZCX_AJSON_ERROR .
else.
  IF_T100_MESSAGE~T100KEY = TEXTID.
endif.
endmethod.

method raise.

  data lx type ref to zcx_abapgit_ajson_error.

  create object lx exporting message = iv_msg.
  lx->set_location(
    iv_location = iv_location
    is_node     = is_node ).
  raise exception lx.

endmethod.

method set_location.

  data ls_msg type ty_message_parts.
  data lv_location type string.
  data lv_tmp type string.
  field-symbols <path> type string.
  field-symbols <name> type string.

  if iv_location is not initial.
    lv_location = iv_location.
  elseif is_node is not initial.
    assign component 'PATH' of structure is_node to <path>.
    assign component 'NAME' of structure is_node to <name>.
    if <path> is assigned and <name> is assigned.
      lv_location = <path> && <name>.
    endif.
  endif.

  if lv_location is not initial.
    lv_tmp = message && | @{ lv_location }|.
  else.
    lv_tmp = message.
  endif.

  ls_msg = lv_tmp.

  location = lv_location.
  a1       = ls_msg-a1.
  a2       = ls_msg-a2.
  a3       = ls_msg-a3.
  a4       = ls_msg-a4.

endmethod.
ENDCLASS.

"! abapGit general error
CLASS zcx_abapgit_exception DEFINITION

  INHERITING FROM cx_static_check
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES if_t100_message .

    CONSTANTS:
      BEGIN OF c_section_text,
        cause           TYPE string VALUE `Cause`,
        system_response TYPE string VALUE `System response`,
        what_to_do      TYPE string VALUE `Procedure`,
        sys_admin       TYPE string VALUE `System administration`,
      END OF c_section_text .
    CONSTANTS:
      BEGIN OF c_section_token,
        cause           TYPE string VALUE `&CAUSE&`,
        system_response TYPE string VALUE `&SYSTEM_RESPONSE&`,
        what_to_do      TYPE string VALUE `&WHAT_TO_DO&`,
        sys_admin       TYPE string VALUE `&SYS_ADMIN&`,
      END OF c_section_token .

    CLASS-DATA null TYPE string.

    DATA msgv1 TYPE symsgv READ-ONLY .
    DATA msgv2 TYPE symsgv READ-ONLY .
    DATA msgv3 TYPE symsgv READ-ONLY .
    DATA msgv4 TYPE symsgv READ-ONLY .
    DATA mv_longtext TYPE string READ-ONLY.
    DATA mt_callstack TYPE abap_callstack READ-ONLY.
    DATA mi_log TYPE REF TO zif_abapgit_log READ-ONLY.

    "! Raise exception with text
    "! @parameter iv_text | Text
    "! @parameter ix_previous | Previous exception
    "! @parameter ii_log | Log
    "! @parameter iv_longtext | Longtext
    "! @raising zcx_abapgit_exception | Exception
    CLASS-METHODS raise
      IMPORTING
        !iv_text     TYPE clike
        !ix_previous TYPE REF TO cx_root OPTIONAL
        !ii_log      TYPE REF TO zif_abapgit_log OPTIONAL
        !iv_longtext TYPE csequence OPTIONAL
      RAISING
        zcx_abapgit_exception .
    "! Raise exception with T100 message
    "! <p>
    "! Will default to sy-msg* variables. These need to be set right before calling this method.
    "! </p>
    "! @parameter iv_msgid | Message ID
    "! @parameter iv_msgno | Message number
    "! @parameter iv_msgv1 | Message variable 1
    "! @parameter iv_msgv2 | Message variable 2
    "! @parameter iv_msgv3 | Message variable 3
    "! @parameter iv_msgv4 | Message variable 4
    "! @parameter ii_log | Log
    "! @parameter ix_previous | Previous exception
    "! @parameter iv_longtext | Longtext
    "! @raising zcx_abapgit_exception | Exception
    CLASS-METHODS raise_t100
      IMPORTING
        !iv_msgid    TYPE symsgid DEFAULT sy-msgid
        !iv_msgno    TYPE symsgno DEFAULT sy-msgno
        !iv_msgv1    TYPE symsgv DEFAULT sy-msgv1
        !iv_msgv2    TYPE symsgv DEFAULT sy-msgv2
        !iv_msgv3    TYPE symsgv DEFAULT sy-msgv3
        !iv_msgv4    TYPE symsgv DEFAULT sy-msgv4
        !ii_log      TYPE REF TO zif_abapgit_log OPTIONAL
        !ix_previous TYPE REF TO cx_root OPTIONAL
        !iv_longtext TYPE csequence OPTIONAL
      RAISING
        zcx_abapgit_exception .
    "! Raise with text from previous exception
    "! @parameter ix_previous | Previous exception
    "! @parameter iv_longtext | Longtext
    "! @raising zcx_abapgit_exception | Exception
    CLASS-METHODS raise_with_text
      IMPORTING
        !ix_previous TYPE REF TO cx_root
        !iv_longtext TYPE csequence OPTIONAL
      RAISING
        zcx_abapgit_exception .
    METHODS constructor
      IMPORTING
        !textid   LIKE if_t100_message=>t100key OPTIONAL
        !previous LIKE previous OPTIONAL
        !log      TYPE REF TO zif_abapgit_log OPTIONAL
        !msgv1    TYPE symsgv OPTIONAL
        !msgv2    TYPE symsgv OPTIONAL
        !msgv3    TYPE symsgv OPTIONAL
        !msgv4    TYPE symsgv OPTIONAL
        !longtext TYPE csequence OPTIONAL .

    METHODS get_source_position
        REDEFINITION .
    METHODS if_message~get_longtext
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.

    CONSTANTS c_generic_error_msg TYPE string VALUE `An error occurred (ZCX_ABAPGIT_EXCEPTION)`.

    METHODS save_callstack .
    METHODS itf_to_string
      IMPORTING
        !it_itf          TYPE tline_tab
      RETURNING
        VALUE(rv_result) TYPE string .
    METHODS get_t100_longtext_itf
      RETURNING
        VALUE(rt_itf) TYPE tline_tab .
    METHODS remove_empty_section
      IMPORTING
        !iv_tabix_from TYPE i
        !iv_tabix_to   TYPE i
      CHANGING
        !ct_itf        TYPE tline_tab .
    METHODS replace_section_head_with_text
      CHANGING
        !cs_itf TYPE tline .
    CLASS-METHODS remove_newlines_from_string
      IMPORTING
        iv_string        TYPE string
      RETURNING
        VALUE(rv_result) TYPE string.
ENDCLASS.

CLASS zcx_abapgit_exception IMPLEMENTATION.

  METHOD constructor ##ADT_SUPPRESS_GENERATION.

    super->constructor( previous = previous ).

    me->msgv1 = msgv1.
    me->msgv2 = msgv2.
    me->msgv3 = msgv3.
    me->msgv4 = msgv4.
    mi_log = log.
    mv_longtext = longtext.

    CLEAR me->textid.

    IF textid IS INITIAL.
      if_t100_message~t100key = if_t100_message=>default_textid.
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.

    save_callstack( ).

  ENDMETHOD.

  METHOD get_source_position.

    FIELD-SYMBOLS: <ls_callstack> LIKE LINE OF mt_callstack.

    READ TABLE mt_callstack ASSIGNING <ls_callstack>
                            INDEX 1.
    IF sy-subrc = 0.
      program_name = <ls_callstack>-mainprogram.
      include_name = <ls_callstack>-include.
      source_line  = <ls_callstack>-line.
    ELSE.
      super->get_source_position(
        IMPORTING
          program_name = program_name
          include_name = include_name
          source_line  = source_line ).
    ENDIF.

  ENDMETHOD.

  METHOD get_t100_longtext_itf.

    DATA: lv_docu_key TYPE doku_obj.

    FIELD-SYMBOLS <lv_msgv> TYPE any.

    lv_docu_key = if_t100_message~t100key-msgid && if_t100_message~t100key-msgno.

    CALL FUNCTION 'DOCU_GET'
      EXPORTING
        id     = 'NA'
        langu  = sy-langu
        object = lv_docu_key
        typ    = 'E'
      TABLES
        line   = rt_itf
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc = 0.
      ASSIGN me->(if_t100_message~t100key-attr1) TO <lv_msgv>.
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V1&' IN TABLE rt_itf WITH <lv_msgv>.
      ENDIF.
      ASSIGN me->(if_t100_message~t100key-attr2) TO <lv_msgv>.
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V2&' IN TABLE rt_itf WITH <lv_msgv>.
      ENDIF.
      ASSIGN me->(if_t100_message~t100key-attr3) TO <lv_msgv>.
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V3&' IN TABLE rt_itf WITH <lv_msgv>.
      ENDIF.
      ASSIGN me->(if_t100_message~t100key-attr4) TO <lv_msgv>.
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V4&' IN TABLE rt_itf WITH <lv_msgv>.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD if_message~get_longtext.
    DATA: lv_preserve_newlines_handled TYPE abap_bool VALUE abap_false.

    IF mv_longtext IS NOT INITIAL.
      result = mv_longtext.
    ELSEIF if_t100_message~t100key IS NOT INITIAL.
      result = itf_to_string( get_t100_longtext_itf( ) ).
    ELSE.
      result = super->get_longtext( preserve_newlines ).
      lv_preserve_newlines_handled = abap_true.
    ENDIF.

    IF lv_preserve_newlines_handled = abap_false AND preserve_newlines = abap_false.
      result = remove_newlines_from_string( result ).
    ENDIF.
  ENDMETHOD.

  METHOD itf_to_string.

    CONSTANTS: lc_format_section TYPE string VALUE 'U1'.

    DATA:
      lt_stream      TYPE TABLE OF tdline,
      lt_string      TYPE TABLE OF string,
      lt_itf         TYPE tline_tab,
      lv_has_content TYPE abap_bool,
      lv_tabix_from  TYPE syst-tabix,
      lv_tabix_to    TYPE syst-tabix.

    FIELD-SYMBOLS: <ls_itf_section>      TYPE tline,
                   <ls_itf_section_item> TYPE tline.

    lt_itf = it_itf.

    " You should remember that we replace the U1 format because
    " that preserves the section header of longtexts.
    LOOP AT lt_itf ASSIGNING <ls_itf_section>
                   WHERE tdformat = lc_format_section.

      CLEAR:
        lv_has_content,
        lv_tabix_to.

      lv_tabix_from = sy-tabix.

      LOOP AT lt_itf ASSIGNING <ls_itf_section_item>
                     FROM sy-tabix + 1.

        IF <ls_itf_section_item>-tdformat = lc_format_section.
          lv_tabix_to = sy-tabix.
          EXIT.
        ELSEIF <ls_itf_section_item>-tdline IS NOT INITIAL.
          lv_has_content = abap_true.
        ENDIF.

      ENDLOOP.

      IF lv_has_content = abap_false.
        remove_empty_section(
          EXPORTING
            iv_tabix_from = lv_tabix_from
            iv_tabix_to   = lv_tabix_to
          CHANGING
            ct_itf        = lt_itf ).
        CONTINUE.
      ENDIF.

      replace_section_head_with_text( CHANGING cs_itf = <ls_itf_section> ).

    ENDLOOP.

    CALL FUNCTION 'CONVERT_ITF_TO_STREAM_TEXT'
      EXPORTING
        lf           = 'X'
      IMPORTING
        stream_lines = lt_string
      TABLES
        itf_text     = lt_itf
        text_stream  = lt_stream.

    rv_result = concat_lines_of(
      table = lt_string
      sep   = cl_abap_char_utilities=>newline ).

  ENDMETHOD.

  METHOD raise.

    IF iv_text IS INITIAL.
      cl_message_helper=>set_msg_vars_for_clike( c_generic_error_msg ).
    ELSE.
      cl_message_helper=>set_msg_vars_for_clike( iv_text ).
    ENDIF.

    raise_t100(
      ii_log      = ii_log
      ix_previous = ix_previous
      iv_longtext = iv_longtext ).

  ENDMETHOD.

  METHOD raise_t100.
    DATA: ls_t100_key TYPE scx_t100key.

    ls_t100_key-msgid = iv_msgid.
    ls_t100_key-msgno = iv_msgno.
    ls_t100_key-attr1 = 'MSGV1'.
    ls_t100_key-attr2 = 'MSGV2'.
    ls_t100_key-attr3 = 'MSGV3'.
    ls_t100_key-attr4 = 'MSGV4'.

    IF iv_msgid IS INITIAL.
      CLEAR ls_t100_key.
    ENDIF.

    RAISE EXCEPTION TYPE zcx_abapgit_exception
      EXPORTING
        textid   = ls_t100_key
        log      = ii_log
        msgv1    = iv_msgv1
        msgv2    = iv_msgv2
        msgv3    = iv_msgv3
        msgv4    = iv_msgv4
        previous = ix_previous
        longtext = iv_longtext.
  ENDMETHOD.

  METHOD raise_with_text.
    raise(
      iv_text     = ix_previous->get_text( )
      ix_previous = ix_previous
      iv_longtext = iv_longtext ).
  ENDMETHOD.

  METHOD remove_empty_section.
    IF iv_tabix_to BETWEEN iv_tabix_from AND lines( ct_itf ).
      DELETE ct_itf FROM iv_tabix_from TO iv_tabix_to.
    ELSE.
      DELETE ct_itf FROM iv_tabix_from.
    ENDIF.
  ENDMETHOD.

  METHOD remove_newlines_from_string.
    rv_result = iv_string.

    REPLACE ALL OCCURRENCES OF ` ` && cl_abap_char_utilities=>cr_lf IN rv_result WITH ` `.
    REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>cr_lf IN rv_result WITH ` `.
    REPLACE ALL OCCURRENCES OF ` ` && cl_abap_char_utilities=>newline IN rv_result WITH ` `.
    REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>newline IN rv_result WITH ` `.
  ENDMETHOD.

  METHOD replace_section_head_with_text.

    CASE cs_itf-tdline.
      WHEN c_section_token-cause.
        cs_itf-tdline = c_section_text-cause.
      WHEN c_section_token-system_response.
        cs_itf-tdline = c_section_text-system_response.
      WHEN c_section_token-what_to_do.
        cs_itf-tdline = c_section_text-what_to_do.
      WHEN c_section_token-sys_admin.
        cs_itf-tdline = c_section_text-sys_admin.
    ENDCASE.

  ENDMETHOD.

  METHOD save_callstack.

    FIELD-SYMBOLS: <ls_callstack> LIKE LINE OF mt_callstack.

    CALL FUNCTION 'SYSTEM_CALLSTACK'
      IMPORTING
        callstack = mt_callstack.

    " You should remember that the first lines are from zcx_abapgit_exception
    " and are removed so that highest level in the callstack is the position where
    " the exception is raised.
    "
    " For the merged report it's hard to do that, because zcx_abapgit_exception
    " isn't visible in the callstack. Therefore we have to check the Events.
    LOOP AT mt_callstack ASSIGNING <ls_callstack>.

      IF <ls_callstack>-mainprogram CP |ZCX_ABAPGIT_EXCEPTION*| " full
      OR <ls_callstack>-blockname = `SAVE_CALLSTACK` " merged
      OR <ls_callstack>-blockname = `CONSTRUCTOR` " merged
      OR <ls_callstack>-blockname CP `RAISE*`. "merged
        DELETE TABLE mt_callstack FROM <ls_callstack>.
      ELSE.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcx_abapgit_cancel DEFINITION

  INHERITING FROM zcx_abapgit_exception
  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !textid   LIKE if_t100_message=>t100key OPTIONAL
        !previous LIKE previous OPTIONAL
        !log      TYPE REF TO zif_abapgit_log OPTIONAL
        !msgv1    TYPE symsgv OPTIONAL
        !msgv2    TYPE symsgv OPTIONAL
        !msgv3    TYPE symsgv OPTIONAL
        !msgv4    TYPE symsgv OPTIONAL
        !longtext TYPE csequence OPTIONAL.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcx_abapgit_cancel IMPLEMENTATION.

  METHOD constructor ##ADT_SUPPRESS_GENERATION.
    super->constructor(
      previous = previous
      log      = log
      msgv1    = msgv1
      msgv2    = msgv2
      msgv3    = msgv3
      msgv4    = msgv4
      longtext = longtext ).

    CLEAR me->textid.

    IF textid IS INITIAL.
      if_t100_message~t100key = if_t100_message=>default_textid.
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS zcx_abapinst_exception DEFINITION

  INHERITING FROM cx_static_check
  CREATE PUBLIC.

  PUBLIC SECTION.

    INTERFACES if_t100_message.

    CONSTANTS:
      BEGIN OF gc_section_text,
        cause           TYPE string VALUE `Cause`,
        system_response TYPE string VALUE `System response`,
        what_to_do      TYPE string VALUE `Procedure`,
        sys_admin       TYPE string VALUE `System administration`,
      END OF gc_section_text,
      BEGIN OF gc_section_token,
        cause           TYPE string VALUE `&CAUSE&`,
        system_response TYPE string VALUE `&SYSTEM_RESPONSE&`,
        what_to_do      TYPE string VALUE `&WHAT_TO_DO&`,
        sys_admin       TYPE string VALUE `&SYS_ADMIN&`,
      END OF gc_section_token.

    DATA:
      msgv1        TYPE symsgv READ-ONLY,
      msgv2        TYPE symsgv READ-ONLY,
      msgv3        TYPE symsgv READ-ONLY,
      msgv4        TYPE symsgv READ-ONLY,
      mt_callstack TYPE abap_callstack READ-ONLY.

    "! Raise exception with text
    "! @parameter iv_text | Text
    "! @parameter ix_previous | Previous exception
    "! @raising zcx_abapinst_exception | Exception
    CLASS-METHODS raise
      IMPORTING
        !iv_text     TYPE clike
        !ix_previous TYPE REF TO cx_root OPTIONAL
      RAISING
        zcx_abapinst_exception.

    "! Raise exception with T100 message
    "! <p>
    "! Will default to sy-msg* variables. These need to be set right before calling this method.
    "! </p>
    "! @parameter iv_msgid | Message ID
    "! @parameter iv_msgno | Message number
    "! @parameter iv_msgv1 | Message variable 1
    "! @parameter iv_msgv2 | Message variable 2
    "! @parameter iv_msgv3 | Message variable 3
    "! @parameter iv_msgv4 | Message variable 4
    "! @raising zcx_abapinst_exception | Exception
    CLASS-METHODS raise_t100
      IMPORTING
        VALUE(iv_msgid) TYPE symsgid DEFAULT sy-msgid
        VALUE(iv_msgno) TYPE symsgno DEFAULT sy-msgno
        VALUE(iv_msgv1) TYPE symsgv DEFAULT sy-msgv1
        VALUE(iv_msgv2) TYPE symsgv DEFAULT sy-msgv2
        VALUE(iv_msgv3) TYPE symsgv DEFAULT sy-msgv3
        VALUE(iv_msgv4) TYPE symsgv DEFAULT sy-msgv4
        !ix_previous    TYPE REF TO cx_root OPTIONAL
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS raise_with_text
      IMPORTING
        !ix_previous TYPE REF TO cx_root
      RAISING
        zcx_abapinst_exception.

    METHODS constructor
      IMPORTING
        !textid       LIKE if_t100_message=>t100key OPTIONAL
        !previous     LIKE previous OPTIONAL
        !msgv1        TYPE symsgv OPTIONAL
        !msgv2        TYPE symsgv OPTIONAL
        !msgv3        TYPE symsgv OPTIONAL
        !msgv4        TYPE symsgv OPTIONAL
        !mt_callstack TYPE abap_callstack OPTIONAL.

    METHODS get_source_position REDEFINITION.

    METHODS if_message~get_longtext REDEFINITION.
  PROTECTED SECTION.
  PRIVATE SECTION.

    CONSTANTS gc_generic_error_msg TYPE string VALUE 'An error occured (ZCX_ABAPINST_EXCEPTION)' ##NO_TEXT.

    CLASS-METHODS split_text_to_symsg
      IMPORTING
        !iv_text TYPE string.

    METHODS save_callstack.

    METHODS itf_to_string
      IMPORTING
        !it_itf          TYPE tline_tab
      RETURNING
        VALUE(rv_result) TYPE string.

    METHODS get_t100_longtext_itf
      RETURNING
        VALUE(rt_itf) TYPE tline_tab.

    METHODS remove_empty_section
      IMPORTING
        !iv_tabix_from TYPE i
        !iv_tabix_to   TYPE i
      CHANGING
        !ct_itf        TYPE tline_tab.

    METHODS replace_section_head_with_text
      CHANGING
        !cs_itf TYPE tline.

ENDCLASS.

CLASS zcx_abapinst_exception IMPLEMENTATION.

  METHOD constructor ##ADT_SUPPRESS_GENERATION.

    CALL METHOD super->constructor
      EXPORTING
        previous = previous.

    me->msgv1 = msgv1.
    me->msgv2 = msgv2.
    me->msgv3 = msgv3.
    me->msgv4 = msgv4.
    me->mt_callstack = mt_callstack.

    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = if_t100_message=>default_textid.
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.

  ENDMETHOD.

  METHOD get_source_position.

    FIELD-SYMBOLS <ls_callstack> TYPE abap_callstack_line.

    READ TABLE mt_callstack ASSIGNING <ls_callstack> INDEX 1.
    IF sy-subrc = 0.
      program_name = <ls_callstack>-mainprogram.
      include_name = <ls_callstack>-include.
      source_line  = <ls_callstack>-line.
    ELSE.
      super->get_source_position(
        IMPORTING
          program_name = program_name
          include_name = include_name
          source_line  = source_line ).
    ENDIF.

  ENDMETHOD.

  METHOD get_t100_longtext_itf.

    DATA lv_docu_key TYPE doku_obj.

    FIELD-SYMBOLS <lv_msgv> TYPE any.

    lv_docu_key = if_t100_message~t100key-msgid && if_t100_message~t100key-msgno.

    CALL FUNCTION 'DOCU_GET'
      EXPORTING
        id     = 'NA'
        langu  = sy-langu
        object = lv_docu_key
        typ    = 'E'
      TABLES
        line   = rt_itf
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc = 0.
      ASSIGN me->(if_t100_message~t100key-attr1) TO <lv_msgv>.
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V1&' IN TABLE rt_itf WITH <lv_msgv>.
      ENDIF.
      ASSIGN me->(if_t100_message~t100key-attr2) TO <lv_msgv>.
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V2&' IN TABLE rt_itf WITH <lv_msgv>.
      ENDIF.
      ASSIGN me->(if_t100_message~t100key-attr3) TO <lv_msgv>.
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V3&' IN TABLE rt_itf WITH <lv_msgv>.
      ENDIF.
      ASSIGN me->(if_t100_message~t100key-attr4) TO <lv_msgv>.
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V4&' IN TABLE rt_itf WITH <lv_msgv>.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD if_message~get_longtext.

    result = super->get_longtext( ).

    IF if_t100_message~t100key IS NOT INITIAL.

      result = itf_to_string( get_t100_longtext_itf( ) ).

    ENDIF.

  ENDMETHOD.

  METHOD itf_to_string.

    CONSTANTS lc_format_section TYPE string VALUE 'U1'.

    DATA:
      lt_stream      TYPE TABLE OF tdline,
      lt_string      TYPE TABLE OF string,
      lv_string      LIKE LINE OF lt_string,
      lt_itf         TYPE tline_tab,
      lv_has_content TYPE abap_bool,
      lv_tabix_from  TYPE syst-tabix,
      lv_tabix_to    TYPE syst-tabix.

    FIELD-SYMBOLS:
      <ls_itf_section>      TYPE tline,
      <ls_itf_section_item> TYPE tline.

    lt_itf = it_itf.

    " You should remember that we replace the U1 format because
    " that preserves the section header of longtexts.
    LOOP AT lt_itf ASSIGNING <ls_itf_section> WHERE tdformat = lc_format_section.

      CLEAR:
        lv_has_content,
        lv_tabix_to.

      lv_tabix_from = sy-tabix.

      LOOP AT lt_itf ASSIGNING <ls_itf_section_item> FROM sy-tabix + 1.

        IF <ls_itf_section_item>-tdformat = lc_format_section.
          lv_tabix_to = sy-tabix.
          EXIT.
        ELSEIF <ls_itf_section_item>-tdline IS NOT INITIAL.
          lv_has_content = abap_true.
        ENDIF.

      ENDLOOP.

      IF lv_has_content = abap_false.
        remove_empty_section(
          EXPORTING
            iv_tabix_from = lv_tabix_from
            iv_tabix_to   = lv_tabix_to
          CHANGING
            ct_itf        = lt_itf ).
        CONTINUE.
      ENDIF.

      replace_section_head_with_text( CHANGING cs_itf = <ls_itf_section> ).

    ENDLOOP.

    CALL FUNCTION 'CONVERT_ITF_TO_STREAM_TEXT'
      EXPORTING
        lf           = abap_true
      IMPORTING
        stream_lines = lt_string
      TABLES
        itf_text     = lt_itf
        text_stream  = lt_stream.

    LOOP AT lt_string INTO lv_string.
      IF sy-tabix = 1.
        rv_result = lv_string.
      ELSE.
        CONCATENATE rv_result lv_string INTO rv_result
          SEPARATED BY cl_abap_char_utilities=>newline.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD raise.

    DATA lv_text TYPE string.

    IF iv_text IS INITIAL.
      lv_text = gc_generic_error_msg.
    ELSE.
      lv_text = iv_text.
    ENDIF.

    split_text_to_symsg( lv_text ).

    raise_t100( ix_previous = ix_previous ).

  ENDMETHOD.

  METHOD raise_t100.

    DATA ls_t100_key TYPE scx_t100key.

    ls_t100_key-msgid = iv_msgid.
    ls_t100_key-msgno = iv_msgno.
    ls_t100_key-attr1 = 'MSGV1'.
    ls_t100_key-attr2 = 'MSGV2'.
    ls_t100_key-attr3 = 'MSGV3'.
    ls_t100_key-attr4 = 'MSGV4'.

    IF iv_msgid IS INITIAL.
      CLEAR ls_t100_key.
    ENDIF.

    RAISE EXCEPTION TYPE zcx_abapinst_exception
      EXPORTING
        textid   = ls_t100_key
        msgv1    = iv_msgv1
        msgv2    = iv_msgv2
        msgv3    = iv_msgv3
        msgv4    = iv_msgv4
        previous = ix_previous.

  ENDMETHOD.

  METHOD raise_with_text.
    raise(
      iv_text     = ix_previous->get_text( )
      ix_previous = ix_previous ).
  ENDMETHOD.

  METHOD remove_empty_section.
    IF iv_tabix_to BETWEEN iv_tabix_from AND lines( ct_itf ).
      DELETE ct_itf FROM iv_tabix_from TO iv_tabix_to.
    ELSE.
      DELETE ct_itf FROM iv_tabix_from.
    ENDIF.
  ENDMETHOD.

  METHOD replace_section_head_with_text.

    CASE cs_itf-tdline.
      WHEN gc_section_token-cause.
        cs_itf-tdline = gc_section_text-cause.
      WHEN gc_section_token-system_response.
        cs_itf-tdline = gc_section_text-system_response.
      WHEN gc_section_token-what_to_do.
        cs_itf-tdline = gc_section_text-what_to_do.
      WHEN gc_section_token-sys_admin.
        cs_itf-tdline = gc_section_text-sys_admin.
    ENDCASE.

  ENDMETHOD.

  METHOD save_callstack.

    FIELD-SYMBOLS <ls_callstack> TYPE abap_callstack_line.

    CALL FUNCTION 'SYSTEM_CALLSTACK'
      IMPORTING
        callstack = mt_callstack.

    " You should remember that the first lines are from zcx_abapinst_exception
    " and are removed so that highest level in the callstack is the position where
    " the exception is raised.
    " For the merged report it's hard to do that, because zcx_abapinst_exception
    " isn't visible in the callstack. Therefore we have to check the events.
    LOOP AT mt_callstack ASSIGNING <ls_callstack>.

      IF <ls_callstack>-mainprogram CP 'ZCX_ABAPINST_EXCEPTION*' " full
          OR <ls_callstack>-blockname = 'SAVE_CALLSTACK' " merged
          OR <ls_callstack>-blockname = 'CONSTRUCTOR' " merged
          OR <ls_callstack>-blockname CP 'RAISE*'. "merged
        DELETE TABLE mt_callstack FROM <ls_callstack>.
      ELSE.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD split_text_to_symsg.

    CONSTANTS:
      lc_length_of_msgv           TYPE i VALUE 50,
      lc_offset_of_last_character TYPE i VALUE 49.

    DATA:
      lv_text    TYPE c LENGTH 200,
      lv_rest    TYPE c LENGTH 200,
      ls_msg     TYPE symsg,
      lv_msg_var TYPE c LENGTH lc_length_of_msgv,
      lv_index   TYPE sy-index.

    lv_text = iv_text.

    DO 4 TIMES.

      lv_index = sy-index.

      CALL FUNCTION 'TEXT_SPLIT'
        EXPORTING
          length = lc_length_of_msgv
          text   = lv_text
        IMPORTING
          line   = lv_msg_var
          rest   = lv_rest.

      IF lv_msg_var+lc_offset_of_last_character(1) = space OR
         lv_text+lc_length_of_msgv(1) = space.
        " Keep the space at the beginning of the rest because otherwise it's lost
        lv_rest = | { lv_rest }|.
      ENDIF.

      lv_text = lv_rest.

      CASE lv_index.
        WHEN 1.
          ls_msg-msgv1 = lv_msg_var.
        WHEN 2.
          ls_msg-msgv2 = lv_msg_var.
        WHEN 3.
          ls_msg-msgv3 = lv_msg_var.
        WHEN 4.
          ls_msg-msgv4 = lv_msg_var.
      ENDCASE.

    ENDDO.

    " Set syst using generic error message
    MESSAGE e001(00) WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4 INTO sy-lisel.

  ENDMETHOD.
ENDCLASS.

CLASS lcl_error_longtext DEFINITION.

  PUBLIC SECTION.

    CLASS-METHODS remove_newlines
      IMPORTING
        longtext      TYPE string
      RETURNING
        VALUE(result) TYPE string.

    CLASS-METHODS to_string
      IMPORTING
        lines         TYPE tline_tab
      RETURNING
        VALUE(result) TYPE string.

  PRIVATE SECTION.

    CLASS-METHODS remove_empty_section
      IMPORTING
        !tabix_from TYPE i
        !tabix_to   TYPE i
      CHANGING
        !itf        TYPE tline_tab.

    CLASS-METHODS replace_section_head_with_text
      CHANGING
        !itf TYPE tline.

ENDCLASS.

CLASS lcl_error_longtext IMPLEMENTATION.

  METHOD remove_newlines.

    result = longtext.
    REPLACE ALL OCCURRENCES OF ` ` && cl_abap_char_utilities=>cr_lf IN result WITH ` `.
    REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>cr_lf IN result WITH ` `.
    REPLACE ALL OCCURRENCES OF ` ` && cl_abap_char_utilities=>newline IN result WITH ` `.
    REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>newline IN result WITH ` `.

  ENDMETHOD.

  METHOD to_string.

    CONSTANTS c_format_section TYPE string VALUE 'U1'.

    DATA:
      stream       TYPE STANDARD TABLE OF tdline WITH KEY table_line,
      stream_lines TYPE string_table,
      itf          TYPE tline_tab.

    itf = lines.

    " We replace the U1 format because that preserves the section header of longtexts
    LOOP AT itf ASSIGNING FIELD-SYMBOL(<section>) WHERE tdformat = c_format_section.

      DATA(has_content) = VALUE abap_bool( ).
      DATA(tabix_from)  = sy-tabix.
      DATA(tabix_to)    = 0.

      LOOP AT itf ASSIGNING FIELD-SYMBOL(<section_item>) FROM sy-tabix + 1.

        IF <section_item>-tdformat = c_format_section.
          tabix_to = sy-tabix.
          EXIT.
        ELSEIF <section_item>-tdline IS NOT INITIAL.
          has_content = abap_true.
        ENDIF.

      ENDLOOP.

      IF has_content = abap_false.
        remove_empty_section(
          EXPORTING
            tabix_from = tabix_from
            tabix_to   = tabix_to
          CHANGING
            itf        = itf ).
        CONTINUE.
      ENDIF.

      replace_section_head_with_text( CHANGING itf = <section> ).

    ENDLOOP.

    CALL FUNCTION 'CONVERT_ITF_TO_STREAM_TEXT'
      EXPORTING
        lf           = 'X'
      IMPORTING
        stream_lines = stream_lines
      TABLES
        itf_text     = itf
        text_stream  = stream.

    result = concat_lines_of(
      table = stream_lines
      sep   = cl_abap_char_utilities=>newline ).

  ENDMETHOD.

  METHOD remove_empty_section.

    IF tabix_to BETWEEN tabix_from AND lines( itf ).
      DELETE itf FROM tabix_from TO tabix_to.
    ELSE.
      DELETE itf INDEX tabix_from.
    ENDIF.

  ENDMETHOD.

  METHOD replace_section_head_with_text.

    CONSTANTS:
      BEGIN OF c_section_text,
        cause           TYPE string VALUE `Cause`,
        system_response TYPE string VALUE `System response`,
        what_to_do      TYPE string VALUE `Procedure`,
        sys_admin       TYPE string VALUE `System administration`,
      END OF c_section_text,
      BEGIN OF c_section_token,
        cause           TYPE string VALUE `&CAUSE&`,
        system_response TYPE string VALUE `&SYSTEM_RESPONSE&`,
        what_to_do      TYPE string VALUE `&WHAT_TO_DO&`,
        sys_admin       TYPE string VALUE `&SYS_ADMIN&`,
      END OF c_section_token.

    CASE itf-tdline.
      WHEN c_section_token-cause.
        itf-tdline = c_section_text-cause.
      WHEN c_section_token-system_response.
        itf-tdline = c_section_text-system_response.
      WHEN c_section_token-what_to_do.
        itf-tdline = c_section_text-what_to_do.
      WHEN c_section_token-sys_admin.
        itf-tdline = c_section_text-sys_admin.
    ENDCASE.

  ENDMETHOD.

ENDCLASS.

CLASS zcx_error DEFINITION

  INHERITING FROM cx_static_check
  CREATE PUBLIC.

************************************************************************
* Error
*
* Copyright 2024 apm.to Inc. <https://apm.to>
* SPDX-License-Identifier: MIT
************************************************************************
  PUBLIC SECTION.

    CONSTANTS c_version TYPE string VALUE '1.0.0' ##NEEDED.

    INTERFACES:
      if_t100_dyn_msg,
      if_t100_message.

    "! Black Hole
    "! Can be used for MESSAGE ... INTO null
    CLASS-DATA null TYPE string ##NEEDED.

    DATA longtext TYPE string READ-ONLY.
    DATA callstack TYPE abap_callstack READ-ONLY.

    METHODS constructor
      IMPORTING
        !textid   LIKE if_t100_message=>t100key OPTIONAL
        !previous LIKE previous OPTIONAL
        !msgv1    TYPE symsgv OPTIONAL
        !msgv2    TYPE symsgv OPTIONAL
        !msgv3    TYPE symsgv OPTIONAL
        !msgv4    TYPE symsgv OPTIONAL
        !longtext TYPE csequence OPTIONAL.

    "! Raise exception with text
    "! @parameter text | Text
    "! @parameter previous | Previous exception
    "! @parameter longtext | Longtext
    "! @raising zcx_error | Exception
    CLASS-METHODS raise
      IMPORTING
        !text     TYPE clike
        !previous TYPE REF TO cx_root OPTIONAL
        !longtext TYPE csequence OPTIONAL
      RAISING
        zcx_error.

    "! Raise exception with T100 message
    "! <p>
    "! Will default to sy-msg* variables. These need to be set right before calling this method.
    "! </p>
    "! @parameter msgid | Message ID
    "! @parameter msgno | Message number
    "! @parameter msgv1 | Message variable 1
    "! @parameter msgv2 | Message variable 2
    "! @parameter msgv3 | Message variable 3
    "! @parameter msgv4 | Message variable 4
    "! @parameter previous | Previous exception
    "! @parameter longtext | Longtext
    "! @raising zcx_error | Exception
    CLASS-METHODS raise_t100
      IMPORTING
        msgid     TYPE symsgid DEFAULT sy-msgid
        msgno     TYPE symsgno DEFAULT sy-msgno
        msgv1     TYPE symsgv DEFAULT sy-msgv1
        msgv2     TYPE symsgv DEFAULT sy-msgv2
        msgv3     TYPE symsgv DEFAULT sy-msgv3
        msgv4     TYPE symsgv DEFAULT sy-msgv4
        !previous TYPE REF TO cx_root OPTIONAL
        !longtext TYPE csequence OPTIONAL
      RAISING
        zcx_error.

    "! Raise with text from previous exception
    "! @parameter previous | Previous exception
    "! @parameter longtext | Longtext
    "! @raising zcx_error | Exception
    CLASS-METHODS raise_with_text
      IMPORTING
        !previous TYPE REF TO cx_root
        !longtext TYPE csequence OPTIONAL
      RAISING
        zcx_error.

    METHODS get_source_position REDEFINITION.
    METHODS if_message~get_longtext REDEFINITION.

  PROTECTED SECTION.
  PRIVATE SECTION.

    CONSTANTS c_generic_error_msg TYPE string VALUE `An error occured`.

    METHODS save_callstack.

    METHODS get_t100_longtext
      RETURNING
        VALUE(result) TYPE tline_tab.

ENDCLASS.

CLASS zcx_error IMPLEMENTATION.

  METHOD constructor ##ADT_SUPPRESS_GENERATION.

    super->constructor( previous = previous ).

    if_t100_dyn_msg~msgv1 = msgv1.
    if_t100_dyn_msg~msgv2 = msgv2.
    if_t100_dyn_msg~msgv3 = msgv3.
    if_t100_dyn_msg~msgv4 = msgv4.

    CLEAR me->textid.

    IF textid IS INITIAL.
      if_t100_message~t100key = if_t100_message=>default_textid.
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.

    me->longtext = longtext.

    save_callstack( ).

  ENDMETHOD.

  METHOD get_source_position.

    READ TABLE callstack ASSIGNING FIELD-SYMBOL(<callstack>) INDEX 1.
    IF sy-subrc = 0.
      program_name = <callstack>-mainprogram.
      include_name = <callstack>-include.
      source_line  = <callstack>-line.
    ELSE.
      super->get_source_position(
        IMPORTING
          program_name = program_name
          include_name = include_name
          source_line  = source_line ).
    ENDIF.

  ENDMETHOD.

  METHOD get_t100_longtext.

    DATA(docu_key) = CONV doku_obj( if_t100_message~t100key-msgid && if_t100_message~t100key-msgno ).

    CALL FUNCTION 'DOCU_GET'
      EXPORTING
        id     = 'NA'
        langu  = sy-langu
        object = docu_key
        typ    = 'E'
      TABLES
        line   = result
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc = 0.
      ASSIGN me->(if_t100_message~t100key-attr1) TO FIELD-SYMBOL(<msgv>).
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V1&' IN TABLE result WITH <msgv>.
      ENDIF.
      ASSIGN me->(if_t100_message~t100key-attr2) TO <msgv>.
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V2&' IN TABLE result WITH <msgv>.
      ENDIF.
      ASSIGN me->(if_t100_message~t100key-attr3) TO <msgv>.
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V3&' IN TABLE result WITH <msgv>.
      ENDIF.
      ASSIGN me->(if_t100_message~t100key-attr4) TO <msgv>.
      IF sy-subrc = 0.
        REPLACE ALL OCCURRENCES OF '&V4&' IN TABLE result WITH <msgv>.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD if_message~get_longtext.

    IF longtext IS NOT INITIAL.

      result = longtext.

      IF preserve_newlines = abap_false.
        result = lcl_error_longtext=>remove_newlines( result ).
      ENDIF.

    ELSEIF if_t100_message~t100key IS NOT INITIAL.

      result = lcl_error_longtext=>to_string( get_t100_longtext( ) ).

      IF preserve_newlines = abap_false.
        result = lcl_error_longtext=>remove_newlines( result ).
      ENDIF.

    ELSE.
      result = super->get_longtext( preserve_newlines ).
    ENDIF.

  ENDMETHOD.

  METHOD raise.

    IF text IS INITIAL.
      cl_message_helper=>set_msg_vars_for_clike( c_generic_error_msg ).
    ELSE.
      cl_message_helper=>set_msg_vars_for_clike( text ).
    ENDIF.

    raise_t100(
      previous = previous
      longtext = longtext ).

  ENDMETHOD.

  METHOD raise_t100.

    IF msgid IS NOT INITIAL.
      DATA(t100_key) = VALUE scx_t100key(
        msgid = msgid
        msgno = msgno
        attr1 = 'IF_T100_DYN_MSG~MSGV1'
        attr2 = 'IF_T100_DYN_MSG~MSGV2'
        attr3 = 'IF_T100_DYN_MSG~MSGV3'
        attr4 = 'IF_T100_DYN_MSG~MSGV4' ).
    ENDIF.

    RAISE EXCEPTION TYPE zcx_error
      EXPORTING
        textid   = t100_key
        msgv1    = msgv1
        msgv2    = msgv2
        msgv3    = msgv3
        msgv4    = msgv4
        previous = previous
        longtext = longtext.

  ENDMETHOD.

  METHOD raise_with_text.

    raise(
      text     = previous->get_text( )
      previous = previous
      longtext = longtext ).

  ENDMETHOD.

  METHOD save_callstack.

    CALL FUNCTION 'SYSTEM_CALLSTACK'
      IMPORTING
        callstack = callstack.

    DATA(main_pattern) = cl_abap_typedescr=>describe_by_object_ref( me )->get_relative_name( ) && '*'.

    " Remember that the first lines are from this exception class and are
    " removed so that highest level in the callstack is the position where
    " the exception is raised.
    "
    " For a merged report it's hard to do that, because the exception
    " isn't visible in the callstack. Therefore we have to check the events.
    LOOP AT callstack ASSIGNING FIELD-SYMBOL(<callstack>).

      IF <callstack>-mainprogram CP main_pattern " full
        OR <callstack>-blockname = `SAVE_CALLSTACK` " merged
        OR <callstack>-blockname = `CONSTRUCTOR` " merged
        OR <callstack>-blockname CP `RAISE*`. "merged

        DELETE TABLE callstack FROM <callstack>.

      ELSE.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

****** CLASSES DEFERRED ******

CLASS zcl_abapgit_abap_language_vers DEFINITION DEFERRED.
CLASS zcl_abapgit_adt_link DEFINITION DEFERRED.
CLASS zcl_abapgit_aff_registry DEFINITION DEFERRED.
CLASS zcl_abapgit_ajson DEFINITION DEFERRED.
CLASS zcl_abapgit_ajson_filter_lib DEFINITION DEFERRED.
CLASS zcl_abapgit_ajson_mapping DEFINITION DEFERRED.
CLASS zcl_abapgit_ajson_utilities DEFINITION DEFERRED.
CLASS zcl_abapgit_convert DEFINITION DEFERRED.
CLASS zcl_abapgit_cts_api DEFINITION DEFERRED.
CLASS zcl_abapgit_data_config DEFINITION DEFERRED.
CLASS zcl_abapgit_data_deserializer DEFINITION DEFERRED.
CLASS zcl_abapgit_data_serializer DEFINITION DEFERRED.
CLASS zcl_abapgit_data_supporter DEFINITION DEFERRED.
CLASS zcl_abapgit_data_factory DEFINITION DEFERRED.
CLASS zcl_abapgit_data_injector DEFINITION DEFERRED.
CLASS zcl_abapgit_data_utils DEFINITION DEFERRED.
CLASS zcl_abapgit_default_transport DEFINITION DEFERRED.
CLASS zcl_abapgit_dependencies DEFINITION DEFERRED.
CLASS zcl_abapgit_dot_abapgit DEFINITION DEFERRED.
CLASS zcl_abapgit_environment DEFINITION DEFERRED.
CLASS zcl_abapgit_exit DEFINITION DEFERRED.
CLASS zcl_abapgit_filename_logic DEFINITION DEFERRED.
CLASS zcl_abapgit_folder_logic DEFINITION DEFERRED.
CLASS zcl_abapgit_frontend_services DEFINITION DEFERRED.
CLASS zcl_abapgit_function_module DEFINITION DEFERRED.
CLASS zcl_abapgit_gui_jumper DEFINITION DEFERRED.
CLASS zcl_abapgit_hash DEFINITION DEFERRED.
CLASS zcl_abapgit_i18n_params DEFINITION DEFERRED.
CLASS zcl_abapgit_item_graph DEFINITION DEFERRED.
CLASS zcl_abapgit_json_path DEFINITION DEFERRED.
CLASS zcl_abapgit_language DEFINITION DEFERRED.
CLASS zcl_abapgit_log DEFINITION DEFERRED.
CLASS zcl_abapgit_longtexts DEFINITION DEFERRED.
CLASS zcl_abapgit_lxe_texts DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_activation DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_super DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_bridge DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_factory DEFINITION DEFERRED.
CLASS zcl_abapgit_xml DEFINITION DEFERRED.
CLASS zcl_abapgit_xml_input DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_files DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_injector DEFINITION DEFERRED.
CLASS zcl_abapgit_xml_output DEFINITION DEFERRED.
CLASS zcl_abapgit_objects_program DEFINITION DEFERRED.
CLASS zcl_abapgit_object_acid DEFINITION DEFERRED.
CLASS zcl_abapgit_object_avar DEFINITION DEFERRED.
CLASS zcl_abapgit_object_clas DEFINITION DEFERRED.
CLASS zcl_abapgit_persist_packages DEFINITION DEFERRED.
CLASS zcl_abapgit_object_devc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_doma DEFINITION DEFERRED.
CLASS zcl_abapgit_object_dsys DEFINITION DEFERRED.
CLASS zcl_abapgit_object_dtel DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enhc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_badi DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_hook DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_class DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_intf DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_wdyc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_fugr DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_wdyn DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enho_clif DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enhs_badi_d DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enhs_hook_d DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enhs DEFINITION DEFERRED.
CLASS zcl_abapgit_object_enqu DEFINITION DEFERRED.
CLASS zcl_abapgit_object_fugr DEFINITION DEFERRED.
CLASS zcl_abapgit_object_idoc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_intf DEFINITION DEFERRED.
CLASS zcl_abapgit_object_msag DEFINITION DEFERRED.
CLASS zcl_abapgit_object_nspc DEFINITION DEFERRED.
CLASS zcl_abapgit_object_para DEFINITION DEFERRED.
CLASS zcl_abapgit_object_prog DEFINITION DEFERRED.
CLASS zcl_abapgit_object_shlp DEFINITION DEFERRED.
CLASS zcl_abapgit_object_sots DEFINITION DEFERRED.
CLASS zcl_abapgit_object_tabl_compar DEFINITION DEFERRED.
CLASS zcl_abapgit_object_tabl DEFINITION DEFERRED.
CLASS zcl_abapgit_object_tabl_ddl DEFINITION DEFERRED.
CLASS zcl_abapgit_object_tobj DEFINITION DEFERRED.
CLASS zcl_abapgit_object_tran DEFINITION DEFERRED.
CLASS zcl_abapgit_object_ttyp DEFINITION DEFERRED.
CLASS zcl_abapgit_object_w3xx_super DEFINITION DEFERRED.
CLASS zcl_abapgit_object_w3ht DEFINITION DEFERRED.
CLASS zcl_abapgit_object_w3mi DEFINITION DEFERRED.
CLASS zcl_abapgit_oo_base DEFINITION DEFERRED.
CLASS zcl_abapgit_oo_class DEFINITION DEFERRED.
CLASS zcl_abapgit_oo_interface DEFINITION DEFERRED.
CLASS zcl_abapgit_oo_factory DEFINITION DEFERRED.
CLASS zcl_abapgit_oo_serializer DEFINITION DEFERRED.
CLASS zcl_abapgit_path DEFINITION DEFERRED.
CLASS zcl_abapgit_persistence_db DEFINITION DEFERRED.
CLASS zcl_abapgit_po_file DEFINITION DEFERRED.
CLASS zcl_abapgit_progress DEFINITION DEFERRED.
CLASS zcl_abapgit_properties_file DEFINITION DEFERRED.
CLASS zcl_abapgit_sap_namespace DEFINITION DEFERRED.
CLASS zcl_abapgit_sap_package DEFINITION DEFERRED.
CLASS zcl_abapgit_sap_report DEFINITION DEFERRED.
CLASS zcl_abapgit_sotr_handler DEFINITION DEFERRED.
CLASS zcl_abapgit_sots_handler DEFINITION DEFERRED.
CLASS zcl_abapgit_tadir DEFINITION DEFERRED.
CLASS zcl_abapgit_url DEFINITION DEFERRED.
CLASS zcl_abapgit_version DEFINITION DEFERRED.
CLASS zcl_abapgit_xml_pretty DEFINITION DEFERRED.
CLASS zcl_abapinst_factory DEFINITION DEFERRED.
CLASS zcl_abapinst_file DEFINITION DEFERRED.
CLASS zcl_abapinst_popups DEFINITION DEFERRED.
CLASS zcl_tar DEFINITION DEFERRED.
CLASS zcl_abapinst_installer DEFINITION DEFERRED.
CLASS zcl_abapinst_log_viewer DEFINITION DEFERRED.
CLASS zcl_abapinst_objects DEFINITION DEFERRED.
CLASS zcl_abapinst_persistence DEFINITION DEFERRED.
CLASS zcl_abapinst_repo_status DEFINITION DEFERRED.
CLASS zcl_abapinst_requirements DEFINITION DEFERRED.
CLASS zcl_abapinst_screen DEFINITION DEFERRED.
CLASS zcl_abapinst_setup DEFINITION DEFERRED.
CLASS zcl_abapinst_textpool DEFINITION DEFERRED.

****** INTERFACES ******

INTERFACE zif_abapgit_aff_types_v1 .

  TYPES ty_format_version TYPE string.

  TYPES ty_abap_language_version TYPE c LENGTH 1.

  TYPES ty_abap_language_version_cloud TYPE c LENGTH 1.

  TYPES ty_abap_language_version_src TYPE c LENGTH 1.

  CONSTANTS:
    BEGIN OF co_abap_language_version_src,
      standard          TYPE ty_abap_language_version_src VALUE 'X',
      key_user          TYPE ty_abap_language_version_src VALUE '2',
      cloud_development TYPE ty_abap_language_version_src VALUE '5',
    END OF co_abap_language_version_src.

  CONSTANTS:
    BEGIN OF co_abap_language_version,
      standard          TYPE ty_abap_language_version VALUE space,
      key_user          TYPE ty_abap_language_version VALUE '2',
      cloud_development TYPE ty_abap_language_version VALUE '5',
    END OF co_abap_language_version.

  CONSTANTS:
    BEGIN OF co_abap_language_version_cloud,
      standard          TYPE ty_abap_language_version_cloud VALUE space,
      cloud_development TYPE ty_abap_language_version_cloud VALUE '5',
    END OF co_abap_language_version_cloud.

  TYPES ty_description_60 TYPE c LENGTH 60.
  TYPES ty_description_100 TYPE c LENGTH 100.

  TYPES ty_object_name_30 TYPE c LENGTH 30.

  TYPES ty_original_language TYPE sy-langu.

  TYPES:
    BEGIN OF ty_header_60_src,
      description           TYPE ty_description_60,
      original_language     TYPE ty_original_language,
      abap_language_version TYPE ty_abap_language_version_src,
    END OF ty_header_60_src.

  TYPES:
    BEGIN OF ty_header_60_cloud,
      description           TYPE ty_description_60,
      original_language     TYPE ty_original_language,
      abap_language_version TYPE ty_abap_language_version_cloud,
    END OF ty_header_60_cloud.

  TYPES:
    BEGIN OF ty_header_60,
      description           TYPE ty_description_60,
      original_language     TYPE ty_original_language,
      abap_language_version TYPE ty_abap_language_version,
    END OF ty_header_60.

  TYPES:
    BEGIN OF ty_header_60_no_abap_lv,
      description       TYPE ty_description_60,
      original_language TYPE ty_original_language,
    END OF ty_header_60_no_abap_lv.

  TYPES:
    BEGIN OF ty_header_100,
      description           TYPE ty_description_100,
      original_language     TYPE ty_original_language,
      abap_language_version TYPE ty_abap_language_version,
    END OF ty_header_100.

  TYPES:
    BEGIN OF ty_header_only_description,
      description TYPE ty_description_60,
    END OF ty_header_only_description.

  TYPES ty_option TYPE c LENGTH 2.

  CONSTANTS:
    BEGIN OF co_option,
      equals               TYPE ty_option VALUE 'EQ',
      between              TYPE ty_option VALUE 'BT',
      greater_than         TYPE ty_option VALUE 'GT',
      contains_pattern     TYPE ty_option VALUE 'CP',
      not_equal            TYPE ty_option VALUE 'NE',
      not_between          TYPE ty_option VALUE 'NB',
      not_contains_pattern TYPE ty_option VALUE 'NP',
      greater_equal        TYPE ty_option VALUE 'GE',
      less_than            TYPE ty_option VALUE 'LT',
      less_equal           TYPE ty_option VALUE 'LE',
    END OF co_option.

  TYPES ty_sign TYPE c LENGTH 1.

  CONSTANTS:
    BEGIN OF co_sign,
      include TYPE ty_sign VALUE 'I',
      exclude TYPE ty_sign VALUE 'E',
    END OF co_sign.

ENDINTERFACE.

INTERFACE zif_abapgit_git_definitions
   .
* this interface is self contained
* only references to built in types
* git does not know the concept of TADIR objects, only knows files
  TYPES:
    ty_type    TYPE c LENGTH 6 .
  TYPES:
    ty_bitbyte TYPE c LENGTH 8 .
  TYPES:
    ty_sha1    TYPE c LENGTH 40 .
  TYPES: ty_sha1_tt TYPE STANDARD TABLE OF ty_sha1 WITH DEFAULT KEY .
  TYPES:
    ty_adler32 TYPE x LENGTH 4 .

  TYPES ty_item_state TYPE c LENGTH 1.
  TYPES:
    BEGIN OF ty_file_signature,
      path     TYPE string,
      filename TYPE string,
      sha1     TYPE ty_sha1,
    END OF ty_file_signature .
  TYPES:
    ty_file_signatures_tt TYPE STANDARD TABLE OF
           ty_file_signature WITH DEFAULT KEY .
  TYPES:
    ty_file_signatures_ts TYPE SORTED TABLE OF
           ty_file_signature WITH UNIQUE KEY path filename .
  TYPES:
    BEGIN OF ty_file.
      INCLUDE TYPE ty_file_signature.
  TYPES: data TYPE xstring,
    END OF ty_file .
  TYPES:
    ty_files_tt TYPE STANDARD TABLE OF ty_file WITH DEFAULT KEY
                     WITH UNIQUE SORTED KEY file_path COMPONENTS path filename
                     WITH NON-UNIQUE SORTED KEY file COMPONENTS filename.

  TYPES ty_git_branch_type TYPE c LENGTH 2 .
  TYPES:
    BEGIN OF ty_git_branch,
      sha1         TYPE ty_sha1,
      name         TYPE string,
      type         TYPE ty_git_branch_type,
      is_head      TYPE abap_bool,
      display_name TYPE string,
    END OF ty_git_branch .
  TYPES:
    ty_git_branch_list_tt TYPE STANDARD TABLE OF ty_git_branch WITH DEFAULT KEY
                               WITH NON-UNIQUE SORTED KEY name_key
                               COMPONENTS name.
  TYPES:
    BEGIN OF ty_git_tag,
      sha1         TYPE ty_sha1,
      object       TYPE ty_sha1,
      name         TYPE string,
      type         TYPE ty_git_branch_type,
      display_name TYPE string,
      tagger_name  TYPE string,
      tagger_email TYPE string,
      message      TYPE string,
      body         TYPE string,
    END OF ty_git_tag .
  TYPES:
    BEGIN OF ty_git_user,
      name  TYPE string,
      email TYPE string,
    END OF ty_git_user .
  TYPES:
    BEGIN OF ty_comment,
      committer TYPE ty_git_user,
      author    TYPE ty_git_user,
      comment   TYPE string,
    END OF ty_comment .

  TYPES:
    ty_chmod TYPE c LENGTH 6 .

  CONSTANTS:
    BEGIN OF c_chmod,
      file          TYPE ty_chmod VALUE '100644',
      executable    TYPE ty_chmod VALUE '100755',
      dir           TYPE ty_chmod VALUE '40000 ',
      submodule     TYPE ty_chmod VALUE '160000',
      symbolic_link TYPE ty_chmod VALUE '120000',
    END OF c_chmod .

  TYPES:
    BEGIN OF ty_expanded,
      path  TYPE string,
      name  TYPE string,
      sha1  TYPE ty_sha1,
      chmod TYPE ty_chmod,
    END OF ty_expanded .
  TYPES:
    ty_expanded_tt TYPE STANDARD TABLE OF ty_expanded WITH DEFAULT KEY
      WITH NON-UNIQUE SORTED KEY path_name COMPONENTS path name.

  TYPES:
    BEGIN OF ty_create,
      name   TYPE string,
      parent TYPE string,
    END OF ty_create .
  TYPES:
    BEGIN OF ty_commit,
      sha1       TYPE ty_sha1,
      parent1    TYPE ty_sha1,
      parent2    TYPE ty_sha1,
      author     TYPE string,
      email      TYPE string,
      time       TYPE string,
      message    TYPE string,
      body       TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
      branch     TYPE string,
      merge      TYPE string,
      tags       TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
      create     TYPE STANDARD TABLE OF ty_create WITH DEFAULT KEY,
      compressed TYPE abap_bool,
    END OF ty_commit .
  TYPES:
    ty_commit_tt TYPE STANDARD TABLE OF ty_commit WITH DEFAULT KEY .

  CONSTANTS:
    BEGIN OF c_type,
      commit TYPE ty_type VALUE 'commit',                   "#EC NOTEXT
      tree   TYPE ty_type VALUE 'tree',                     "#EC NOTEXT
      ref_d  TYPE ty_type VALUE 'ref_d',                    "#EC NOTEXT
      tag    TYPE ty_type VALUE 'tag',                      "#EC NOTEXT
      blob   TYPE ty_type VALUE 'blob',                     "#EC NOTEXT
    END OF c_type .

  CONSTANTS:
    BEGIN OF c_git_branch_type,
      branch          TYPE ty_git_branch_type VALUE 'HD',
      lightweight_tag TYPE ty_git_branch_type VALUE 'TG',
      annotated_tag   TYPE ty_git_branch_type VALUE 'AT',
      other           TYPE ty_git_branch_type VALUE 'ZZ',
    END OF c_git_branch_type .
  CONSTANTS c_head_name TYPE string VALUE 'HEAD' ##NO_TEXT.
  CONSTANTS:
    BEGIN OF c_git_branch,
      main         TYPE string VALUE 'refs/heads/main',
      prefix       TYPE string VALUE 'refs/',
      heads_prefix TYPE string VALUE 'refs/heads/',
      heads        TYPE string VALUE 'refs/heads/*',
      tags_prefix  TYPE string VALUE 'refs/tags/',
      tags         TYPE string VALUE 'refs/tags/*',
      peel         TYPE string VALUE '^{}',
    END OF c_git_branch.

ENDINTERFACE.

INTERFACE zif_abapgit_definitions
   .

  TYPES:
    ty_string_tt TYPE STANDARD TABLE OF string WITH DEFAULT KEY .
  TYPES:
    BEGIN OF ty_item_signature,
      obj_type TYPE tadir-object,
      obj_name TYPE tadir-obj_name,
      devclass TYPE devclass,
    END OF ty_item_signature .
  TYPES:
    BEGIN OF ty_obj_namespace,
      namespace             TYPE trnspace-namespace,
      obj_without_namespace TYPE tadir-obj_name,
    END OF ty_obj_namespace.
  TYPES:
    BEGIN OF ty_item.
      INCLUDE TYPE ty_item_signature.
  TYPES:
      srcsystem             TYPE tadir-srcsystem,
      origlang              TYPE tadir-masterlang,
      inactive              TYPE abap_bool,
      abap_language_version TYPE zif_abapgit_aff_types_v1=>ty_abap_language_version,
    END OF ty_item .
  TYPES:
    ty_items_tt TYPE STANDARD TABLE OF ty_item WITH DEFAULT KEY .
  TYPES:
    ty_items_ts TYPE SORTED TABLE OF ty_item WITH UNIQUE KEY obj_type obj_name .
  TYPES:
    BEGIN OF ty_file_item,
      file TYPE zif_abapgit_git_definitions=>ty_file,
      item TYPE ty_item,
    END OF ty_file_item .
  TYPES:
    ty_files_item_tt TYPE STANDARD TABLE OF ty_file_item WITH DEFAULT KEY .
  TYPES:
    ty_files_item_by_file_tt TYPE SORTED TABLE OF ty_file_item WITH UNIQUE KEY file-path file-filename.
  TYPES:
    ty_yes_no         TYPE c LENGTH 1,
    ty_yes_no_partial TYPE c LENGTH 1.
  TYPES:
    BEGIN OF ty_overwrite.
      INCLUDE TYPE ty_item.
  TYPES:
      state    TYPE c LENGTH 2,
      action   TYPE i,
      icon     TYPE icon_d,
      text     TYPE string,
      decision TYPE ty_yes_no,
    END OF ty_overwrite .
  TYPES:
    ty_overwrite_tt TYPE STANDARD TABLE OF ty_overwrite WITH DEFAULT KEY
                              WITH UNIQUE HASHED KEY object_type_and_name
                                   COMPONENTS obj_type obj_name .
  TYPES:
    BEGIN OF ty_requirements,
      met      TYPE ty_yes_no,
      decision TYPE ty_yes_no,
    END OF ty_requirements .
  TYPES:
    BEGIN OF ty_dependencies,
      met      TYPE ty_yes_no,
      decision TYPE ty_yes_no,
    END OF ty_dependencies .
  TYPES:
    BEGIN OF ty_transport_type,
      request TYPE trfunction,
      task    TYPE trfunction,
    END OF ty_transport_type .
  TYPES:
    BEGIN OF ty_transport,
      required  TYPE abap_bool,
      transport TYPE trkorr,
      type      TYPE ty_transport_type,
    END OF ty_transport .
  TYPES:
    BEGIN OF ty_deserialize_checks,
      overwrite       TYPE ty_overwrite_tt,
      warning_package TYPE ty_overwrite_tt,
      requirements    TYPE ty_requirements,
      dependencies    TYPE ty_dependencies,
      transport       TYPE ty_transport,
      customizing     TYPE ty_transport,
    END OF ty_deserialize_checks .
  TYPES:
    BEGIN OF ty_delete_checks,
      transport TYPE ty_transport,
    END OF ty_delete_checks .
  TYPES:
    BEGIN OF ty_metadata,
      class   TYPE string,
      version TYPE string,
    END OF ty_metadata .
  TYPES:
    BEGIN OF ty_repo_file,
      path       TYPE string,
      filename   TYPE string,
      is_changed TYPE abap_bool,
      rstate     TYPE zif_abapgit_git_definitions=>ty_item_state,
      lstate     TYPE zif_abapgit_git_definitions=>ty_item_state,
    END OF ty_repo_file .
  TYPES:
    ty_repo_file_tt TYPE STANDARD TABLE OF ty_repo_file WITH DEFAULT KEY .
  TYPES:
    BEGIN OF ty_object,
      sha1    TYPE zif_abapgit_git_definitions=>ty_sha1,
      type    TYPE zif_abapgit_git_definitions=>ty_type,
      data    TYPE xstring,
      adler32 TYPE zif_abapgit_git_definitions=>ty_adler32,
      index   TYPE i,
    END OF ty_object .
  TYPES:
    ty_objects_tt TYPE STANDARD TABLE OF ty_object WITH DEFAULT KEY
      WITH NON-UNIQUE SORTED KEY sha COMPONENTS sha1
      WITH NON-UNIQUE SORTED KEY type COMPONENTS type sha1 .
  TYPES:
    BEGIN OF ty_tadir,
      pgmid      TYPE tadir-pgmid,
      object     TYPE tadir-object,
      obj_name   TYPE tadir-obj_name,
      devclass   TYPE tadir-devclass,
      korrnum    TYPE tadir-korrnum, " used by ZCL_ABAPGIT_DEPENDENCIES->RESOLVE
      delflag    TYPE tadir-delflag,
      genflag    TYPE tadir-genflag,
      path       TYPE string,
      srcsystem  TYPE tadir-srcsystem,
      masterlang TYPE tadir-masterlang,
    END OF ty_tadir .
  TYPES:
    ty_tadir_tt TYPE STANDARD TABLE OF ty_tadir WITH DEFAULT KEY .
  TYPES:
    BEGIN OF ty_result,
      obj_type  TYPE tadir-object,
      obj_name  TYPE tadir-obj_name,
      inactive  TYPE abap_bool,
      path      TYPE string,
      filename  TYPE string,
      package   TYPE devclass,
      match     TYPE abap_bool,
      lstate    TYPE zif_abapgit_git_definitions=>ty_item_state,
      rstate    TYPE zif_abapgit_git_definitions=>ty_item_state,
      packmove  TYPE abap_bool,
      srcsystem TYPE tadir-srcsystem,
      origlang  TYPE tadir-masterlang,
    END OF ty_result .
  TYPES:
    ty_results_tt TYPE STANDARD TABLE OF ty_result WITH DEFAULT KEY
                       WITH NON-UNIQUE SORTED KEY sec_key
                       COMPONENTS obj_type obj_name.
  TYPES:
    ty_results_ts_path TYPE HASHED TABLE OF ty_result WITH UNIQUE KEY path filename .
  TYPES:
    BEGIN OF ty_stage_files,
      local  TYPE ty_files_item_tt,
      remote TYPE zif_abapgit_git_definitions=>ty_files_tt,
      status TYPE ty_results_ts_path,
    END OF ty_stage_files .
  TYPES:
    BEGIN OF ty_tpool.
      INCLUDE TYPE textpool.
  TYPES: split TYPE c LENGTH 8.
  TYPES: END OF ty_tpool .
  TYPES:
    ty_tpool_tt TYPE STANDARD TABLE OF ty_tpool WITH DEFAULT KEY .

  TYPES:
    BEGIN OF ty_transport_to_branch,
      branch_name TYPE string,
      commit_text TYPE string,
    END OF ty_transport_to_branch .

  TYPES:
    BEGIN OF ty_diff,
      patch_flag TYPE abap_bool,
      new_num    TYPE c LENGTH 6,
      new        TYPE string,
      result     TYPE c LENGTH 1,
      old_num    TYPE c LENGTH 6,
      old        TYPE string,
      short      TYPE abap_bool,
      beacon     TYPE i,
    END OF ty_diff .
  TYPES:
    ty_diffs_tt TYPE STANDARD TABLE OF ty_diff
                     WITH DEFAULT KEY
                     WITH NON-UNIQUE SORTED KEY new_num COMPONENTS new_num
                     WITH NON-UNIQUE SORTED KEY old_num COMPONENTS old_num.
  TYPES:
    BEGIN OF ty_count,
      insert TYPE i,
      delete TYPE i,
      update TYPE i,
    END OF ty_count .
  TYPES:
    BEGIN OF ty_ancestor,
      commit TYPE zif_abapgit_git_definitions=>ty_sha1,
      tree   TYPE zif_abapgit_git_definitions=>ty_sha1,
      time   TYPE string,
      body   TYPE string,
    END OF ty_ancestor .
  TYPES:
    BEGIN OF ty_repo_item,
      obj_type   TYPE tadir-object,
      obj_name   TYPE tadir-obj_name,
      inactive   TYPE abap_bool,
      sortkey    TYPE i,
      path       TYPE string,
      is_dir     TYPE abap_bool,
      changes    TYPE i,
      lstate     TYPE zif_abapgit_git_definitions=>ty_item_state,
      rstate     TYPE zif_abapgit_git_definitions=>ty_item_state,
      files      TYPE ty_repo_file_tt,
      changed_by TYPE syuname,
      transport  TYPE trkorr,
      packmove   TYPE abap_bool,
      srcsystem  TYPE tadir-srcsystem,
      origlang   TYPE tadir-masterlang,
    END OF ty_repo_item .
  TYPES:
    ty_repo_item_tt TYPE STANDARD TABLE OF ty_repo_item WITH DEFAULT KEY .
  TYPES:
    BEGIN OF ty_s_user_settings,
      max_lines              TYPE i,
      adt_jump_enabled       TYPE abap_bool,
      show_default_repo      TYPE abap_bool,
      link_hints_enabled     TYPE abap_bool,
      link_hint_key          TYPE c LENGTH 1,
      parallel_proc_disabled TYPE abap_bool,
      icon_scaling           TYPE c LENGTH 1,
      ui_theme               TYPE string,
      hide_sapgui_hint       TYPE abap_bool,
      activate_wo_popup      TYPE abap_bool,
      label_colors           TYPE string,
      default_git_uname      TYPE string,
      default_git_email      TYPE string,
    END OF ty_s_user_settings .
  TYPES:
    BEGIN OF ty_list_settings,
      filter           TYPE string,
      only_favorites   TYPE abap_bool,
      show_details     TYPE abap_bool,
      order_by         TYPE string,
      order_descending TYPE abap_bool,
    END OF ty_list_settings.
  TYPES:
    ty_dokil_tt TYPE STANDARD TABLE OF dokil
                         WITH NON-UNIQUE DEFAULT KEY .
  TYPES:
    BEGIN OF ty_col_spec,
      tech_name      TYPE string,
      display_name   TYPE string,
      css_class      TYPE string,
      add_tz         TYPE abap_bool,
      title          TYPE string,
      allow_order_by TYPE abap_bool,
    END OF ty_col_spec,
    ty_col_spec_tt TYPE STANDARD TABLE OF ty_col_spec
                      WITH NON-UNIQUE KEY tech_name.
  TYPES:
    ty_proxy_bypass_url       TYPE c LENGTH 255,
    ty_range_proxy_bypass_url TYPE RANGE OF ty_proxy_bypass_url.
  TYPES:
    BEGIN OF ty_version,
      major           TYPE i,
      minor           TYPE i,
      patch           TYPE i,
      prerelase       TYPE string,
      prerelase_patch TYPE i,
    END OF ty_version.
  TYPES ty_sci_result TYPE c LENGTH 1.
  CONSTANTS:
    BEGIN OF c_sci_result,
      no_run  TYPE ty_sci_result VALUE '',
      failed  TYPE ty_sci_result VALUE 'F',
      warning TYPE ty_sci_result VALUE 'W',
      passed  TYPE ty_sci_result VALUE 'P',
    END OF c_sci_result.
  CONSTANTS:
    BEGIN OF c_diff,
      unchanged TYPE c LENGTH 1 VALUE ' ',
      insert    TYPE c LENGTH 1 VALUE 'I',
      delete    TYPE c LENGTH 1 VALUE 'D',
      update    TYPE c LENGTH 1 VALUE 'U',
    END OF c_diff .
  CONSTANTS:
    BEGIN OF c_state, " https://git-scm.com/docs/git-status
      unchanged TYPE zif_abapgit_git_definitions=>ty_item_state VALUE '',
      added     TYPE zif_abapgit_git_definitions=>ty_item_state VALUE 'A',
      modified  TYPE zif_abapgit_git_definitions=>ty_item_state VALUE 'M',
      deleted   TYPE zif_abapgit_git_definitions=>ty_item_state VALUE 'D',
      mixed     TYPE zif_abapgit_git_definitions=>ty_item_state VALUE '*',
    END OF c_state .
  CONSTANTS c_english TYPE spras VALUE 'E' ##NO_TEXT.
  CONSTANTS c_root_dir TYPE string VALUE '/' ##NO_TEXT.
  CONSTANTS c_dot_abapgit TYPE string VALUE '.abapgit.xml' ##NO_TEXT.
  CONSTANTS c_author_regex TYPE string VALUE '^(.+) <(.*)> (\d{10})\s?.\d{4}$' ##NO_TEXT.
  CONSTANTS:
    BEGIN OF c_action,
      abapgit_home                  TYPE string VALUE 'abapgit_home',
      bg_update                     TYPE string VALUE 'bg_update',
      change_order_by               TYPE string VALUE 'change_order_by',
      changelog                     TYPE string VALUE 'changelog',
      clipboard                     TYPE string VALUE 'clipboard',
      db_display                    TYPE string VALUE 'db_display',
      db_edit                       TYPE string VALUE 'db_edit',
      direction                     TYPE string VALUE 'direction',
      documentation                 TYPE string VALUE 'documentation',
      flow                          TYPE string VALUE 'flow',
      git_branch_create             TYPE string VALUE 'git_branch_create',
      git_branch_delete             TYPE string VALUE 'git_branch_delete',
      git_branch_merge              TYPE string VALUE 'git_branch_merge',
      git_branch_switch             TYPE string VALUE 'git_branch_switch',
      git_commit                    TYPE string VALUE 'git_commit',
      git_pull                      TYPE string VALUE 'git_pull',
      git_tag_create                TYPE string VALUE 'git_tag_create',
      git_tag_delete                TYPE string VALUE 'git_tag_delete',
      git_tag_switch                TYPE string VALUE 'git_tag_switch',
      go_back                       TYPE string VALUE 'go_back',
      go_background                 TYPE string VALUE 'go_background',
      go_background_run             TYPE string VALUE 'go_background_run',
      go_commit                     TYPE string VALUE 'go_commit',
      go_db                         TYPE string VALUE 'go_db',
      go_debuginfo                  TYPE string VALUE 'go_debuginfo',
      go_explore                    TYPE string VALUE 'go_explore',
      go_file_diff                  TYPE string VALUE 'go_file_diff',
      go_home                       TYPE string VALUE 'go_home',
      go_patch                      TYPE string VALUE 'go_patch',
      go_repo                       TYPE string VALUE 'go_repo',
      go_repo_diff                  TYPE string VALUE 'go_repo_diff',
      go_settings                   TYPE string VALUE 'go_settings',
      go_settings_personal          TYPE string VALUE 'go_settings_personal',
      go_stage                      TYPE string VALUE 'go_stage',
      go_stage_transport            TYPE string VALUE 'go_stage_transport',
      go_tutorial                   TYPE string VALUE 'go_tutorial',
      goto_message                  TYPE string VALUE 'goto_message',
      goto_source                   TYPE string VALUE 'goto_source',
      homepage                      TYPE string VALUE 'homepage',
      ie_devtools                   TYPE string VALUE 'ie_devtools',
      jump                          TYPE string VALUE 'jump',
      jump_transaction              TYPE string VALUE 'jump_transaction',
      jump_transport                TYPE string VALUE 'jump_transport',
      jump_user                     TYPE string VALUE 'jump_user',
      performance_test              TYPE string VALUE 'performance_test',
      repo_activate_objects         TYPE string VALUE 'repo_activate_objects',
      repo_add_all_obj_to_trans_req TYPE string VALUE 'repo_add_all_obj_to_trans_req',
      repo_background               TYPE string VALUE 'repo_background',
      repo_change_package           TYPE string VALUE 'repo_change_package',
      repo_code_inspector           TYPE string VALUE 'repo_code_inspector',
      repo_delete_objects           TYPE string VALUE 'repo_delete_objects',
      repo_infos                    TYPE string VALUE 'repo_infos',
      repo_local_settings           TYPE string VALUE 'repo_local_settings',
      repo_log                      TYPE string VALUE 'repo_log',
      repo_newoffline               TYPE string VALUE 'repo_newoffline',
      repo_newonline                TYPE string VALUE 'repo_newonline',
      repo_open_in_master_lang      TYPE string VALUE 'repo_open_in_master_lang',
      repo_purge                    TYPE string VALUE 'repo_purge',
      repo_refresh                  TYPE string VALUE 'repo_refresh',
      repo_refresh_checksums        TYPE string VALUE 'repo_refresh_checksums',
      repo_remote_settings          TYPE string VALUE 'repo_remote_settings',
      repo_remove                   TYPE string VALUE 'repo_remove',
      repo_settings                 TYPE string VALUE 'repo_settings',
      repo_syntax_check             TYPE string VALUE 'repo_syntax_check',
      repo_toggle_fav               TYPE string VALUE 'repo_toggle_fav',
      repo_transport_to_branch      TYPE string VALUE 'repo_transport_to_branch',
      rfc_compare                   TYPE string VALUE 'rfc_compare',
      show_callstack                TYPE string VALUE 'show_callstack',
      show_hotkeys                  TYPE string VALUE 'show_hotkeys',
      sponsor                       TYPE string VALUE 'sponsor',
      toggle_favorites              TYPE string VALUE 'toggle_favorites',
      url                           TYPE string VALUE 'url',
      where_used                    TYPE string VALUE 'where_used',
      zip_export                    TYPE string VALUE 'zip_export',
      zip_export_transport          TYPE string VALUE 'zip_export_transport',
      zip_import                    TYPE string VALUE 'zip_import',
      zip_object                    TYPE string VALUE 'zip_object',
      zip_package                   TYPE string VALUE 'zip_package',
      zip_transport                 TYPE string VALUE 'zip_transport',
    END OF c_action.
  CONSTANTS c_spagpa_param_repo_key TYPE c LENGTH 20 VALUE 'REPO_KEY' ##NO_TEXT.
  CONSTANTS c_spagpa_param_package TYPE c LENGTH 20 VALUE 'PACKAGE' ##NO_TEXT.
  CONSTANTS c_yes TYPE ty_yes_no VALUE 'Y'.
  CONSTANTS c_no TYPE ty_yes_no VALUE 'N'.
  CONSTANTS c_partial TYPE ty_yes_no_partial VALUE 'P'.

  TYPES:
    ty_method TYPE c LENGTH 1 .
  TYPES:
    BEGIN OF ty_stage,
      file   TYPE zif_abapgit_git_definitions=>ty_file,
      method TYPE ty_method,
      status TYPE ty_result,
    END OF ty_stage .
  TYPES:
    ty_stage_tt TYPE SORTED TABLE OF ty_stage
          WITH UNIQUE KEY file-path file-filename .

  CONSTANTS:
    BEGIN OF c_method,
      add    TYPE ty_method VALUE 'A',
      rm     TYPE ty_method VALUE 'R',
      ignore TYPE ty_method VALUE 'I',
      skip   TYPE ty_method VALUE '?',
    END OF c_method .

  TYPES:
    ty_sap_langu_tab TYPE STANDARD TABLE OF langu WITH DEFAULT KEY.
  TYPES:
    ty_languages TYPE STANDARD TABLE OF laiso WITH DEFAULT KEY.
  TYPES:
    BEGIN OF ty_i18n_params,
      main_language         TYPE sy-langu,
      main_language_only    TYPE abap_bool,
      translation_languages TYPE ty_languages,
      use_lxe               TYPE abap_bool,
    END OF ty_i18n_params .
  TYPES ty_trrngtrkor_tt TYPE RANGE OF trkorr.

  CONSTANTS c_multiple_transports TYPE trkorr VALUE 'MULTIPLE'.

ENDINTERFACE.

INTERFACE zif_abapgit_ajson_types
  .

  TYPES:
    ty_node_type TYPE string.

  CONSTANTS:
    BEGIN OF node_type,
      boolean TYPE ty_node_type VALUE 'bool',
      string  TYPE ty_node_type VALUE 'str',
      number  TYPE ty_node_type VALUE 'num',
      null    TYPE ty_node_type VALUE 'null',
      array   TYPE ty_node_type VALUE 'array',
      object  TYPE ty_node_type VALUE 'object',
    END OF node_type.

  TYPES:
    BEGIN OF ty_node,
      path     TYPE string,
      name     TYPE string,
      type     TYPE ty_node_type,
      value    TYPE string,
      index    TYPE i,
      order    TYPE i,
      children TYPE i,
    END OF ty_node.
  TYPES:
    ty_nodes_tt TYPE STANDARD TABLE OF ty_node WITH KEY path name.
  TYPES:
    ty_nodes_ts TYPE SORTED TABLE OF ty_node
      WITH UNIQUE KEY path name
      WITH NON-UNIQUE SORTED KEY array_index COMPONENTS path index
      WITH NON-UNIQUE SORTED KEY item_order COMPONENTS path order.

  TYPES:
    BEGIN OF ty_path_name,
      path TYPE string,
      name TYPE string,
    END OF ty_path_name.

ENDINTERFACE.

INTERFACE zif_abapgit_ajson
  .

  CONSTANTS version TYPE string VALUE 'v1.1.11'. "#EC NOTEXT
  CONSTANTS origin TYPE string VALUE 'https://github.com/sbcgua/ajson'. "#EC NOTEXT
  CONSTANTS license TYPE string VALUE 'MIT'. "#EC NOTEXT

  TYPES:
    BEGIN OF ty_opts,
      read_only                  TYPE abap_bool,
      keep_item_order            TYPE abap_bool,
      format_datetime            TYPE abap_bool,
      to_abap_corresponding_only TYPE abap_bool,
    END OF ty_opts.

  " DATA

  DATA mt_json_tree TYPE zif_abapgit_ajson_types=>ty_nodes_ts READ-ONLY.

  " CLONING

  METHODS clone
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.
  METHODS filter
    IMPORTING
      ii_filter      TYPE REF TO zif_abapgit_ajson_filter
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.
  METHODS map
    IMPORTING
      ii_mapper      TYPE REF TO zif_abapgit_ajson_mapping
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  " METHODS

  METHODS freeze.
  METHODS keep_item_order
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson.
  METHODS format_datetime
    IMPORTING
      iv_use_iso     TYPE abap_bool DEFAULT abap_true
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson.
  METHODS to_abap_corresponding_only
    IMPORTING
      iv_enable      TYPE abap_bool DEFAULT abap_true
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson.
  METHODS opts
    RETURNING
      VALUE(rs_opts) TYPE ty_opts.

  " METHODS ex.reader

  METHODS is_empty
    RETURNING
      VALUE(rv_yes) TYPE abap_bool.

  METHODS exists
    IMPORTING
      iv_path          TYPE string
    RETURNING
      VALUE(rv_exists) TYPE abap_bool.

  METHODS members
    IMPORTING
      iv_path           TYPE string
    RETURNING
      VALUE(rt_members) TYPE string_table.

  METHODS get
    IMPORTING
      iv_path         TYPE string
    RETURNING
      VALUE(rv_value) TYPE string.

  METHODS get_node_type
    IMPORTING
      iv_path             TYPE string
    RETURNING
      VALUE(rv_node_type) TYPE zif_abapgit_ajson_types=>ty_node_type.

  METHODS get_boolean
    IMPORTING
      iv_path         TYPE string
    RETURNING
      VALUE(rv_value) TYPE abap_bool.

  METHODS get_integer
    IMPORTING
      iv_path         TYPE string
    RETURNING
      VALUE(rv_value) TYPE i.

  METHODS get_number
    IMPORTING
      iv_path         TYPE string
    RETURNING
      VALUE(rv_value) TYPE f.

  METHODS get_date
    IMPORTING
      iv_path         TYPE string
    RETURNING
      VALUE(rv_value) TYPE d.

  METHODS get_timestamp
    IMPORTING
      iv_path         TYPE string
    RETURNING
      VALUE(rv_value) TYPE timestamp.

  METHODS get_string
    IMPORTING
      iv_path         TYPE string
    RETURNING
      VALUE(rv_value) TYPE string.

  METHODS slice
    IMPORTING
      iv_path        TYPE string
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson.

  METHODS to_abap
    IMPORTING
      iv_corresponding TYPE abap_bool DEFAULT abap_false
    EXPORTING
      ev_container     TYPE any
    RAISING
      zcx_abapgit_ajson_error.

  METHODS array_to_string_table
    IMPORTING
      iv_path                TYPE string
    RETURNING
      VALUE(rt_string_table) TYPE string_table
    RAISING
      zcx_abapgit_ajson_error.

  " METHODS ex.writer

  METHODS clear
    RAISING
      zcx_abapgit_ajson_error.

  METHODS set
    IMPORTING
      iv_path         TYPE string
      iv_val          TYPE any
      iv_ignore_empty TYPE abap_bool DEFAULT abap_true
      iv_node_type    TYPE zif_abapgit_ajson_types=>ty_node_type OPTIONAL
    RETURNING
      VALUE(ri_json)  TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  METHODS setx
    IMPORTING
      iv_param       TYPE string
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  METHODS set_boolean
    IMPORTING
      iv_path        TYPE string
      iv_val         TYPE any
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  METHODS set_string
    IMPORTING
      iv_path        TYPE string
      iv_val         TYPE clike
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  METHODS set_integer
    IMPORTING
      iv_path        TYPE string
      iv_val         TYPE i
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  METHODS set_date
    IMPORTING
      iv_path        TYPE string
      iv_val         TYPE d
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  METHODS set_timestamp
    IMPORTING
      iv_path        TYPE string
      iv_val         TYPE timestamp
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  METHODS set_null
    IMPORTING
      iv_path        TYPE string
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  METHODS delete
    IMPORTING
      iv_path        TYPE string
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  METHODS touch_array
    IMPORTING
      iv_path        TYPE string
      iv_clear       TYPE abap_bool DEFAULT abap_false
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  METHODS push
    IMPORTING
      iv_path        TYPE string
      iv_val         TYPE any
    RETURNING
      VALUE(ri_json) TYPE REF TO zif_abapgit_ajson
    RAISING
      zcx_abapgit_ajson_error.

  METHODS stringify
    IMPORTING
      iv_indent      TYPE i DEFAULT 0
    RETURNING
      VALUE(rv_json) TYPE string
    RAISING
      zcx_abapgit_ajson_error.

ENDINTERFACE.

INTERFACE zif_abapgit_ajson_filter
  .

  TYPES ty_filter_tab TYPE STANDARD TABLE OF REF TO zif_abapgit_ajson_filter WITH KEY table_line.
  TYPES ty_visit_type TYPE i.

  CONSTANTS:
    BEGIN OF visit_type,
      value TYPE ty_visit_type VALUE 0,
      open  TYPE ty_visit_type VALUE 1,
      close TYPE ty_visit_type VALUE 2,
    END OF visit_type.

  METHODS keep_node
    IMPORTING
      is_node        TYPE zif_abapgit_ajson_types=>ty_node
      iv_visit       TYPE ty_visit_type DEFAULT visit_type-value
    RETURNING
      VALUE(rv_keep) TYPE abap_bool
    RAISING
      zcx_abapgit_ajson_error.

ENDINTERFACE.

INTERFACE zif_abapgit_ajson_mapping
  .

  TYPES:
    BEGIN OF ty_mapping_field, " deprecated, will be removed
      abap TYPE string,
      json TYPE string,
    END OF ty_mapping_field,
    ty_mapping_fields TYPE STANDARD TABLE OF ty_mapping_field
      WITH UNIQUE SORTED KEY abap COMPONENTS abap
      WITH UNIQUE SORTED KEY json COMPONENTS json.

  TYPES:
    BEGIN OF ty_rename,
      from TYPE string,
      to   TYPE string,
    END OF ty_rename,
    tty_rename_map TYPE STANDARD TABLE OF ty_rename
      WITH UNIQUE SORTED KEY by_name COMPONENTS from.

  TYPES:
    ty_table_of TYPE STANDARD TABLE OF REF TO zif_abapgit_ajson_mapping.

  METHODS to_abap " deprecated, will be removed
    IMPORTING
      !iv_path         TYPE string
      !iv_name         TYPE string
    RETURNING
      VALUE(rv_result) TYPE string.

  METHODS to_json " deprecated, will be removed
    IMPORTING
      !iv_path         TYPE string
      !iv_name         TYPE string
    RETURNING
      VALUE(rv_result) TYPE string.

  METHODS rename_node
    IMPORTING
      !is_node TYPE zif_abapgit_ajson_types=>ty_node
    CHANGING
      !cv_name TYPE zif_abapgit_ajson_types=>ty_node-name.

ENDINTERFACE.

INTERFACE zif_abapgit_cts_api
   .

  TYPES:
    BEGIN OF ty_transport,
      obj_type TYPE tadir-object,
      obj_name TYPE tadir-obj_name,
      trkorr   TYPE trkorr,
    END OF ty_transport .
  TYPES:
    ty_transport_list TYPE SORTED TABLE OF ty_transport WITH NON-UNIQUE KEY obj_type obj_name .
  TYPES:
    ty_trkorr_tt TYPE STANDARD TABLE OF trkorr WITH DEFAULT KEY .
  TYPES:
    BEGIN OF ty_transport_key,
      object  TYPE e071k-object,
      objname TYPE e071k-objname,
      tabkey  TYPE e071k-tabkey,
    END OF ty_transport_key .
  TYPES:
    BEGIN OF ty_transport_data,
      trstatus TYPE e070-trstatus,
      keys     TYPE STANDARD TABLE OF ty_transport_key WITH DEFAULT KEY,
    END OF ty_transport_data .
  TYPES:
    BEGIN OF ty_transport_obj,
      object   TYPE e071-object,
      obj_name TYPE e071-obj_name,
    END OF ty_transport_obj .
  TYPES:
    ty_transport_obj_tt TYPE STANDARD TABLE OF ty_transport_obj WITH DEFAULT KEY .

  CONSTANTS:
    BEGIN OF c_transport_type,
      wb_request   TYPE c LENGTH 1 VALUE 'K', "workbench request
      wb_repair    TYPE c LENGTH 1 VALUE 'R', "workbench repair
      wb_task      TYPE c LENGTH 1 VALUE 'S', "workbench task
      cust_request TYPE c LENGTH 1 VALUE 'W', "customizing request
      cust_task    TYPE c LENGTH 1 VALUE 'Q', "customizing task
    END OF c_transport_type .
  CONSTANTS:
    BEGIN OF c_transport_category,
      workbench   TYPE c LENGTH 4 VALUE 'SYST',
      customizing TYPE c LENGTH 4 VALUE 'CUST',
    END OF c_transport_category .
  CONSTANTS:
    BEGIN OF c_transport_mode,
      insert TYPE c LENGTH 1 VALUE 'I',
      delete TYPE c LENGTH 1 VALUE 'D',
    END OF c_transport_mode .
  CONSTANTS:
    BEGIN OF c_transport_status,
      modifiable TYPE c LENGTH 1 VALUE 'D',
    END OF c_transport_status .

  METHODS confirm_transport_messages
    RETURNING
      VALUE(rv_messages_confirmed) TYPE abap_bool .
  METHODS create_transport_entries
    IMPORTING
      !iv_transport TYPE trkorr
      !it_table_ins TYPE ANY TABLE OPTIONAL
      !it_table_upd TYPE ANY TABLE OPTIONAL
      !it_table_del TYPE ANY TABLE OPTIONAL
      !iv_tabname   TYPE tabname
    RAISING
      zcx_abapgit_exception .
  METHODS get_r3tr_obj_for_limu_obj
    IMPORTING
      !iv_object   TYPE tadir-object
      !iv_obj_name TYPE trobj_name
    EXPORTING
      !ev_object   TYPE tadir-object
      !ev_obj_name TYPE trobj_name
    RAISING
      zcx_abapgit_exception .
  METHODS get_transports_for_list
    IMPORTING
      !it_items            TYPE zif_abapgit_definitions=>ty_items_tt
    RETURNING
      VALUE(rt_transports) TYPE ty_transport_list
    RAISING
      zcx_abapgit_exception .
  "! Returns the transport request / task the object is currently in
  "! @parameter is_item | Object
  "! @parameter rv_transport | Transport request / task
  "! @raising zcx_abapgit_exception | Object is not in a transport
  METHODS get_transport_for_object
    IMPORTING
      !is_item            TYPE zif_abapgit_definitions=>ty_item
    RETURNING
      VALUE(rv_transport) TYPE trkorr
    RAISING
      zcx_abapgit_exception .
  METHODS insert_transport_object
    IMPORTING
      !iv_pgmid    TYPE tadir-pgmid DEFAULT 'R3TR'
      !iv_object   TYPE tadir-object
      !iv_obj_name TYPE csequence
      !iv_package  TYPE devclass
      !iv_language TYPE sy-langu DEFAULT sy-langu
      !iv_mode     TYPE c DEFAULT 'I'
    EXPORTING
      !ev_object   TYPE tadir-object
      !ev_obj_name TYPE trobj_name
    RAISING
      zcx_abapgit_exception .
  "! Check if change recording is possible for the given package
  "! @parameter iv_package | Package
  "! @parameter rv_possible | Change recording is possible
  "! @raising zcx_abapgit_exception | Package could not be loaded
  METHODS is_chrec_possible_for_package
    IMPORTING
      !iv_package        TYPE devclass
    RETURNING
      VALUE(rv_possible) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS list_open_requests_by_user
    IMPORTING
      !iv_user         TYPE sy-uname DEFAULT sy-uname
    RETURNING
      VALUE(rt_trkorr) TYPE ty_trkorr_tt
    RAISING
      zcx_abapgit_exception .
  METHODS list_r3tr_by_request
    IMPORTING
      !iv_request    TYPE trkorr
    RETURNING
      VALUE(rt_list) TYPE ty_transport_obj_tt
    RAISING
      zcx_abapgit_exception .
  METHODS read
    IMPORTING
      !iv_trkorr        TYPE trkorr
    RETURNING
      VALUE(rs_request) TYPE ty_transport_data
    RAISING
      zcx_abapgit_exception .
  METHODS read_description
    IMPORTING
      !iv_trkorr            TYPE trkorr
    RETURNING
      VALUE(rv_description) TYPE string .
  METHODS read_user
    IMPORTING
      !iv_trkorr      TYPE trkorr
    RETURNING
      VALUE(rv_uname) TYPE uname .
  METHODS validate_transport_request
    IMPORTING
      !iv_transport_request TYPE trkorr
    RAISING
      zcx_abapgit_exception .

  METHODS change_transport_type
    IMPORTING
      !iv_transport_request   TYPE trkorr
      !iv_transport_type_from TYPE trfunction
      !iv_transport_type_to   TYPE trfunction
    RAISING
      zcx_abapgit_exception.
ENDINTERFACE.

INTERFACE zif_abapgit_data_config
   .

  TYPES:
    ty_data_type TYPE c LENGTH 4 .
  TYPES:
    BEGIN OF ty_config,
      type         TYPE ty_data_type,
      name         TYPE tadir-obj_name,
      skip_initial TYPE abap_bool,
      where        TYPE string_table,
    END OF ty_config .
  TYPES:
    ty_config_tt TYPE SORTED TABLE OF ty_config WITH UNIQUE KEY type name .

  CONSTANTS c_default_path TYPE string VALUE '/data/' ##NO_TEXT.
  CONSTANTS c_default_format TYPE string VALUE 'json' ##NO_TEXT.
  CONSTANTS c_config TYPE string VALUE 'conf' ##NO_TEXT.
  CONSTANTS:
    BEGIN OF c_data_type,
      tabu TYPE ty_data_type VALUE 'TABU',
      vdat TYPE ty_data_type VALUE 'VDAT',
      cdat TYPE ty_data_type VALUE 'CDAT',
      tdat TYPE ty_data_type VALUE 'TDAT',
    END OF c_data_type .

  METHODS add_config
    IMPORTING
      !is_config TYPE ty_config
    RAISING
      zcx_abapgit_exception .
  METHODS from_json
    IMPORTING
      !it_files TYPE zif_abapgit_git_definitions=>ty_files_tt
    RAISING
      zcx_abapgit_exception .
  METHODS get_configs
    RETURNING
      VALUE(rt_configs) TYPE ty_config_tt .
  METHODS remove_config
    IMPORTING
      !is_config TYPE ty_config
    RAISING
      zcx_abapgit_exception .
  METHODS to_json
    RETURNING
      VALUE(rt_files) TYPE zif_abapgit_git_definitions=>ty_files_tt
    RAISING
      zcx_abapgit_exception .
  METHODS update_config
    IMPORTING
      !is_config TYPE ty_config
    RAISING
      zcx_abapgit_exception .
ENDINTERFACE.

INTERFACE zif_abapgit_data_deserializer
   .

  TYPES: BEGIN OF ty_result,
           type    TYPE zif_abapgit_data_config=>ty_config-type,
           name    TYPE zif_abapgit_data_config=>ty_config-name,
           deletes TYPE REF TO data,
           updates TYPE REF TO data,
           inserts TYPE REF TO data,
           file    TYPE zif_abapgit_git_definitions=>ty_file_signature,
           config  TYPE zif_abapgit_git_definitions=>ty_file_signature,
         END OF ty_result.
  TYPES: ty_results TYPE STANDARD TABLE OF ty_result WITH KEY type name.

  METHODS deserialize_check
    IMPORTING
      !io_repo         TYPE REF TO zcl_abapgit_repo
      !ii_config       TYPE REF TO zif_abapgit_data_config
    RETURNING
      VALUE(rs_checks) TYPE zif_abapgit_definitions=>ty_deserialize_checks-customizing
    RAISING
      zcx_abapgit_exception .

  METHODS deserialize
    IMPORTING
      !ii_config       TYPE REF TO zif_abapgit_data_config
      !it_files        TYPE zif_abapgit_git_definitions=>ty_files_tt
    RETURNING
      VALUE(rt_result) TYPE ty_results
    RAISING
      zcx_abapgit_exception .

  METHODS actualize
    IMPORTING
      !is_checks               TYPE zif_abapgit_definitions=>ty_deserialize_checks
      !it_result               TYPE ty_results
    RETURNING
      VALUE(rt_accessed_files) TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt
    RAISING
      zcx_abapgit_exception .
ENDINTERFACE.

INTERFACE zif_abapgit_data_serializer
   .

  METHODS serialize
    IMPORTING
      !ii_config      TYPE REF TO zif_abapgit_data_config
    RETURNING
      VALUE(rt_files) TYPE zif_abapgit_git_definitions=>ty_files_tt
    RAISING
      zcx_abapgit_exception .
ENDINTERFACE.

INTERFACE zif_abapgit_data_supporter
  .

  TYPES:
    BEGIN OF ty_object,
      type TYPE zif_abapgit_data_config=>ty_config-type,
      name TYPE zif_abapgit_data_config=>ty_config-name,
    END OF ty_object.
  TYPES:
    ty_objects TYPE SORTED TABLE OF ty_object WITH UNIQUE KEY type name.

  METHODS is_object_supported
    IMPORTING
      !iv_type            TYPE ty_object-type
      !iv_name            TYPE ty_object-name
    RETURNING
      VALUE(rv_supported) TYPE abap_bool.

ENDINTERFACE.

INTERFACE zif_abapgit_default_transport .

  TYPES: BEGIN OF ty_get,
           trfunction TYPE c LENGTH 1,
           ordernum   TYPE trkorr,
         END OF ty_get.

  METHODS set
    IMPORTING
      iv_transport TYPE trkorr
    RAISING
      zcx_abapgit_exception.

  METHODS reset
    RAISING
      zcx_abapgit_exception.

  METHODS get
    RETURNING
      VALUE(rs_default_task) TYPE ty_get
    RAISING
      zcx_abapgit_exception .

ENDINTERFACE.

INTERFACE zif_abapgit_sap_package
   .

  TYPES:
    ty_devclass_tt TYPE STANDARD TABLE OF devclass WITH DEFAULT KEY .

  TYPES: BEGIN OF ty_create,
           devclass  TYPE devclass,
           dlvunit   TYPE tdevc-dlvunit,
           component TYPE c LENGTH 20,
           ctext     TYPE c LENGTH 60,
           parentcl  TYPE devclass,
           pdevclass TYPE c LENGTH 4,
           as4user   TYPE usnam,
         END OF ty_create.

  METHODS get
    RETURNING
      VALUE(rs_package) TYPE ty_create
    RAISING
      zcx_abapgit_exception .
  METHODS validate_name
    RAISING
      zcx_abapgit_exception .
  METHODS create
    IMPORTING
      !is_package TYPE ty_create
    RAISING
      zcx_abapgit_exception .
  METHODS create_local
    RAISING
      zcx_abapgit_exception .
  METHODS list_subpackages
    RETURNING
      VALUE(rt_list) TYPE ty_devclass_tt .
  METHODS list_superpackages
    RETURNING
      VALUE(rt_list) TYPE ty_devclass_tt
    RAISING
      zcx_abapgit_exception .
  METHODS read_parent
    RETURNING
      VALUE(rv_parentcl) TYPE devclass
    RAISING
      zcx_abapgit_exception .
  METHODS read_description
    RETURNING
      VALUE(rv_description) TYPE string.
  METHODS read_responsible
    RETURNING
      VALUE(rv_responsible) TYPE usnam.
  METHODS create_child
    IMPORTING
      !iv_child TYPE devclass
    RAISING
      zcx_abapgit_exception .
  METHODS exists
    RETURNING
      VALUE(rv_bool) TYPE abap_bool .
  METHODS are_changes_recorded_in_tr_req
    RETURNING
      VALUE(rv_are_changes_rec_in_tr_req) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .
  METHODS get_transport_type
    RETURNING
      VALUE(rs_transport_type) TYPE zif_abapgit_definitions=>ty_transport_type
    RAISING
      zcx_abapgit_exception .
ENDINTERFACE.

INTERFACE zif_abapinst_dot_abapgit .

  TYPES:
  " Former APACK
    BEGIN OF ty_dependency,
      name           TYPE string,
      version        TYPE string,
      sem_version    TYPE zif_abapgit_definitions=>ty_version,
      git_url        TYPE string,
      target_package TYPE devclass,
    END OF ty_dependency,
    ty_dependencies TYPE STANDARD TABLE OF ty_dependency WITH NON-UNIQUE DEFAULT KEY.

  TYPES:
    BEGIN OF ty_descriptor,
      name           TYPE string,
      version        TYPE string,
      sem_version    TYPE zif_abapgit_definitions=>ty_version,
      description    TYPE string,
      git_url        TYPE string,
      target_package TYPE devclass,
      logo           TYPE string,
    END OF ty_descriptor.

  TYPES:
    BEGIN OF ty_packaging.
      INCLUDE TYPE ty_descriptor.
  TYPES:
      dependencies TYPE ty_dependencies,
    END OF ty_packaging.

ENDINTERFACE.

INTERFACE zif_abapgit_dot_abapgit .

  TYPES:
    BEGIN OF ty_requirement,
      component   TYPE tdevc-dlvunit,
      min_release TYPE saprelease,
      min_patch   TYPE sappatchlv,
    END OF ty_requirement .
  TYPES:
    ty_requirement_tt TYPE STANDARD TABLE OF ty_requirement WITH DEFAULT KEY .

  TYPES:
    BEGIN OF ty_dot_abapgit,
      name                  TYPE string,
      master_language       TYPE spras,
      i18n_languages        TYPE zif_abapgit_definitions=>ty_languages,
      use_lxe               TYPE abap_bool,
      starting_folder       TYPE string,
      folder_logic          TYPE string,
      ignore                TYPE STANDARD TABLE OF string WITH DEFAULT KEY,
      requirements          TYPE ty_requirement_tt,
      version_constant      TYPE string,
      abap_language_version TYPE string,
      original_system       TYPE tadir-srcsystem,
      packaging             TYPE zif_abapinst_dot_abapgit=>ty_packaging,
    END OF ty_dot_abapgit .

  CONSTANTS:
    BEGIN OF c_folder_logic,
      prefix TYPE string VALUE 'PREFIX',
      full   TYPE string VALUE 'FULL',
      mixed  TYPE string VALUE 'MIXED',
    END OF c_folder_logic,

    BEGIN OF c_abap_language_version,
      standard          TYPE string VALUE 'standard',
      key_user          TYPE string VALUE 'keyUser',
      cloud_development TYPE string VALUE 'cloudDevelopment',
      ignore            TYPE string VALUE 'ignore',
      undefined         TYPE string VALUE 'undefined', " any
    END OF c_abap_language_version.

ENDINTERFACE.

INTERFACE zif_abapgit_environment
  .
  TYPES:
    BEGIN OF ty_release_sp,
      release TYPE c LENGTH 10,
      sp      TYPE c LENGTH 10,
    END OF ty_release_sp,
    ty_system_language_filter TYPE RANGE OF spras.

  METHODS is_sap_cloud_platform
    RETURNING
      VALUE(rv_result) TYPE abap_bool.
  METHODS is_merged
    RETURNING
      VALUE(rv_result) TYPE abap_bool.
  METHODS is_repo_object_changes_allowed
    RETURNING
      VALUE(rv_result) TYPE abap_bool.
  METHODS compare_with_inactive
    RETURNING
      VALUE(rv_result) TYPE abap_bool.
  METHODS is_restart_required
    RETURNING
      VALUE(rv_result) TYPE abap_bool.
  METHODS is_sap_object_allowed
    RETURNING
      VALUE(rv_allowed) TYPE abap_bool.
  METHODS get_basis_release
    RETURNING
      VALUE(rs_result) TYPE ty_release_sp.
  METHODS get_system_language_filter
    RETURNING
      VALUE(rt_system_language_filter) TYPE ty_system_language_filter.
  METHODS is_variant_maintenance
    RETURNING
      VALUE(rv_is_variant_maintenance) TYPE abap_bool.
  METHODS init_parallel_processing
    IMPORTING
      iv_group                      TYPE clike
    RETURNING
      VALUE(rv_free_work_processes) TYPE i.
  METHODS check_parallel_processing
    IMPORTING
      iv_group          TYPE clike
    RETURNING
      VALUE(rv_checked) TYPE abap_bool.
  METHODS get_available_user_sessions
    RETURNING
      VALUE(rv_sessions) TYPE i.

ENDINTERFACE.

INTERFACE zif_abapgit_persistence .

  TYPES:
    ty_type  TYPE c LENGTH 12 .
  TYPES:
    ty_value TYPE c LENGTH 12 .
  TYPES:
    BEGIN OF ty_content,
      type     TYPE ty_type,
      value    TYPE ty_value,
      data_str TYPE string,
    END OF ty_content .
  TYPES:
    ty_contents TYPE SORTED TABLE OF ty_content WITH UNIQUE KEY type value .

  TYPES: BEGIN OF ty_local_checksum,
           item  TYPE zif_abapgit_definitions=>ty_item_signature,
           files TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt,
         END OF ty_local_checksum.

  TYPES:
    BEGIN OF ty_local_settings,
      display_name                 TYPE string,
      ignore_subpackages           TYPE abap_bool,
      write_protected              TYPE abap_bool,
      only_local_objects           TYPE abap_bool,
      code_inspector_check_variant TYPE sci_chkv,
      block_commit                 TYPE abap_bool,
      main_language_only           TYPE abap_bool,
      labels                       TYPE string,
      transport_request            TYPE trkorr,
      customizing_request          TYPE trkorr,
      flow                         TYPE abap_bool,
      exclude_remote_paths         TYPE string_table,
    END OF ty_local_settings.

  TYPES: ty_local_checksum_tt TYPE STANDARD TABLE OF ty_local_checksum WITH DEFAULT KEY.
  TYPES: ty_local_checksum_by_item_tt TYPE SORTED TABLE OF ty_local_checksum
    WITH NON-UNIQUE KEY item-obj_type item-obj_name.

  TYPES: BEGIN OF ty_repo_xml,
           url             TYPE string,
           branch_name     TYPE string,
           selected_commit TYPE zif_abapgit_git_definitions=>ty_sha1,
           package         TYPE devclass,
           created_by      TYPE syuname,
           created_at      TYPE timestampl,
           deserialized_by TYPE syuname,
           deserialized_at TYPE timestampl,
           offline         TYPE abap_bool,
           switched_origin TYPE string,
           dot_abapgit     TYPE zif_abapgit_dot_abapgit=>ty_dot_abapgit,
           head_branch     TYPE string,   " HEAD symref of the repo, master branch
           local_settings  TYPE ty_local_settings,
         END OF ty_repo_xml.

  TYPES:
    BEGIN OF ty_repo_meta_mask,
      url             TYPE abap_bool,
      branch_name     TYPE abap_bool,
      selected_commit TYPE abap_bool,
      package         TYPE abap_bool,
      created_by      TYPE abap_bool,
      created_at      TYPE abap_bool,
      deserialized_by TYPE abap_bool,
      deserialized_at TYPE abap_bool,
      offline         TYPE abap_bool,
      switched_origin TYPE abap_bool,
      dot_abapgit     TYPE abap_bool,
      head_branch     TYPE abap_bool,
      local_settings  TYPE abap_bool,
    END OF ty_repo_meta_mask.

  TYPES: BEGIN OF ty_repo,
           key TYPE ty_value.
      INCLUDE TYPE ty_repo_xml.
  TYPES: END OF ty_repo.
  TYPES: ty_repos TYPE STANDARD TABLE OF ty_repo WITH DEFAULT KEY.
  TYPES: ty_repo_keys TYPE STANDARD TABLE OF ty_repo-key WITH DEFAULT KEY.

ENDINTERFACE.

INTERFACE zif_abapgit_objects .

  TYPES:
    BEGIN OF ty_serialization,
      files TYPE zif_abapgit_git_definitions=>ty_files_tt,
      item  TYPE zif_abapgit_definitions=>ty_item,
    END OF ty_serialization .
  TYPES:
    BEGIN OF ty_deserialization,
      obj     TYPE REF TO zif_abapgit_object,
      xml     TYPE REF TO zif_abapgit_xml_input,
      package TYPE devclass,
      item    TYPE zif_abapgit_definitions=>ty_item,
    END OF ty_deserialization .
  TYPES:
    ty_deserialization_tt TYPE STANDARD TABLE OF ty_deserialization WITH DEFAULT KEY .
  TYPES:
    ty_types_tt TYPE SORTED TABLE OF tadir-object WITH UNIQUE KEY table_line.
  TYPES:
    ty_deserialization_step TYPE string.
  TYPES:
    ty_deserialization_step_tt TYPE STANDARD TABLE OF ty_deserialization_step WITH DEFAULT KEY.
  TYPES:
    BEGIN OF ty_step_data,
      step_id      TYPE ty_deserialization_step,
      order        TYPE i,
      descr        TYPE string,
      syntax_check TYPE abap_bool,
      objects      TYPE ty_deserialization_tt,
    END OF ty_step_data .
  TYPES:
    ty_step_data_tt TYPE STANDARD TABLE OF ty_step_data
                                WITH DEFAULT KEY .

  CONSTANTS:
    BEGIN OF c_deserialize_action,
      " also used to determine priority if object has multiple changes, so don't change order
      no_support TYPE i VALUE -1,
      none       TYPE i VALUE 0,
      add        TYPE i VALUE 1,
      update     TYPE i VALUE 2,
      overwrite  TYPE i VALUE 3,
      delete     TYPE i VALUE 4,
      delete_add TYPE i VALUE 5,
      packmove   TYPE i VALUE 6,
    END OF c_deserialize_action.

ENDINTERFACE.

INTERFACE zif_abapgit_exit .

  TYPES:
    BEGIN OF ty_ci_repo,
      name      TYPE string,
      clone_url TYPE string,
    END OF ty_ci_repo.

  TYPES ty_ci_repos TYPE STANDARD TABLE OF ty_ci_repo WITH DEFAULT KEY.

  TYPES ty_object_types TYPE HASHED TABLE OF tadir-object WITH UNIQUE KEY table_line.

  TYPES:
    BEGIN OF ty_class_key,
      clsname TYPE abap_classname,
    END OF ty_class_key.

  METHODS adjust_display_commit_url
    IMPORTING
      !iv_repo_url    TYPE csequence
      !iv_repo_name   TYPE csequence
      !iv_repo_key    TYPE csequence
      !iv_commit_hash TYPE zif_abapgit_git_definitions=>ty_sha1
    CHANGING
      !cv_display_url TYPE csequence
    RAISING
      zcx_abapgit_exception.

  METHODS adjust_display_filename
    IMPORTING
      !is_repo_meta      TYPE zif_abapgit_persistence=>ty_repo
      !iv_filename       TYPE string
    RETURNING
      VALUE(rv_filename) TYPE string.

  METHODS allow_sap_objects
    RETURNING
      VALUE(rv_allowed) TYPE abap_bool.

  METHODS change_local_host
    CHANGING
      !ct_hosts TYPE zif_abapgit_definitions=>ty_string_tt.

  METHODS change_max_parallel_processes
    IMPORTING
      !iv_package       TYPE devclass
    CHANGING
      !cv_max_processes TYPE i.

  METHODS change_proxy_authentication
    IMPORTING
      !iv_repo_url             TYPE csequence
    CHANGING
      !cv_proxy_authentication TYPE abap_bool.

  METHODS change_proxy_port
    IMPORTING
      !iv_repo_url   TYPE csequence
    CHANGING
      !cv_proxy_port TYPE string.

  METHODS change_proxy_url
    IMPORTING
      !iv_repo_url  TYPE csequence
    CHANGING
      !cv_proxy_url TYPE string.

  METHODS change_rfc_server_group
    CHANGING
      !cv_group TYPE rzlli_apcl.

  METHODS change_supported_data_objects
    CHANGING
      !ct_objects TYPE zif_abapgit_data_supporter=>ty_objects.

  METHODS change_supported_object_types
    CHANGING
      !ct_types TYPE ty_object_types.

  METHODS change_tadir
    IMPORTING
      !iv_package            TYPE devclass
      !ii_log                TYPE REF TO zif_abapgit_log
      !is_dot_abapgit        TYPE zif_abapgit_dot_abapgit=>ty_dot_abapgit
      !iv_ignore_subpackages TYPE abap_bool DEFAULT abap_false
      !iv_only_local_objects TYPE abap_bool DEFAULT abap_false
    CHANGING
      !ct_tadir              TYPE zif_abapgit_definitions=>ty_tadir_tt.

  METHODS create_http_client
    IMPORTING
      !iv_url          TYPE string
    RETURNING
      VALUE(ri_client) TYPE REF TO if_http_client
    RAISING
      zcx_abapgit_exception.

  METHODS custom_serialize_abap_clif
    IMPORTING
      !is_class_key    TYPE ty_class_key
      !it_source       TYPE zif_abapgit_definitions=>ty_string_tt OPTIONAL
    RETURNING
      VALUE(rt_source) TYPE zif_abapgit_definitions=>ty_string_tt
    RAISING
      zcx_abapgit_exception.

  METHODS deserialize_postprocess
    IMPORTING
      !is_step TYPE zif_abapgit_objects=>ty_step_data
      !ii_log  TYPE REF TO zif_abapgit_log.

  METHODS determine_transport_request
    IMPORTING
      !io_repo              TYPE REF TO zcl_abapgit_repo
      !iv_transport_type    TYPE zif_abapgit_definitions=>ty_transport_type
    CHANGING
      !cv_transport_request TYPE trkorr.

  METHODS enhance_any_toolbar
    IMPORTING
      !io_menu TYPE REF TO zcl_abapgit_html_toolbar.

  METHODS enhance_repo_toolbar
    IMPORTING
      !io_menu TYPE REF TO zcl_abapgit_html_toolbar
      !iv_key  TYPE zif_abapgit_persistence=>ty_value
      !iv_act  TYPE string.

  METHODS get_ci_tests
    IMPORTING
      !iv_object   TYPE tadir-object
    CHANGING
      !ct_ci_repos TYPE ty_ci_repos.

  METHODS get_ssl_id
    RETURNING
      VALUE(rv_ssl_id) TYPE ssfapplssl.

  METHODS http_client
    IMPORTING
      !iv_url    TYPE string
      !ii_client TYPE REF TO if_http_client.

  METHODS pre_calculate_repo_status
    IMPORTING
      !is_repo_meta TYPE zif_abapgit_persistence=>ty_repo
    CHANGING
      !ct_local     TYPE zif_abapgit_definitions=>ty_files_item_tt
      !ct_remote    TYPE zif_abapgit_git_definitions=>ty_files_tt
    RAISING
      zcx_abapgit_exception.

  METHODS serialize_postprocess
    IMPORTING
      !iv_package TYPE devclass
      !ii_log     TYPE REF TO zif_abapgit_log
    CHANGING
      !ct_files   TYPE zif_abapgit_definitions=>ty_files_item_tt.

  METHODS validate_before_push
    IMPORTING
      !is_comment TYPE zif_abapgit_git_definitions=>ty_comment
      !io_stage   TYPE REF TO zcl_abapgit_stage
      !io_repo    TYPE REF TO zcl_abapgit_repo_online
    RAISING
      zcx_abapgit_exception.

ENDINTERFACE.

INTERFACE zif_abapgit_frontend_services .

  TYPES:
    ty_char1       TYPE c LENGTH 1,
    ty_gui_release TYPE n LENGTH 4,
    ty_gui_sp      TYPE n LENGTH 2,
    ty_gui_patch   TYPE n LENGTH 2.

  METHODS file_upload
    IMPORTING
      !iv_path       TYPE string
    RETURNING
      VALUE(rv_xstr) TYPE xstring
    RAISING
      zcx_abapgit_exception.

  METHODS file_download
    IMPORTING
      !iv_path TYPE string
      !iv_xstr TYPE xstring
    RAISING
      zcx_abapgit_exception .

  METHODS show_file_save_dialog
    IMPORTING
      !iv_title            TYPE string
      !iv_extension        TYPE string
      !iv_default_filename TYPE string
    RETURNING
      VALUE(rv_path)       TYPE string
    RAISING
      zcx_abapgit_exception.

  METHODS show_file_open_dialog
    IMPORTING
      !iv_title            TYPE string
      !iv_extension        TYPE string
      !iv_default_filename TYPE string
    RETURNING
      VALUE(rv_path)       TYPE string
    RAISING
      zcx_abapgit_exception.

  METHODS clipboard_export
    IMPORTING
      iv_no_auth_check TYPE abap_bool DEFAULT abap_false
      VALUE(it_data)   TYPE STANDARD TABLE
    RAISING
      zcx_abapgit_exception.

  METHODS execute
    IMPORTING
      !iv_document          TYPE string OPTIONAL
      !iv_application       TYPE string OPTIONAL
      !iv_parameter         TYPE string OPTIONAL
      !iv_default_directory TYPE string OPTIONAL
      !iv_maximized         TYPE string OPTIONAL
      !iv_minimized         TYPE string OPTIONAL
      !iv_synchronous       TYPE string OPTIONAL
      !iv_operation         TYPE string DEFAULT 'OPEN'
    RAISING
      zcx_abapgit_exception.

  METHODS get_system_directory
    CHANGING
      !cv_system_directory TYPE string
    RAISING
      zcx_abapgit_exception.

  METHODS directory_browse
    IMPORTING
      iv_window_title    TYPE string OPTIONAL
      iv_initial_folder  TYPE string OPTIONAL
    CHANGING
      cv_selected_folder TYPE string
    RAISING
      zcx_abapgit_exception.

  METHODS get_file_separator
    CHANGING
      cv_file_separator TYPE ty_char1
    RAISING
      zcx_abapgit_exception.

  METHODS get_gui_version
    EXPORTING
      ev_gui_release        TYPE ty_gui_release
      ev_gui_sp             TYPE ty_gui_sp
      ev_gui_patch          TYPE ty_gui_patch
      ev_gui_version_string TYPE string
    RAISING
      zcx_abapgit_exception.

  METHODS directory_exist
    IMPORTING
      iv_directory     TYPE string
    RETURNING
      VALUE(rv_exists) TYPE abap_bool
    RAISING
      zcx_abapgit_exception.

  METHODS directory_create
    IMPORTING
      iv_directory TYPE string
    CHANGING
      cv_rc        TYPE i
    RAISING
      zcx_abapgit_exception.

  METHODS gui_is_available
    RETURNING
      VALUE(rv_gui_is_available) TYPE abap_bool.

  METHODS is_sapgui_for_java
    RETURNING
      VALUE(rv_result) TYPE abap_bool.

  METHODS is_sapgui_for_windows
    RETURNING
      VALUE(rv_result) TYPE abap_bool.

  METHODS is_webgui
    RETURNING
      VALUE(rv_is_webgui) TYPE abap_bool.

  METHODS open_ie_devtools
    RAISING
      zcx_abapgit_exception.

ENDINTERFACE.

INTERFACE zif_abapgit_gui_jumper
  .

  TYPES:
    ty_bdcdata_tt TYPE STANDARD TABLE OF bdcdata WITH DEFAULT KEY.

  METHODS jump
    IMPORTING
      !is_item        TYPE zif_abapgit_definitions=>ty_item
      !is_sub_item    TYPE zif_abapgit_definitions=>ty_item OPTIONAL
      !iv_line_number TYPE i OPTIONAL
      !iv_new_window  TYPE abap_bool DEFAULT abap_true
    RETURNING
      VALUE(rv_exit)  TYPE abap_bool
    RAISING
      zcx_abapgit_exception.

  METHODS jump_adt
    IMPORTING
      !is_item         TYPE zif_abapgit_definitions=>ty_item
      !iv_sub_obj_name TYPE zif_abapgit_definitions=>ty_item-obj_name
      !iv_line_number  TYPE i
    RETURNING
      VALUE(rv_exit)   TYPE abap_bool
    RAISING
      zcx_abapgit_exception.

  METHODS jump_batch_input
    IMPORTING
      !iv_tcode      TYPE sy-tcode
      !it_bdcdata    TYPE ty_bdcdata_tt
      !iv_new_window TYPE abap_bool DEFAULT abap_true
    RAISING
      zcx_abapgit_exception.

  METHODS jump_abapgit
    IMPORTING
      !iv_language TYPE spras
      !iv_key      TYPE zif_abapgit_persistence=>ty_value
    RAISING
      zcx_abapgit_exception.

ENDINTERFACE.

INTERFACE zif_abapgit_log
   .

  CONSTANTS:
    BEGIN OF c_status,
      ok      TYPE sy-msgty VALUE 'S',
      error   TYPE sy-msgty VALUE 'E',
      warning TYPE sy-msgty VALUE 'W',
    END OF c_status.

  CONSTANTS:
    BEGIN OF c_log_level,
      empty   TYPE i VALUE 0,
      info    TYPE i VALUE 1,
      warning TYPE i VALUE 2,
      error   TYPE i VALUE 3,
    END OF c_log_level.

  TYPES:
    BEGIN OF ty_log_out,
      type      TYPE sy-msgty,
      id        TYPE sy-msgid,
      number    TYPE sy-msgno,
      text      TYPE string,
      obj_type  TYPE tadir-object,
      obj_name  TYPE tadir-obj_name,
      exception TYPE REF TO cx_root,
    END OF ty_log_out .
  TYPES:
    ty_log_outs TYPE STANDARD TABLE OF ty_log_out
                WITH NON-UNIQUE DEFAULT KEY .
  TYPES:
    BEGIN OF ty_msg,
      text   TYPE string,
      type   TYPE sy-msgty,
      id     TYPE sy-msgid,
      number TYPE sy-msgno,
      level  TYPE i,
    END OF ty_msg .
  TYPES:
    ty_msgs TYPE STANDARD TABLE OF ty_msg
                          WITH NON-UNIQUE DEFAULT KEY .
  TYPES:
    BEGIN OF ty_item_status_out,
      item     TYPE zif_abapgit_definitions=>ty_item,
      status   TYPE sy-msgty,
      messages TYPE ty_msgs,
    END OF ty_item_status_out .
  TYPES:
    ty_item_status_outs TYPE SORTED TABLE OF ty_item_status_out
                        WITH UNIQUE KEY item-obj_type item-obj_name .

  METHODS add
    IMPORTING
      !iv_msg    TYPE csequence
      !iv_type   TYPE sy-msgty DEFAULT 'E'
      !iv_class  TYPE sy-msgid OPTIONAL
      !iv_number TYPE sy-msgno OPTIONAL
      !is_item   TYPE zif_abapgit_definitions=>ty_item OPTIONAL
      !ix_exc    TYPE REF TO cx_root OPTIONAL .
  METHODS add_error
    IMPORTING
      !iv_msg  TYPE csequence
      !is_item TYPE zif_abapgit_definitions=>ty_item OPTIONAL .
  METHODS add_info
    IMPORTING
      !iv_msg  TYPE csequence
      !is_item TYPE zif_abapgit_definitions=>ty_item OPTIONAL .
  METHODS add_warning
    IMPORTING
      !iv_msg  TYPE csequence
      !is_item TYPE zif_abapgit_definitions=>ty_item OPTIONAL .
  METHODS add_success
    IMPORTING
      !iv_msg  TYPE csequence
      !is_item TYPE zif_abapgit_definitions=>ty_item OPTIONAL .
  METHODS add_exception
    IMPORTING
      !ix_exc  TYPE REF TO cx_root
      !is_item TYPE zif_abapgit_definitions=>ty_item OPTIONAL .
  METHODS clear .
  METHODS count
    RETURNING
      VALUE(rv_count) TYPE i .
  METHODS get_messages
    RETURNING
      VALUE(rt_msg) TYPE ty_log_outs .
  METHODS get_item_status
    RETURNING
      VALUE(rt_item_status) TYPE ty_item_status_outs .
  METHODS get_status
    RETURNING
      VALUE(rv_status) TYPE sy-msgty .
  METHODS get_log_level
    RETURNING
      VALUE(rv_level) TYPE i .
  METHODS get_title
    RETURNING
      VALUE(rv_title) TYPE string .
  METHODS set_title
    IMPORTING
      !iv_title     TYPE csequence
    RETURNING
      VALUE(ri_log) TYPE REF TO zif_abapgit_log.
  METHODS merge_with
    IMPORTING
      ii_log        TYPE REF TO zif_abapgit_log
      iv_min_level  TYPE i DEFAULT 0
    RETURNING
      VALUE(ri_log) TYPE REF TO zif_abapgit_log.
  METHODS clone
    RETURNING
      VALUE(ri_log) TYPE REF TO zif_abapgit_log.

ENDINTERFACE.

INTERFACE zif_abapgit_longtexts
   .

  TYPES:
    BEGIN OF ty_longtext,
      dokil TYPE dokil,
      head  TYPE thead,
      lines TYPE tline_tab,
    END OF ty_longtext .
  TYPES:
    ty_longtexts TYPE STANDARD TABLE OF ty_longtext WITH NON-UNIQUE DEFAULT KEY .

  METHODS changed_by
    IMPORTING
      !iv_object_name TYPE tadir-obj_name
      !iv_longtext_id TYPE dokil-id
      !it_dokil       TYPE zif_abapgit_definitions=>ty_dokil_tt OPTIONAL
    RETURNING
      VALUE(rv_user)  TYPE syuname
    RAISING
      zcx_abapgit_exception .
  METHODS serialize
    IMPORTING
      !iv_longtext_name   TYPE string DEFAULT 'LONGTEXTS'
      !iv_object_name     TYPE clike
      !iv_longtext_id     TYPE dokil-id
      !it_dokil           TYPE zif_abapgit_definitions=>ty_dokil_tt OPTIONAL
      !ii_xml             TYPE REF TO zif_abapgit_xml_output
      !io_i18n_params     TYPE REF TO zcl_abapgit_i18n_params
    RETURNING
      VALUE(rt_longtexts) TYPE ty_longtexts
    RAISING
      zcx_abapgit_exception .
  METHODS deserialize
    IMPORTING
      !iv_longtext_name TYPE string DEFAULT 'LONGTEXTS'
      !iv_object_name   TYPE clike
      !iv_longtext_id   TYPE dokil-id
      !ii_xml           TYPE REF TO zif_abapgit_xml_input
      !iv_main_language TYPE sy-langu
    RAISING
      zcx_abapgit_exception .
  METHODS delete
    IMPORTING
      !iv_object_name TYPE tadir-obj_name
      !iv_longtext_id TYPE dokil-id
    RAISING
      zcx_abapgit_exception .
ENDINTERFACE.

INTERFACE zif_abapgit_lxe_texts
   .

* type LXE_PCX_S1 inlined to be compatible with open-abap and ABAP Cloud
  TYPES: BEGIN OF ty_text_pair,
           textkey  TYPE c LENGTH 32,
           s_text   TYPE c LENGTH 255,
           t_text   TYPE c LENGTH 255,
           unitmlt  TYPE i,
           uppcase  TYPE c LENGTH 4,
           texttype TYPE c LENGTH 1,
         END OF ty_text_pair.

  TYPES ty_text_pairs TYPE STANDARD TABLE OF ty_text_pair WITH DEFAULT KEY.

  METHODS serialize
    IMPORTING
      !iv_object_type TYPE tadir-object
      !iv_object_name TYPE tadir-obj_name
      !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params
      !ii_xml         TYPE REF TO zif_abapgit_xml_output
      !io_files       TYPE REF TO zcl_abapgit_objects_files
    RAISING
      zcx_abapgit_exception .
  METHODS deserialize
    IMPORTING
      !iv_object_type TYPE tadir-object OPTIONAL
      !iv_object_name TYPE tadir-obj_name OPTIONAL
      !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params
      !ii_xml         TYPE REF TO zif_abapgit_xml_input
      !io_files       TYPE REF TO zcl_abapgit_objects_files
    RAISING
      zcx_abapgit_exception .

ENDINTERFACE.

INTERFACE zif_abapgit_i18n_file .

  TYPES ty_table_of TYPE STANDARD TABLE OF REF TO zif_abapgit_i18n_file WITH DEFAULT KEY.

  METHODS render
    RETURNING
      VALUE(rv_data) TYPE xstring
    RAISING
      zcx_abapgit_exception.

  METHODS translate
    CHANGING
      ct_text_pairs TYPE zif_abapgit_lxe_texts=>ty_text_pairs
    RAISING
      zcx_abapgit_exception.

  METHODS ext
    RETURNING
      VALUE(rv_ext) TYPE string.

  METHODS lang
    RETURNING
      VALUE(rv_lang) TYPE laiso.

ENDINTERFACE.

INTERFACE zif_abapgit_object .

  CONSTANTS:
    BEGIN OF gc_step_id,
      early TYPE zif_abapgit_objects=>ty_deserialization_step VALUE 'EARLY',
      abap  TYPE zif_abapgit_objects=>ty_deserialization_step VALUE 'ABAP',
      ddic  TYPE zif_abapgit_objects=>ty_deserialization_step VALUE 'DDIC',
      late  TYPE zif_abapgit_objects=>ty_deserialization_step VALUE 'LATE',
    END OF gc_step_id.

  METHODS serialize
    IMPORTING
      !io_xml TYPE REF TO zif_abapgit_xml_output
    RAISING
      zcx_abapgit_exception .

  METHODS deserialize
    IMPORTING
      !iv_package   TYPE devclass
      !io_xml       TYPE REF TO zif_abapgit_xml_input
      !iv_step      TYPE zif_abapgit_objects=>ty_deserialization_step
      !ii_log       TYPE REF TO zif_abapgit_log
      !iv_transport TYPE trkorr
    RAISING
      zcx_abapgit_exception .

  METHODS delete
    IMPORTING
      !iv_package   TYPE devclass
      !iv_transport TYPE trkorr
    RAISING
      zcx_abapgit_exception .

  METHODS exists
    RETURNING
      VALUE(rv_bool) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .

  METHODS is_locked
    RETURNING
      VALUE(rv_is_locked) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .

  METHODS is_active
    RETURNING
      VALUE(rv_active) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .

  METHODS changed_by
    IMPORTING
      !iv_extra      TYPE string OPTIONAL
    RETURNING
      VALUE(rv_user) TYPE syuname
    RAISING
      zcx_abapgit_exception .

  METHODS jump
    IMPORTING
      !iv_extra      TYPE string OPTIONAL
    RETURNING
      VALUE(rv_exit) TYPE abap_bool
    RAISING
      zcx_abapgit_exception .

  METHODS get_metadata
    RETURNING
      VALUE(rs_metadata) TYPE zif_abapgit_definitions=>ty_metadata .

  METHODS get_comparator
    RETURNING
      VALUE(ri_comparator) TYPE REF TO zif_abapgit_comparator
    RAISING
      zcx_abapgit_exception .

  METHODS get_deserialize_steps
    RETURNING
      VALUE(rt_steps) TYPE zif_abapgit_objects=>ty_deserialization_step_tt.

  METHODS get_deserialize_order
    IMPORTING
      !it_all_objects          TYPE zif_abapgit_definitions=>ty_items_tt
    RETURNING
      VALUE(rt_objects_before) TYPE zif_abapgit_definitions=>ty_items_tt.

  CLASS-METHODS map_filename_to_object
    IMPORTING
      !iv_filename TYPE string
      !iv_path     TYPE string OPTIONAL
      !io_dot      TYPE REF TO zcl_abapgit_dot_abapgit OPTIONAL
      !iv_package  TYPE devclass OPTIONAL
    CHANGING
      cs_item      TYPE zif_abapgit_definitions=>ty_item
    RAISING
      zcx_abapgit_exception.

  CLASS-METHODS map_object_to_filename
    IMPORTING
      !is_item    TYPE zif_abapgit_definitions=>ty_item
      !iv_ext     TYPE string
      !iv_extra   TYPE clike
    CHANGING
      cv_filename TYPE string
    RAISING
      zcx_abapgit_exception.

ENDINTERFACE.

INTERFACE zif_abapgit_xml_input
   .

  METHODS read
    IMPORTING
      !iv_name TYPE clike
    CHANGING
      !cg_data TYPE any
    RAISING
      zcx_abapgit_exception .
  METHODS get_raw
    RETURNING
      VALUE(ri_raw) TYPE REF TO if_ixml_document .

* todo, add read_xml to match add_xml in lcl_xml_output
  METHODS get_metadata
    RETURNING
      VALUE(rs_metadata) TYPE zif_abapgit_definitions=>ty_metadata .

ENDINTERFACE.

INTERFACE zif_abapgit_sap_report
  .

  TYPES:
    BEGIN OF ty_progdir,
      name    TYPE progdir-name,
      state   TYPE progdir-state,
      sqlx    TYPE progdir-sqlx,
      edtx    TYPE progdir-edtx,
      varcl   TYPE progdir-varcl,
      dbapl   TYPE progdir-dbapl,
      dbna    TYPE progdir-dbna,
      clas    TYPE progdir-clas,
      type    TYPE progdir-type,
      occurs  TYPE progdir-occurs,
      subc    TYPE progdir-subc,
      appl    TYPE progdir-appl,
      secu    TYPE progdir-secu,
      cnam    TYPE progdir-cnam,
      cdat    TYPE progdir-cdat,
      unam    TYPE progdir-unam,
      udat    TYPE progdir-udat,
      vern    TYPE progdir-vern,
      levl    TYPE progdir-levl,
      rstat   TYPE progdir-rstat,
      rmand   TYPE progdir-rmand,
      rload   TYPE progdir-rload,
      fixpt   TYPE progdir-fixpt,
      sset    TYPE progdir-sset,
      sdate   TYPE progdir-sdate,
      stime   TYPE progdir-stime,
      idate   TYPE progdir-idate,
      itime   TYPE progdir-itime,
      ldbname TYPE progdir-ldbname,
      uccheck TYPE progdir-uccheck,
    END OF ty_progdir.

  METHODS read_report
    IMPORTING
      iv_name          TYPE syrepid
      iv_state         TYPE r3state OPTIONAL
      is_item          TYPE zif_abapgit_definitions=>ty_item OPTIONAL
    RETURNING
      VALUE(rt_source) TYPE abaptxt255_tab
    RAISING
      zcx_abapgit_exception.

  METHODS insert_report
    IMPORTING
      iv_name           TYPE syrepid
      it_source         TYPE STANDARD TABLE
      iv_state          TYPE r3state OPTIONAL
      iv_program_type   TYPE c OPTIONAL
      iv_extension_type TYPE c OPTIONAL
      iv_package        TYPE devclass
      iv_version        TYPE uccheck
      is_item           TYPE zif_abapgit_definitions=>ty_item OPTIONAL
    RAISING
      zcx_abapgit_exception.

  METHODS update_report
    IMPORTING
      iv_name           TYPE syrepid
      it_source         TYPE STANDARD TABLE
      iv_state          TYPE r3state OPTIONAL
      iv_program_type   TYPE c OPTIONAL
      iv_extension_type TYPE c OPTIONAL
      iv_package        TYPE devclass
      iv_version        TYPE uccheck
      is_item           TYPE zif_abapgit_definitions=>ty_item OPTIONAL
    RETURNING
      VALUE(rv_updated) TYPE abap_bool
    RAISING
      zcx_abapgit_exception.

  METHODS delete_report
    IMPORTING
      iv_name        TYPE syrepid
      iv_raise_error TYPE abap_bool DEFAULT abap_false
      is_item        TYPE zif_abapgit_definitions=>ty_item OPTIONAL
    RAISING
      zcx_abapgit_exception.

  METHODS read_progdir
    IMPORTING
      iv_name           TYPE syrepid
      iv_state          TYPE r3state DEFAULT 'A'
    RETURNING
      VALUE(rs_progdir) TYPE ty_progdir
    RAISING
      zcx_abapgit_exception.

  METHODS update_progdir
    IMPORTING
      is_progdir TYPE ty_progdir
      iv_package TYPE devclass
      iv_state   TYPE r3state DEFAULT 'I'
    RAISING
      zcx_abapgit_exception.

ENDINTERFACE.

INTERFACE zif_abapgit_xml_output
   .

  METHODS add
    IMPORTING
      !iv_name TYPE clike
      !ig_data TYPE any
    RAISING
      zcx_abapgit_exception .
  METHODS set_raw
    IMPORTING
      !ii_raw TYPE REF TO if_ixml_element .
  METHODS add_xml
    IMPORTING
      !iv_name TYPE clike
      !ii_xml  TYPE REF TO if_ixml_element .
  METHODS render
    IMPORTING
      !iv_normalize TYPE abap_bool DEFAULT abap_true
      !is_metadata  TYPE zif_abapgit_definitions=>ty_metadata OPTIONAL
    RETURNING
      VALUE(rv_xml) TYPE string .

ENDINTERFACE.

INTERFACE zif_abapgit_lang_definitions
   .

  TYPES: BEGIN OF ty_i18n_tpool,
           language TYPE langu,
           textpool TYPE zif_abapgit_definitions=>ty_tpool_tt,
         END OF ty_i18n_tpool,
         ty_i18n_tpools TYPE STANDARD TABLE OF ty_i18n_tpool.

  TYPES: BEGIN OF ty_i18n_line,
           language TYPE langu,
           lines    TYPE tlinetab,
         END OF ty_i18n_line,
         ty_i18n_lines TYPE STANDARD TABLE OF ty_i18n_line WITH KEY language.

  TYPES: ty_langus TYPE STANDARD TABLE OF langu.

ENDINTERFACE.

INTERFACE zif_abapgit_oo_object_fnc .

  CONSTANTS:
    BEGIN OF c_parts,
      locals_def  TYPE string VALUE 'locals_def',
      locals_imp  TYPE string VALUE 'locals_imp',
      macros      TYPE string VALUE 'macros',
      testclasses TYPE string VALUE 'testclasses',
    END OF c_parts.

  TYPES: BEGIN OF ty_includes,
           programm TYPE syrepid,
         END OF ty_includes,
         ty_includes_tt TYPE STANDARD TABLE OF ty_includes WITH DEFAULT KEY.

  TYPES:
    ty_seoclasstx_tt TYPE STANDARD TABLE OF seoclasstx WITH DEFAULT KEY .
  TYPES:
    ty_seocompotx_tt TYPE STANDARD TABLE OF seocompotx WITH DEFAULT KEY .
  TYPES:
    ty_seosubcotx_tt TYPE STANDARD TABLE OF seosubcotx WITH DEFAULT KEY .

  TYPES:
    BEGIN OF ty_obj_attribute,
      cmpname   TYPE seocmpname,
      attkeyfld TYPE seokeyfld,
      attbusobj TYPE seobusobj,
      exposure  TYPE seoexpose,
    END OF ty_obj_attribute .
  TYPES:
    ty_obj_attribute_tt TYPE STANDARD TABLE OF ty_obj_attribute WITH DEFAULT KEY
                             WITH NON-UNIQUE SORTED KEY cmpname COMPONENTS cmpname .

  METHODS:
    create
      IMPORTING
        iv_check      TYPE abap_bool
        iv_package    TYPE devclass
        it_attributes TYPE ty_obj_attribute_tt OPTIONAL
      CHANGING
        cg_properties TYPE any
      RAISING
        zcx_abapgit_exception,
    generate_locals
      IMPORTING
        is_key                   TYPE seoclskey
        it_local_definitions     TYPE seop_source_string OPTIONAL
        it_local_implementations TYPE seop_source_string OPTIONAL
        it_local_macros          TYPE seop_source_string OPTIONAL
        it_local_test_classes    TYPE seop_source_string OPTIONAL
        iv_package               TYPE devclass
        iv_version               TYPE uccheck
      RAISING
        zcx_abapgit_exception,
    deserialize_source
      IMPORTING
        is_key     TYPE seoclskey
        it_source  TYPE zif_abapgit_definitions=>ty_string_tt
        iv_package TYPE devclass
        iv_version TYPE uccheck
      RAISING
        zcx_abapgit_exception
        cx_sy_dyn_call_error,
    insert_text_pool
      IMPORTING
        iv_class_name TYPE seoclsname
        it_text_pool  TYPE textpool_table
        iv_language   TYPE spras
        iv_state      TYPE c DEFAULT 'I'
      RAISING
        zcx_abapgit_exception,
    update_descriptions_class
      IMPORTING
        is_key          TYPE seoclskey
        iv_language     TYPE spras
        it_descriptions TYPE ty_seoclasstx_tt,
    update_descriptions_compo
      IMPORTING
        is_key          TYPE seoclskey
        it_descriptions TYPE ty_seocompotx_tt,
    update_descriptions_subco
      IMPORTING
        is_key          TYPE seoclskey
        it_descriptions TYPE ty_seosubcotx_tt,
    add_to_activation_list
      IMPORTING
        is_item TYPE zif_abapgit_definitions=>ty_item
      RAISING
        zcx_abapgit_exception,
    create_sotr
      IMPORTING
        iv_object_name TYPE sobj_name
        iv_package     TYPE devclass
        ii_xml         TYPE REF TO zif_abapgit_xml_input
      RAISING
        zcx_abapgit_exception,
    create_documentation
      IMPORTING
        it_lines         TYPE tlinetab
        iv_id            TYPE dokhl-id
        iv_object_name   TYPE dokhl-object
        iv_language      TYPE spras
        iv_no_masterlang TYPE abap_bool OPTIONAL
      RAISING
        zcx_abapgit_exception,
    delete_documentation
      IMPORTING
        iv_id          TYPE dokhl-id
        iv_object_name TYPE dokhl-object
        iv_language    TYPE spras
      RAISING
        zcx_abapgit_exception,
    get_includes
      IMPORTING
        iv_object_name     TYPE sobj_name
      RETURNING
        VALUE(rt_includes) TYPE ty_includes_tt
      RAISING
        zcx_abapgit_exception,
    exists
      IMPORTING
        iv_object_name   TYPE seoclsname
      RETURNING
        VALUE(rv_exists) TYPE abap_bool,
    serialize_abap
      IMPORTING
        is_class_key     TYPE seoclskey
        iv_type          TYPE seop_include_ext_app OPTIONAL
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=>ty_string_tt
      RAISING
        zcx_abapgit_exception
        cx_sy_dyn_call_error,
    get_skip_test_classes
      RETURNING
        VALUE(rv_skip) TYPE abap_bool,
    get_class_properties
      IMPORTING
        is_class_key               TYPE seoclskey
      RETURNING
        VALUE(rs_class_properties) TYPE vseoclass
      RAISING
        zcx_abapgit_exception,
    get_interface_properties
      IMPORTING
        is_interface_key               TYPE seoclskey
      RETURNING
        VALUE(rs_interface_properties) TYPE vseointerf
      RAISING
        zcx_abapgit_exception,
    read_text_pool
      IMPORTING
        iv_class_name       TYPE seoclsname
        iv_language         TYPE spras
      RETURNING
        VALUE(rt_text_pool) TYPE textpool_table,
    read_documentation
      IMPORTING
        iv_id           TYPE dokhl-id
        iv_object_name  TYPE dokhl-object
        iv_language     TYPE spras
      RETURNING
        VALUE(rt_lines) TYPE tlinetab,
    read_sotr
      IMPORTING
        iv_object_name TYPE sobj_name
        ii_xml         TYPE REF TO zif_abapgit_xml_output
        io_i18n_params TYPE REF TO zcl_abapgit_i18n_params
      RAISING
        zcx_abapgit_exception,
    read_descriptions_class
      IMPORTING
        iv_object_name         TYPE seoclsname
        iv_language            TYPE spras OPTIONAL
      RETURNING
        VALUE(rt_descriptions) TYPE ty_seoclasstx_tt,
    read_descriptions_compo
      IMPORTING
        iv_object_name         TYPE seoclsname
        iv_language            TYPE spras OPTIONAL
      RETURNING
        VALUE(rt_descriptions) TYPE ty_seocompotx_tt,
    read_descriptions_subco
      IMPORTING
        iv_object_name         TYPE seoclsname
        iv_language            TYPE spras OPTIONAL
      RETURNING
        VALUE(rt_descriptions) TYPE ty_seosubcotx_tt,
    delete
      IMPORTING
        is_deletion_key TYPE seoclskey
      RAISING
        zcx_abapgit_exception,
    read_superclass
      IMPORTING
        iv_classname         TYPE seoclsname
      RETURNING
        VALUE(rv_superclass) TYPE seoclsname,
    read_attributes
      IMPORTING
        iv_object_name       TYPE seoclsname
      RETURNING
        VALUE(rt_attributes) TYPE ty_obj_attribute_tt,
    syntax_check
      IMPORTING
        iv_object_name TYPE seoclsname
      RAISING
        zcx_abapgit_exception.
ENDINTERFACE.

INTERFACE zif_abapgit_object_enho .

  METHODS:
    deserialize
      IMPORTING ii_xml     TYPE REF TO zif_abapgit_xml_input
                iv_package TYPE devclass
      RAISING   zcx_abapgit_exception,
    serialize
      IMPORTING ii_xml      TYPE REF TO zif_abapgit_xml_output
                ii_enh_tool TYPE REF TO if_enh_tool
      RAISING   zcx_abapgit_exception.

ENDINTERFACE.

INTERFACE zif_abapgit_aff_oo_types_v1
  .

  TYPES:
    BEGIN OF ty_component_description,
      name        TYPE zif_abapgit_aff_types_v1=>ty_object_name_30,
      description TYPE zif_abapgit_aff_types_v1=>ty_description_60,
    END OF ty_component_description,

    ty_component_descriptions TYPE SORTED TABLE OF ty_component_description WITH UNIQUE KEY name.

  TYPES:
    BEGIN OF ty_method,
      name        TYPE zif_abapgit_aff_types_v1=>ty_object_name_30,
      description TYPE zif_abapgit_aff_types_v1=>ty_description_60,
      parameters  TYPE ty_component_descriptions,
      exceptions  TYPE ty_component_descriptions,
    END OF ty_method,
    ty_methods TYPE SORTED TABLE OF ty_method WITH UNIQUE KEY name.

  TYPES:
    BEGIN OF ty_event,
      name        TYPE zif_abapgit_aff_types_v1=>ty_object_name_30,
      description TYPE zif_abapgit_aff_types_v1=>ty_description_60,
      parameters  TYPE ty_component_descriptions,
    END OF ty_event,
    ty_events TYPE SORTED TABLE OF ty_event WITH UNIQUE KEY name.

  TYPES:
    BEGIN OF ty_descriptions,
      types      TYPE ty_component_descriptions,
      attributes TYPE ty_component_descriptions,
      events     TYPE ty_events,
      methods    TYPE ty_methods,
    END OF ty_descriptions.

ENDINTERFACE.

INTERFACE zif_abapgit_aff_intf_v1 .

  TYPES ty_category TYPE n LENGTH 2.

  CONSTANTS:
    BEGIN OF co_category,
      general                      TYPE ty_category VALUE '00',
      classic_badi                 TYPE ty_category VALUE '01',
      business_static_components   TYPE ty_category VALUE '51',
      business_instance_components TYPE ty_category VALUE '52',
      db_procedure_proxy           TYPE ty_category VALUE '65',
      web_dynpro_runtime           TYPE ty_category VALUE '80',
      enterprise_service           TYPE ty_category VALUE '90',
    END OF co_category.

  TYPES:
    BEGIN OF ty_main,
      format_version TYPE zif_abapgit_aff_types_v1=>ty_format_version,
      header         TYPE zif_abapgit_aff_types_v1=>ty_header_60_src,
      category       TYPE ty_category,
      proxy          TYPE abap_bool,
      descriptions   TYPE zif_abapgit_aff_oo_types_v1=>ty_descriptions,
    END OF ty_main.

ENDINTERFACE.

INTERFACE zif_abapgit_object_tabl .
  CONSTANTS: BEGIN OF c_s_dataname,
               segment_definition TYPE string VALUE 'SEGMENT_DEFINITION',
               tabl_extras        TYPE string VALUE 'TABL_EXTRAS',
             END OF c_s_dataname.

  TYPES: BEGIN OF ty_dd02_text,
           ddlanguage TYPE dd02t-ddlanguage,
           ddtext     TYPE dd02t-ddtext,
         END OF ty_dd02_text.

  TYPES ty_dd02_texts TYPE STANDARD TABLE OF ty_dd02_text WITH DEFAULT KEY.

  TYPES ty_dd03p_tt TYPE STANDARD TABLE OF dd03p WITH DEFAULT KEY.

  TYPES: BEGIN OF ty_segment_definition,
           segmentheader     TYPE edisegmhd,
           segmentdefinition TYPE edisegmdef,
           segmentstructures TYPE STANDARD TABLE OF edisegstru WITH DEFAULT KEY,
         END OF ty_segment_definition.

  TYPES: ty_segment_definitions TYPE STANDARD TABLE OF ty_segment_definition WITH DEFAULT KEY.

  TYPES: BEGIN OF ty_tabl_extras,
           tddat TYPE tddat,
         END OF ty_tabl_extras.

  TYPES: BEGIN OF ty_internal,
           dd02v               TYPE dd02v,
           dd09l               TYPE dd09l,
           dd03p               TYPE ty_dd03p_tt,
           dd05m               TYPE STANDARD TABLE OF dd05m WITH DEFAULT KEY,
           dd08v               TYPE STANDARD TABLE OF dd08v WITH DEFAULT KEY,
           dd12v               TYPE STANDARD TABLE OF dd12v WITH DEFAULT KEY,
           dd17v               TYPE STANDARD TABLE OF dd17v WITH DEFAULT KEY,
           dd35v               TYPE STANDARD TABLE OF dd35v WITH DEFAULT KEY,
           dd36m               TYPE STANDARD TABLE OF dd36m WITH DEFAULT KEY,
           dd02_texts          TYPE ty_dd02_texts,
           i18n_langs          TYPE STANDARD TABLE OF langu WITH DEFAULT KEY,
           longtexts           TYPE zif_abapgit_longtexts=>ty_longtexts,
           segment_definitions TYPE ty_segment_definitions,
           extras              TYPE ty_tabl_extras,
         END OF ty_internal.

ENDINTERFACE.

INTERFACE zif_abapgit_comparator
   .

  TYPES:
    BEGIN OF ty_result,
      text TYPE string,
    END OF ty_result .

  METHODS compare
    IMPORTING
      !ii_remote       TYPE REF TO zif_abapgit_xml_input
      !ii_log          TYPE REF TO zif_abapgit_log
    RETURNING
      VALUE(rs_result) TYPE ty_result
    RAISING
      zcx_abapgit_exception .
ENDINTERFACE.

INTERFACE zif_abapgit_progress
   .

  METHODS show
    IMPORTING
      !iv_current TYPE i
      !iv_text    TYPE csequence .
  METHODS set_total
    IMPORTING
      !iv_total TYPE i .
  METHODS off .
ENDINTERFACE.

INTERFACE zif_abapgit_sap_namespace
   .

  METHODS exists
    IMPORTING
      iv_namespace  TYPE trnspace-namespace
    RETURNING
      VALUE(rv_yes) TYPE abap_bool.

  METHODS is_editable
    IMPORTING
      iv_namespace  TYPE trnspace-namespace
    RETURNING
      VALUE(rv_yes) TYPE abap_bool.

  METHODS split_by_name
    IMPORTING
      iv_obj_with_namespace   TYPE csequence
      iv_allow_slash_in_name  TYPE abap_bool DEFAULT abap_true
    RETURNING
      VALUE(rs_obj_namespace) TYPE zif_abapgit_definitions=>ty_obj_namespace
    RAISING
      zcx_abapgit_exception.

ENDINTERFACE.

INTERFACE zif_abapgit_tadir
   .

  METHODS get_object_package
    IMPORTING
      !iv_pgmid          TYPE tadir-pgmid DEFAULT 'R3TR'
      !iv_object         TYPE tadir-object
      !iv_obj_name       TYPE tadir-obj_name
    RETURNING
      VALUE(rv_devclass) TYPE tadir-devclass
    RAISING
      zcx_abapgit_exception .
  METHODS read
    IMPORTING
      !iv_package            TYPE tadir-devclass
      !iv_ignore_subpackages TYPE abap_bool DEFAULT abap_false
      !iv_only_local_objects TYPE abap_bool DEFAULT abap_false
      !io_dot                TYPE REF TO zcl_abapgit_dot_abapgit OPTIONAL
      !ii_log                TYPE REF TO zif_abapgit_log OPTIONAL
      !it_filter             TYPE zif_abapgit_definitions=>ty_tadir_tt OPTIONAL
      !iv_check_exists       TYPE abap_bool DEFAULT abap_true
    RETURNING
      VALUE(rt_tadir)        TYPE zif_abapgit_definitions=>ty_tadir_tt
    RAISING
      zcx_abapgit_exception .
  METHODS read_single
    IMPORTING
      !iv_pgmid       TYPE tadir-pgmid DEFAULT 'R3TR'
      !iv_object      TYPE tadir-object
      !iv_obj_name    TYPE tadir-obj_name
    RETURNING
      VALUE(rs_tadir) TYPE zif_abapgit_definitions=>ty_tadir.
ENDINTERFACE.

INTERFACE zif_abapinst_definitions .

  CONSTANTS c_version TYPE string VALUE '1.1.0' ##NO_TEXT.

  CONSTANTS:
    c_tabname         TYPE tabname VALUE 'ZABAPINST' ##NO_TEXT,
    c_lock            TYPE viewname VALUE 'EZABAPINST' ##NO_TEXT,
    c_english         TYPE sy-langu VALUE 'E' ##NO_TEXT,
    c_prog_developer  TYPE progname VALUE 'ZABAPINST_DEV' ##NO_TEXT,
    c_prog_standalone TYPE progname VALUE 'ZABAPINST' ##NO_TEXT,
    c_url_docs        TYPE string VALUE 'https://github.com/abapGit/abapinst' ##NO_TEXT,
    c_url_license     TYPE string VALUE 'https://github.com/abapGit/abapinst/blob/master/LICENSE' ##NO_TEXT,
    c_url_repo        TYPE string VALUE 'https://github.com/abapGit/abapinst' ##NO_TEXT.

  " Avoids warning due to key length
  CONSTANTS c_name_length TYPE i VALUE 90 ##NO_TEXT.

  TYPES:
    ty_name     TYPE c LENGTH c_name_length,
    ty_pack     TYPE devclass,
    ty_base     TYPE c LENGTH 80,
    ty_base_tab TYPE TABLE OF ty_base.

  TYPES:
    BEGIN OF ty_content,
      name TYPE ty_name,
      pack TYPE ty_pack,
      json TYPE string,
    END OF ty_content.
  TYPES:
    ty_contents TYPE SORTED TABLE OF ty_content WITH UNIQUE KEY name pack.

  TYPES:
    BEGIN OF ty_version,
      major           TYPE i,
      minor           TYPE i,
      patch           TYPE i,
      prerelase       TYPE string,
      prerelase_patch TYPE i,
    END OF ty_version.

  TYPES:
    BEGIN OF ty_inst,
      name            TYPE ty_name,
      pack            TYPE devclass,
      version         TYPE string,
      sem_version     TYPE ty_version,
      status          TYPE icon_d,
      description     TYPE string,
      source_type     TYPE string,
      source_name     TYPE string,
      transport       TYPE trkorr,
      folder_logic    TYPE string,
      installed_langu TYPE sy-langu,
      installed_by    TYPE xubname,
      installed_at    TYPE timestamp,
      updated_by      TYPE xubname,
      updated_at      TYPE timestamp,
    END OF ty_inst.
  TYPES:
    ty_list TYPE STANDARD TABLE OF ty_inst WITH KEY name pack.

ENDINTERFACE.

INTERFACE zif_abapgit_apack_definitions  .

  TYPES:
    BEGIN OF ty_dependency,
      group_id       TYPE string,
      artifact_id    TYPE string,
      version        TYPE string,
      sem_version    TYPE zif_abapgit_definitions=>ty_version,
      git_url        TYPE string,
      target_package TYPE devclass,
    END OF ty_dependency,
    ty_dependencies    TYPE STANDARD TABLE OF ty_dependency
                    WITH NON-UNIQUE DEFAULT KEY,

    ty_repository_type TYPE string,

    BEGIN OF ty_descriptor_wo_dependencies,
      group_id        TYPE string,
      artifact_id     TYPE string,
      version         TYPE string,
      sem_version     TYPE zif_abapgit_definitions=>ty_version,
      repository_type TYPE ty_repository_type,
      git_url         TYPE string,
    END OF ty_descriptor_wo_dependencies,

    BEGIN OF ty_descriptor.
      INCLUDE TYPE ty_descriptor_wo_dependencies.
  TYPES:
      dependencies TYPE ty_dependencies,
    END OF ty_descriptor,

    ty_descriptors TYPE STANDARD TABLE OF ty_descriptor WITH NON-UNIQUE DEFAULT KEY.

  TYPES:
    BEGIN OF ty_manifest_declaration,
      clsname  TYPE seoclsname,
      devclass TYPE devclass,
    END OF ty_manifest_declaration,
    ty_manifest_declarations TYPE STANDARD TABLE OF ty_manifest_declaration WITH DEFAULT KEY.

  CONSTANTS c_dot_apack_manifest TYPE string VALUE '.apack-manifest.xml' ##NO_TEXT.
  CONSTANTS c_repository_type_abapgit TYPE ty_repository_type VALUE 'abapGit' ##NO_TEXT.
  CONSTANTS c_apack_interface_sap TYPE seoclsname VALUE 'IF_APACK_MANIFEST' ##NO_TEXT.
  CONSTANTS c_apack_interface_cust TYPE seoclsname VALUE 'ZIF_APACK_MANIFEST' ##NO_TEXT.
  CONSTANTS c_apack_interface_nspc TYPE seoclsname VALUE '/*/IF_APACK_MANIFEST' ##NO_TEXT.
ENDINTERFACE.

INTERFACE zif_abapgit_function_module
  .

  METHODS:
    function_exists
      IMPORTING
        iv_function_module_name TYPE clike
      RETURNING
        VALUE(rv_exists)        TYPE abap_bool.

ENDINTERFACE.

INTERFACE zif_abapgit_object_enhs .

  METHODS:
    deserialize
      IMPORTING ii_xml           TYPE REF TO zif_abapgit_xml_input
                iv_package       TYPE devclass
                ii_enh_spot_tool TYPE REF TO if_enh_spot_tool
      RAISING   zcx_abapgit_exception,

    serialize
      IMPORTING ii_xml           TYPE REF TO zif_abapgit_xml_output
                ii_enh_spot_tool TYPE REF TO if_enh_spot_tool
      RAISING   zcx_abapgit_exception.

ENDINTERFACE.

INTERFACE zif_abapgit_version
   .

  CONSTANTS c_xml_version TYPE string VALUE 'v1.0.0' ##NO_TEXT.
  CONSTANTS c_abap_version TYPE string VALUE '1.131.0' ##NO_TEXT.

ENDINTERFACE.

****** CLASSES ******

CLASS zcl_abapgit_abap_language_vers DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    CONSTANTS:
      c_any_abap_language_version TYPE zif_abapgit_aff_types_v1=>ty_abap_language_version VALUE '*',
      c_no_abap_language_version  TYPE zif_abapgit_aff_types_v1=>ty_abap_language_version VALUE '-',
      c_feature_flag              TYPE string VALUE 'ALAV'.

    METHODS constructor
      IMPORTING
        !io_dot_abapgit TYPE REF TO zcl_abapgit_dot_abapgit.

    METHODS get_abap_language_vers_by_objt
      IMPORTING
        !iv_object_type                      TYPE trobjtype
        !iv_package                          TYPE devclass
      RETURNING
        VALUE(rv_allowed_abap_langu_version) TYPE zif_abapgit_aff_types_v1=>ty_abap_language_version.

    METHODS get_repo_abap_language_version
      RETURNING
        VALUE(rv_abap_language_version) TYPE zif_abapgit_aff_types_v1=>ty_abap_language_version.

    METHODS is_import_allowed
      IMPORTING
        !iv_package       TYPE devclass
      RETURNING
        VALUE(rv_allowed) TYPE abap_bool.

    CLASS-METHODS check_abap_language_version
      IMPORTING
        !iv_abap_language_version TYPE zif_abapgit_aff_types_v1=>ty_abap_language_version
        !is_item                  TYPE zif_abapgit_definitions=>ty_item
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA mo_dot_abapgit TYPE REF TO zcl_abapgit_dot_abapgit.

    " Depends on experimental feature flag and repo setting
    DATA mv_has_abap_language_vers TYPE abap_bool.

    METHODS get_default_abap_language_vers
      IMPORTING
        !iv_object_type                 TYPE trobjtype
      RETURNING
        VALUE(rv_abap_language_version) TYPE zif_abapgit_aff_types_v1=>ty_abap_language_version.

    METHODS get_abap_language_vers_by_devc
      IMPORTING
        !iv_package                     TYPE devclass
      RETURNING
        VALUE(rv_abap_language_version) TYPE string.

    METHODS get_abap_language_vers_by_repo
      RETURNING
        VALUE(rv_abap_language_version) TYPE string.

    CLASS-METHODS get_description
      IMPORTING
        !iv_abap_language_version TYPE zif_abapgit_aff_types_v1=>ty_abap_language_version
      RETURNING
        VALUE(rv_description)     TYPE string.

ENDCLASS.

CLASS zcl_abapgit_adt_link DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    CLASS-METHODS jump
      IMPORTING
        !iv_obj_name     TYPE zif_abapgit_definitions=>ty_item-obj_name
        !iv_obj_type     TYPE zif_abapgit_definitions=>ty_item-obj_type
        !iv_sub_obj_name TYPE zif_abapgit_definitions=>ty_item-obj_name OPTIONAL
        !iv_line_number  TYPE i OPTIONAL
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS link_transport
      IMPORTING
        iv_transport   TYPE trkorr
      RETURNING
        VALUE(rv_link) TYPE string.

  PROTECTED SECTION.

    CLASS-METHODS generate
      IMPORTING
        !iv_obj_name     TYPE zif_abapgit_definitions=>ty_item-obj_name
        !iv_obj_type     TYPE zif_abapgit_definitions=>ty_item-obj_type
        !iv_sub_obj_name TYPE zif_abapgit_definitions=>ty_item-obj_name OPTIONAL
        !iv_line_number  TYPE i OPTIONAL
      RETURNING
        VALUE(rv_result) TYPE string
      RAISING
        zcx_abapgit_exception.

  PRIVATE SECTION.

    CLASS-METHODS get_adt_objects_and_names
      IMPORTING
        iv_obj_name       TYPE zif_abapgit_definitions=>ty_item-obj_name
        iv_obj_type       TYPE zif_abapgit_definitions=>ty_item-obj_type
      EXPORTING
        eo_adt_uri_mapper TYPE REF TO object
        eo_adt_objectref  TYPE REF TO object
        ev_program        TYPE progname
        ev_include        TYPE progname
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS is_adt_jump_possible
      IMPORTING
        io_object                      TYPE REF TO cl_wb_object
        io_adt                         TYPE REF TO object
      RETURNING
        VALUE(rv_is_adt_jump_possible) TYPE abap_bool
      RAISING
        zcx_abapgit_exception.

ENDCLASS.

CLASS zcl_abapgit_aff_registry DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_aff_registry.

    CONSTANTS c_aff_feature TYPE string VALUE 'AFF'.

    METHODS constructor.

  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_registry_entry,
        obj_type     TYPE tadir-object,
        experimental TYPE abap_bool,
      END OF ty_registry_entry.

    CLASS-DATA:
      gt_registry TYPE HASHED TABLE OF ty_registry_entry WITH UNIQUE KEY obj_type.

    DATA mv_aff_enabled TYPE abap_bool.

    CLASS-METHODS initialize_registry_table.

    CLASS-METHODS:
      register
        IMPORTING
          iv_obj_type     TYPE tadir-object
          iv_experimental TYPE abap_bool DEFAULT abap_false.

ENDCLASS.

CLASS zcl_abapgit_ajson DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_ajson .

    ALIASES:
      is_empty FOR zif_abapgit_ajson~is_empty,
      exists FOR zif_abapgit_ajson~exists,
      members FOR zif_abapgit_ajson~members,
      get FOR zif_abapgit_ajson~get,
      get_boolean FOR zif_abapgit_ajson~get_boolean,
      get_integer FOR zif_abapgit_ajson~get_integer,
      get_number FOR zif_abapgit_ajson~get_number,
      get_date FOR zif_abapgit_ajson~get_date,
      get_timestamp FOR zif_abapgit_ajson~get_timestamp,
      get_string FOR zif_abapgit_ajson~get_string,
      slice FOR zif_abapgit_ajson~slice,
      to_abap FOR zif_abapgit_ajson~to_abap,
      array_to_string_table FOR zif_abapgit_ajson~array_to_string_table.

    ALIASES:
      clear FOR zif_abapgit_ajson~clear,
      set FOR zif_abapgit_ajson~set,
      setx FOR zif_abapgit_ajson~setx,
      set_boolean FOR zif_abapgit_ajson~set_boolean,
      set_string FOR zif_abapgit_ajson~set_string,
      set_integer FOR zif_abapgit_ajson~set_integer,
      set_date FOR zif_abapgit_ajson~set_date,
      set_timestamp FOR zif_abapgit_ajson~set_timestamp,
      set_null FOR zif_abapgit_ajson~set_null,
      delete FOR zif_abapgit_ajson~delete,
      touch_array FOR zif_abapgit_ajson~touch_array,
      push FOR zif_abapgit_ajson~push,
      stringify FOR zif_abapgit_ajson~stringify.

    ALIASES:
      clone FOR zif_abapgit_ajson~clone,
      filter FOR zif_abapgit_ajson~filter,
      map FOR zif_abapgit_ajson~map.

    ALIASES:
      mt_json_tree FOR zif_abapgit_ajson~mt_json_tree,
      keep_item_order FOR zif_abapgit_ajson~keep_item_order,
      format_datetime FOR zif_abapgit_ajson~format_datetime,
      to_abap_corresponding_only FOR zif_abapgit_ajson~to_abap_corresponding_only,
      freeze FOR zif_abapgit_ajson~freeze.

    CLASS-METHODS parse
      IMPORTING
        !iv_json            TYPE any
        !iv_freeze          TYPE abap_bool DEFAULT abap_false
        !ii_custom_mapping  TYPE REF TO zif_abapgit_ajson_mapping OPTIONAL
        !iv_keep_item_order TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(ro_instance)  TYPE REF TO zcl_abapgit_ajson
      RAISING
        zcx_abapgit_ajson_error .

    CLASS-METHODS create_empty " Might be deprecated, prefer using new( ) or create object
      IMPORTING
        !ii_custom_mapping            TYPE REF TO zif_abapgit_ajson_mapping OPTIONAL
        iv_keep_item_order            TYPE abap_bool DEFAULT abap_false
        iv_format_datetime            TYPE abap_bool DEFAULT abap_true
        iv_to_abap_corresponding_only TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(ro_instance)            TYPE REF TO zcl_abapgit_ajson.

    " Experimental ! May change
    CLASS-METHODS create_from " TODO, rename to 'from' ?
      IMPORTING
        !ii_source_json    TYPE REF TO zif_abapgit_ajson
        !ii_filter         TYPE REF TO zif_abapgit_ajson_filter OPTIONAL " Might be deprecated, use filter() instead
        !ii_mapper         TYPE REF TO zif_abapgit_ajson_mapping OPTIONAL " Might be deprecated, use map() instead
      RETURNING
        VALUE(ro_instance) TYPE REF TO zcl_abapgit_ajson
      RAISING
        zcx_abapgit_ajson_error .

    METHODS constructor
      IMPORTING
        iv_keep_item_order            TYPE abap_bool DEFAULT abap_false
        iv_format_datetime            TYPE abap_bool DEFAULT abap_true
        iv_to_abap_corresponding_only TYPE abap_bool DEFAULT abap_false.
    CLASS-METHODS new
      IMPORTING
        iv_keep_item_order            TYPE abap_bool DEFAULT abap_false
        iv_format_datetime            TYPE abap_bool DEFAULT abap_true
        iv_to_abap_corresponding_only TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(ro_instance)            TYPE REF TO zcl_abapgit_ajson.

  PROTECTED SECTION.

  PRIVATE SECTION.

    CLASS-DATA go_float_regex TYPE REF TO cl_abap_regex.

    DATA ms_opts TYPE zif_abapgit_ajson=>ty_opts.
    DATA mi_custom_mapping TYPE REF TO zif_abapgit_ajson_mapping. " DEPRECATED, will be removed

    METHODS get_item
      IMPORTING
        iv_path        TYPE string
      RETURNING
        VALUE(rv_item) TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    METHODS prove_path_exists
      IMPORTING
        iv_path            TYPE string
      RETURNING
        VALUE(rr_end_node) TYPE REF TO zif_abapgit_ajson_types=>ty_node
      RAISING
        zcx_abapgit_ajson_error.
    METHODS delete_subtree
      IMPORTING
        iv_path            TYPE string
        iv_name            TYPE string
        ir_parent          TYPE REF TO zif_abapgit_ajson_types=>ty_node OPTIONAL
      RETURNING
        VALUE(rs_top_node) TYPE zif_abapgit_ajson_types=>ty_node.
    METHODS read_only_watchdog
      RAISING
        zcx_abapgit_ajson_error.
ENDCLASS.

CLASS zcl_abapgit_ajson_filter_lib DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS create_empty_filter
      RETURNING
        VALUE(ri_filter) TYPE REF TO zif_abapgit_ajson_filter
      RAISING
        zcx_abapgit_ajson_error .
    CLASS-METHODS create_path_filter
      IMPORTING
        !it_skip_paths     TYPE string_table OPTIONAL
        !iv_skip_paths     TYPE string OPTIONAL
        !iv_pattern_search TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(ri_filter)   TYPE REF TO zif_abapgit_ajson_filter
      RAISING
        zcx_abapgit_ajson_error .
    CLASS-METHODS create_and_filter
      IMPORTING
        !it_filters      TYPE zif_abapgit_ajson_filter=>ty_filter_tab
      RETURNING
        VALUE(ri_filter) TYPE REF TO zif_abapgit_ajson_filter
      RAISING
        zcx_abapgit_ajson_error .

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS lcl_mapping_fields DEFINITION.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_ajson_mapping.

    METHODS constructor
      IMPORTING
        it_mapping_fields TYPE zif_abapgit_ajson_mapping~ty_mapping_fields OPTIONAL.

  PROTECTED SECTION.

  PRIVATE SECTION.
    DATA mt_mapping_fields TYPE zif_abapgit_ajson_mapping~ty_mapping_fields.

ENDCLASS.

CLASS lcl_rename DEFINITION.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_ajson_mapping.

    METHODS constructor
      IMPORTING
        it_rename_map TYPE zif_abapgit_ajson_mapping~tty_rename_map
        iv_rename_by  TYPE i.

  PROTECTED SECTION.

  PRIVATE SECTION.
    DATA mt_rename_map TYPE zif_abapgit_ajson_mapping~tty_rename_map.
    DATA mv_rename_by TYPE i.

ENDCLASS.

CLASS lcl_mapping_to_upper DEFINITION.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_ajson_mapping.

    METHODS constructor
      IMPORTING
        it_mapping_fields TYPE zif_abapgit_ajson_mapping~ty_mapping_fields OPTIONAL.

  PROTECTED SECTION.

  PRIVATE SECTION.
    DATA mi_mapping_fields TYPE REF TO zif_abapgit_ajson_mapping.

ENDCLASS.

CLASS lcl_mapping_to_lower DEFINITION.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_ajson_mapping.

    METHODS constructor
      IMPORTING
        it_mapping_fields TYPE zif_abapgit_ajson_mapping~ty_mapping_fields OPTIONAL.

  PROTECTED SECTION.

  PRIVATE SECTION.
    DATA mi_mapping_fields TYPE REF TO zif_abapgit_ajson_mapping.

ENDCLASS.

CLASS lcl_mapping_camel DEFINITION.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_ajson_mapping.

    METHODS constructor
      IMPORTING
        it_mapping_fields   TYPE zif_abapgit_ajson_mapping~ty_mapping_fields OPTIONAL
        iv_first_json_upper TYPE abap_bool DEFAULT abap_true.

  PROTECTED SECTION.

  PRIVATE SECTION.
    DATA mv_first_json_upper TYPE abap_bool.
    DATA mi_mapping_fields TYPE REF TO zif_abapgit_ajson_mapping.

ENDCLASS.

CLASS lcl_compound_mapper DEFINITION.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_ajson_mapping.

    METHODS constructor
      IMPORTING
        it_queue TYPE zif_abapgit_ajson_mapping=>ty_table_of.

  PROTECTED SECTION.

  PRIVATE SECTION.
    DATA mt_queue TYPE zif_abapgit_ajson_mapping=>ty_table_of.

ENDCLASS.

CLASS lcl_to_snake DEFINITION.
  PUBLIC SECTION.
    INTERFACES zif_abapgit_ajson_mapping.
ENDCLASS.

CLASS lcl_to_camel DEFINITION.
  PUBLIC SECTION.
    INTERFACES zif_abapgit_ajson_mapping.
    METHODS constructor
      IMPORTING
        iv_first_json_upper TYPE abap_bool.
  PRIVATE SECTION.
    DATA mv_first_json_upper TYPE abap_bool.
ENDCLASS.

CLASS zcl_abapgit_ajson_mapping DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    CONSTANTS:
      BEGIN OF rename_by,
        attr_name TYPE i VALUE 0,
        full_path TYPE i VALUE 1,
        pattern TYPE i VALUE 2,
        " regex type i value 3, " TODO add if needed in future
      END OF rename_by.

    CLASS-METHODS create_camel_case " DEPRECATED
      IMPORTING
        it_mapping_fields   TYPE zif_abapgit_ajson_mapping=>ty_mapping_fields OPTIONAL
        iv_first_json_upper TYPE abap_bool DEFAULT abap_true
      RETURNING
        VALUE(ri_mapping)   TYPE REF TO zif_abapgit_ajson_mapping.

    CLASS-METHODS create_upper_case
      IMPORTING
        it_mapping_fields TYPE zif_abapgit_ajson_mapping=>ty_mapping_fields OPTIONAL
      RETURNING
        VALUE(ri_mapping) TYPE REF TO zif_abapgit_ajson_mapping.

    CLASS-METHODS create_lower_case
      IMPORTING
        it_mapping_fields TYPE zif_abapgit_ajson_mapping=>ty_mapping_fields OPTIONAL
      RETURNING
        VALUE(ri_mapping) TYPE REF TO zif_abapgit_ajson_mapping.

    CLASS-METHODS create_field_mapping " DEPRECATED
      IMPORTING
        it_mapping_fields TYPE zif_abapgit_ajson_mapping=>ty_mapping_fields
      RETURNING
        VALUE(ri_mapping) TYPE REF TO zif_abapgit_ajson_mapping.

    CLASS-METHODS create_rename
      IMPORTING
        it_rename_map     TYPE zif_abapgit_ajson_mapping=>tty_rename_map
        iv_rename_by      TYPE i DEFAULT rename_by-attr_name
      RETURNING
        VALUE(ri_mapping) TYPE REF TO zif_abapgit_ajson_mapping.

    CLASS-METHODS create_compound_mapper
      IMPORTING
        ii_mapper1        TYPE REF TO zif_abapgit_ajson_mapping OPTIONAL
        ii_mapper2        TYPE REF TO zif_abapgit_ajson_mapping OPTIONAL
        ii_mapper3        TYPE REF TO zif_abapgit_ajson_mapping OPTIONAL
        it_more           TYPE zif_abapgit_ajson_mapping=>ty_table_of OPTIONAL
      RETURNING
        VALUE(ri_mapping) TYPE REF TO zif_abapgit_ajson_mapping.

    CLASS-METHODS create_to_snake_case
      RETURNING
        VALUE(ri_mapping) TYPE REF TO zif_abapgit_ajson_mapping.

    CLASS-METHODS create_to_camel_case
      IMPORTING
        iv_first_json_upper TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(ri_mapping)   TYPE REF TO zif_abapgit_ajson_mapping.

  PROTECTED SECTION.

  PRIVATE SECTION.

ENDCLASS.

CLASS zcl_abapgit_ajson_utilities DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS new
      RETURNING
        VALUE(ro_instance) TYPE REF TO zcl_abapgit_ajson_utilities.
    METHODS diff
      IMPORTING
        !iv_json_a            TYPE string OPTIONAL
        !iv_json_b            TYPE string OPTIONAL
        !io_json_a            TYPE REF TO zif_abapgit_ajson OPTIONAL
        !io_json_b            TYPE REF TO zif_abapgit_ajson OPTIONAL
        !iv_keep_empty_arrays TYPE abap_bool DEFAULT abap_false
      EXPORTING
        !eo_insert            TYPE REF TO zif_abapgit_ajson
        !eo_delete            TYPE REF TO zif_abapgit_ajson
        !eo_change            TYPE REF TO zif_abapgit_ajson
      RAISING
        zcx_abapgit_ajson_error .
    METHODS merge
      IMPORTING
        !iv_json_a            TYPE string OPTIONAL
        !iv_json_b            TYPE string OPTIONAL
        !io_json_a            TYPE REF TO zif_abapgit_ajson OPTIONAL
        !io_json_b            TYPE REF TO zif_abapgit_ajson OPTIONAL
        !iv_keep_empty_arrays TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(ro_json)        TYPE REF TO zif_abapgit_ajson
      RAISING
        zcx_abapgit_ajson_error .
    METHODS sort
      IMPORTING
        !iv_json         TYPE string OPTIONAL
        !io_json         TYPE REF TO zif_abapgit_ajson OPTIONAL
      RETURNING
        VALUE(rv_sorted) TYPE string
      RAISING
        zcx_abapgit_ajson_error .
    METHODS is_equal
      IMPORTING
        !iv_json_a    TYPE string OPTIONAL
        !iv_json_b    TYPE string OPTIONAL
        !ii_json_a    TYPE REF TO zif_abapgit_ajson OPTIONAL
        !ii_json_b    TYPE REF TO zif_abapgit_ajson OPTIONAL
      RETURNING
        VALUE(rv_yes) TYPE abap_bool
      RAISING
        zcx_abapgit_ajson_error .

  PROTECTED SECTION.

  PRIVATE SECTION.

    DATA mo_json_a TYPE REF TO zif_abapgit_ajson .
    DATA mo_json_b TYPE REF TO zif_abapgit_ajson .
    DATA mo_insert TYPE REF TO zif_abapgit_ajson .
    DATA mo_delete TYPE REF TO zif_abapgit_ajson .
    DATA mo_change TYPE REF TO zif_abapgit_ajson .

    METHODS normalize_input
      IMPORTING
        !iv_json       TYPE string OPTIONAL
        !io_json       TYPE REF TO zif_abapgit_ajson OPTIONAL
      RETURNING
        VALUE(ro_json) TYPE REF TO zif_abapgit_ajson
      RAISING
        zcx_abapgit_ajson_error .
    METHODS diff_a_b
      IMPORTING
        !iv_path TYPE string
      RAISING
        zcx_abapgit_ajson_error .
    METHODS diff_b_a
      IMPORTING
        !iv_path  TYPE string
        !iv_array TYPE abap_bool DEFAULT abap_false
      RAISING
        zcx_abapgit_ajson_error .
    METHODS delete_empty_nodes
      IMPORTING
        !io_json              TYPE REF TO zif_abapgit_ajson
        !iv_keep_empty_arrays TYPE abap_bool
      RAISING
        zcx_abapgit_ajson_error .
ENDCLASS.

CLASS zcl_abapgit_convert DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS bitbyte_to_int
      IMPORTING
        !iv_bits      TYPE clike
      RETURNING
        VALUE(rv_int) TYPE i .
    CLASS-METHODS x_to_bitbyte
      IMPORTING
        !iv_x             TYPE x
      RETURNING
        VALUE(rv_bitbyte) TYPE zif_abapgit_git_definitions=>ty_bitbyte .
    CLASS-METHODS string_to_xstring_utf8
      IMPORTING
        !iv_string        TYPE string
      RETURNING
        VALUE(rv_xstring) TYPE xstring
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS xstring_to_string_utf8
      IMPORTING
        !iv_data         TYPE xsequence
        !iv_length       TYPE i OPTIONAL
      RETURNING
        VALUE(rv_string) TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS string_to_xstring_utf8_bom
      IMPORTING
        !iv_string        TYPE string
      RETURNING
        VALUE(rv_xstring) TYPE xstring
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS xstring_to_string_utf8_bom
      IMPORTING
        !iv_xstring      TYPE xstring
      RETURNING
        VALUE(rv_string) TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS xstring_to_int
      IMPORTING
        !iv_xstring TYPE xstring
      RETURNING
        VALUE(rv_i) TYPE i
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS int_to_xstring4
      IMPORTING
        !iv_i             TYPE i
      RETURNING
        VALUE(rv_xstring) TYPE xstring .
    CLASS-METHODS split_string
      IMPORTING
        !iv_string      TYPE string
      RETURNING
        VALUE(rt_lines) TYPE string_table .
    CLASS-METHODS conversion_exit_isola_output
      IMPORTING
        !iv_spras       TYPE spras
      RETURNING
        VALUE(rv_spras) TYPE laiso .
    CLASS-METHODS string_to_xstring
      IMPORTING
        !iv_str        TYPE string
      RETURNING
        VALUE(rv_xstr) TYPE xstring
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS string_to_tab
      IMPORTING
        !iv_str  TYPE string
      EXPORTING
        !ev_size TYPE i
        !et_tab  TYPE STANDARD TABLE .
    CLASS-METHODS base64_to_xstring
      IMPORTING
        !iv_base64     TYPE string
      RETURNING
        VALUE(rv_xstr) TYPE xstring .
    CLASS-METHODS xstring_to_bintab
      IMPORTING
        !iv_xstr   TYPE xsequence
      EXPORTING
        !ev_size   TYPE i
        !et_bintab TYPE STANDARD TABLE .

    CLASS-METHODS language_sap1_to_sap2
      IMPORTING
        im_lang_sap1        TYPE sy-langu
      RETURNING
        VALUE(re_lang_sap2) TYPE string
      EXCEPTIONS
        no_assignment.

    CLASS-METHODS language_sap2_to_sap1
      IMPORTING
        im_lang_sap2        TYPE laiso
      RETURNING
        VALUE(re_lang_sap1) TYPE sy-langu
      EXCEPTIONS
        no_assignment.

    CLASS-METHODS language_sap1_to_bcp47
      IMPORTING
        im_lang_sap1         TYPE sy-langu
      RETURNING
        VALUE(re_lang_bcp47) TYPE string
      EXCEPTIONS
        no_assignment.

    CLASS-METHODS language_bcp47_to_sap1
      IMPORTING
        im_lang_bcp47       TYPE string
      RETURNING
        VALUE(re_lang_sap1) TYPE sy-langu
      EXCEPTIONS
        no_assignment.

    TYPES ty_char02 TYPE c LENGTH 2.
    CLASS-METHODS uccp
      IMPORTING
        iv_uccp        TYPE string
      RETURNING
        VALUE(rv_char) TYPE ty_char02
      EXCEPTIONS
        no_assignment.

  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-METHODS xstring_remove_bom
      IMPORTING
        iv_xstr        TYPE xsequence
      RETURNING
        VALUE(rv_xstr) TYPE xstring.
ENDCLASS.

"! Change transport system API
CLASS zcl_abapgit_cts_api DEFINITION

  FINAL
  CREATE PRIVATE
   FRIENDS zcl_abapinst_factory.

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_cts_api.
  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA mv_confirm_transp_msgs_called TYPE abap_bool.

    "! Returns the transport request / task the object is currently locked in
    "! @parameter iv_program_id | Program ID
    "! @parameter iv_object_type | Object type
    "! @parameter iv_object_name | Object name
    "! @parameter rv_transport | Transport request / task
    "! @raising zcx_abapgit_exception | Object is not locked in a transport
    METHODS get_current_transport_for_obj
      IMPORTING
        !iv_program_id      TYPE pgmid DEFAULT 'R3TR'
        !iv_object_type     TYPE trobjtype
        !iv_object_name     TYPE sobj_name
      RETURNING
        VALUE(rv_transport) TYPE trkorr
      RAISING
        zcx_abapgit_exception .
    "! Returns the transport request / task that includes the object (even if not locked)
    "! @parameter iv_program_id | Program ID
    "! @parameter iv_object_type | Object type
    "! @parameter iv_object_name | Object name
    "! @parameter rv_transport | Transport request / task
    "! @raising zcx_abapgit_exception | Object is not locked in a transport
    METHODS get_current_transport_from_db
      IMPORTING
        !iv_program_id      TYPE pgmid DEFAULT 'R3TR'
        !iv_object_type     TYPE trobjtype
        !iv_object_name     TYPE sobj_name
      RETURNING
        VALUE(rv_transport) TYPE trkorr
      RAISING
        zcx_abapgit_exception .
    "! Check if the object is currently locked in a transport
    "! @parameter iv_program_id | Program ID
    "! @parameter iv_object_type | Object type
    "! @parameter iv_object_name | Object name
    "! @parameter rv_locked | Object is locked
    "! @raising zcx_abapgit_exception | Object type is not lockable
    METHODS is_object_locked_in_transport
      IMPORTING
        !iv_program_id   TYPE pgmid DEFAULT 'R3TR'
        !iv_object_type  TYPE trobjtype
        !iv_object_name  TYPE sobj_name
      RETURNING
        VALUE(rv_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    "! Check if the object type is lockable
    "! @parameter iv_program_id | Program ID
    "! @parameter iv_object_type | Object type
    "! @parameter rv_lockable | Lockable
    METHODS is_object_type_lockable
      IMPORTING
        !iv_program_id     TYPE pgmid DEFAULT 'R3TR'
        !iv_object_type    TYPE trobjtype
      RETURNING
        VALUE(rv_lockable) TYPE abap_bool .
    "! Check if the object type can be transported
    "! @parameter iv_program_id | Program ID
    "! @parameter iv_object_type | Object type
    "! @parameter rv_transportable | Transportable
    METHODS is_object_type_transportable
      IMPORTING
        !iv_program_id          TYPE pgmid DEFAULT 'R3TR'
        !iv_object_type         TYPE trobjtype
      RETURNING
        VALUE(rv_transportable) TYPE abap_bool .
ENDCLASS.

CLASS zcl_abapgit_data_config DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_data_config .
  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA mt_config TYPE zif_abapgit_data_config=>ty_config_tt .

    METHODS dump
      IMPORTING
        !is_config     TYPE zif_abapgit_data_config=>ty_config
      RETURNING
        VALUE(rv_json) TYPE xstring
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_data_deserializer DEFINITION

  CREATE PRIVATE
   FRIENDS zcl_abapgit_data_factory .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_data_deserializer .

  PROTECTED SECTION.

  PRIVATE SECTION.

    METHODS convert_json_to_itab
      IMPORTING
        !is_file TYPE zif_abapgit_git_definitions=>ty_file
        !ir_data TYPE REF TO data
      RAISING
        zcx_abapgit_exception .
    METHODS preview_database_changes
      IMPORTING
        !iv_name         TYPE tadir-obj_name
        !ir_lc_data      TYPE REF TO data
        !ir_db_data      TYPE REF TO data
      RETURNING
        VALUE(rs_result) TYPE zif_abapgit_data_deserializer=>ty_result
      RAISING
        zcx_abapgit_exception.
    METHODS write_database_table
      IMPORTING
        !iv_name TYPE tadir-obj_name
        !ir_del  TYPE REF TO data
        !ir_ins  TYPE REF TO data
        !ir_upd  TYPE REF TO data
      RAISING
        zcx_abapgit_exception .
    METHODS read_database_table
      IMPORTING
        !iv_name       TYPE tadir-obj_name
        !it_where      TYPE string_table
      RETURNING
        VALUE(rr_data) TYPE REF TO data
      RAISING
        zcx_abapgit_exception .
    METHODS determine_transport_request
      IMPORTING
        io_repo                     TYPE REF TO zcl_abapgit_repo
        iv_transport_type           TYPE zif_abapgit_definitions=>ty_transport_type
      RETURNING
        VALUE(rv_transport_request) TYPE trkorr.
    METHODS is_table_allowed_to_edit
      IMPORTING
        !is_result                TYPE zif_abapgit_data_deserializer=>ty_result
      RETURNING
        VALUE(rv_allowed_to_edit) TYPE abap_bool .

ENDCLASS.

CLASS zcl_abapgit_data_serializer DEFINITION

  CREATE PRIVATE
   FRIENDS zcl_abapgit_data_factory .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_data_serializer .

  PROTECTED SECTION.

  PRIVATE SECTION.

    CONSTANTS c_max_records TYPE i VALUE 20000 ##NO_TEXT.

    METHODS convert_itab_to_json
      IMPORTING
        !ir_data         TYPE REF TO data
        !iv_skip_initial TYPE abap_bool
      RETURNING
        VALUE(rv_data)   TYPE xstring
      RAISING
        zcx_abapgit_exception .
    METHODS read_database_table
      IMPORTING
        !iv_name       TYPE tadir-obj_name
        !it_where      TYPE string_table
      RETURNING
        VALUE(rr_data) TYPE REF TO data
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_data_supporter DEFINITION

  CREATE PRIVATE
   FRIENDS zcl_abapgit_data_factory .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_data_supporter.

  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA mt_supported_objects TYPE zif_abapgit_data_supporter=>ty_objects.

    METHODS get_supported_objects.

ENDCLASS.

CLASS zcl_abapgit_data_factory DEFINITION

  CREATE PUBLIC
   FRIENDS zcl_abapgit_data_injector .

  PUBLIC SECTION.

    CLASS-METHODS get_supporter
      RETURNING
        VALUE(ri_supporter) TYPE REF TO zif_abapgit_data_supporter .
    CLASS-METHODS get_serializer
      RETURNING
        VALUE(ri_serializer) TYPE REF TO zif_abapgit_data_serializer .
    CLASS-METHODS get_deserializer
      RETURNING
        VALUE(ri_deserializer) TYPE REF TO zif_abapgit_data_deserializer .
    CLASS-METHODS get_config
      RETURNING
        VALUE(ri_config) TYPE REF TO zif_abapgit_data_config .
  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA gi_supporter TYPE REF TO zif_abapgit_data_supporter .
    CLASS-DATA gi_serializer TYPE REF TO zif_abapgit_data_serializer .
    CLASS-DATA gi_deserializer TYPE REF TO zif_abapgit_data_deserializer .
ENDCLASS.

CLASS zcl_abapgit_data_injector DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS set_supporter
      IMPORTING
        !ii_supporter TYPE REF TO zif_abapgit_data_supporter .
    METHODS set_serializer
      IMPORTING
        !ii_serializer TYPE REF TO zif_abapgit_data_serializer .
    METHODS set_deserializer
      IMPORTING
        !ii_deserializer TYPE REF TO zif_abapgit_data_deserializer .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_data_utils DEFINITION

  CREATE PUBLIC.

  PUBLIC SECTION.
    TYPES ty_names TYPE STANDARD TABLE OF abap_compname WITH DEFAULT KEY .
    CLASS-METHODS build_table_itab
      IMPORTING
        !iv_name       TYPE tadir-obj_name
      RETURNING
        VALUE(rr_data) TYPE REF TO data
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS build_data_filename
      IMPORTING
        !is_config         TYPE zif_abapgit_data_config=>ty_config
      RETURNING
        VALUE(rv_filename) TYPE string.
    CLASS-METHODS build_config_filename
      IMPORTING
        !is_config         TYPE zif_abapgit_data_config=>ty_config
      RETURNING
        VALUE(rv_filename) TYPE string.
    CLASS-METHODS jump
      IMPORTING
        !is_item TYPE zif_abapgit_definitions=>ty_item
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS does_table_exist
      IMPORTING
        !iv_name         TYPE tadir-obj_name
      RETURNING
        VALUE(rv_exists) TYPE abap_bool.
    CLASS-METHODS is_customizing_table
      IMPORTING
        !iv_name              TYPE tadir-obj_name
      RETURNING
        VALUE(rv_customizing) TYPE abap_bool.
    CLASS-METHODS list_key_fields
      IMPORTING
        !iv_name        TYPE tadir-obj_name
      RETURNING
        VALUE(rt_names) TYPE ty_names
      RAISING
        zcx_abapgit_exception.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_default_transport DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES zif_abapgit_default_transport.

    METHODS constructor.

  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA mv_is_set_by_abapgit TYPE abap_bool .
    DATA ms_save TYPE e070use .

    METHODS store.
    METHODS restore
      RAISING
        zcx_abapgit_exception .
    METHODS set_internal
      IMPORTING
        !iv_transport TYPE trkorr
      RAISING
        zcx_abapgit_exception .
    METHODS clear
      IMPORTING
        !is_default_task TYPE e070use
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_dependencies DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS resolve
      CHANGING
        !ct_tadir TYPE zif_abapgit_definitions=>ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_dependency,
        depname  TYPE dd02l-tabname,
        deptyp   TYPE c LENGTH 4,
        deplocal TYPE dd02l-as4local,
        refname  TYPE dd02l-tabname,
        reftyp   TYPE c LENGTH 4,
        kind     TYPE c LENGTH 1,
      END OF ty_dependency .
    TYPES:
      ty_dedenpencies TYPE STANDARD TABLE OF ty_dependency
                                 WITH NON-UNIQUE DEFAULT KEY .
    TYPES:
      BEGIN OF ty_item,
        obj_type TYPE tadir-object,
        obj_name TYPE tadir-obj_name,
        devclass TYPE devclass,
      END OF ty_item .

    CLASS-METHODS resolve_ddic
      CHANGING
        !ct_tadir TYPE zif_abapgit_definitions=>ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_ddls_dependencies
      IMPORTING
        iv_ddls_name         TYPE tadir-obj_name
      RETURNING
        VALUE(rt_dependency) TYPE ty_dedenpencies.
    CLASS-METHODS resolve_packages
      CHANGING
        ct_tadir TYPE zif_abapgit_definitions=>ty_tadir_tt.
ENDCLASS.

CLASS zcl_abapgit_dot_abapgit DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS build_default
      RETURNING
        VALUE(ro_dot_abapgit) TYPE REF TO zcl_abapgit_dot_abapgit .
    CLASS-METHODS deserialize
      IMPORTING
        !iv_xstr              TYPE xstring
      RETURNING
        VALUE(ro_dot_abapgit) TYPE REF TO zcl_abapgit_dot_abapgit
      RAISING
        zcx_abapgit_exception .
    METHODS constructor
      IMPORTING
        !is_data TYPE zif_abapgit_dot_abapgit=>ty_dot_abapgit .
    METHODS serialize
      RETURNING
        VALUE(rv_xstr) TYPE xstring
      RAISING
        zcx_abapgit_exception .
    METHODS to_file
      RETURNING
        VALUE(rs_file) TYPE zif_abapgit_git_definitions=>ty_file
      RAISING
        zcx_abapgit_exception .
    METHODS get_data
      RETURNING
        VALUE(rs_data) TYPE zif_abapgit_dot_abapgit=>ty_dot_abapgit .
    METHODS add_ignore
      IMPORTING
        !iv_path     TYPE string
        !iv_filename TYPE string .
    METHODS is_ignored
      IMPORTING
        !iv_path          TYPE string
        !iv_filename      TYPE string
      RETURNING
        VALUE(rv_ignored) TYPE abap_bool .
    METHODS remove_ignore
      IMPORTING
        !iv_path     TYPE string
        !iv_filename TYPE string .
    METHODS get_starting_folder
      RETURNING
        VALUE(rv_path) TYPE string .
    METHODS get_folder_logic
      RETURNING
        VALUE(rv_logic) TYPE string .
    METHODS set_folder_logic
      IMPORTING
        !iv_logic TYPE string .
    METHODS set_starting_folder
      IMPORTING
        !iv_path TYPE string .
    METHODS get_main_language
      RETURNING
        VALUE(rv_language) TYPE spras .
    METHODS get_i18n_languages
      RETURNING
        VALUE(rt_languages) TYPE zif_abapgit_definitions=>ty_languages
      RAISING
        zcx_abapgit_exception .
    METHODS set_i18n_languages
      IMPORTING
        it_languages TYPE zif_abapgit_definitions=>ty_languages
      RAISING
        zcx_abapgit_exception .
    METHODS determine_i18n_parameters
      IMPORTING
        !iv_main_language_only TYPE abap_bool
      RETURNING
        VALUE(rs_i18n_params)  TYPE zif_abapgit_definitions=>ty_i18n_params
      RAISING
        zcx_abapgit_exception.
    METHODS get_signature
      RETURNING
        VALUE(rs_signature) TYPE zif_abapgit_git_definitions=>ty_file_signature
      RAISING
        zcx_abapgit_exception .
    METHODS use_lxe
      IMPORTING
        !iv_yes       TYPE abap_bool DEFAULT abap_undefined
      RETURNING
        VALUE(rv_yes) TYPE abap_bool .
    METHODS get_requirements
      RETURNING
        VALUE(rt_requirements) TYPE zif_abapgit_dot_abapgit=>ty_requirement_tt .
    METHODS set_requirements
      IMPORTING
        !it_requirements TYPE zif_abapgit_dot_abapgit=>ty_requirement_tt .
    METHODS get_name
      RETURNING
        VALUE(rv_name) TYPE string.
    METHODS set_name
      IMPORTING
        !iv_name TYPE csequence.
    METHODS get_version_constant
      RETURNING
        VALUE(rv_version_constant) TYPE string .
    METHODS set_version_constant
      IMPORTING
        !iv_version_constant TYPE csequence .
    METHODS get_abap_language_version
      RETURNING
        VALUE(rv_abap_language_version) TYPE string .
    METHODS set_abap_language_version
      IMPORTING
        !iv_abap_language_version TYPE string .
    METHODS get_original_system
      RETURNING
        VALUE(rv_original_system) TYPE string .
    METHODS set_original_system
      IMPORTING
        !iv_original_system TYPE csequence .

    METHODS get_packaging
      RETURNING
        VALUE(rs_packaging) TYPE zif_abapinst_dot_abapgit=>ty_packaging
      RAISING
        zcx_abapgit_exception.

    METHODS set_packaging
      IMPORTING
        !is_packaging TYPE zif_abapinst_dot_abapgit=>ty_packaging.

  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA ms_data TYPE zif_abapgit_dot_abapgit=>ty_dot_abapgit .

    CLASS-METHODS to_xml
      IMPORTING
        !is_data      TYPE zif_abapgit_dot_abapgit=>ty_dot_abapgit
      RETURNING
        VALUE(rv_xml) TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS from_xml
      IMPORTING
        !iv_xml        TYPE string
      RETURNING
        VALUE(rs_data) TYPE zif_abapgit_dot_abapgit=>ty_dot_abapgit .
ENDCLASS.

CLASS zcl_abapgit_environment DEFINITION

  FINAL
  CREATE PRIVATE
   FRIENDS zcl_abapinst_factory.

  PUBLIC SECTION.

    INTERFACES zif_abapgit_environment.
  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA mv_cloud TYPE abap_bool VALUE abap_undefined ##NO_TEXT.
    DATA mv_is_merged TYPE abap_bool VALUE abap_undefined ##NO_TEXT.
    DATA mv_modifiable TYPE abap_bool VALUE abap_undefined ##NO_TEXT.

    METHODS is_system_changes_allowed
      RETURNING
        VALUE(rv_result) TYPE abap_bool.
ENDCLASS.

CLASS zcl_abapgit_exit DEFINITION

  CREATE PUBLIC
   FRIENDS zcl_abapgit_injector.

  PUBLIC SECTION.

    INTERFACES zif_abapgit_exit.

    CLASS-METHODS get_instance
      RETURNING
        VALUE(ri_exit) TYPE REF TO zif_abapgit_exit.

  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA gi_global_exit TYPE REF TO zif_abapgit_exit.
    CLASS-DATA gi_exit TYPE REF TO zif_abapgit_exit.

    CLASS-METHODS is_running_in_test_context
      RETURNING
        VALUE(rv_running_in_test_context) TYPE abap_bool.

ENDCLASS.

CLASS zcl_abapgit_filename_logic DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CONSTANTS:
      BEGIN OF c_package_file,
        obj_name  TYPE c LENGTH 7 VALUE 'package',
        sep1      TYPE c LENGTH 1 VALUE '.',
        obj_type  TYPE c LENGTH 4 VALUE 'devc',
        sep2      TYPE c LENGTH 1 VALUE '.',
        extension TYPE c LENGTH 3 VALUE 'xml',
      END OF c_package_file.

    CONSTANTS:
      BEGIN OF c_json_file,
        extension TYPE c LENGTH 4 VALUE 'json',
      END OF c_json_file.

    CLASS-METHODS detect_obj_definition
      IMPORTING
        !iv_type    TYPE string
        !iv_ext     TYPE string
      EXPORTING
        !ev_is_xml  TYPE abap_bool
        !ev_is_json TYPE abap_bool.

    CLASS-METHODS is_obj_definition_file
      IMPORTING
        !iv_filename  TYPE string
      RETURNING
        VALUE(rv_yes) TYPE abap_bool.

    CLASS-METHODS file_to_object
      IMPORTING
        !iv_filename TYPE string
        !iv_path     TYPE string
        !iv_devclass TYPE devclass OPTIONAL
        !io_dot      TYPE REF TO zcl_abapgit_dot_abapgit
      EXPORTING
        !es_item     TYPE zif_abapgit_definitions=>ty_item
        !ev_is_xml   TYPE abap_bool
        !ev_is_json  TYPE abap_bool
      RAISING
        zcx_abapgit_exception .

    CLASS-METHODS i18n_file_to_object
      IMPORTING
        !iv_filename TYPE string
        !iv_path     TYPE string
      EXPORTING
        !es_item     TYPE zif_abapgit_definitions=>ty_item
        !ev_lang     TYPE laiso
        !ev_ext      TYPE string
      RAISING
        zcx_abapgit_exception .

    CLASS-METHODS object_to_file
      IMPORTING
        !is_item           TYPE zif_abapgit_definitions=>ty_item
        !iv_ext            TYPE string
        !iv_extra          TYPE clike OPTIONAL
      RETURNING
        VALUE(rv_filename) TYPE string .

    CLASS-METHODS object_to_i18n_file
      IMPORTING
        !is_item           TYPE zif_abapgit_definitions=>ty_item
        !iv_lang           TYPE laiso
        !iv_ext            TYPE string
      RETURNING
        VALUE(rv_filename) TYPE string.

  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA:
      go_aff_registry TYPE REF TO zif_abapgit_aff_registry.

    CLASS-METHODS name_escape
      IMPORTING
        !iv_name       TYPE csequence
      RETURNING
        VALUE(rv_name) TYPE string.

    CLASS-METHODS name_unescape
      IMPORTING
        !iv_name       TYPE csequence
      RETURNING
        VALUE(rv_name) TYPE string.

    CLASS-METHODS map_filename_to_object
      IMPORTING
        !iv_filename TYPE string
        !iv_path     TYPE string
        !iv_package  TYPE devclass
        !io_dot      TYPE REF TO zcl_abapgit_dot_abapgit
      CHANGING
        cs_item      TYPE zif_abapgit_definitions=>ty_item
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS map_object_to_filename
      IMPORTING
        !is_item    TYPE zif_abapgit_definitions=>ty_item
        !iv_ext     TYPE string
        !iv_extra   TYPE clike
      CHANGING
        cv_filename TYPE string
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS get_lang_and_ext
      IMPORTING
        iv_filename TYPE string
      EXPORTING
        ev_lang     TYPE laiso
        ev_ext      TYPE string
      RAISING
        zcx_abapgit_exception.

ENDCLASS.

CLASS zcl_abapgit_folder_logic DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS package_to_path
      IMPORTING
        !iv_top        TYPE devclass
        !io_dot        TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_package    TYPE devclass
      RETURNING
        VALUE(rv_path) TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS path_to_package
      IMPORTING
        !iv_top                  TYPE devclass
        !io_dot                  TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_path                 TYPE string
        !iv_create_if_not_exists TYPE abap_bool DEFAULT abap_true
      RETURNING
        VALUE(rv_package)        TYPE devclass
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_instance
      RETURNING
        VALUE(ro_instance) TYPE REF TO zcl_abapgit_folder_logic .
  PROTECTED SECTION.

    METHODS get_parent
      IMPORTING
        !iv_top          TYPE devclass
        !iv_package      TYPE devclass
      RETURNING
        VALUE(rv_parent) TYPE devclass
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_devclass_info,
        devclass  TYPE devclass,
        namespace TYPE namespace,
        parentcl  TYPE parentcl,
      END OF ty_devclass_info .
    TYPES:
      ty_devclass_info_tt TYPE SORTED TABLE OF ty_devclass_info
        WITH UNIQUE KEY devclass .
    DATA mt_top_subpackages TYPE ty_devclass_info_tt .
    DATA mt_parent TYPE ty_devclass_info_tt .
ENDCLASS.

CLASS zcl_abapgit_frontend_services DEFINITION

  CREATE PRIVATE
   FRIENDS zcl_abapinst_factory.
  PUBLIC SECTION.

    INTERFACES zif_abapgit_frontend_services.
  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA gv_initial_folder TYPE string.

    METHODS get_path_from_fullname
      IMPORTING
        iv_fullname    TYPE string
      RETURNING
        VALUE(rv_path) TYPE string.

ENDCLASS.

CLASS zcl_abapgit_function_module DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_function_module.

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_gui_jumper DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    INTERFACES zif_abapgit_gui_jumper.

  PROTECTED SECTION.
  PRIVATE SECTION.

    METHODS jump_tr
      IMPORTING
        !is_item       TYPE zif_abapgit_definitions=>ty_item
      RETURNING
        VALUE(rv_exit) TYPE abap_bool.

    METHODS jump_wb
      IMPORTING
        !is_item       TYPE zif_abapgit_definitions=>ty_item
        !iv_new_window TYPE abap_bool
      RETURNING
        VALUE(rv_exit) TYPE abap_bool.

    METHODS jump_wb_line
      IMPORTING
        !is_item         TYPE zif_abapgit_definitions=>ty_item
        !iv_sub_obj_name TYPE zif_abapgit_definitions=>ty_item-obj_name
        !iv_sub_obj_type TYPE zif_abapgit_definitions=>ty_item-obj_type
        !iv_line_number  TYPE i
        !iv_new_window   TYPE abap_bool
      RETURNING
        VALUE(rv_exit)   TYPE abap_bool.

    METHODS jump_bw
      IMPORTING
        !is_item       TYPE zif_abapgit_definitions=>ty_item
        !iv_new_window TYPE abap_bool
      RETURNING
        VALUE(rv_exit) TYPE abap_bool.

ENDCLASS.

CLASS zcl_abapgit_hash DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS adler32
      IMPORTING
        !iv_xstring        TYPE xstring
      RETURNING
        VALUE(rv_checksum) TYPE zif_abapgit_git_definitions=>ty_adler32 .
    CLASS-METHODS sha1
      IMPORTING
        !iv_type       TYPE zif_abapgit_git_definitions=>ty_type
        !iv_data       TYPE xstring
      RETURNING
        VALUE(rv_sha1) TYPE zif_abapgit_git_definitions=>ty_sha1
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS sha1_commit
      IMPORTING
        !iv_data       TYPE xstring
      RETURNING
        VALUE(rv_sha1) TYPE zif_abapgit_git_definitions=>ty_sha1
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS sha1_tree
      IMPORTING
        !iv_data       TYPE xstring
      RETURNING
        VALUE(rv_sha1) TYPE zif_abapgit_git_definitions=>ty_sha1
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS sha1_tag
      IMPORTING
        !iv_data       TYPE xstring
      RETURNING
        VALUE(rv_sha1) TYPE zif_abapgit_git_definitions=>ty_sha1
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS sha1_blob
      IMPORTING
        !iv_data       TYPE xstring
      RETURNING
        VALUE(rv_sha1) TYPE zif_abapgit_git_definitions=>ty_sha1
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS sha1_raw
      IMPORTING
        !iv_data       TYPE xstring
      RETURNING
        VALUE(rv_sha1) TYPE zif_abapgit_git_definitions=>ty_sha1
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS sha1_string
      IMPORTING
        !iv_data       TYPE string
      RETURNING
        VALUE(rv_sha1) TYPE zif_abapgit_git_definitions=>ty_sha1
      RAISING
        zcx_abapgit_exception .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_i18n_params DEFINITION

  FINAL
  CREATE PRIVATE.

  PUBLIC SECTION.

    DATA ms_params TYPE zif_abapgit_definitions=>ty_i18n_params READ-ONLY .

    CLASS-METHODS new
      IMPORTING
        !iv_main_language      TYPE spras DEFAULT zif_abapgit_definitions=>c_english
        !iv_main_language_only TYPE abap_bool DEFAULT abap_false
        !it_translation_langs  TYPE zif_abapgit_definitions=>ty_languages OPTIONAL
        !iv_use_lxe            TYPE abap_bool DEFAULT abap_false
        !is_params             TYPE zif_abapgit_definitions=>ty_i18n_params OPTIONAL
      RETURNING
        VALUE(ro_instance)     TYPE REF TO zcl_abapgit_i18n_params .
    METHODS constructor
      IMPORTING
        !iv_main_language      TYPE spras DEFAULT zif_abapgit_definitions=>c_english
        !iv_main_language_only TYPE abap_bool DEFAULT abap_false
        !it_translation_langs  TYPE zif_abapgit_definitions=>ty_languages OPTIONAL
        !iv_use_lxe            TYPE abap_bool DEFAULT abap_false
        !is_params             TYPE zif_abapgit_definitions=>ty_i18n_params OPTIONAL .

    METHODS is_lxe_applicable
      RETURNING
        VALUE(rv_yes) TYPE abap_bool .
    METHODS build_language_filter
      RETURNING
        VALUE(rt_language_filter) TYPE zif_abapgit_environment=>ty_system_language_filter .
    METHODS trim_saplang_list
      CHANGING
        ct_sap_langs TYPE zif_abapgit_definitions=>ty_sap_langu_tab
      RAISING
        zcx_abapgit_exception.
    METHODS trim_saplang_keyed_table
      IMPORTING
        iv_lang_field_name  TYPE abap_compname
        iv_keep_master_lang TYPE abap_bool DEFAULT abap_false  "sy-langu OPTIONAL
      CHANGING
        ct_tab              TYPE STANDARD TABLE
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA mt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    CLASS-METHODS iso_langs_to_lang_filter
      IMPORTING
        it_iso_filter             TYPE zif_abapgit_definitions=>ty_languages
      RETURNING
        VALUE(rt_language_filter) TYPE zif_abapgit_environment=>ty_system_language_filter.

ENDCLASS.

CLASS zcl_abapgit_item_graph DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !it_items TYPE zif_abapgit_definitions=>ty_items_tt .
    METHODS add_edge
      IMPORTING
        !is_from TYPE zif_abapgit_definitions=>ty_item
        !is_to   TYPE zif_abapgit_definitions=>ty_item .
    METHODS has_vertices
      RETURNING
        VALUE(rv_bool) TYPE abap_bool .
    METHODS get_next
      IMPORTING
        !ii_log        TYPE REF TO zif_abapgit_log
      RETURNING
        VALUE(rs_item) TYPE zif_abapgit_definitions=>ty_item .
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES: BEGIN OF ty_edge,
             from TYPE zif_abapgit_definitions=>ty_item,
             to   TYPE zif_abapgit_definitions=>ty_item,
           END OF ty_edge.

    DATA mt_vertices TYPE STANDARD TABLE OF zif_abapgit_definitions=>ty_item WITH DEFAULT KEY.
    DATA mt_edges TYPE STANDARD TABLE OF ty_edge WITH DEFAULT KEY
      WITH NON-UNIQUE SORTED KEY sec_to COMPONENTS to
      WITH NON-UNIQUE SORTED KEY sec_from COMPONENTS from.
    DATA mv_warning TYPE abap_bool.

    METHODS remove_vertex IMPORTING iv_index TYPE i.
ENDCLASS.

CLASS zcl_abapgit_json_path DEFINITION  CREATE PUBLIC.
  PUBLIC SECTION.
    METHODS: serialize
      IMPORTING iv_json          TYPE string
      RETURNING VALUE(rt_result) TYPE string_table
      RAISING   zcx_abapgit_exception.
    METHODS: deserialize
      IMPORTING it_json_path     TYPE string_table
      RETURNING VALUE(rv_result) TYPE string
      RAISING   zcx_abapgit_exception.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

*----------------------------------------------------------------------*
* This helper class is used to set and restore the current language.
* As some of the SAP functions used rely on SY-LANGU containing the
* main language, this class is used to temporarily change and then
* restore the value of SY-LANGU.
*----------------------------------------------------------------------*
CLASS zcl_abapgit_language DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS class_constructor .
    CLASS-METHODS restore_login_language .
    CLASS-METHODS set_current_language
      IMPORTING
        !iv_language TYPE sy-langu .
  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA gv_login_language TYPE sy-langu .
ENDCLASS.

CLASS zcl_abapgit_log DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_log .

    METHODS constructor
      IMPORTING
        iv_title TYPE string OPTIONAL.

    CLASS-METHODS from_exception
      IMPORTING
        io_x          TYPE REF TO cx_root
      RETURNING
        VALUE(ro_log) TYPE REF TO zcl_abapgit_log.

  PROTECTED SECTION.

    TYPES:
      BEGIN OF ty_log, "in order of occurrence
        msg       TYPE zif_abapgit_log=>ty_msg,
        item      TYPE zif_abapgit_definitions=>ty_item,
        exception TYPE REF TO cx_root,
      END OF ty_log .

    DATA:
      mt_log TYPE STANDARD TABLE OF ty_log WITH DEFAULT KEY .
    DATA mv_title TYPE string .

    METHODS get_messages_status
      IMPORTING
        !it_msg          TYPE zif_abapgit_log=>ty_msgs
      RETURNING
        VALUE(rv_status) TYPE sy-msgty .
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_longtexts DEFINITION

  CREATE PRIVATE
   FRIENDS zcl_abapinst_factory.

  PUBLIC SECTION.

    INTERFACES zif_abapgit_longtexts.

  PROTECTED SECTION.

    METHODS read
      IMPORTING
        !iv_object_name     TYPE clike
        !iv_longtext_id     TYPE dokil-id
        !it_dokil           TYPE zif_abapgit_definitions=>ty_dokil_tt
        !iv_main_lang_only  TYPE abap_bool DEFAULT abap_false
        !iv_clear_fields    TYPE abap_bool DEFAULT abap_true
      RETURNING
        VALUE(rt_longtexts) TYPE zif_abapgit_longtexts=>ty_longtexts
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    CONSTANTS c_docu_state_active TYPE dokstate VALUE 'A' ##NO_TEXT.

    METHODS escape_name
      IMPORTING
        !iv_longtext_id  TYPE dokil-id
        !iv_object_name  TYPE clike
      RETURNING
        VALUE(rv_object) TYPE dokil-object.
ENDCLASS.

CLASS zcl_abapgit_lxe_texts DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_lxe_texts .

    CLASS-METHODS class_constructor.
    CLASS-METHODS get_translation_languages
      IMPORTING
        !iv_main_language   TYPE spras
        !it_i18n_languages  TYPE zif_abapgit_definitions=>ty_languages
      RETURNING
        VALUE(rt_languages) TYPE zif_abapgit_definitions=>ty_languages
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS get_installed_languages
      RETURNING
        VALUE(rt_languages) TYPE zif_abapgit_definitions=>ty_languages
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS convert_lang_string_to_table
      IMPORTING
        !iv_langs              TYPE string
        !iv_skip_main_language TYPE spras OPTIONAL
      RETURNING
        VALUE(rt_languages)    TYPE zif_abapgit_definitions=>ty_languages
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS convert_table_to_lang_string
      IMPORTING
        !it_languages   TYPE zif_abapgit_definitions=>ty_languages
      RETURNING
        VALUE(rv_langs) TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS detect_unsupported_languages
      IMPORTING
        !it_languages                   TYPE zif_abapgit_definitions=>ty_languages
      RETURNING
        VALUE(rt_unsupported_languages) TYPE zif_abapgit_definitions=>ty_languages
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS is_object_supported
      IMPORTING
        iv_object_type TYPE tadir-object
      RETURNING
        VALUE(rv_yes)  TYPE abap_bool.

  PROTECTED SECTION.
  PRIVATE SECTION.

    CONSTANTS c_custmnr TYPE lxecustmnr VALUE '999999' ##NEEDED.
    " The value for ABAP system translation is always 999999 (from lxecustmnr docs)

    TYPES:
      BEGIN OF ty_lxe_translation,
        source_lang TYPE lxeisolang,
        target_lang TYPE lxeisolang,
        custmnr     TYPE lxecustmnr,
        objtype     TYPE trobjtype,
        objname     TYPE lxeobjname,
        text_pairs  TYPE zif_abapgit_lxe_texts=>ty_text_pairs,
      END OF ty_lxe_translation.
    TYPES:
      ty_lxe_translations TYPE STANDARD TABLE OF ty_lxe_translation WITH DEFAULT KEY .

    CLASS-DATA gt_installed_languages_cache TYPE zif_abapgit_definitions=>ty_languages.
    CLASS-DATA gt_supported_obj_types TYPE STANDARD TABLE OF tadir-object.

    DATA mo_i18n_params TYPE REF TO zcl_abapgit_i18n_params.
    DATA mi_xml_out     TYPE REF TO zif_abapgit_xml_output.
    DATA mi_xml_in      TYPE REF TO zif_abapgit_xml_input.
    DATA mo_files       TYPE REF TO zcl_abapgit_objects_files.

    METHODS serialize_xml
      IMPORTING
        !iv_lxe_text_name TYPE string DEFAULT 'LXE_TEXTS'
        !iv_object_type   TYPE tadir-object
        !iv_object_name   TYPE tadir-obj_name
      RAISING
        zcx_abapgit_exception .

    METHODS serialize_as_po
      IMPORTING
        !iv_object_type TYPE tadir-object
        !iv_object_name TYPE tadir-obj_name
      RAISING
        zcx_abapgit_exception .

    " Implementation of deserialize_xml is not complete (but kept as future option)
    METHODS deserialize_xml
      IMPORTING
        !iv_lxe_text_name TYPE string DEFAULT 'LXE_TEXTS'
        !iv_object_type   TYPE tadir-object OPTIONAL
        !iv_object_name   TYPE tadir-obj_name OPTIONAL
      RAISING
        zcx_abapgit_exception ##NEEDED.

    METHODS deserialize_from_po
      IMPORTING
        !iv_object_type TYPE tadir-object
        !iv_object_name TYPE tadir-obj_name
      RAISING
        zcx_abapgit_exception .

    METHODS get_lang_iso4
      IMPORTING
        iv_src         TYPE laiso
      RETURNING
        VALUE(rv_iso4) TYPE lxeisolang
      RAISING
        zcx_abapgit_exception.
    METHODS get_lxe_object_list
      IMPORTING
        iv_object_type     TYPE trobjtype
        iv_object_name     TYPE sobj_name
      RETURNING
        VALUE(rt_obj_list) TYPE lxe_tt_colob .
    METHODS read_lxe_object_text_pair
      IMPORTING
        iv_s_lang                TYPE lxeisolang
        iv_t_lang                TYPE lxeisolang
        iv_custmnr               TYPE lxecustmnr
        iv_objtype               TYPE trobjtype
        iv_objname               TYPE lxeobjname
        iv_read_only             TYPE abap_bool DEFAULT abap_true
      RETURNING
        VALUE(rt_text_pairs_tmp) TYPE ty_lxe_translation-text_pairs
      RAISING
        zcx_abapgit_exception.
    METHODS write_lxe_object_text_pair
      IMPORTING
        iv_s_lang  TYPE lxeisolang
        iv_t_lang  TYPE lxeisolang
        iv_custmnr TYPE lxecustmnr
        iv_objtype TYPE trobjtype
        iv_objname TYPE lxeobjname
        it_pcx_s1  TYPE ty_lxe_translation-text_pairs
      RAISING
        zcx_abapgit_exception.
    METHODS read_text_items
      IMPORTING
        iv_object_type       TYPE tadir-object
        iv_object_name       TYPE tadir-obj_name
      RETURNING
        VALUE(rt_text_items) TYPE ty_lxe_translations
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS langu_to_laiso_safe
      IMPORTING
        iv_langu        TYPE sy-langu
      RETURNING
        VALUE(rv_laiso) TYPE laiso
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS iso4_to_iso2
      IMPORTING
        iv_lxe_lang     TYPE lxeisolang
      RETURNING
        VALUE(rv_laiso) TYPE laiso
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS check_langs_versus_installed
      IMPORTING
        it_languages    TYPE zif_abapgit_definitions=>ty_languages
        it_installed    TYPE zif_abapgit_definitions=>ty_languages
      EXPORTING
        et_intersection TYPE zif_abapgit_definitions=>ty_languages
        et_missfits     TYPE zif_abapgit_definitions=>ty_languages.
ENDCLASS.

CLASS zcl_abapgit_objects_activation DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS add
      IMPORTING
        !iv_type   TYPE trobjtype
        !iv_name   TYPE clike
        !iv_delete TYPE abap_bool DEFAULT abap_false
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS add_item
      IMPORTING
        !is_item TYPE zif_abapgit_definitions=>ty_item
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS activate
      IMPORTING
        !iv_ddic TYPE abap_bool DEFAULT abap_false
        !ii_log  TYPE REF TO zif_abapgit_log
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS clear .
    CLASS-METHODS is_ddic_type
      IMPORTING
        !iv_obj_type     TYPE trobjtype
      RETURNING
        VALUE(rv_result) TYPE abap_bool .
    CLASS-METHODS is_active
      IMPORTING
        !is_item         TYPE zif_abapgit_definitions=>ty_item
      RETURNING
        VALUE(rv_active) TYPE abap_bool
      RAISING
        zcx_abapgit_exception.
  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_classes,
        object  TYPE trobjtype,
        clsname TYPE seoclsname,
      END OF ty_classes.

    CONSTANTS:
      c_domain     TYPE c LENGTH 9  VALUE 'DOMA DOMD',
      c_types      TYPE c LENGTH 55 VALUE 'DTEL DTED TABL TABD SQLT SQLD TTYP TTYD VIEW VIED DRTY',
      c_technset   TYPE c LENGTH 24 VALUE 'TABT VIET SQTT INDX XINX',
      c_f4_objects TYPE c LENGTH 35 VALUE 'SHLP SHLD MCOB MCOD MACO MACD MCID',
      c_enqueue    TYPE c LENGTH 9  VALUE 'ENQU ENQD',
      c_sqsc       TYPE c LENGTH 4  VALUE 'SQSC',
      c_stob       TYPE c LENGTH 4  VALUE 'STOB',
      c_ntab       TYPE c LENGTH 14 VALUE 'NTTT NTTB NTDT',
      c_ddls       TYPE c LENGTH 24 VALUE 'DDLS DRUL DTDC DTEB',
      c_switches   TYPE c LENGTH 24 VALUE 'SF01 SF02 SFSW SFBS SFBF',
      c_para       TYPE c LENGTH 4  VALUE 'PARA', " can be referenced by DTEL
      c_enhd       TYPE c LENGTH 4  VALUE 'ENHD',
      c_scalarfunc TYPE c LENGTH 9  VALUE 'DSFD DSFI',
      c_aspect     TYPE c LENGTH 4  VALUE 'DRAS'.

    CLASS-DATA:
      gt_classes TYPE STANDARD TABLE OF ty_classes WITH DEFAULT KEY .
    CLASS-DATA:
      gt_objects TYPE TABLE OF dwinactiv .

    CLASS-METHODS update_where_used
      IMPORTING
        !ii_log TYPE REF TO zif_abapgit_log.
    CLASS-METHODS use_new_activation_logic
      RETURNING
        VALUE(rv_use_new_activation_logic) TYPE abap_bool .
    CLASS-METHODS activate_new
      IMPORTING
        !iv_ddic TYPE abap_bool DEFAULT abap_false
        !ii_log  TYPE REF TO zif_abapgit_log
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS activate_old
      IMPORTING
        !iv_ddic TYPE abap_bool DEFAULT abap_false
        !ii_log  TYPE REF TO zif_abapgit_log
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS activate_ddic
      IMPORTING
        !ii_log TYPE REF TO zif_abapgit_log
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS add_errors_and_warnings_to_log
      IMPORTING
        !iv_logname TYPE ddmass-logname
        !ii_log     TYPE REF TO zif_abapgit_log
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS add_activation_errors_to_log
      IMPORTING
        !io_checklist       TYPE REF TO cl_wb_checklist
        !ii_log             TYPE REF TO zif_abapgit_log
      RETURNING
        VALUE(rv_try_again) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS is_non_ddic_active
      IMPORTING
        !is_item         TYPE zif_abapgit_definitions=>ty_item
      RETURNING
        VALUE(rv_active) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS is_ddic_active
      IMPORTING
        !is_item         TYPE zif_abapgit_definitions=>ty_item
      RETURNING
        VALUE(rv_active) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS get_ddic_type
      IMPORTING
        !iv_obj_type TYPE clike
        !iv_obj_name TYPE clike
      EXPORTING
        !ev_type     TYPE ddobjtyp
        !ev_name     TYPE ddobjname
        !ev_id       TYPE ddobjectid
      RAISING
        zcx_abapgit_exception.
ENDCLASS.

CLASS zcl_abapgit_objects_super DEFINITION

  ABSTRACT
  CREATE PUBLIC.

  PUBLIC SECTION.

    CONSTANTS c_user_unknown TYPE syuname VALUE 'UNKNOWN'.

    METHODS constructor
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !iv_language    TYPE spras
        !io_files       TYPE REF TO zcl_abapgit_objects_files OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params OPTIONAL.

    METHODS get_accessed_files
      RETURNING
        VALUE(rt_files) TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt.
  PROTECTED SECTION.

    DATA:
      ms_item        TYPE zif_abapgit_definitions=>ty_item,
      mv_language    TYPE spras,
      mo_files       TYPE REF TO zcl_abapgit_objects_files,
      mo_i18n_params TYPE REF TO zcl_abapgit_i18n_params.

    METHODS get_metadata
      RETURNING
        VALUE(rs_metadata) TYPE zif_abapgit_definitions=>ty_metadata .
    METHODS corr_insert
      IMPORTING
        !iv_package      TYPE devclass
        !ig_object_class TYPE any OPTIONAL
      RAISING
        zcx_abapgit_exception .
    METHODS tadir_insert
      IMPORTING
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception .
    METHODS tadir_delete
      RAISING
        zcx_abapgit_exception .
    METHODS exists_a_lock_entry_for
      IMPORTING
        !iv_lock_object               TYPE string
        !iv_argument                  TYPE csequence OPTIONAL
        !iv_prefix                    TYPE csequence OPTIONAL
      RETURNING
        VALUE(rv_exists_a_lock_entry) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS set_default_package
      IMPORTING
        !iv_package TYPE devclass .
    METHODS set_default_transport
      IMPORTING
        !iv_transport TYPE trkorr.
    METHODS serialize_longtexts
      IMPORTING
        !ii_xml           TYPE REF TO zif_abapgit_xml_output
        !iv_longtext_id   TYPE dokil-id OPTIONAL
        !it_dokil         TYPE zif_abapgit_definitions=>ty_dokil_tt OPTIONAL
        !iv_longtext_name TYPE string DEFAULT 'LONGTEXTS'
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_longtexts
      IMPORTING
        !ii_xml           TYPE REF TO zif_abapgit_xml_input
        !iv_longtext_id   TYPE dokil-id OPTIONAL
        !iv_longtext_name TYPE string DEFAULT 'LONGTEXTS'
      RAISING
        zcx_abapgit_exception .
    METHODS delete_longtexts
      IMPORTING
        !iv_longtext_id TYPE dokil-id
      RAISING
        zcx_abapgit_exception .
    METHODS is_active
      RETURNING
        VALUE(rv_active) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS delete_ddic
      IMPORTING
        !iv_objtype              TYPE string
        !iv_no_ask               TYPE abap_bool DEFAULT abap_true
        !iv_no_ask_delete_append TYPE abap_bool DEFAULT abap_false
      RAISING
        zcx_abapgit_exception .
    METHODS set_abap_language_version
      CHANGING
        !cv_abap_language_version TYPE uccheck
      RAISING
        zcx_abapgit_exception .
    METHODS clear_abap_language_version
      CHANGING
        !cv_abap_language_version TYPE uccheck
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_objects_bridge DEFINITION  FINAL CREATE PUBLIC INHERITING FROM zcl_abapgit_objects_super.

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !io_files       TYPE REF TO zcl_abapgit_objects_files OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params OPTIONAL
      RAISING
        cx_sy_create_object_error
        zcx_abapgit_exception.

    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA mo_plugin TYPE REF TO object.

    CLASS-METHODS initialize.

    " Metadata flags (late_deser, delete_tadir, and ddic) are not required by abapGit anymore
    " We keep them to stay compatible with old bridge implementation
    TYPES:
      BEGIN OF ty_metadata,
        class        TYPE string,
        version      TYPE string,
        late_deser   TYPE abap_bool,
        delete_tadir TYPE abap_bool,
        ddic         TYPE abap_bool,
      END OF ty_metadata .

    TYPES: BEGIN OF ty_s_objtype_map,
             obj_typ      TYPE tadir-object,
             plugin_class TYPE seoclsname,
           END OF ty_s_objtype_map,
           ty_t_objtype_map TYPE SORTED TABLE OF ty_s_objtype_map WITH UNIQUE KEY obj_typ.

    CLASS-DATA gv_init TYPE abap_bool.
    CLASS-DATA gt_objtype_map TYPE ty_t_objtype_map.

ENDCLASS.

CLASS zcl_abapgit_objects_factory DEFINITION

  CREATE PRIVATE
   FRIENDS zcl_abapgit_objects_injector .

  PUBLIC SECTION.
    CLASS-METHODS get_gui_jumper
      RETURNING
        VALUE(ri_gui_jumper) TYPE REF TO zif_abapgit_gui_jumper .
  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA gi_gui_jumper TYPE REF TO zif_abapgit_gui_jumper .
ENDCLASS.

CLASS zcl_abapgit_xml DEFINITION

  ABSTRACT
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS:
      constructor
        IMPORTING iv_filename TYPE string OPTIONAL.
  PROTECTED SECTION.
    DATA: mi_ixml     TYPE REF TO if_ixml,
          mi_xml_doc  TYPE REF TO if_ixml_document,
          ms_metadata TYPE zif_abapgit_definitions=>ty_metadata,
          mv_filename TYPE string.

    CONSTANTS: c_abapgit_tag             TYPE string VALUE 'abapGit' ##NO_TEXT,
               c_attr_version            TYPE string VALUE 'version' ##NO_TEXT,
               c_attr_serializer         TYPE string VALUE 'serializer' ##NO_TEXT,
               c_attr_serializer_version TYPE string VALUE 'serializer_version' ##NO_TEXT.

    METHODS to_xml
      IMPORTING iv_normalize  TYPE abap_bool DEFAULT abap_true
      RETURNING VALUE(rv_xml) TYPE string.

    METHODS parse
      IMPORTING iv_xml TYPE string
      RAISING   zcx_abapgit_exception.
  PRIVATE SECTION.

    METHODS error
      IMPORTING
        !ii_parser TYPE REF TO if_ixml_parser
      RAISING
        zcx_abapgit_exception .
    METHODS raise_version_mismatch
      IMPORTING
        !iv_vers TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS raise_exception_for
      IMPORTING
        !ii_error TYPE REF TO if_ixml_parse_error
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_xml_input DEFINITION

  INHERITING FROM zcl_abapgit_xml
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_xml_input.

    METHODS constructor
      IMPORTING
        !iv_xml      TYPE clike
        !iv_filename TYPE string OPTIONAL
      RAISING
        zcx_abapgit_exception .

  PROTECTED SECTION.
  PRIVATE SECTION.

    METHODS fix_xml.

ENDCLASS.

CLASS zcl_abapgit_objects_files DEFINITION

  CREATE PRIVATE.

  PUBLIC SECTION.

    CLASS-METHODS new
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !iv_path        TYPE string OPTIONAL
      RETURNING
        VALUE(ro_files) TYPE REF TO zcl_abapgit_objects_files.
    METHODS constructor
      IMPORTING
        !is_item TYPE zif_abapgit_definitions=>ty_item
        !iv_path TYPE string OPTIONAL .
    METHODS add_string
      IMPORTING
        !iv_extra  TYPE clike OPTIONAL
        !iv_ext    TYPE string
        !iv_string TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS read_string
      IMPORTING
        !iv_extra        TYPE clike OPTIONAL
        !iv_ext          TYPE string
      RETURNING
        VALUE(rv_string) TYPE string
      RAISING
        zcx_abapgit_exception .
    METHODS add_xml
      IMPORTING
        !iv_extra     TYPE clike OPTIONAL
        !ii_xml       TYPE REF TO zif_abapgit_xml_output
        !iv_normalize TYPE abap_bool DEFAULT abap_true
        !is_metadata  TYPE zif_abapgit_definitions=>ty_metadata OPTIONAL
      RAISING
        zcx_abapgit_exception .
    METHODS read_xml
      IMPORTING
        !iv_extra     TYPE clike OPTIONAL
      RETURNING
        VALUE(ri_xml) TYPE REF TO zif_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS read_abap
      IMPORTING
        !iv_extra      TYPE clike OPTIONAL
        !iv_error      TYPE abap_bool DEFAULT abap_true
      RETURNING
        VALUE(rt_abap) TYPE abaptxt255_tab
      RAISING
        zcx_abapgit_exception .
    METHODS add_abap
      IMPORTING
        !iv_extra TYPE clike OPTIONAL
        !it_abap  TYPE STANDARD TABLE
      RAISING
        zcx_abapgit_exception .
    METHODS add
      IMPORTING
        !is_file TYPE zif_abapgit_git_definitions=>ty_file .
    METHODS add_raw
      IMPORTING
        !iv_extra TYPE clike OPTIONAL
        !iv_ext   TYPE string
        !iv_data  TYPE xstring.
    METHODS read_raw
      IMPORTING
        !iv_extra      TYPE clike OPTIONAL
        !iv_ext        TYPE string
      RETURNING
        VALUE(rv_data) TYPE xstring
      RAISING
        zcx_abapgit_exception .
    METHODS get_files
      RETURNING
        VALUE(rt_files) TYPE zif_abapgit_git_definitions=>ty_files_tt .
    METHODS set_files
      IMPORTING
        !it_files TYPE zif_abapgit_git_definitions=>ty_files_tt .
    METHODS get_accessed_files
      RETURNING
        VALUE(rt_files) TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt .
    METHODS contains_file
      IMPORTING
        !iv_extra         TYPE clike OPTIONAL
        !iv_ext           TYPE string
      RETURNING
        VALUE(rv_present) TYPE abap_bool .
    METHODS get_file_pattern
      RETURNING
        VALUE(rv_pattern) TYPE string .
    METHODS is_json_metadata
      RETURNING
        VALUE(rv_result) TYPE abap_bool.
    METHODS add_i18n_file
      IMPORTING
        !ii_i18n_file TYPE REF TO zif_abapgit_i18n_file
      RAISING
        zcx_abapgit_exception .
    METHODS read_i18n_files
      RETURNING
        VALUE(rt_i18n_files) TYPE zif_abapgit_i18n_file=>ty_table_of
      RAISING
        zcx_abapgit_exception .

  PROTECTED SECTION.

    METHODS read_file
      IMPORTING
        !iv_filename   TYPE string
        !iv_error      TYPE abap_bool DEFAULT abap_true
      RETURNING
        VALUE(rv_data) TYPE xstring
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    DATA ms_item TYPE zif_abapgit_definitions=>ty_item .
    DATA mt_accessed_files TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt .
    DATA mt_files TYPE zif_abapgit_git_definitions=>ty_files_tt .
    DATA mv_path TYPE string .

    METHODS mark_accessed
      IMPORTING
        !iv_path TYPE zif_abapgit_git_definitions=>ty_file-path
        !iv_file TYPE zif_abapgit_git_definitions=>ty_file-filename
        !iv_sha1 TYPE zif_abapgit_git_definitions=>ty_file-sha1.

ENDCLASS.

CLASS zcl_abapgit_objects_injector DEFINITION

  CREATE PRIVATE .

  PUBLIC SECTION.

    CLASS-METHODS set_gui_jumper
      IMPORTING
        !ii_gui_jumper TYPE REF TO zif_abapgit_gui_jumper .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_xml_output DEFINITION

  INHERITING FROM zcl_abapgit_xml
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_xml_output.

  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA mi_raw TYPE REF TO if_ixml_element .

    METHODS build_asx_node
      RETURNING
        VALUE(ri_element) TYPE REF TO if_ixml_element .
ENDCLASS.

CLASS zcl_abapgit_objects_program DEFINITION

  INHERITING FROM zcl_abapgit_objects_super
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_cua,
        adm TYPE rsmpe_adm,
        sta TYPE STANDARD TABLE OF rsmpe_stat WITH DEFAULT KEY,
        fun TYPE STANDARD TABLE OF rsmpe_funt WITH DEFAULT KEY,
        men TYPE STANDARD TABLE OF rsmpe_men WITH DEFAULT KEY,
        mtx TYPE STANDARD TABLE OF rsmpe_mnlt WITH DEFAULT KEY,
        act TYPE STANDARD TABLE OF rsmpe_act WITH DEFAULT KEY,
        but TYPE STANDARD TABLE OF rsmpe_but WITH DEFAULT KEY,
        pfk TYPE STANDARD TABLE OF rsmpe_pfk WITH DEFAULT KEY,
        set TYPE STANDARD TABLE OF rsmpe_staf WITH DEFAULT KEY,
        doc TYPE STANDARD TABLE OF rsmpe_atrt WITH DEFAULT KEY,
        tit TYPE STANDARD TABLE OF rsmpe_titt WITH DEFAULT KEY,
        biv TYPE STANDARD TABLE OF rsmpe_buts WITH DEFAULT KEY,
      END OF ty_cua.

    METHODS serialize_program
      IMPORTING
        !io_xml     TYPE REF TO zif_abapgit_xml_output OPTIONAL
        !is_item    TYPE zif_abapgit_definitions=>ty_item
        !io_files   TYPE REF TO zcl_abapgit_objects_files
        !iv_program TYPE syrepid OPTIONAL
        !iv_extra   TYPE clike OPTIONAL
      RAISING
        zcx_abapgit_exception.
    METHODS deserialize_program
      IMPORTING
        !is_progdir TYPE zif_abapgit_sap_report=>ty_progdir
        !it_source  TYPE abaptxt255_tab
        !it_tpool   TYPE textpool_table
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception.
  PROTECTED SECTION.

    TYPES:
      ty_spaces_tt TYPE STANDARD TABLE OF i WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ty_dynpro,
        header     TYPE rpy_dyhead,
        containers TYPE dycatt_tab,
        fields     TYPE dyfatc_tab,
        flow_logic TYPE swydyflow,
        spaces     TYPE ty_spaces_tt,
        nat_header TYPE d020s,
        nat_fields TYPE STANDARD TABLE OF d021s WITH DEFAULT KEY,
        nat_texts  TYPE STANDARD TABLE OF d021t WITH DEFAULT KEY,
      END OF ty_dynpro .
    TYPES:
      ty_dynpro_tt TYPE STANDARD TABLE OF ty_dynpro WITH DEFAULT KEY .

    METHODS strip_generation_comments
      CHANGING
        ct_source TYPE STANDARD TABLE. " tab of string or charX
    METHODS serialize_dynpros
      IMPORTING
        !iv_program_name TYPE syrepid
      RETURNING
        VALUE(rt_dynpro) TYPE ty_dynpro_tt
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_cua
      IMPORTING
        !iv_program_name TYPE syrepid
      RETURNING
        VALUE(rs_cua)    TYPE ty_cua
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_dynpros
      IMPORTING
        !it_dynpros TYPE ty_dynpro_tt
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_textpool
      IMPORTING
        !iv_program    TYPE syrepid
        !it_tpool      TYPE textpool_table
        !iv_language   TYPE sy-langu OPTIONAL
        !iv_is_include TYPE abap_bool DEFAULT abap_false
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_cua
      IMPORTING
        !iv_program_name TYPE syrepid
        !is_cua          TYPE ty_cua
      RAISING
        zcx_abapgit_exception .
    METHODS is_any_dynpro_locked
      IMPORTING
        !iv_program                    TYPE syrepid
      RETURNING
        VALUE(rv_is_any_dynpro_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS is_cua_locked
      IMPORTING
        !iv_program             TYPE syrepid
      RETURNING
        VALUE(rv_is_cua_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS is_text_locked
      IMPORTING
        !iv_program              TYPE syrepid
      RETURNING
        VALUE(rv_is_text_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS add_tpool
      IMPORTING
        !it_tpool       TYPE textpool_table
      RETURNING
        VALUE(rt_tpool) TYPE zif_abapgit_definitions=>ty_tpool_tt .
    CLASS-METHODS read_tpool
      IMPORTING
        !it_tpool       TYPE zif_abapgit_definitions=>ty_tpool_tt
      RETURNING
        VALUE(rt_tpool) TYPE zif_abapgit_definitions=>ty_tpool_tt .
  PRIVATE SECTION.

    CONSTANTS:
      BEGIN OF c_state,
        active   TYPE r3state VALUE 'A',
        inactive TYPE r3state VALUE 'I',
      END OF c_state.

    CONSTANTS c_native_dynpro TYPE c LENGTH 2 VALUE 'IN'.

    METHODS:
      uncondense_flow
        IMPORTING it_flow        TYPE swydyflow
                  it_spaces      TYPE ty_spaces_tt
        RETURNING VALUE(rt_flow) TYPE swydyflow.

    CLASS-METHODS auto_correct_cua_adm
      IMPORTING
        is_cua TYPE ty_cua
      CHANGING
        cs_adm TYPE rsmpe_adm.

    METHODS get_program_title
      IMPORTING
        !it_tpool       TYPE textpool_table
      RETURNING
        VALUE(rv_title) TYPE repti .
    METHODS insert_program
      IMPORTING
        !is_progdir TYPE zif_abapgit_sap_report=>ty_progdir
        !it_source  TYPE abaptxt255_tab
        !iv_title   TYPE repti
        !iv_package TYPE devclass
        !iv_state   TYPE progdir-state DEFAULT c_state-inactive
      RAISING
        zcx_abapgit_exception .
    METHODS update_program
      IMPORTING
        !is_progdir TYPE zif_abapgit_sap_report=>ty_progdir
        !it_source  TYPE abaptxt255_tab
        !iv_title   TYPE repti
        !iv_state   TYPE progdir-state DEFAULT c_state-inactive
      RAISING
        zcx_abapgit_exception .
    METHODS is_exit_include
      IMPORTING
        !iv_program               TYPE syrepid
      RETURNING
        VALUE(rv_is_exit_include) TYPE abap_bool.
    METHODS deserialize_exit_include
      IMPORTING
        !is_progdir TYPE zif_abapgit_sap_report=>ty_progdir
        !it_source  TYPE abaptxt255_tab
        !it_tpool   TYPE textpool_table
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception.
ENDCLASS.

CLASS zcl_abapgit_object_acid DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS: create_object
      RETURNING VALUE(ro_aab) TYPE REF TO cl_aab_id
      RAISING   zcx_abapgit_exception.

ENDCLASS.

CLASS zcl_abapgit_object_avar DEFINITION

  INHERITING FROM zcl_abapgit_objects_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .
  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS: create_object
      RETURNING VALUE(ro_aab_var) TYPE REF TO cl_aab_variant
      RAISING   zcx_abapgit_exception.

ENDCLASS.

CLASS zcl_abapgit_object_clas DEFINITION

  INHERITING FROM zcl_abapgit_objects_program
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .

    METHODS constructor
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !iv_language    TYPE spras
        !io_files       TYPE REF TO zcl_abapgit_objects_files OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params OPTIONAL
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.
    DATA: mi_object_oriented_object_fct TYPE REF TO zif_abapgit_oo_object_fnc,
          mv_skip_testclass             TYPE abap_bool,
          mv_classpool_name             TYPE progname.
    METHODS:
      deserialize_abap
        IMPORTING ii_xml     TYPE REF TO zif_abapgit_xml_input
                  iv_package TYPE devclass
        RAISING   zcx_abapgit_exception,
      deserialize_descr
        IMPORTING ii_xml TYPE REF TO zif_abapgit_xml_input
        RAISING   zcx_abapgit_exception,
      deserialize_docu
        IMPORTING ii_xml TYPE REF TO zif_abapgit_xml_input
        RAISING   zcx_abapgit_exception,
      deserialize_tpool
        IMPORTING ii_xml TYPE REF TO zif_abapgit_xml_input
        RAISING   zcx_abapgit_exception,
      deserialize_tpool_i18n
        IMPORTING ii_xml TYPE REF TO zif_abapgit_xml_input
        RAISING   zcx_abapgit_exception,
      deserialize_sotr
        IMPORTING ii_xml     TYPE REF TO zif_abapgit_xml_input
                  iv_package TYPE devclass
        RAISING   zcx_abapgit_exception,
      deserialize_exceptions
        IMPORTING ii_xml TYPE REF TO zif_abapgit_xml_input
        RAISING   zcx_abapgit_exception,
      serialize_xml
        IMPORTING ii_xml TYPE REF TO zif_abapgit_xml_output
        RAISING   zcx_abapgit_exception,
      serialize_attr
        IMPORTING
          !ii_xml     TYPE REF TO zif_abapgit_xml_output
          !iv_clsname TYPE seoclsname
        RAISING
          zcx_abapgit_exception,
      serialize_descr_class
        IMPORTING
          !ii_xml     TYPE REF TO zif_abapgit_xml_output
          !iv_clsname TYPE seoclsname
        RAISING
          zcx_abapgit_exception,
      serialize_descr_compo
        IMPORTING
          !ii_xml     TYPE REF TO zif_abapgit_xml_output
          !iv_clsname TYPE seoclsname
        RAISING
          zcx_abapgit_exception,
      serialize_descr_subco
        IMPORTING
          !ii_xml     TYPE REF TO zif_abapgit_xml_output
          !iv_clsname TYPE seoclsname
        RAISING
          zcx_abapgit_exception,
      serialize_docu
        IMPORTING
          !ii_xml              TYPE REF TO zif_abapgit_xml_output
          !it_langu_additional TYPE zif_abapgit_lang_definitions=>ty_langus OPTIONAL
          !iv_clsname          TYPE seoclsname
        RAISING
          zcx_abapgit_exception,
      serialize_tpool
        IMPORTING
          !ii_xml         TYPE REF TO zif_abapgit_xml_output
          !iv_clsname     TYPE seoclsname
        RETURNING
          VALUE(rt_tpool) TYPE textpool_table
        RAISING
          zcx_abapgit_exception,
      serialize_tpool_i18n
        IMPORTING
          !ii_xml              TYPE REF TO zif_abapgit_xml_output
          !it_langu_additional TYPE zif_abapgit_lang_definitions=>ty_langus OPTIONAL
          !iv_clsname          TYPE seoclsname
          !it_tpool_main       TYPE textpool_table
        RAISING
          zcx_abapgit_exception,
      serialize_sotr
        IMPORTING
          !ii_xml TYPE REF TO zif_abapgit_xml_output
        RAISING
          zcx_abapgit_exception,
      source_apack_replacement
        CHANGING
          !ct_source TYPE seop_source_string
        RAISING
          zcx_abapgit_exception,
      repo_apack_replacement
        CHANGING
          !ct_source TYPE seop_source_string
        RAISING
          zcx_abapgit_exception.

  PRIVATE SECTION.

    CONSTANTS:
      BEGIN OF c_longtext_name,
        attributes TYPE string VALUE 'LONGTEXTS_CA',
        methods    TYPE string VALUE 'LONGTEXTS_CO',
        events     TYPE string VALUE 'LONGTEXTS_CE',
        types      TYPE string VALUE 'LONGTEXTS_CT',
      END OF c_longtext_name.
    CONSTANTS:
      BEGIN OF c_longtext_id,
        class      TYPE dokil-id VALUE 'CL',
        attributes TYPE dokil-id VALUE 'CA',
        methods    TYPE dokil-id VALUE 'CO',
        events     TYPE dokil-id VALUE 'CE',
        types      TYPE dokil-id VALUE 'CT',
      END OF c_longtext_id.

    METHODS deserialize_pre_ddic
      IMPORTING
        !ii_xml     TYPE REF TO zif_abapgit_xml_input
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception.

    METHODS is_class_locked
      RETURNING
        VALUE(rv_is_class_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception.

    METHODS interface_replacement
      IMPORTING
        !iv_from_interface TYPE seoclsname
        !iv_to_interface   TYPE seoclsname
      CHANGING
        !ct_source         TYPE seop_source_string.

ENDCLASS.

CLASS zcl_abapgit_persist_packages DEFINITION

  CREATE PRIVATE .

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_package,
        devclass   TYPE scompkdtln-devclass,
        component  TYPE scompkdtln-component,
        comp_posid TYPE scompkdtln-comp_posid,
      END OF ty_package .
    TYPES:
      ty_packages TYPE HASHED TABLE OF ty_package WITH UNIQUE KEY devclass .

    METHODS init .
    METHODS modify
      IMPORTING
        !iv_package    TYPE scompkdtln-devclass
        !iv_component  TYPE scompkdtln-component OPTIONAL
        !iv_comp_posid TYPE scompkdtln-comp_posid OPTIONAL
      RAISING
        zcx_abapgit_exception .
    METHODS read
      IMPORTING
        !iv_package       TYPE scompkdtln-devclass
      RETURNING
        VALUE(rs_package) TYPE ty_package .
    CLASS-METHODS get_instance
      RETURNING
        VALUE(ro_persist) TYPE REF TO zcl_abapgit_persist_packages .
  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA go_persist TYPE REF TO zcl_abapgit_persist_packages.
    DATA mt_packages TYPE ty_packages.

    METHODS from_xml
      IMPORTING
        iv_xml             TYPE string
      RETURNING
        VALUE(rt_packages) TYPE ty_packages
      RAISING
        zcx_abapgit_exception.
    METHODS to_xml
      IMPORTING
        it_packages   TYPE ty_packages
      RETURNING
        VALUE(rv_xml) TYPE string
      RAISING
        zcx_abapgit_exception.

ENDCLASS.

CLASS zcl_abapgit_object_devc DEFINITION
  INHERITING FROM zcl_abapgit_objects_super
  FINAL.

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_object.

    METHODS constructor
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !iv_language    TYPE spras
        !io_files       TYPE REF TO zcl_abapgit_objects_files OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params OPTIONAL
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA mv_local_devclass TYPE devclass .

    METHODS get_package
      RETURNING
        VALUE(ri_package) TYPE REF TO if_package
      RAISING
        zcx_abapgit_exception .
    METHODS update_pinf_usages
      IMPORTING
        !ii_package    TYPE REF TO if_package
        !it_usage_data TYPE scomppdata
      RAISING
        zcx_abapgit_exception .
    METHODS set_lock
      IMPORTING
        !ii_package TYPE REF TO if_package
        !iv_lock    TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS unlock_and_raise_error
      IMPORTING
        !ii_package TYPE REF TO if_package
      RAISING
        zcx_abapgit_exception .
    METHODS is_empty
      IMPORTING
        !iv_package_name   TYPE devclass
      RETURNING
        VALUE(rv_is_empty) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS load_package
      IMPORTING
        !iv_package_name  TYPE devclass
      RETURNING
        VALUE(ri_package) TYPE REF TO if_package
      RAISING
        zcx_abapgit_exception .
    METHODS is_local
      IMPORTING
        !iv_package_name   TYPE devclass
      RETURNING
        VALUE(rv_is_local) TYPE abap_bool .
    METHODS remove_obsolete_tadir
      IMPORTING
        !iv_package_name TYPE devclass .
    METHODS adjust_sw_component
      CHANGING
        cv_dlvunit TYPE dlvunit.
ENDCLASS.

CLASS zcl_abapgit_object_doma DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_dd01_text,
        ddlanguage TYPE dd01v-ddlanguage,
        ddtext     TYPE dd01v-ddtext,
      END OF ty_dd01_text .
    TYPES:
      BEGIN OF ty_dd07_text,
        valpos     TYPE dd07v-valpos,
        ddlanguage TYPE dd07v-ddlanguage,
        domvalue_l TYPE dd07v-domvalue_l,
        domvalue_h TYPE dd07v-domvalue_h,
        ddtext     TYPE dd07v-ddtext,
        domval_ld  TYPE dd07v-domval_ld,
        domval_hd  TYPE dd07v-domval_hd,
      END OF ty_dd07_text .
    TYPES:
      ty_dd01_texts TYPE STANDARD TABLE OF ty_dd01_text .
    TYPES:
      ty_dd07_texts TYPE STANDARD TABLE OF ty_dd07_text .

    CONSTANTS c_longtext_id_doma TYPE dokil-id VALUE 'DO' ##NO_TEXT.

    METHODS serialize_texts
      IMPORTING
        !ii_xml   TYPE REF TO zif_abapgit_xml_output
        !it_dd07v TYPE dd07v_tab
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_texts
      IMPORTING
        !ii_xml   TYPE REF TO zif_abapgit_xml_input
        !is_dd01v TYPE dd01v
        !it_dd07v TYPE dd07v_tab
      RAISING
        zcx_abapgit_exception .

    METHODS handle_dependencies
      IMPORTING
        !iv_step TYPE zif_abapgit_objects=>ty_deserialization_step
      CHANGING
        !cv_exit TYPE dd01v-convexit
        !cv_done TYPE abap_bool.

    METHODS adjust_exit
      CHANGING
        !cv_exit TYPE dd01v-convexit.

    METHODS check_exit
      IMPORTING
        !iv_exit       TYPE dd01v-convexit
      RETURNING
        VALUE(rv_done) TYPE abap_bool.

ENDCLASS.

CLASS zcl_abapgit_object_dsys DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object.

    METHODS constructor
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !iv_language    TYPE spras
        !io_files       TYPE REF TO zcl_abapgit_objects_files OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params OPTIONAL
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.

  PRIVATE SECTION.

    CONSTANTS: c_typ TYPE dokhl-typ VALUE 'E',
               c_id  TYPE dokhl-id VALUE 'HY'.

    DATA: mv_doc_object  TYPE sobj_name.

    TYPES: BEGIN OF ty_data,
             doctitle TYPE dsyst-doktitle,
             head     TYPE thead,
             lines    TYPE tline_tab,
           END OF ty_data.

    METHODS deserialize_dsys
      IMPORTING
        ii_xml TYPE REF TO zif_abapgit_xml_input
      RAISING
        zcx_abapgit_exception.

    METHODS get_main_lang
      RETURNING
        VALUE(rv_language) TYPE spras.

ENDCLASS.

CLASS zcl_abapgit_object_dtel DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_dd04_text,
        ddlanguage TYPE dd04t-ddlanguage,
        ddtext     TYPE dd04t-ddtext,
        reptext    TYPE dd04t-reptext,
        scrtext_s  TYPE dd04t-scrtext_s,
        scrtext_m  TYPE dd04t-scrtext_m,
        scrtext_l  TYPE dd04t-scrtext_l,
      END OF ty_dd04_text .
    TYPES:
      ty_dd04_texts TYPE STANDARD TABLE OF ty_dd04_text .

    CONSTANTS c_longtext_id_dtel TYPE dokil-id VALUE 'DE' ##NO_TEXT.
    CONSTANTS c_longtext_id_dtel_suppl TYPE dokil-id VALUE 'DZ' ##NO_TEXT.

    METHODS serialize_texts
      IMPORTING
        !ii_xml TYPE REF TO zif_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_texts
      IMPORTING
        !ii_xml   TYPE REF TO zif_abapgit_xml_input
        !is_dd04v TYPE dd04v
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_object_enhc DEFINITION

  INHERITING FROM zcl_abapgit_objects_super.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

    METHODS constructor
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !iv_language    TYPE spras
        !io_files       TYPE REF TO zcl_abapgit_objects_files OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params OPTIONAL
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA:
      mv_composite_id TYPE enhcompositename.

ENDCLASS.

CLASS zcl_abapgit_object_enho_badi DEFINITION .

  PUBLIC SECTION.
    METHODS: constructor
      IMPORTING
        is_item TYPE zif_abapgit_definitions=>ty_item.
    INTERFACES: zif_abapgit_object_enho.

  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA: ms_item  TYPE zif_abapgit_definitions=>ty_item.

ENDCLASS.

CLASS zcl_abapgit_object_enho_hook DEFINITION .
  PUBLIC SECTION.
    METHODS: constructor
      IMPORTING
        is_item  TYPE zif_abapgit_definitions=>ty_item
        io_files TYPE REF TO zcl_abapgit_objects_files.

    INTERFACES: zif_abapgit_object_enho.

  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES: BEGIN OF ty_spaces,
             full_name TYPE string,
             spaces    TYPE STANDARD TABLE OF i WITH DEFAULT KEY,
           END OF ty_spaces.

    TYPES: ty_spaces_tt TYPE STANDARD TABLE OF ty_spaces WITH DEFAULT KEY.

    TYPES: BEGIN OF ty_file,
             name TYPE string,
             file TYPE string,
           END OF ty_file.

    TYPES: ty_files TYPE HASHED TABLE OF ty_file WITH UNIQUE KEY name.

    CONSTANTS c_enhancement TYPE string VALUE 'ENHANCEMENT 0 *.' ##NO_TEXT.
    CONSTANTS c_endenhancement TYPE string VALUE 'ENDENHANCEMENT.' ##NO_TEXT.

    DATA: ms_item TYPE zif_abapgit_definitions=>ty_item.
    DATA: mo_files TYPE REF TO zcl_abapgit_objects_files.

    METHODS add_sources
      CHANGING
        !ct_enhancements TYPE enh_hook_impl_it
        !ct_files        TYPE ty_files
      RAISING
        zcx_abapgit_exception .
    METHODS read_sources
      CHANGING
        !ct_enhancements TYPE enh_hook_impl_it
        !ct_files        TYPE ty_files
      RAISING
        zcx_abapgit_exception .
    METHODS hook_impl_deserialize
      IMPORTING
        !it_spaces TYPE ty_spaces_tt
      CHANGING
        !ct_impl   TYPE enh_hook_impl_it
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_object_enho_class DEFINITION

  CREATE PUBLIC.

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object_enho.

    METHODS constructor
      IMPORTING
        !is_item  TYPE zif_abapgit_definitions=>ty_item
        !io_files TYPE REF TO zcl_abapgit_objects_files.
  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-METHODS adjust_generated_comments
      CHANGING
        ct_source TYPE rswsourcet.
    METHODS:
      serialize_includes
        IMPORTING
          io_class TYPE REF TO cl_enh_tool_class
        RAISING
          zcx_abapgit_exception,
      deserialize_includes
        IMPORTING
          ii_xml   TYPE REF TO zif_abapgit_xml_input
          io_class TYPE REF TO cl_enh_tool_class
        RAISING
          zcx_abapgit_exception.

    DATA: ms_item TYPE zif_abapgit_definitions=>ty_item.
    DATA: mo_files TYPE REF TO zcl_abapgit_objects_files.

ENDCLASS.

CLASS zcl_abapgit_object_enho_intf DEFINITION .

  PUBLIC SECTION.
    METHODS:
      constructor
        IMPORTING
          is_item  TYPE zif_abapgit_definitions=>ty_item
          io_files TYPE REF TO zcl_abapgit_objects_files.
    INTERFACES: zif_abapgit_object_enho.

  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA: ms_item  TYPE zif_abapgit_definitions=>ty_item,
          mo_files TYPE REF TO zcl_abapgit_objects_files.

ENDCLASS.

CLASS zcl_abapgit_object_enho_wdyc DEFINITION .

  PUBLIC SECTION.
    METHODS: constructor
      IMPORTING
        is_item TYPE zif_abapgit_definitions=>ty_item.
    INTERFACES: zif_abapgit_object_enho.

  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA: ms_item  TYPE zif_abapgit_definitions=>ty_item.

ENDCLASS.

CLASS zcl_abapgit_object_enho_fugr DEFINITION .

  PUBLIC SECTION.
    METHODS: constructor
      IMPORTING
        is_item  TYPE zif_abapgit_definitions=>ty_item
        io_files TYPE REF TO zcl_abapgit_objects_files.
    INTERFACES: zif_abapgit_object_enho.

  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA: ms_item  TYPE zif_abapgit_definitions=>ty_item,
          mo_files TYPE REF TO zcl_abapgit_objects_files.

ENDCLASS.

CLASS zcl_abapgit_object_enho_wdyn DEFINITION .

  PUBLIC SECTION.
    METHODS: constructor
      IMPORTING
        is_item TYPE zif_abapgit_definitions=>ty_item.
    INTERFACES: zif_abapgit_object_enho.

  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA: ms_item  TYPE zif_abapgit_definitions=>ty_item.

ENDCLASS.

CLASS zcl_abapgit_object_enho DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.

    METHODS:
      factory
        IMPORTING
          iv_tool        TYPE enhtooltype
        RETURNING
          VALUE(ri_enho) TYPE REF TO zif_abapgit_object_enho
        RAISING
          zcx_abapgit_exception.

ENDCLASS.

CLASS zcl_abapgit_object_enho_clif DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS deserialize
      IMPORTING
        !io_xml  TYPE REF TO zif_abapgit_xml_input
        !io_clif TYPE REF TO cl_enh_tool_clif
      RAISING
        zcx_abapgit_exception
        cx_enh_root .
    CLASS-METHODS serialize
      IMPORTING
        !io_xml  TYPE REF TO zif_abapgit_xml_output
        !io_clif TYPE REF TO cl_enh_tool_clif
      RAISING
        zcx_abapgit_exception .
  PROTECTED SECTION.
  PRIVATE SECTION.

ENDCLASS.

CLASS zcl_abapgit_object_enhs_badi_d DEFINITION .

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_object_enhs.

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_object_enhs_hook_d DEFINITION .

  PUBLIC SECTION.
    INTERFACES: zif_abapgit_object_enhs.

  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES: BEGIN OF ty_hook_defifnition,
             pgmid     TYPE pgmid,
             obj_name  TYPE trobj_name,
             obj_type  TYPE trobjtype,
             main_type TYPE trobjtype,
             main_name TYPE eu_aname,
             program   TYPE progname,
             def_hooks TYPE enh_hook_def_ext_it,
           END OF ty_hook_defifnition.

ENDCLASS.

CLASS zcl_abapgit_object_enhs DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS:
      factory
        IMPORTING
          iv_tool        TYPE enhtooltype
        RETURNING
          VALUE(ri_enho) TYPE REF TO zif_abapgit_object_enhs
        RAISING
          zcx_abapgit_exception.

ENDCLASS.

CLASS zcl_abapgit_object_enqu DEFINITION

  INHERITING FROM zcl_abapgit_objects_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES: ty_dd27p TYPE STANDARD TABLE OF dd27p WITH DEFAULT KEY.
    METHODS _clear_dd27p_fields CHANGING ct_dd27p TYPE ty_dd27p.

ENDCLASS.

CLASS zcl_abapgit_object_fugr DEFINITION

  INHERITING FROM zcl_abapgit_objects_program
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .
  PROTECTED SECTION.
  PRIVATE SECTION.

    CONSTANTS:
      c_longtext_id_prog     TYPE dokil-id VALUE 'RE',
      c_longtext_id_func     TYPE dokil-id VALUE 'FU',
      c_longtext_id_func_exc TYPE dokil-id VALUE 'FX'.

    TYPES:
      ty_rs38l_incl_tt TYPE STANDARD TABLE OF rs38l_incl WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ty_function,
        funcname          TYPE rs38l_fnam,
        global_flag       TYPE rs38l-global,
        remote_call       TYPE rs38l-remote,
        update_task       TYPE rs38l-utask,
        short_text        TYPE tftit-stext,
        remote_basxml     TYPE rs38l-basxml_enabled,
        import            TYPE STANDARD TABLE OF rsimp WITH DEFAULT KEY,
        changing          TYPE STANDARD TABLE OF rscha WITH DEFAULT KEY,
        export            TYPE STANDARD TABLE OF rsexp WITH DEFAULT KEY,
        tables            TYPE STANDARD TABLE OF rstbl WITH DEFAULT KEY,
        exception         TYPE STANDARD TABLE OF rsexc WITH DEFAULT KEY,
        documentation     TYPE STANDARD TABLE OF rsfdo WITH DEFAULT KEY,
        exception_classes TYPE abap_bool,
      END OF ty_function .
    TYPES:
      ty_function_tt TYPE STANDARD TABLE OF ty_function WITH DEFAULT KEY .
    TYPES:
      ty_sobj_name_tt TYPE STANDARD TABLE OF sobj_name  WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ty_tpool_i18n,
        language TYPE langu,
        textpool TYPE zif_abapgit_definitions=>ty_tpool_tt,
      END OF ty_tpool_i18n .
    TYPES:
      ty_tpools_i18n TYPE STANDARD TABLE OF ty_tpool_i18n .

    DATA mt_includes_cache TYPE ty_sobj_name_tt .
    DATA mt_includes_all TYPE ty_sobj_name_tt .

    METHODS check_rfc_parameters
      IMPORTING
        !is_function TYPE ty_function
      RAISING
        zcx_abapgit_exception .
    METHODS update_where_used
      IMPORTING
        !it_includes TYPE ty_sobj_name_tt .
    METHODS main_name
      RETURNING
        VALUE(rv_program) TYPE program
      RAISING
        zcx_abapgit_exception .
    METHODS functions
      RETURNING
        VALUE(rt_functab) TYPE ty_rs38l_incl_tt
      RAISING
        zcx_abapgit_exception .
    METHODS includes
      RETURNING
        VALUE(rt_includes) TYPE ty_sobj_name_tt
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_functions
      RETURNING
        VALUE(rt_functions) TYPE ty_function_tt
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_functions
      IMPORTING
        !it_functions TYPE ty_function_tt
        !ii_log       TYPE REF TO zif_abapgit_log
        !iv_version   TYPE uccheck
        !iv_package   TYPE devclass
        !iv_transport TYPE trkorr
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_function_docs
      IMPORTING
        !iv_prog_name TYPE syrepid
        !it_functions TYPE ty_function_tt
        !ii_xml       TYPE REF TO zif_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_function_docs
      IMPORTING
        !iv_prog_name TYPE syrepid
        !it_functions TYPE ty_function_tt
        !ii_xml       TYPE REF TO zif_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_xml
      IMPORTING
        !ii_xml TYPE REF TO zif_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_xml
      IMPORTING
        !ii_xml       TYPE REF TO zif_abapgit_xml_input
        !iv_version   TYPE uccheck
        !iv_package   TYPE devclass
        !iv_transport TYPE trkorr
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_includes
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_includes
      IMPORTING
        !ii_xml     TYPE REF TO zif_abapgit_xml_input
        !iv_package TYPE devclass
        !ii_log     TYPE REF TO zif_abapgit_log
      RAISING
        zcx_abapgit_exception .
    METHODS is_function_group_locked
      RETURNING
        VALUE(rv_is_functions_group_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS is_any_include_locked
      RETURNING
        VALUE(rv_is_any_include_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS is_any_function_module_locked
      RETURNING
        VALUE(rv_any_function_module_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS get_abap_version
      IMPORTING
        !ii_xml                TYPE REF TO zif_abapgit_xml_input
      RETURNING
        VALUE(rv_abap_version) TYPE progdir-uccheck
      RAISING
        zcx_abapgit_exception .
    METHODS update_func_group_short_text
      IMPORTING
        !iv_group      TYPE rs38l-area
        !iv_short_text TYPE tftit-stext .
    METHODS serialize_texts
      IMPORTING
        !iv_prog_name TYPE syrepid
        !ii_xml       TYPE REF TO zif_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_texts
      IMPORTING
        !iv_prog_name TYPE syrepid
        !ii_xml       TYPE REF TO zif_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS is_part_of_other_fugr
      IMPORTING
        !iv_include                     TYPE sobj_name
      RETURNING
        VALUE(rv_belongs_to_other_fugr) TYPE abap_bool.
ENDCLASS.

CLASS zcl_abapgit_object_idoc DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

    METHODS constructor
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !iv_language    TYPE spras
        !io_files       TYPE REF TO zcl_abapgit_objects_files OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params OPTIONAL
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS clear_idoc_segement_fields CHANGING cg_structure TYPE any.
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_idoc,
        attributes TYPE edi_iapi01,
        t_syntax   TYPE STANDARD TABLE OF edi_iapi02 WITH NON-UNIQUE DEFAULT KEY,
      END OF ty_idoc.

    DATA: mv_idoctyp TYPE edi_iapi00-idoctyp.

    CLASS-METHODS clear_idoc_segement_field
      IMPORTING iv_fieldname TYPE csequence
      CHANGING  cg_structure TYPE any.

    METHODS is_closed
      RETURNING
        VALUE(rv_closed) TYPE abap_bool.
ENDCLASS.

CLASS zcl_abapgit_object_intf DEFINITION  FINAL INHERITING FROM zcl_abapgit_objects_program.
  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.

    TYPES:
      BEGIN OF ty_docu,
        lines      TYPE tlinetab,
        i18n_lines TYPE zif_abapgit_lang_definitions=>ty_i18n_lines,
      END OF ty_docu.

    TYPES:
      BEGIN OF ty_intf,
        vseointerf      TYPE vseointerf,
        docu            TYPE ty_docu,
        description_int TYPE zif_abapgit_oo_object_fnc=>ty_seoclasstx_tt,
        description     TYPE zif_abapgit_oo_object_fnc=>ty_seocompotx_tt,
        description_sub TYPE zif_abapgit_oo_object_fnc=>ty_seosubcotx_tt,
      END OF ty_intf.

    METHODS constructor
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !iv_language    TYPE spras
        !io_files       TYPE REF TO zcl_abapgit_objects_files OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params OPTIONAL
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.
    METHODS deserialize_proxy
      IMPORTING
        iv_transport TYPE trkorr
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_docu
      IMPORTING
        !ii_xml  TYPE REF TO zif_abapgit_xml_input
        !is_docu TYPE ty_docu
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_docu
      IMPORTING
                !it_langu_additional TYPE zif_abapgit_lang_definitions=>ty_langus OPTIONAL
                !iv_clsname          TYPE seoclsname
      RETURNING VALUE(rs_docu)       TYPE ty_docu
      RAISING
                zcx_abapgit_exception.
    METHODS serialize_descr_class
      IMPORTING
        !iv_clsname           TYPE seoclsname
      RETURNING
        VALUE(rs_description) TYPE ty_intf-description_int
      RAISING
        zcx_abapgit_exception.
    METHODS serialize_descr_compo
      IMPORTING
        !iv_clsname           TYPE seoclsname
      RETURNING
        VALUE(rs_description) TYPE ty_intf-description
      RAISING
        zcx_abapgit_exception.
    METHODS serialize_descr_subco
      IMPORTING
        !iv_clsname           TYPE seoclsname
      RETURNING
        VALUE(rs_description) TYPE ty_intf-description_sub
      RAISING
        zcx_abapgit_exception.
    METHODS serialize_xml
      IMPORTING
        !io_xml TYPE REF TO zif_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

    CONSTANTS:
      BEGIN OF c_longtext_name,
        attributes TYPE string VALUE 'LONGTEXTS_IA',
        methods    TYPE string VALUE 'LONGTEXTS_IO',
        events     TYPE string VALUE 'LONGTEXTS_IE',
      END OF c_longtext_name.

    CONSTANTS:
      BEGIN OF c_longtext_id,
        interface  TYPE dokil-id VALUE 'IF',
        attributes TYPE dokil-id VALUE 'IA',
        methods    TYPE dokil-id VALUE 'IO',
        events     TYPE dokil-id VALUE 'IE',
      END OF c_longtext_id.

    DATA mv_aff_enabled TYPE abap_bool.
    DATA mi_object_oriented_object_fct TYPE REF TO zif_abapgit_oo_object_fnc .

    METHODS deserialize_pre_ddic
      IMPORTING
        ii_xml     TYPE REF TO zif_abapgit_xml_input
        iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception.

    METHODS deserialize_descr_class
      IMPORTING
        it_description TYPE zif_abapgit_oo_object_fnc=>ty_seoclasstx_tt OPTIONAL.
    METHODS deserialize_descr_compo
      IMPORTING
        it_description TYPE zif_abapgit_oo_object_fnc=>ty_seocompotx_tt OPTIONAL.
    METHODS deserialize_descr_subco
      IMPORTING
        it_description TYPE zif_abapgit_oo_object_fnc=>ty_seosubcotx_tt OPTIONAL.
    METHODS read_xml
      IMPORTING
                ii_xml         TYPE REF TO zif_abapgit_xml_input
      RETURNING VALUE(rs_intf) TYPE ty_intf
      RAISING
                zcx_abapgit_exception.
    METHODS read_json
      RETURNING VALUE(rs_intf) TYPE ty_intf
      RAISING
                zcx_abapgit_exception.
    METHODS extract_languages_for_transl
      IMPORTING is_intf          TYPE ty_intf
      RETURNING VALUE(rs_result) TYPE zif_abapgit_definitions=>ty_languages.
ENDCLASS.

CLASS zcl_abapgit_object_msag DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_t100_text,
        sprsl TYPE t100-sprsl,
        msgnr TYPE t100-msgnr,
        text  TYPE t100-text,
      END OF ty_t100_text .
    TYPES:
      ty_t100_texts TYPE STANDARD TABLE OF ty_t100_text .
    TYPES:
      ty_t100s      TYPE STANDARD TABLE OF t100
                           WITH NON-UNIQUE DEFAULT KEY .

    CONSTANTS c_longtext_id_msag TYPE dokil-id VALUE 'NA'.

    METHODS serialize_texts
      IMPORTING
        !ii_xml TYPE REF TO zif_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_texts
      IMPORTING
        !ii_xml TYPE REF TO zif_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_longtexts_msag
      IMPORTING
        !it_t100 TYPE ty_t100s
        !ii_xml  TYPE REF TO zif_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS delete_msgid
      IMPORTING
        !iv_message_id TYPE arbgb
      RAISING
        zcx_abapgit_exception.
    METHODS free_access_permission
      IMPORTING
        !iv_message_id TYPE arbgb .
    METHODS delete_documentation
      IMPORTING
        !iv_message_id TYPE arbgb
      RAISING
        zcx_abapgit_exception.
ENDCLASS.

CLASS zcl_abapgit_object_nspc DEFINITION

  INHERITING FROM zcl_abapgit_objects_super
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .

    METHODS constructor
      IMPORTING
        is_item         TYPE zif_abapgit_definitions=>ty_item
        iv_language     TYPE spras
        !io_files       TYPE REF TO zcl_abapgit_objects_files OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params OPTIONAL.

  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_nspc,
        namespace  TYPE trnspacet-namespace,
        replicense TYPE trnspacet-replicense,
        sscrflag   TYPE trnspacet-sscrflag,
        sapflag    TYPE trnspacet-sapflag,
        gen_only   TYPE trnspacet-gen_only,
      END OF ty_nspc .
    TYPES:
      BEGIN OF ty_nspc_text,
        spras     TYPE trnspacett-spras,
        descriptn TYPE trnspacett-descriptn,
        owner     TYPE trnspacett-owner,
      END OF ty_nspc_text .
    TYPES:
      ty_nspc_texts TYPE STANDARD TABLE OF ty_nspc_text .

    DATA mv_component TYPE cvers-component.

    METHODS serialize_texts
      IMPORTING
        !ii_xml TYPE REF TO zif_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_texts
      IMPORTING
        !ii_xml       TYPE REF TO zif_abapgit_xml_input
        !iv_namespace TYPE namespace
      RAISING
        zcx_abapgit_exception .
    METHODS add_to_transport
      IMPORTING
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_sw_component
      IMPORTING
        !ii_xml TYPE REF TO zif_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_sw_component
      IMPORTING
        !ii_xml TYPE REF TO zif_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_object_para DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.

    METHODS unlock
      IMPORTING
        !iv_paramid TYPE memoryid .

ENDCLASS.

CLASS zcl_abapgit_object_prog DEFINITION  INHERITING FROM zcl_abapgit_objects_program FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_tpool_i18n,
        language TYPE langu,
        textpool TYPE zif_abapgit_definitions=>ty_tpool_tt,
      END OF ty_tpool_i18n .
    TYPES:
      ty_tpools_i18n TYPE STANDARD TABLE OF ty_tpool_i18n .

    CONSTANTS c_longtext_id_prog TYPE dokil-id VALUE 'RE' ##NO_TEXT.

    METHODS deserialize_with_ext
      IMPORTING
        !is_progdir TYPE zif_abapgit_sap_report=>ty_progdir
        !it_source  TYPE abaptxt255_tab
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_texts
      IMPORTING
        !ii_xml TYPE REF TO zif_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_texts
      IMPORTING
        !ii_xml TYPE REF TO zif_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS is_program_locked
      RETURNING
        VALUE(rv_is_program_locked) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_object_shlp DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.

    METHODS handle_dependencies
      IMPORTING
        !iv_step TYPE zif_abapgit_objects=>ty_deserialization_step
      CHANGING
        !cv_exit TYPE dd30v-selmexit
        !cv_done TYPE abap_bool.

    METHODS adjust_exit
      CHANGING
        !cv_exit TYPE dd30v-selmexit.

    METHODS check_exit
      IMPORTING
        !iv_exit       TYPE dd30v-selmexit
      RETURNING
        VALUE(rv_done) TYPE abap_bool.

ENDCLASS.

CLASS zcl_abapgit_object_sots DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES:
      zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_sots,
        header  TYPE sotr_headu,
        entries TYPE sotr_textl_tt,
      END OF ty_sots,
      ty_sots_tt TYPE STANDARD TABLE OF ty_sots
                    WITH NON-UNIQUE DEFAULT KEY.

    METHODS:
      read_sots
        RETURNING
          VALUE(rt_sots) TYPE ty_sots_tt,

      create_sots
        IMPORTING
          is_sots    TYPE ty_sots
          iv_package TYPE devclass
          iv_object  TYPE trobjtype
        RAISING
          zcx_abapgit_exception,

      get_raw_text_filename
        IMPORTING
          is_entry           TYPE sotr_textl
        RETURNING
          VALUE(rv_filename) TYPE string.

ENDCLASS.

CLASS zcl_abapgit_object_tabl_compar DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_comparator .

    METHODS constructor
      IMPORTING
        !ii_local TYPE REF TO zif_abapgit_xml_input.
  PROTECTED SECTION.

    TYPES:
      ty_founds  TYPE STANDARD TABLE OF rsfindlst
                           WITH NON-UNIQUE DEFAULT KEY .
    TYPES:
      ty_seu_obj TYPE STANDARD TABLE OF seu_obj
                           WITH NON-UNIQUE DEFAULT KEY .

    DATA mi_local TYPE REF TO zif_abapgit_xml_input.

    METHODS get_where_used_recursive
      IMPORTING
        !iv_object_name      TYPE csequence
        !iv_depth            TYPE i
        !iv_object_type      TYPE euobj-id
        !it_scope            TYPE ty_seu_obj
      RETURNING
        VALUE(rt_founds_all) TYPE ty_founds
      RAISING
        zcx_abapgit_exception .
    METHODS is_structure_used_in_db_table
      IMPORTING
        !iv_object_name                       TYPE dd02v-tabname
      RETURNING
        VALUE(rv_is_structure_used_in_db_tab) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    METHODS validate
      IMPORTING
        !ii_remote_version TYPE REF TO zif_abapgit_xml_input
        !ii_local_version  TYPE REF TO zif_abapgit_xml_input
        !ii_log            TYPE REF TO zif_abapgit_log
      RETURNING
        VALUE(rv_message)  TYPE string
      RAISING
        zcx_abapgit_exception .
  PRIVATE SECTION.

ENDCLASS.

CLASS zcl_abapgit_object_tabl DEFINITION

  INHERITING FROM zcl_abapgit_objects_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .
  PROTECTED SECTION.

    "! get additional data like table authorization group
    "! @parameter iv_tabname | name of the table
    METHODS read_extras IMPORTING iv_tabname            TYPE ddobjname
                        RETURNING VALUE(rs_tabl_extras) TYPE zif_abapgit_object_tabl=>ty_tabl_extras.

    "! Update additional data
    "! @parameter iv_tabname | name of the table
    "! @parameter is_tabl_extras | additional table data
    METHODS update_extras IMPORTING iv_tabname     TYPE ddobjname
                                    is_tabl_extras TYPE zif_abapgit_object_tabl=>ty_tabl_extras.

    "! Delete additional data
    "! @parameter iv_tabname | name of the table
    METHODS delete_extras IMPORTING iv_tabname TYPE ddobjname.

    "! Serialize IDoc Segment type/definition if exits
    "! @raising zcx_abapgit_exception | Exceptions
    METHODS serialize_idoc_segment CHANGING cs_internal TYPE zif_abapgit_object_tabl=>ty_internal
                                   RAISING  zcx_abapgit_exception.

    "! Deserialize IDoc Segment type/definition if exits
    "! @parameter iv_package | Target package
    "! @parameter rv_deserialized | It's a segment and was deserialized
    "! @raising zcx_abapgit_exception | Exceptions
    METHODS deserialize_idoc_segment IMPORTING is_internal            TYPE zif_abapgit_object_tabl=>ty_internal
                                               iv_transport           TYPE trkorr
                                               iv_package             TYPE devclass
                                     RETURNING VALUE(rv_deserialized) TYPE abap_bool
                                     RAISING   zcx_abapgit_exception.
    "! Delete the IDoc Segment type if exists
    "! @parameter rv_deleted | It's a segment and was deleted
    "! @raising zcx_abapgit_exception | Exceptions
    METHODS delete_idoc_segment RETURNING VALUE(rv_deleted) TYPE abap_bool
                                RAISING   zcx_abapgit_exception.
  PRIVATE SECTION.
    CONSTANTS c_longtext_id_tabl TYPE dokil-id VALUE 'TB' ##NO_TEXT.

    METHODS deserialize_indexes
      IMPORTING
        !is_internal TYPE zif_abapgit_object_tabl=>ty_internal
      RAISING
        zcx_abapgit_exception .
    METHODS clear_dd03p_fields
      CHANGING
        !ct_dd03p TYPE zif_abapgit_object_tabl=>ty_dd03p_tt .
    "! Check if structure is an IDoc segment
    "! @parameter rv_is_idoc_segment | It's an IDoc segment or not
    METHODS is_idoc_segment
      RETURNING
        VALUE(rv_is_idoc_segment) TYPE abap_bool .
    METHODS clear_dd03p_fields_common
      CHANGING
        !cs_dd03p TYPE dd03p .
    METHODS clear_dd03p_fields_dataelement
      CHANGING
        !cs_dd03p TYPE dd03p .
    METHODS serialize_texts
      CHANGING
        !cs_internal TYPE zif_abapgit_object_tabl=>ty_internal
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_texts
      CHANGING
        !cs_internal TYPE zif_abapgit_object_tabl=>ty_internal
      RAISING
        zcx_abapgit_exception .
    METHODS is_db_table_category
      IMPORTING
        !iv_tabclass               TYPE dd02l-tabclass
      RETURNING
        VALUE(rv_is_db_table_type) TYPE dd02l-tabclass .
ENDCLASS.

CLASS zcl_abapgit_object_tabl_ddl DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS read_data
      IMPORTING
        !iv_name       TYPE tadir-obj_name
      RETURNING
        VALUE(rs_data) TYPE zif_abapgit_object_tabl=>ty_internal .
    METHODS serialize
      IMPORTING
        !is_data      TYPE zif_abapgit_object_tabl=>ty_internal
      RETURNING
        VALUE(rv_ddl) TYPE string .
    METHODS deserialize
      IMPORTING
        !iv_ddl        TYPE string
      RETURNING
        VALUE(rs_data) TYPE zif_abapgit_object_tabl=>ty_internal .
    METHODS serialize_adt
      IMPORTING
        !iv_name      TYPE tadir-obj_name
      RETURNING
        VALUE(rv_ddl) TYPE string
      RAISING
        cx_static_check .
  PROTECTED SECTION.
  PRIVATE SECTION.

    METHODS parse_top_annotations
      CHANGING
        !cs_data TYPE zif_abapgit_object_tabl=>ty_internal
        !cv_ddl  TYPE string .
    METHODS parse_field_annotations
      EXPORTING
        !es_dd08v TYPE dd08v
      CHANGING
        !cv_ddl   TYPE string .
    METHODS parse_field
      IMPORTING
        !iv_field TYPE string
      CHANGING
        !cs_data  TYPE zif_abapgit_object_tabl=>ty_internal .
    METHODS serialize_top
      IMPORTING
        !is_data      TYPE zif_abapgit_object_tabl=>ty_internal
      RETURNING
        VALUE(rv_ddl) TYPE string .
    METHODS serialize_extend
      IMPORTING
        !is_dd03p     TYPE dd03p
        !is_data      TYPE zif_abapgit_object_tabl=>ty_internal
      RETURNING
        VALUE(rv_ddl) TYPE string .
    METHODS serialize_field_annotations
      IMPORTING
        !iv_fieldname TYPE clike
        !is_data      TYPE zif_abapgit_object_tabl=>ty_internal
      RETURNING
        VALUE(rv_ddl) TYPE string .
    METHODS serialize_fkey_annotations
      IMPORTING
        !iv_fieldname TYPE clike
        !is_data      TYPE zif_abapgit_object_tabl=>ty_internal
      RETURNING
        VALUE(rv_ddl) TYPE string .
    METHODS serialize_field_foreign_key
      IMPORTING
        !iv_fieldname TYPE clike
        !is_data      TYPE zif_abapgit_object_tabl=>ty_internal
      RETURNING
        VALUE(rv_ddl) TYPE string .
    METHODS serialize_value_help
      IMPORTING
        !iv_fieldname TYPE clike
        !is_data      TYPE zif_abapgit_object_tabl=>ty_internal
      RETURNING
        VALUE(rv_ddl) TYPE string .
    METHODS escape_string
      IMPORTING
        !iv_string       TYPE clike
      RETURNING
        VALUE(rv_string) TYPE string .
    METHODS unescape_string
      IMPORTING
        !iv_string       TYPE clike
      RETURNING
        VALUE(rv_string) TYPE string .
    METHODS serialize_type
      IMPORTING
        !is_dd03p      TYPE dd03p
      RETURNING
        VALUE(rv_type) TYPE string .
    METHODS parse_type
      IMPORTING
        !iv_token TYPE string
      CHANGING
        !cs_dd03p TYPE dd03p .
ENDCLASS.

CLASS zcl_abapgit_object_tobj DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES: BEGIN OF ty_tobj,
             tddat TYPE tddat,
             tvdir TYPE tvdir,
             tvimf TYPE STANDARD TABLE OF tvimf WITH DEFAULT KEY,
           END OF ty_tobj.

    METHODS:
      read_extra IMPORTING iv_tabname     TYPE vim_name
                 RETURNING VALUE(rs_tobj) TYPE ty_tobj,
      update_extra IMPORTING is_tobj TYPE ty_tobj,
      delete_extra IMPORTING iv_tabname TYPE vim_name.

ENDCLASS.

CLASS zcl_abapgit_object_tran DEFINITION

  INHERITING FROM zcl_abapgit_objects_super
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object .
  PROTECTED SECTION.

  PRIVATE SECTION.
    TYPES:
      ty_param_values TYPE STANDARD TABLE OF rsparam
                                     WITH NON-UNIQUE DEFAULT KEY ,
      ty_tstca        TYPE STANDARD TABLE OF tstca
                                     WITH DEFAULT KEY.

    CONSTANTS:
      c_oo_program   TYPE c LENGTH 9 VALUE '\PROGRAM=' ##NO_TEXT,
      c_oo_class     TYPE c LENGTH 7 VALUE '\CLASS=' ##NO_TEXT,
      c_oo_method    TYPE c LENGTH 8 VALUE '\METHOD=' ##NO_TEXT,
      c_oo_tcode     TYPE tcode VALUE 'OS_APPLICATION' ##NO_TEXT,
      c_oo_frclass   TYPE c LENGTH 30 VALUE 'CLASS' ##NO_TEXT,
      c_oo_frmethod  TYPE c LENGTH 30 VALUE 'METHOD' ##NO_TEXT,
      c_oo_frupdtask TYPE c LENGTH 30 VALUE 'UPDATE_MODE' ##NO_TEXT,
      c_oo_synchron  TYPE c VALUE 'S' ##NO_TEXT,
      c_oo_asynchron TYPE c VALUE 'U' ##NO_TEXT,
      c_true         TYPE c VALUE 'X' ##NO_TEXT,
      c_false        TYPE c VALUE space ##NO_TEXT,
      BEGIN OF c_variant_type,
        dialog     TYPE rglif-docutype VALUE 'D' ##NO_TEXT,
        report     TYPE rglif-docutype VALUE 'R' ##NO_TEXT,
        variant    TYPE rglif-docutype VALUE 'V' ##NO_TEXT,
        parameters TYPE rglif-docutype VALUE 'P' ##NO_TEXT,
        object     TYPE rglif-docutype VALUE 'O' ##NO_TEXT,
      END OF c_variant_type.

    DATA:
      mt_bcdata TYPE STANDARD TABLE OF bdcdata .

    METHODS transaction_read
      IMPORTING
        iv_transaction TYPE tcode
      EXPORTING
        es_transaction TYPE tstc
        es_gui_attr    TYPE tstcc
      RAISING
        zcx_abapgit_exception.
    METHODS shift_param
      CHANGING
        !ct_rsparam TYPE s_param
        !cs_tstcp   TYPE tstcp .
    METHODS add_data
      IMPORTING
        !iv_fnam TYPE bdcdata-fnam
        !iv_fval TYPE clike .
    METHODS call_se93
      RAISING
        zcx_abapgit_exception .
    METHODS set_oo_parameters
      IMPORTING
        !it_rsparam TYPE s_param
      CHANGING
        !cs_rsstcd  TYPE rsstcd .
    METHODS split_parameters
      CHANGING
        !ct_rsparam TYPE s_param
        !cs_rsstcd  TYPE rsstcd
        !cs_tstcp   TYPE tstcp
        !cs_tstc    TYPE tstc .
    METHODS split_parameters_comp
      IMPORTING
        !ig_type  TYPE any
        !ig_param TYPE any
      CHANGING
        !cg_value TYPE any .
    METHODS serialize_texts
      IMPORTING
        !ii_xml TYPE REF TO zif_abapgit_xml_output
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_texts
      IMPORTING
        !ii_xml TYPE REF TO zif_abapgit_xml_input
      RAISING
        zcx_abapgit_exception .
    METHODS deserialize_oo_transaction
      IMPORTING
        !iv_package TYPE devclass
        !is_tstc    TYPE tstc
        !is_tstcc   TYPE tstcc
        !is_tstct   TYPE tstct
        !is_rsstcd  TYPE rsstcd
      RAISING
        zcx_abapgit_exception .
    METHODS save_authorizations
      IMPORTING
        iv_transaction    TYPE tstc-tcode
        it_authorizations TYPE ty_tstca
      RAISING
        zcx_abapgit_exception.
    METHODS clear_functiongroup_globals.
    METHODS is_variant_transaction IMPORTING is_tstcp                      TYPE tstcp
                                   RETURNING VALUE(rv_variant_transaction) TYPE abap_bool.
ENDCLASS.

CLASS zcl_abapgit_object_ttyp DEFINITION  INHERITING FROM zcl_abapgit_objects_super FINAL.

  PUBLIC SECTION.
    INTERFACES zif_abapgit_object.
  PROTECTED SECTION.
  PRIVATE SECTION.
    CONSTANTS c_longtext_id_ttyp TYPE dokil-id VALUE 'TT'.
ENDCLASS.

CLASS zcl_abapgit_object_w3xx_super DEFINITION

  INHERITING FROM zcl_abapgit_objects_super
  ABSTRACT
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_object .

    TYPES:
      ty_wwwparams_tt TYPE STANDARD TABLE OF wwwparams WITH DEFAULT KEY .

    CONSTANTS:
      BEGIN OF c_param_names,
        version  TYPE w3_name VALUE 'version',
        fileext  TYPE w3_name VALUE 'fileextension',
        filesize TYPE w3_name VALUE 'filesize',
        filename TYPE w3_name VALUE 'filename',
        mimetype TYPE w3_name VALUE 'mimetype',
      END OF c_param_names .

    METHODS constructor
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !iv_language    TYPE spras
        !io_files       TYPE REF TO zcl_abapgit_objects_files OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params OPTIONAL
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.
    TYPES ty_bdcdata TYPE STANDARD TABLE OF bdcdata
                           WITH NON-UNIQUE DEFAULT KEY.

    METHODS change_bdc_jump_data ABSTRACT
      CHANGING
        ct_bdcdata TYPE ty_bdcdata.

  PRIVATE SECTION.

    DATA ms_key TYPE wwwdatatab.

    METHODS get_ext
      IMPORTING it_params     TYPE ty_wwwparams_tt
      RETURNING VALUE(rv_ext) TYPE string
      RAISING   zcx_abapgit_exception.

    METHODS normalize_params
      IMPORTING iv_size   TYPE i
      CHANGING  ct_params TYPE ty_wwwparams_tt  " Param table to patch
      RAISING   zcx_abapgit_exception.

    METHODS strip_params
      CHANGING ct_params TYPE ty_wwwparams_tt
      RAISING  zcx_abapgit_exception.

    METHODS find_param
      IMPORTING it_params       TYPE ty_wwwparams_tt
                iv_name         TYPE w3_name
      RETURNING VALUE(rv_value) TYPE string
      RAISING   zcx_abapgit_exception.

ENDCLASS.

CLASS zcl_abapgit_object_w3ht DEFINITION  INHERITING FROM zcl_abapgit_object_w3xx_super FINAL.

  PROTECTED SECTION.
    METHODS: change_bdc_jump_data REDEFINITION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_object_w3mi DEFINITION  INHERITING FROM zcl_abapgit_object_w3xx_super FINAL.

  PROTECTED SECTION.
    METHODS: change_bdc_jump_data REDEFINITION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_oo_base DEFINITION

  ABSTRACT
  CREATE PROTECTED.

  PUBLIC SECTION.

    INTERFACES zif_abapgit_oo_object_fnc .
    CONSTANTS c_cp_program_type TYPE c LENGTH 1 VALUE 'K'.
    CONSTANTS c_include_program_type TYPE c LENGTH 1 VALUE 'I'.
    CONSTANTS c_ip_program_type TYPE c LENGTH 1 VALUE 'J'.
  PROTECTED SECTION.
    CLASS-METHODS:
      convert_attrib_to_vseoattrib
        IMPORTING iv_clsname           TYPE seoclsname
                  it_attributes        TYPE zif_abapgit_oo_object_fnc=>ty_obj_attribute_tt
        RETURNING VALUE(rt_vseoattrib) TYPE seoo_attributes_r.

  PRIVATE SECTION.
    CONSTANTS c_docu_state_active TYPE dokstate VALUE 'A'. " See include SDOC_CONSTANTS

    DATA mv_skip_test_classes TYPE abap_bool .

ENDCLASS.

CLASS zcl_abapgit_oo_class DEFINITION

  INHERITING FROM zcl_abapgit_oo_base
  CREATE PUBLIC
   FRIENDS zcl_abapgit_oo_factory.

  PUBLIC SECTION.

    METHODS zif_abapgit_oo_object_fnc~create
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~create_sotr
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~delete
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~deserialize_source
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~generate_locals
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~get_class_properties
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~get_includes
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~insert_text_pool
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~read_sotr
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~read_text_pool
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~exists
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~syntax_check
        REDEFINITION .
  PROTECTED SECTION.

    TYPES:
      ty_char1 TYPE c LENGTH 1 .
    TYPES:
      ty_char2 TYPE c LENGTH 2 .
  PRIVATE SECTION.

    CLASS-METHODS update_source_index
      IMPORTING
        !iv_clsname TYPE csequence
        !io_scanner TYPE REF TO cl_oo_source_scanner_class .
    CLASS-METHODS update_report
      IMPORTING
        !iv_program       TYPE syrepid
        !it_source        TYPE string_table
        !iv_package       TYPE devclass
        !iv_version       TYPE uccheck
      RETURNING
        VALUE(rv_updated) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS generate_classpool
      IMPORTING
        !iv_name TYPE seoclsname
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS update_meta
      IMPORTING
        !iv_name     TYPE seoclsname
        !iv_exposure TYPE seoexpose
        !it_source   TYPE rswsourcet
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS determine_method_include
      IMPORTING
        !iv_name          TYPE seoclsname
        !iv_method        TYPE seocpdname
      RETURNING
        VALUE(rv_program) TYPE syrepid
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS init_scanner
      IMPORTING
        !it_source        TYPE zif_abapgit_definitions=>ty_string_tt
        !iv_name          TYPE seoclsname
      RETURNING
        VALUE(ro_scanner) TYPE REF TO cl_oo_source_scanner_class
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS update_full_class_include
      IMPORTING
        !iv_classname TYPE seoclsname
        !it_source    TYPE string_table
        !it_methods   TYPE cl_oo_source_scanner_class=>type_method_implementations
        !iv_package   TYPE devclass
        !iv_version   TYPE uccheck
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS create_report
      IMPORTING
        !iv_program      TYPE syrepid
        !it_source       TYPE string_table
        !iv_extension    TYPE ty_char2
        !iv_program_type TYPE ty_char1
        !iv_state        TYPE r3state
        !iv_package      TYPE devclass
        !iv_version      TYPE uccheck
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS update_cs_number_of_methods
      IMPORTING
        !iv_classname              TYPE seoclsname
        !iv_number_of_impl_methods TYPE i .
    CLASS-METHODS delete_report
      IMPORTING
        !iv_program TYPE syrepid
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS get_method_includes
      IMPORTING
        !iv_classname      TYPE seoclsname
      RETURNING
        VALUE(rt_includes) TYPE seop_methods_w_include.
    CLASS-METHODS repair_classpool
      IMPORTING
        !is_key TYPE seoclskey
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS repair_redefinitions
      IMPORTING
        !is_key TYPE seoclskey
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_oo_interface DEFINITION

  INHERITING FROM zcl_abapgit_oo_base
  CREATE PUBLIC
   FRIENDS zcl_abapgit_oo_factory.

  PUBLIC SECTION.

    METHODS zif_abapgit_oo_object_fnc~create
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~delete
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~get_includes
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~get_interface_properties
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~deserialize_source
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~exists
        REDEFINITION .
    METHODS zif_abapgit_oo_object_fnc~syntax_check
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-METHODS update_report
      IMPORTING
        !iv_program       TYPE syrepid
        !it_source        TYPE string_table
        !iv_package       TYPE devclass
        !iv_version       TYPE uccheck
      RETURNING
        VALUE(rv_updated) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS update_meta
      IMPORTING
        !iv_name   TYPE seoclsname
        !it_source TYPE rswsourcet
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS init_scanner
      IMPORTING
        !it_source        TYPE zif_abapgit_definitions=>ty_string_tt
        !iv_name          TYPE seoclsname
      RETURNING
        VALUE(ro_scanner) TYPE REF TO cl_oo_source_scanner_interface
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_oo_factory DEFINITION .

  PUBLIC SECTION.
    CLASS-METHODS:
      get_by_type
        IMPORTING
          iv_object_type                   TYPE tadir-object
        RETURNING
          VALUE(ri_object_oriented_object) TYPE REF TO zif_abapgit_oo_object_fnc,

      get_by_name
        IMPORTING
          iv_object_name                   TYPE seoclsname
        RETURNING
          VALUE(ri_object_oriented_object) TYPE REF TO zif_abapgit_oo_object_fnc
        RAISING
          zcx_abapgit_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_oo_serializer DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    METHODS serialize_abap_clif_source
      IMPORTING
        !is_class_key    TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=>ty_string_tt
      RAISING
        zcx_abapgit_exception
        cx_sy_dyn_call_error .
    METHODS are_test_classes_skipped
      RETURNING
        VALUE(rv_return) TYPE abap_bool .
    METHODS serialize_locals_imp
      IMPORTING
        !is_clskey       TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=>ty_string_tt
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_locals_def
      IMPORTING
        !is_clskey       TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=>ty_string_tt
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_testclasses
      IMPORTING
        !is_clskey       TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=>ty_string_tt
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_macros
      IMPORTING
        !is_clskey       TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=>ty_string_tt
      RAISING
        zcx_abapgit_exception .
  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA mv_skip_testclass TYPE abap_bool .

    METHODS calculate_skip_testclass
      IMPORTING
        !it_source               TYPE zif_abapgit_definitions=>ty_string_tt
      RETURNING
        VALUE(rv_skip_testclass) TYPE abap_bool .
    METHODS serialize_abap_old
      IMPORTING
        !is_clskey       TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=>ty_string_tt
      RAISING
        zcx_abapgit_exception .
    METHODS serialize_abap_new
      IMPORTING
        !is_clskey       TYPE seoclskey
      RETURNING
        VALUE(rt_source) TYPE zif_abapgit_definitions=>ty_string_tt
      RAISING
        zcx_abapgit_exception
        cx_sy_dyn_call_error .
    METHODS remove_signatures
      CHANGING
        !ct_source TYPE zif_abapgit_definitions=>ty_string_tt .
    METHODS read_include
      IMPORTING
        !is_clskey       TYPE seoclskey
        !iv_type         TYPE seop_include_ext_app
      RETURNING
        VALUE(rt_source) TYPE seop_source_string
      RAISING
        zcx_abapgit_exception.
    METHODS reduce
      CHANGING
        !ct_source TYPE zif_abapgit_definitions=>ty_string_tt .
ENDCLASS.

CLASS zcl_abapgit_path DEFINITION
   FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    CLASS-METHODS split_file_location
      IMPORTING iv_fullpath TYPE string
      EXPORTING ev_path     TYPE string
                ev_filename TYPE string.

    CLASS-METHODS is_root
      IMPORTING iv_path       TYPE string
      RETURNING VALUE(rv_yes) TYPE abap_bool.

    CLASS-METHODS is_subdir
      IMPORTING iv_path       TYPE string
                iv_parent     TYPE string
      RETURNING VALUE(rv_yes) TYPE abap_bool.

    CLASS-METHODS change_dir
      IMPORTING iv_cur_dir     TYPE string
                iv_cd          TYPE string
      RETURNING VALUE(rv_path) TYPE string.

    CLASS-METHODS get_filename_from_syspath
      IMPORTING iv_path            TYPE string
      RETURNING VALUE(rv_filename) TYPE string.

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_persistence_db DEFINITION

  CREATE PRIVATE .

  PUBLIC SECTION.
    CONSTANTS c_tabname TYPE c LENGTH 30 VALUE 'ZABAPGIT' ##NO_TEXT.
    CONSTANTS c_lock TYPE c LENGTH 30 VALUE 'EZABAPGIT' ##NO_TEXT.

    CONSTANTS:
      c_type_settings   TYPE zif_abapgit_persistence=>ty_type VALUE 'SETTINGS' ##NO_TEXT,
      c_type_repo       TYPE zif_abapgit_persistence=>ty_type VALUE 'REPO' ##NO_TEXT,
      c_type_repo_csum  TYPE zif_abapgit_persistence=>ty_type VALUE 'REPO_CS' ##NO_TEXT,
      c_type_background TYPE zif_abapgit_persistence=>ty_type VALUE 'BACKGROUND' ##NO_TEXT,
      c_type_packages   TYPE zif_abapgit_persistence=>ty_type VALUE 'PACKAGES' ##NO_TEXT,
      c_type_user       TYPE zif_abapgit_persistence=>ty_type VALUE 'USER' ##NO_TEXT.

    CLASS-METHODS get_instance
      RETURNING
        VALUE(ro_db) TYPE REF TO zcl_abapgit_persistence_db .
    METHODS add
      IMPORTING
        !iv_type  TYPE zif_abapgit_persistence=>ty_type
        !iv_value TYPE zif_abapgit_persistence=>ty_content-value
        !iv_data  TYPE zif_abapgit_persistence=>ty_content-data_str
      RAISING
        zcx_abapgit_exception .
    METHODS delete
      IMPORTING
        !iv_type  TYPE zif_abapgit_persistence=>ty_type
        !iv_value TYPE zif_abapgit_persistence=>ty_content-value
      RAISING
        zcx_abapgit_exception .
    METHODS list
      RETURNING
        VALUE(rt_content) TYPE zif_abapgit_persistence=>ty_contents .
    METHODS list_by_type
      IMPORTING
        !iv_type          TYPE zif_abapgit_persistence=>ty_type
      RETURNING
        VALUE(rt_content) TYPE zif_abapgit_persistence=>ty_contents .
    METHODS list_by_keys
      IMPORTING it_keys            TYPE zif_abapgit_persistence=>ty_repo_keys
                iv_type            TYPE zif_abapgit_persistence=>ty_type
      RETURNING VALUE(rt_contents) TYPE zif_abapgit_persistence=>ty_contents.
    METHODS lock
      IMPORTING
        !iv_mode  TYPE enqmode DEFAULT 'E'
        !iv_type  TYPE zif_abapgit_persistence=>ty_type
        !iv_value TYPE zif_abapgit_persistence=>ty_content-value
      RAISING
        zcx_abapgit_exception .
    METHODS modify
      IMPORTING
        !iv_type  TYPE zif_abapgit_persistence=>ty_type
        !iv_value TYPE zif_abapgit_persistence=>ty_content-value
        !iv_data  TYPE zif_abapgit_persistence=>ty_content-data_str
      RAISING
        zcx_abapgit_exception .
    METHODS read
      IMPORTING
        !iv_type       TYPE zif_abapgit_persistence=>ty_type
        !iv_value      TYPE zif_abapgit_persistence=>ty_content-value
      RETURNING
        VALUE(rv_data) TYPE zif_abapgit_persistence=>ty_content-data_str
      RAISING
        zcx_abapgit_not_found .
    METHODS update
      IMPORTING
        !iv_type  TYPE zif_abapgit_persistence=>ty_type
        !iv_value TYPE zif_abapgit_persistence=>ty_content-value
        !iv_data  TYPE zif_abapgit_persistence=>ty_content-data_str
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS validate_entry_type
      IMPORTING
        !iv_type TYPE zif_abapgit_persistence=>ty_type
      RAISING
        zcx_abapgit_exception .

  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA go_db TYPE REF TO zcl_abapgit_persistence_db .
    DATA mv_update_function TYPE funcname .

    METHODS get_update_function
      RETURNING
        VALUE(rv_funcname) TYPE funcname .
    METHODS validate_and_unprettify_xml
      IMPORTING
        !iv_xml       TYPE string
      RETURNING
        VALUE(rv_xml) TYPE string
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_po_file DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES zif_abapgit_i18n_file.

    METHODS constructor
      IMPORTING
        iv_lang TYPE laiso.

    METHODS parse
      IMPORTING
        iv_xdata TYPE xstring
      RAISING
        zcx_abapgit_exception.

    METHODS push_text_pairs
      IMPORTING
        iv_objtype    TYPE trobjtype
        iv_objname    TYPE lxeobjname
        it_text_pairs TYPE zif_abapgit_lxe_texts=>ty_text_pairs
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.

    CONSTANTS:
      BEGIN OF c_comment,
        translator TYPE i VALUE 1,
        extracted  TYPE i VALUE 2,
        reference  TYPE i VALUE 3,
        flag       TYPE i VALUE 4,
        previous   TYPE i VALUE 5,
      END OF c_comment.
    TYPES:
      BEGIN OF ty_comment,
        kind TYPE i,
        text TYPE string,
      END OF ty_comment.
    TYPES:
      BEGIN OF ty_msg_pair,
        source   TYPE string,
        target   TYPE string,
        comments TYPE STANDARD TABLE OF ty_comment WITH KEY kind text,
      END OF ty_msg_pair.

    DATA mv_lang TYPE laiso.
    DATA mt_pairs TYPE SORTED TABLE OF ty_msg_pair WITH UNIQUE KEY source.

    METHODS build_po_body
      RETURNING
        VALUE(ro_buf) TYPE REF TO zcl_abapgit_string_buffer.
    METHODS build_po_head
      RETURNING
        VALUE(ro_buf) TYPE REF TO zcl_abapgit_string_buffer.
    METHODS parse_po
      IMPORTING
        iv_data TYPE string
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS get_comment_marker
      IMPORTING
        iv_comment_kind  TYPE i
      RETURNING
        VALUE(rv_marker) TYPE string.

    CLASS-METHODS quote
      IMPORTING
        iv_text        TYPE string
      RETURNING
        VALUE(rv_text) TYPE string.
    CLASS-METHODS unquote
      IMPORTING
        iv_text        TYPE string
      RETURNING
        VALUE(rv_text) TYPE string
      RAISING
        zcx_abapgit_exception.

ENDCLASS.

CLASS zcl_abapgit_progress DEFINITION

  FINAL
  CREATE PROTECTED .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_progress .

    CLASS-METHODS set_instance
      IMPORTING
        !ii_progress TYPE REF TO zif_abapgit_progress .
    CLASS-METHODS get_instance
      IMPORTING
        !iv_total          TYPE i
      RETURNING
        VALUE(ri_progress) TYPE REF TO zif_abapgit_progress .
  PROTECTED SECTION.

    DATA mv_total TYPE i .
    CLASS-DATA gi_progress TYPE REF TO zif_abapgit_progress .

    METHODS calc_pct
      IMPORTING
        !iv_current   TYPE i
      RETURNING
        VALUE(rv_pct) TYPE i .
  PRIVATE SECTION.

    DATA mv_cv_time_next TYPE sy-uzeit .
    DATA mv_cv_datum_next TYPE sy-datum .
ENDCLASS.

CLASS zcl_abapgit_properties_file DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES zif_abapgit_i18n_file.

    CONSTANTS:
      c_properties_feature TYPE string VALUE 'TRANSL'.

    METHODS constructor
      IMPORTING
        iv_lang TYPE laiso.

    METHODS parse
      IMPORTING
        iv_xdata TYPE xstring
      RAISING
        zcx_abapgit_exception.

    METHODS push_text_pairs
      IMPORTING it_translation TYPE string_table.

    METHODS get_translations
      EXPORTING
        ev_data TYPE data
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA mv_lang TYPE laiso.
    DATA mt_translation TYPE string_table.

ENDCLASS.

CLASS zcl_abapgit_sap_namespace DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES zif_abapgit_sap_namespace.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_sap_package DEFINITION

  CREATE PRIVATE
   FRIENDS zcl_abapinst_factory .

  PUBLIC SECTION.

    INTERFACES zif_abapgit_sap_package .

    METHODS constructor
      IMPORTING
        !iv_package TYPE devclass .
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA: mv_package TYPE devclass.

    METHODS get_transport_layer
      RETURNING
        VALUE(rv_transport_layer) TYPE devlayer
      RAISING
        zcx_abapgit_exception .

ENDCLASS.

CLASS zcl_abapgit_sap_report DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    INTERFACES zif_abapgit_sap_report.

  PROTECTED SECTION.
  PRIVATE SECTION.

    METHODS authorization_check
      IMPORTING
        iv_mode TYPE csequence
        is_item TYPE zif_abapgit_definitions=>ty_item
      RAISING
        zcx_abapgit_exception.

ENDCLASS.

CLASS zcl_abapgit_sotr_handler DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_sotr,
        header  TYPE sotr_head,
        entries TYPE sotr_text_tt,
      END OF ty_sotr.
    TYPES:
      ty_sotr_tt TYPE STANDARD TABLE OF ty_sotr WITH DEFAULT KEY.
    TYPES:
      ty_sotr_use_tt TYPE STANDARD TABLE OF sotr_use WITH DEFAULT KEY.

    CLASS-METHODS read_sotr
      IMPORTING
        !iv_pgmid       TYPE pgmid DEFAULT 'R3TR'
        !iv_object      TYPE trobjtype
        !iv_obj_name    TYPE csequence
        !io_xml         TYPE REF TO zif_abapgit_xml_output OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params
      EXPORTING
        !et_sotr        TYPE ty_sotr_tt
        !et_sotr_use    TYPE ty_sotr_use_tt
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS create_sotr
      IMPORTING
        !iv_package TYPE devclass
        !io_xml     TYPE REF TO zif_abapgit_xml_input
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS create_sotr_from_data
      IMPORTING
        !iv_package  TYPE devclass
        !it_sotr     TYPE ty_sotr_tt
        !it_sotr_use TYPE ty_sotr_use_tt
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS delete_sotr
      IMPORTING
        !iv_pgmid    TYPE pgmid DEFAULT 'R3TR'
        !iv_object   TYPE trobjtype
        !iv_obj_name TYPE csequence
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS delete_sotr_package
      IMPORTING
        !iv_package TYPE devclass
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS change_sotr_package
      IMPORTING
        !iv_old_package TYPE devclass
        !iv_new_package TYPE devclass
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.

    CLASS-METHODS get_sotr_usage
      IMPORTING
        !iv_pgmid          TYPE pgmid
        !iv_object         TYPE trobjtype
        !iv_obj_name       TYPE csequence
      RETURNING
        VALUE(rt_sotr_use) TYPE ty_sotr_use_tt.

    CLASS-METHODS get_sotr_4_concept
      IMPORTING
        !iv_concept    TYPE sotr_conc
      RETURNING
        VALUE(rs_sotr) TYPE ty_sotr.

  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapgit_sots_handler DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_sots,
        header  TYPE sotr_headu,
        entries TYPE sotr_textl_tt,
      END OF ty_sots.
    TYPES:
      ty_sots_tt TYPE STANDARD TABLE OF ty_sots WITH DEFAULT KEY.
    TYPES:
      ty_sots_use_tt TYPE STANDARD TABLE OF sotr_useu WITH DEFAULT KEY.

    CLASS-METHODS read_sots
      IMPORTING
        !iv_pgmid       TYPE pgmid DEFAULT 'R3TR'
        !iv_object      TYPE trobjtype
        !iv_obj_name    TYPE csequence
        !io_xml         TYPE REF TO zif_abapgit_xml_output OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params
      EXPORTING
        !et_sots        TYPE ty_sots_tt
        !et_sots_use    TYPE ty_sots_use_tt
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS create_sots
      IMPORTING
        !iv_package TYPE devclass
        !io_xml     TYPE REF TO zif_abapgit_xml_input OPTIONAL
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS create_sots_from_data
      IMPORTING
        !iv_package  TYPE devclass
        !it_sots     TYPE ty_sots_tt OPTIONAL
        !it_sots_use TYPE ty_sots_use_tt OPTIONAL
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS delete_sots
      IMPORTING
        !iv_pgmid    TYPE pgmid DEFAULT 'R3TR'
        !iv_object   TYPE trobjtype
        !iv_obj_name TYPE csequence
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.

    CLASS-METHODS get_sots_usage
      IMPORTING
        !iv_pgmid          TYPE pgmid
        !iv_object         TYPE trobjtype
        !iv_obj_name       TYPE csequence
      RETURNING
        VALUE(rt_sots_use) TYPE ty_sots_use_tt.

    CLASS-METHODS get_sots_4_concept
      IMPORTING
        !iv_concept    TYPE sotr_conc
      RETURNING
        VALUE(rs_sots) TYPE ty_sots.

  PRIVATE SECTION.

ENDCLASS.

CLASS zcl_abapgit_tadir DEFINITION

  FINAL
  CREATE PRIVATE
   FRIENDS zcl_abapinst_factory .

  PUBLIC SECTION.
    INTERFACES zif_abapgit_tadir .

  PROTECTED SECTION.
  PRIVATE SECTION.

    METHODS check_exists
      IMPORTING
        !it_tadir       TYPE zif_abapgit_definitions=>ty_tadir_tt
      RETURNING
        VALUE(rt_tadir) TYPE zif_abapgit_definitions=>ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
    METHODS build
      IMPORTING
        !iv_package            TYPE tadir-devclass
        !io_dot                TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_ignore_subpackages TYPE abap_bool DEFAULT abap_false
        !iv_only_local_objects TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(rt_tadir)        TYPE zif_abapgit_definitions=>ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
    METHODS select_objects
      IMPORTING
        !iv_package            TYPE tadir-devclass
        !iv_ignore_subpackages TYPE abap_bool DEFAULT abap_false
        !iv_only_local_objects TYPE abap_bool
      EXPORTING
        !et_packages           TYPE zif_abapgit_sap_package=>ty_devclass_tt
        !et_tadir              TYPE zif_abapgit_definitions=>ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
    METHODS add_local_packages
      IMPORTING
        !it_packages TYPE zif_abapgit_sap_package=>ty_devclass_tt
      CHANGING
        !ct_tadir    TYPE zif_abapgit_definitions=>ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
    METHODS add_namespaces
      IMPORTING
        !iv_package TYPE devclass
      CHANGING
        !ct_tadir   TYPE zif_abapgit_definitions=>ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
    METHODS add_namespace
      IMPORTING
        !iv_package    TYPE devclass
        !iv_object     TYPE csequence
      CHANGING
        !ct_tadir      TYPE zif_abapgit_definitions=>ty_tadir_tt
        !ct_tadir_nspc TYPE zif_abapgit_definitions=>ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
    METHODS determine_path
      IMPORTING
        !iv_package TYPE tadir-devclass
        !io_dot     TYPE REF TO zcl_abapgit_dot_abapgit
      CHANGING
        !ct_tadir   TYPE zif_abapgit_definitions=>ty_tadir_tt
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_url DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS validate
      IMPORTING
        !iv_url TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS host
      IMPORTING
        !iv_url        TYPE string
      RETURNING
        VALUE(rv_host) TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS name
      IMPORTING
        !iv_url        TYPE string
        !iv_validate   TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(rv_name) TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS path_name
      IMPORTING
        !iv_url             TYPE string
      RETURNING
        VALUE(rv_path_name) TYPE string
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS is_abapgit_repo
      IMPORTING
        !iv_url           TYPE string
      RETURNING
        VALUE(rv_abapgit) TYPE abap_bool .
    CLASS-METHODS url_address
      IMPORTING
        !iv_url          TYPE string
      RETURNING
        VALUE(rv_adress) TYPE string
      RAISING
        zcx_abapgit_exception.
  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-METHODS regex
      IMPORTING
        !iv_url  TYPE string
      EXPORTING
        !ev_host TYPE string
        !ev_path TYPE string
        !ev_name TYPE string
      RAISING
        zcx_abapgit_exception .
ENDCLASS.

CLASS zcl_abapgit_version DEFINITION

  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS normalize
      IMPORTING
        !iv_version       TYPE string
      RETURNING
        VALUE(rv_version) TYPE string .
    CLASS-METHODS conv_str_to_version
      IMPORTING
        !iv_version       TYPE csequence
      RETURNING
        VALUE(rs_version) TYPE zif_abapgit_definitions=>ty_version
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS check_dependant_version
      IMPORTING
        !is_current   TYPE zif_abapgit_definitions=>ty_version
        !is_dependant TYPE zif_abapgit_definitions=>ty_version
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS compare
      IMPORTING
        !iv_a            TYPE string OPTIONAL
        !iv_b            TYPE string OPTIONAL
        !is_a            TYPE zif_abapgit_definitions=>ty_version OPTIONAL
        !is_b            TYPE zif_abapgit_definitions=>ty_version OPTIONAL
      RETURNING
        VALUE(rv_result) TYPE i .
    CLASS-METHODS get_version_constant_value
      IMPORTING
        iv_version_constant TYPE string
      RETURNING
        VALUE(rv_version)   TYPE string
      RAISING
        zcx_abapgit_exception.
  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-METHODS version_to_numeric
      IMPORTING
        !iv_version       TYPE string
      RETURNING
        VALUE(rv_version) TYPE i.
ENDCLASS.

CLASS zcl_abapgit_xml_pretty DEFINITION

  CREATE PUBLIC .

  PUBLIC SECTION.

    CLASS-METHODS print
      IMPORTING
        !iv_xml           TYPE string
        !iv_ignore_errors TYPE abap_bool DEFAULT abap_true
        !iv_unpretty      TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(rv_xml)     TYPE string
      RAISING
        zcx_abapgit_exception .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_abapinst_factory DEFINITION

  CREATE PRIVATE.

  " This is a replacement for ZCL_ABAPGIT_FACTORY
  "
  " Using ZCL_ABAPGIT_FACTORY would drag in many other dependencies
  " which are completely unnecessary for abapinst (like the abapGit UI layer).
  " Note: This class will show errors when trying to activated it!
  "
  " One must ignore errors like 'An instance of the class
  " "ZCL_ABAPGIT_..." cannot be created outside the class.'
  " and activate the class anyway.
  "
  " Once the class is embedded into the standalone program as a local class,
  " it will work just fine.
  PUBLIC SECTION.

    CLASS-METHODS get_tadir
      RETURNING
        VALUE(ri_tadir) TYPE REF TO zif_abapgit_tadir.
    CLASS-METHODS get_sap_package
      IMPORTING
        !iv_package           TYPE devclass
      RETURNING
        VALUE(ri_sap_package) TYPE REF TO zif_abapgit_sap_package.
    CLASS-METHODS get_cts_api
      RETURNING
        VALUE(ri_cts_api) TYPE REF TO zif_abapgit_cts_api.
    CLASS-METHODS get_default_transport
      RETURNING
        VALUE(ri_default_transport) TYPE REF TO zif_abapgit_default_transport
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS get_environment
      RETURNING
        VALUE(ri_environment) TYPE REF TO zif_abapgit_environment.
    CLASS-METHODS get_longtexts
      RETURNING
        VALUE(ri_longtexts) TYPE REF TO zif_abapgit_longtexts.
    CLASS-METHODS get_frontend_services
      RETURNING
        VALUE(ri_fe_serv) TYPE REF TO zif_abapgit_frontend_services.
    CLASS-METHODS get_lxe_texts
      RETURNING
        VALUE(ri_lxe_texts) TYPE REF TO zif_abapgit_lxe_texts.
    CLASS-METHODS get_sap_namespace
      RETURNING
        VALUE(ri_namespace) TYPE REF TO zif_abapgit_sap_namespace.
    CLASS-METHODS get_sap_report
      RETURNING
        VALUE(ri_report) TYPE REF TO zif_abapgit_sap_report.
    CLASS-METHODS get_function_module
      RETURNING
        VALUE(ri_function_module) TYPE REF TO zif_abapgit_function_module.
  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_sap_package,
        package  TYPE devclass,
        instance TYPE REF TO zif_abapgit_sap_package,
      END OF ty_sap_package.
    TYPES:
      ty_sap_packages TYPE HASHED TABLE OF ty_sap_package
                                          WITH UNIQUE KEY package.

    CLASS-DATA gi_tadir TYPE REF TO zif_abapgit_tadir.
    CLASS-DATA gt_sap_package TYPE ty_sap_packages.
    CLASS-DATA gi_cts_api TYPE REF TO zif_abapgit_cts_api.
    CLASS-DATA gi_environment TYPE REF TO zif_abapgit_environment.
    CLASS-DATA gi_longtext TYPE REF TO zif_abapgit_longtexts.
    CLASS-DATA gi_fe_serv TYPE REF TO zcl_abapgit_frontend_services.
    CLASS-DATA gi_lxe_texts TYPE REF TO zif_abapgit_lxe_texts.
    CLASS-DATA gi_gui_jumper TYPE REF TO zif_abapgit_gui_jumper ##NEEDED.
    CLASS-DATA gi_sap_namespace TYPE REF TO zif_abapgit_sap_namespace.
    CLASS-DATA gi_sap_report TYPE REF TO zif_abapgit_sap_report.
    CLASS-DATA gi_function_module TYPE REF TO zif_abapgit_function_module.
    CLASS-DATA gi_default_transport TYPE REF TO zif_abapgit_default_transport .
ENDCLASS.

CLASS zcl_abapinst_file DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    CLASS-METHODS load_internet
      IMPORTING
        !iv_url            TYPE string
        !iv_user           TYPE string
        !iv_password       TYPE string
        !iv_proxy_host     TYPE string
        !iv_proxy_port     TYPE string
        !iv_proxy_user     TYPE string
        !iv_proxy_password TYPE string
      RETURNING
        VALUE(rv_file)     TYPE xstring
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS load_local
      IMPORTING
        !iv_filename   TYPE csequence
      RETURNING
        VALUE(rv_file) TYPE xstring
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS load_server
      IMPORTING
        !iv_filename   TYPE csequence
      RETURNING
        VALUE(rv_file) TYPE xstring
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS virus_scan
      IMPORTING
        !iv_data TYPE xstring
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS unzip
      IMPORTING
        !iv_xstr        TYPE xstring
      RETURNING
        VALUE(rt_files) TYPE zif_abapgit_git_definitions=>ty_files_tt
      RAISING
        zcx_abapinst_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-METHODS _filename
      IMPORTING
        !iv_str      TYPE string
      EXPORTING
        !ev_path     TYPE string
        !ev_filename TYPE string
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _normalize_path
      CHANGING
        !ct_files TYPE zif_abapgit_git_definitions=>ty_files_tt
      RAISING
        zcx_abapinst_exception.

ENDCLASS.

CLASS zcl_abapinst_popups DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_alv_column,
        name   TYPE string,
        text   TYPE string,
        length TYPE lvc_outlen,
        key    TYPE abap_bool,
      END OF ty_alv_column,
      ty_alv_column_tt TYPE STANDARD TABLE OF ty_alv_column WITH KEY name.

    CONSTANTS c_default_column TYPE lvc_fname VALUE `DEFAULT_COLUMN` ##NO_TEXT.

    METHODS popup_to_enter_packaging
      IMPORTING
        !iv_name            TYPE csequence OPTIONAL
        !iv_version         TYPE csequence OPTIONAL
      RETURNING
        VALUE(rs_packaging) TYPE zif_abapinst_dot_abapgit=>ty_packaging
      RAISING
        zcx_abapinst_exception.

    METHODS popup_to_confirm
      IMPORTING
        !iv_title                 TYPE csequence
        !iv_question              TYPE csequence
        !iv_text_button_1         TYPE csequence DEFAULT 'Yes'
        !iv_icon_button_1         TYPE icon-name DEFAULT space
        !iv_text_button_2         TYPE csequence DEFAULT 'No'
        !iv_icon_button_2         TYPE icon-name DEFAULT space
        !iv_default_button        TYPE sy-input DEFAULT '1'
        !iv_display_cancel_button TYPE sy-input DEFAULT abap_true
      RETURNING
        VALUE(rv_answer)          TYPE sy-input
      RAISING
        zcx_abapinst_exception.

    METHODS popup_to_select_from_list
      IMPORTING
        !it_list               TYPE STANDARD TABLE
        !iv_title              TYPE lvc_title DEFAULT space
        !iv_header_text        TYPE csequence DEFAULT space
        !iv_start_column       TYPE i DEFAULT 2
        !iv_end_column         TYPE i DEFAULT 65
        !iv_start_line         TYPE i DEFAULT 8
        !iv_end_line           TYPE i DEFAULT 20
        !iv_striped_pattern    TYPE abap_bool DEFAULT abap_false
        !iv_optimize_col_width TYPE abap_bool DEFAULT abap_true
        !iv_selection_mode     TYPE salv_de_constant DEFAULT if_salv_c_selection_mode=>multiple
        !iv_select_column_text TYPE csequence DEFAULT space
        !it_columns_to_display TYPE ty_alv_column_tt
      EXPORTING
        VALUE(et_list)         TYPE STANDARD TABLE
      RAISING
        zcx_abapinst_exception.

    TYPES:
      BEGIN OF ty_popup_position,
        start_column LIKE  sy-cucol,
        start_row    LIKE  sy-curow,
        end_column   LIKE  sy-cucol,
        end_row      LIKE  sy-curow,
      END OF ty_popup_position.

    CLASS-METHODS center
      IMPORTING
        !iv_width          TYPE i
        !iv_height         TYPE i
      RETURNING
        VALUE(rs_position) TYPE ty_popup_position.
  PROTECTED SECTION.
  PRIVATE SECTION.

    CONSTANTS c_fieldname_selected TYPE lvc_fname VALUE `SELECTED` ##NO_TEXT.

    DATA:
      mo_select_list_popup TYPE REF TO cl_salv_table,
      mr_table             TYPE REF TO data,
      mv_cancel            TYPE abap_bool VALUE abap_false,
      mo_table_descr       TYPE REF TO cl_abap_tabledescr.

    METHODS _create_new_table
      IMPORTING
        !it_list TYPE STANDARD TABLE.

    METHODS _get_selected_rows
      EXPORTING
        !et_list TYPE INDEX TABLE.

    METHODS _on_select_list_link_click
      FOR EVENT link_click OF cl_salv_events_table
      IMPORTING
        !row
        !column.

    METHODS _on_select_list_function_click
      FOR EVENT added_function OF cl_salv_events_table
      IMPORTING
        !e_salv_function.

    METHODS _on_double_click
      FOR EVENT double_click OF cl_salv_events_table
      IMPORTING
        !row
        !column.

ENDCLASS.

CLASS zcl_tar DEFINITION

  CREATE PRIVATE.

************************************************************************
* Tar
*
* Tar UStar and Pax Formats
*
* Based on
* https://en.wikipedia.org/wiki/Tar_(computing)
* https://en.wikipedia.org/wiki/Gzip
* https://en.wikipedia.org/wiki/Pax_(command)
* https://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html
*
* Note: Supports reading 7-zip tar files with long links but does not
* support writing such files.
*
* Copyright 2024 apm.to Inc. <https://apm.to>
* SPDX-License-Identifier: MIT
************************************************************************
* Limitation: Block size is hardcoded to 512 bytes
************************************************************************
* Performance note: Do not use && to concatenate xstring since it
* converts to string implicitly. Use CONCATENATE ... IN BYTE MODE.
************************************************************************

  PUBLIC SECTION.

    CONSTANTS c_version TYPE string VALUE '2.0.1' ##NEEDED.

    CONSTANTS c_blocksize TYPE i VALUE 512.

    TYPES:
      ty_typeflag TYPE c LENGTH 1,
      BEGIN OF ty_keyword,
        keyword TYPE string,
        value   TYPE string,
      END OF ty_keyword,
      ty_keywords TYPE STANDARD TABLE OF ty_keyword WITH KEY keyword,
      BEGIN OF ty_file,
        name     TYPE string,
        date     TYPE d,
        time     TYPE t,
        mode     TYPE i,
        unixtime TYPE i,
        size     TYPE i,
        typeflag TYPE ty_typeflag,
        content  TYPE xstring,
        keywords TYPE ty_keywords,
      END OF ty_file,
      ty_tar_files TYPE STANDARD TABLE OF ty_file WITH KEY name.

    TYPES:
      "! Ustar header record (512 bytes)
      BEGIN OF ty_header,
        name     TYPE c LENGTH 100, " Offset 0
        mode     TYPE c LENGTH 8,   " 100
        uid      TYPE c LENGTH 8,   " 108
        gid      TYPE c LENGTH 8,   " 116
        size     TYPE c LENGTH 12,  " 124
        mtime    TYPE c LENGTH 12,  " 136
        chksum   TYPE c LENGTH 8,   " 148
        typeflag TYPE c LENGTH 1,   " 156
        linkname TYPE c LENGTH 100, " 157
        magic    TYPE c LENGTH 6,   " 257
        version  TYPE c LENGTH 2,   " 263
        uname    TYPE c LENGTH 32,  " 265
        gname    TYPE c LENGTH 32,  " 297
        devmajor TYPE c LENGTH 8,   " 329
        devminor TYPE c LENGTH 8,   " 337
        prefix   TYPE c LENGTH 155, " 345
        padding  TYPE c LENGTH 12,  " 500
      END OF ty_header.

    CONSTANTS:
      BEGIN OF c_typeflag,
        file              TYPE ty_typeflag VALUE '0',
        hard_link         TYPE ty_typeflag VALUE '1',
        symbolic_link     TYPE ty_typeflag VALUE '2',
        character_special TYPE ty_typeflag VALUE '3',
        block_special     TYPE ty_typeflag VALUE '4',
        directory         TYPE ty_typeflag VALUE '5',
        fifo              TYPE ty_typeflag VALUE '6',
        contiguous_file   TYPE ty_typeflag VALUE '7',
        long_link         TYPE ty_typeflag VALUE 'L', " 7-zip
        global_header     TYPE ty_typeflag VALUE 'g', " pax
        extended_header   TYPE ty_typeflag VALUE 'x', " pax
      END OF c_typeflag.

    CLASS-METHODS class_constructor.

    "! Create archive
    CLASS-METHODS new
      IMPORTING
        !force_ustar  TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(result) TYPE REF TO zcl_tar.

    METHODS constructor
      IMPORTING
        !force_ustar TYPE abap_bool.

    "! Load archive
    METHODS load
      IMPORTING
        !tar          TYPE xstring
      RETURNING
        VALUE(result) TYPE REF TO zcl_tar
      RAISING
        zcx_error.

    "! Create archive
    METHODS save
      RETURNING
        VALUE(result) TYPE xstring
      RAISING
        zcx_error.

    "! Read file from archive
    METHODS get
      IMPORTING
        !name         TYPE csequence
      RETURNING
        VALUE(result) TYPE xstring
      RAISING
        zcx_error.

    "! List the table of contents of an archive (no data)
    METHODS list
      RETURNING
        VALUE(result) TYPE ty_tar_files
      RAISING
        zcx_error.

    "! Number of files in archive
    METHODS file_count
      RETURNING
        VALUE(result) TYPE i
      RAISING
        zcx_error.

    "! Total size of unpackage files in bytes
    METHODS unpacked_size
      RETURNING
        VALUE(result) TYPE i
      RAISING
        zcx_error.

    "! Append file to archive
    METHODS append
      IMPORTING
        !name         TYPE csequence
        !content      TYPE xsequence
        !date         TYPE d OPTIONAL
        !time         TYPE t OPTIONAL
        !mode         TYPE i OPTIONAL
        !typeflag     TYPE c OPTIONAL
        !keywords     TYPE ty_keywords OPTIONAL " pax
      RETURNING
        VALUE(result) TYPE REF TO zcl_tar
      RAISING
        zcx_error.

    "! Delete file from archive
    METHODS delete
      IMPORTING
        !name         TYPE csequence
      RETURNING
        VALUE(result) TYPE REF TO zcl_tar
      RAISING
        zcx_error.

    "! Gzip archive
    METHODS gzip
      IMPORTING
        !tar          TYPE xstring
      RETURNING
        VALUE(result) TYPE xstring
      RAISING
        zcx_error.

    "! Gunzip archive
    METHODS gunzip
      IMPORTING
        !gzip         TYPE xstring
      RETURNING
        VALUE(result) TYPE xstring
      RAISING
        zcx_error.

  PROTECTED SECTION.
  PRIVATE SECTION.

    CONSTANTS:
      c_ustar_magic   TYPE c LENGTH 5 VALUE 'ustar',
      c_ustar_version TYPE c LENGTH 2 VALUE '00',
      c_mode_default  TYPE i VALUE 436, " octal 664 rw-rw-r--
      c_path_sep      TYPE c VALUE '/', " unix
      c_epoch         TYPE timestamp VALUE '19700101000000'.

    TYPES:
      BEGIN OF ty_tar_item,
        name    TYPE string,
        content TYPE xstring,
      END OF ty_tar_item,
      ty_tar_data TYPE HASHED TABLE OF ty_tar_item WITH UNIQUE KEY name.

    TYPES ty_block TYPE x LENGTH c_blocksize.

    CLASS-DATA null TYPE c LENGTH 256.

    DATA:
      force_ustar TYPE abap_bool,
      tar_files   TYPE ty_tar_files,
      tar_data    TYPE ty_tar_data.

    CLASS-METHODS _append_nulls
      CHANGING
        !data TYPE simple.

    CLASS-METHODS _remove_nulls
      CHANGING
        !data TYPE simple.

    CLASS-METHODS _pad
      IMPORTING
        !number       TYPE numeric
        !length       TYPE i
      RETURNING
        VALUE(result) TYPE string.

    CLASS-METHODS _unpad
      IMPORTING
        !data         TYPE csequence
      RETURNING
        VALUE(result) TYPE i.

    CLASS-METHODS _from_octal
      IMPORTING
        !octal        TYPE string
      RETURNING
        VALUE(result) TYPE i.

    CLASS-METHODS _to_octal
      IMPORTING
        !number       TYPE numeric
      RETURNING
        VALUE(result) TYPE string.

    CLASS-METHODS _from_xstring
      IMPORTING
        !data         TYPE xstring
      RETURNING
        VALUE(result) TYPE string
      RAISING
        zcx_error.

    CLASS-METHODS _to_xstring
      IMPORTING
        !data         TYPE simple
      RETURNING
        VALUE(result) TYPE xstring
      RAISING
        zcx_error.

    CLASS-METHODS _from_filename
      IMPORTING
        !filename TYPE string
      EXPORTING
        !prefix   TYPE ty_header-prefix
        !name     TYPE ty_header-name
      RAISING
        zcx_error.

    CLASS-METHODS _to_filename
      IMPORTING
        !prefix       TYPE ty_header-prefix
        !name         TYPE ty_header-name
      RETURNING
        VALUE(result) TYPE string.

    CLASS-METHODS _from_unixtime
      IMPORTING
        !unixtime TYPE i
      EXPORTING
        !date     TYPE d
        !time     TYPE t
      RAISING
        zcx_error.

    CLASS-METHODS _to_unixtime
      IMPORTING
        !date         TYPE d
        !time         TYPE t
      RETURNING
        VALUE(result) TYPE i
      RAISING
        zcx_error.

    CLASS-METHODS _checksum
      IMPORTING
        !data         TYPE any
      RETURNING
        VALUE(result) TYPE i
      RAISING
        zcx_error.

ENDCLASS.

CLASS zcl_abapinst_installer DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    CONSTANTS:
      BEGIN OF c_enum_zip,
        local    TYPE i VALUE 0,
        internet TYPE i VALUE 1,
        server   TYPE i VALUE 2,
        data     TYPE i VALUE 3,
        registry TYPE i VALUE 4,
      END OF c_enum_zip,
      BEGIN OF c_enum_package,
        default       TYPE i VALUE 0,
        local         TYPE i VALUE 1,
        transportable TYPE i VALUE 2,
      END OF c_enum_package,
      BEGIN OF c_enum_transport,
        prompt   TYPE i VALUE 0,
        existing TYPE i VALUE 1,
      END OF c_enum_transport,
      BEGIN OF c_enum_folder_logic,
        default TYPE i VALUE 0,
        prefix  TYPE i VALUE 1,
        mixed   TYPE i VALUE 2,
        full    TYPE i VALUE 3,
      END OF c_enum_folder_logic.

    CLASS-METHODS init
      IMPORTING
        !iv_tabname TYPE tabname OPTIONAL
        !iv_lock    TYPE viewname OPTIONAL
        !iv_name    TYPE string OPTIONAL
        !iv_names   TYPE string OPTIONAL.

    CLASS-METHODS install
      IMPORTING
        !iv_apm_name          TYPE string OPTIONAL
        !iv_apm_version       TYPE string OPTIONAL
        !iv_enum_zip          TYPE i OPTIONAL
        !iv_name              TYPE char255 OPTIONAL
        !iv_data              TYPE xstring OPTIONAL
        !iv_enum_package      TYPE i OPTIONAL
        !iv_package           TYPE devclass OPTIONAL
        !iv_dlvunit           TYPE dlvunit OPTIONAL
        !iv_devlayer          TYPE devlayer OPTIONAL
        !iv_enum_transport    TYPE i OPTIONAL
        !iv_transport         TYPE trkorr OPTIONAL
        !iv_user              TYPE char255 OPTIONAL
        !iv_password          TYPE char255 OPTIONAL
        !iv_proxy_host        TYPE char255 OPTIONAL
        !iv_proxy_service     TYPE char5 OPTIONAL
        !iv_proxy_user        TYPE char255 OPTIONAL
        !iv_proxy_password    TYPE char255 OPTIONAL
        !iv_enum_folder_logic TYPE i OPTIONAL
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS uninstall
      IMPORTING
        !iv_apm  TYPE abap_bool DEFAULT abap_false
        !iv_name TYPE zif_abapinst_definitions=>ty_name OPTIONAL
        !iv_pack TYPE zif_abapinst_definitions=>ty_pack OPTIONAL
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS list
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS f4
      RETURNING
        VALUE(rs_inst) TYPE zif_abapinst_definitions=>ty_inst
      RAISING
        zcx_abapinst_exception.
  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA:
      BEGIN OF gs_apm,
        name    TYPE string,
        version TYPE string,
      END OF gs_apm,
      go_db           TYPE REF TO zcl_abapinst_persistence,
      gt_remote       TYPE zif_abapgit_git_definitions=>ty_files_tt,
      gs_inst         TYPE zif_abapinst_definitions=>ty_inst,
      go_dot          TYPE REF TO zcl_abapgit_dot_abapgit,
      gi_log          TYPE REF TO zif_abapgit_log,
      gs_packaging    TYPE zif_abapinst_dot_abapgit=>ty_packaging,
      gt_requirements TYPE zif_abapgit_dot_abapgit=>ty_requirement_tt,
      gv_name         TYPE string,
      gv_names        TYPE string,
      gt_clmcus       TYPE STANDARD TABLE OF clmcus WITH DEFAULT KEY.

    CONSTANTS:
      c_success TYPE sy-msgty VALUE 'S' ##NO_TEXT,
      c_warning TYPE sy-msgty VALUE 'W' ##NO_TEXT,
      c_error   TYPE sy-msgty VALUE 'E' ##NO_TEXT.

    CLASS-METHODS _system_check
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _clear.

    CLASS-METHODS _nothing_found
      IMPORTING
        !it_list         TYPE ANY TABLE
      RETURNING
        VALUE(rv_result) TYPE abap_bool.

    CLASS-METHODS _files
      IMPORTING
        !iv_enum_zip       TYPE i
        !iv_name           TYPE char255 OPTIONAL
        !iv_data           TYPE xstring OPTIONAL
        !iv_user           TYPE char255 OPTIONAL
        !iv_password       TYPE char255 OPTIONAL
        !iv_proxy_host     TYPE char255 OPTIONAL
        !iv_proxy_service  TYPE char5 OPTIONAL
        !iv_proxy_user     TYPE char255 OPTIONAL
        !iv_proxy_password TYPE char255 OPTIONAL
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _packaging
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _sap_package
      IMPORTING
        !iv_enum_package TYPE i
        !iv_package      TYPE devclass OPTIONAL
        !iv_dlvunit      TYPE dlvunit OPTIONAL
        !iv_devlayer     TYPE devlayer OPTIONAL
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _check
      IMPORTING
        !iv_force TYPE abap_bool DEFAULT abap_false
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _check_version
      IMPORTING
        !is_new_version       TYPE zif_abapinst_definitions=>ty_version
        !is_installed_version TYPE zif_abapinst_definitions=>ty_version
        !iv_force             TYPE abap_bool DEFAULT abap_false
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _check_requirements
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _check_dependencies
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _folder_logic
      IMPORTING
        !iv_enum_folder_logic TYPE i
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _transport
      IMPORTING
        !iv_enum_transport TYPE i
        !iv_transport      TYPE trkorr OPTIONAL
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _transport_get
      RETURNING
        VALUE(rv_trkorr) TYPE trkorr
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _transport_check
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _transport_reset.

    CLASS-METHODS _namespaces
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _confirm_messages.

    CLASS-METHODS _restore_messages.

    CLASS-METHODS _deserialize_objects
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS _deserialize_data
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS _save
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _load
      IMPORTING
        !iv_name       TYPE zif_abapinst_definitions=>ty_name OPTIONAL
        !iv_pack       TYPE zif_abapinst_definitions=>ty_pack OPTIONAL
      RETURNING
        VALUE(rs_inst) TYPE zif_abapinst_definitions=>ty_inst
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _delete
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _log_start.

    CLASS-METHODS _log_end
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _final_message
      IMPORTING
        !iv_type TYPE string.

    CLASS-METHODS _find_remote_dot_abapgit
      IMPORTING
        !it_remote    TYPE zif_abapgit_git_definitions=>ty_files_tt
      RETURNING
        VALUE(ro_dot) TYPE REF TO zcl_abapgit_dot_abapgit
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _find_remote_dot_apack
      IMPORTING
        !it_remote    TYPE zif_abapgit_git_definitions=>ty_files_tt
      RETURNING
        VALUE(ro_dot) TYPE REF TO zcl_abapgit_dot_abapgit
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _find_remote_namespaces
      RETURNING
        VALUE(rt_remote) TYPE zif_abapgit_git_definitions=>ty_files_tt.

    CLASS-METHODS _find_remote_data_config
      RETURNING
        VALUE(ri_config) TYPE REF TO zif_abapgit_data_config
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS _check_uninstalled
      IMPORTING
        !it_tadir TYPE zif_abapgit_definitions=>ty_tadir_tt.

    CLASS-METHODS _uninstall_sotr
      IMPORTING
        !it_tadir TYPE zif_abapgit_definitions=>ty_tadir_tt.

    CLASS-METHODS _uninstall_sots
      IMPORTING
        !it_tadir TYPE zif_abapgit_definitions=>ty_tadir_tt.

ENDCLASS.

CLASS zcl_abapinst_log_viewer DEFINITION

  FINAL
  CREATE PUBLIC .

  " This is a replacement for ZCL_ABAPGIT_LOG_VIEWER
  "
  " Using ZCL_ABAPGIT_OBJECTS would drag in other dependencies
  " which are completely unnecessary for abapinst (like the abapGit UI layer).

  PUBLIC SECTION.

    CLASS-METHODS show_log
      IMPORTING
        !ii_log TYPE REF TO zif_abapgit_log .
  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_log_out,
        type      TYPE icon_d,
        msg       TYPE string,
        obj_type  TYPE trobjtype,
        obj_name  TYPE sobj_name,
        exception TYPE REF TO cx_root,
        longtext  TYPE icon_d,
        t100      TYPE icon_d,
        source    TYPE icon_d,
        callstack TYPE icon_d,
        cell_type TYPE salv_t_int4_column,
      END OF ty_log_out .
    TYPES:
      ty_log_outs TYPE STANDARD TABLE OF ty_log_out
                                  WITH NON-UNIQUE DEFAULT KEY .

    CLASS-DATA gt_log TYPE ty_log_outs .

    CLASS-METHODS prepare_log_for_display
      IMPORTING
        !ii_log           TYPE REF TO zif_abapgit_log
      RETURNING
        VALUE(rt_log_out) TYPE ty_log_outs .
    CLASS-METHODS show_longtext
      IMPORTING
        !is_log TYPE ty_log_out
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS on_link_click
        FOR EVENT link_click OF cl_salv_events_table
      IMPORTING
        !row
        !column .
    CLASS-METHODS dispatch
      IMPORTING
        !is_log    TYPE ty_log_out
        !iv_column TYPE salv_de_column
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS calculate_cell_type .
ENDCLASS.

CLASS zcl_abapinst_objects DEFINITION

  CREATE PUBLIC .

  " This is a replacement for ZCL_ABAPGIT_OBJECTS
  "
  " Using ZCL_ABAPGIT_OBJECTS would drag in many other dependencies
  " which are completely unnecessary for abapinst (like the abapGit repo layer).
  "
  " The serialize logic has been removed as well since the complete abapGit package
  " is being deployed. This simplifies a lot but could be added back in case a
  " delta logic is required.
  PUBLIC SECTION.

    TYPES:
      ty_types_tt TYPE SORTED TABLE OF tadir-object WITH UNIQUE KEY table_line .

    CLASS-METHODS deserialize
      IMPORTING
        !iv_package              TYPE devclass
        !iv_language             TYPE spras ##NEEDED
        !iv_transport            TYPE trkorr OPTIONAL
        !it_local                TYPE zif_abapgit_definitions=>ty_files_item_tt OPTIONAL
        !it_local_checksums      TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt OPTIONAL
        !it_remote               TYPE zif_abapgit_git_definitions=>ty_files_tt
        !io_dot                  TYPE REF TO zcl_abapgit_dot_abapgit
        !ii_log                  TYPE REF TO zif_abapgit_log
      RETURNING
        VALUE(rt_accessed_files) TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS delete
      IMPORTING
        !it_tadir     TYPE zif_abapgit_definitions=>ty_tadir_tt
        !iv_transport TYPE trkorr OPTIONAL
        !ii_log       TYPE REF TO zif_abapgit_log
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS is_supported
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !iv_native_only TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(rv_bool)  TYPE abap_bool .
    CLASS-METHODS is_type_supported
      IMPORTING
        !iv_obj_type   TYPE zif_abapgit_definitions=>ty_item-obj_type
      RETURNING
        VALUE(rv_bool) TYPE abap_bool .
    CLASS-METHODS exists
      IMPORTING
        !is_item       TYPE zif_abapgit_definitions=>ty_item
      RETURNING
        VALUE(rv_bool) TYPE abap_bool .
    CLASS-METHODS supported_list
      RETURNING
        VALUE(rt_types) TYPE ty_types_tt .
    CLASS-METHODS is_active
      IMPORTING
        !is_item         TYPE zif_abapgit_definitions=>ty_item
      RETURNING
        VALUE(rv_active) TYPE abap_bool
      RAISING
        zcx_abapgit_exception .
  PROTECTED SECTION.

  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_supported_types,
        obj_type  TYPE tadir-object,
        supported TYPE abap_bool,
      END OF ty_supported_types.

    TYPES: ty_supported_types_tt TYPE SORTED TABLE OF ty_supported_types WITH UNIQUE KEY obj_type.

    TYPES:
      BEGIN OF ty_obj_serializer_item,
        item     TYPE zif_abapgit_definitions=>ty_item,
        metadata TYPE zif_abapgit_definitions=>ty_metadata,
      END OF ty_obj_serializer_item .
    TYPES:
      ty_obj_serializer_map TYPE SORTED TABLE OF ty_obj_serializer_item WITH UNIQUE KEY item .

    CLASS-DATA gt_obj_serializer_map TYPE ty_obj_serializer_map .
    CLASS-DATA gt_supported_obj_types TYPE ty_supported_types_tt .
    CLASS-DATA gv_supported_obj_types_loaded TYPE abap_bool .

    CLASS-METHODS files_to_deserialize
      IMPORTING
        !iv_package         TYPE devclass
        !it_local           TYPE zif_abapgit_definitions=>ty_files_item_tt
        !it_local_checksums TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt
        !it_remote          TYPE zif_abapgit_git_definitions=>ty_files_tt
        !io_dot             TYPE REF TO zcl_abapgit_dot_abapgit
        !ii_log             TYPE REF TO zif_abapgit_log OPTIONAL
      RETURNING
        VALUE(rt_results)   TYPE zif_abapgit_definitions=>ty_results_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS prioritize_deser
      IMPORTING
        !ii_log           TYPE REF TO zif_abapgit_log OPTIONAL
        !it_results       TYPE zif_abapgit_definitions=>ty_results_tt
      RETURNING
        VALUE(rt_results) TYPE zif_abapgit_definitions=>ty_results_tt .
    CLASS-METHODS class_name
      IMPORTING
        !is_item             TYPE zif_abapgit_definitions=>ty_item
      RETURNING
        VALUE(rv_class_name) TYPE string .
    CLASS-METHODS update_package_tree
      IMPORTING
        !iv_package TYPE devclass .
    CLASS-METHODS delete_object
      IMPORTING
        !iv_package   TYPE devclass
        !is_item      TYPE zif_abapgit_definitions=>ty_item
        !iv_transport TYPE trkorr
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS compare_remote_to_local
      IMPORTING
        !ii_object TYPE REF TO zif_abapgit_object
        !it_remote TYPE zif_abapgit_git_definitions=>ty_files_tt
        !is_result TYPE zif_abapgit_definitions=>ty_result
        !ii_log    TYPE REF TO zif_abapgit_log
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS deserialize_steps
      IMPORTING
        !it_steps     TYPE zif_abapgit_objects=>ty_step_data_tt
        !ii_log       TYPE REF TO zif_abapgit_log
        !iv_transport TYPE trkorr
      CHANGING
        !ct_files     TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS deserialize_step
      IMPORTING
        !is_step      TYPE zif_abapgit_objects=>ty_step_data
        !ii_log       TYPE REF TO zif_abapgit_log
        !iv_transport TYPE trkorr
      CHANGING
        !ct_files     TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS check_objects_locked
      IMPORTING
        !it_items TYPE zif_abapgit_definitions=>ty_items_tt
      RAISING
        zcx_abapgit_exception .

    CLASS-METHODS create_object
      IMPORTING
        !is_item        TYPE zif_abapgit_definitions=>ty_item
        !io_files       TYPE REF TO zcl_abapgit_objects_files OPTIONAL
        !io_i18n_params TYPE REF TO zcl_abapgit_i18n_params OPTIONAL
        !is_metadata    TYPE zif_abapgit_definitions=>ty_metadata OPTIONAL
        !iv_native_only TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(ri_obj)   TYPE REF TO zif_abapgit_object
      RAISING
        zcx_abapgit_exception .

    CLASS-METHODS map_tadir_to_items
      IMPORTING
        !it_tadir       TYPE zif_abapgit_definitions=>ty_tadir_tt
      RETURNING
        VALUE(rt_items) TYPE zif_abapgit_definitions=>ty_items_tt .
    CLASS-METHODS map_results_to_items
      IMPORTING
        !it_results     TYPE zif_abapgit_definitions=>ty_results_tt
      RETURNING
        VALUE(rt_items) TYPE zif_abapgit_definitions=>ty_items_tt .
    CLASS-METHODS filter_files_to_deserialize
      IMPORTING
        !it_results       TYPE zif_abapgit_definitions=>ty_results_tt
        !ii_log           TYPE REF TO zif_abapgit_log OPTIONAL
      RETURNING
        VALUE(rt_results) TYPE zif_abapgit_definitions=>ty_results_tt .
    CLASS-METHODS get_deserialize_steps
      RETURNING
        VALUE(rt_steps) TYPE zif_abapgit_objects=>ty_step_data_tt .
    CLASS-METHODS check_main_package
      IMPORTING
        !iv_package  TYPE devclass
        !iv_obj_type TYPE tadir-object
      RAISING
        zcx_abapgit_exception .
    CLASS-METHODS change_package_assignments
      IMPORTING
        !is_item TYPE zif_abapgit_definitions=>ty_item
        !ii_log  TYPE REF TO zif_abapgit_log .
    CLASS-METHODS determine_i18n_params
      IMPORTING
        !io_dot                TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_main_language_only TYPE abap_bool
      RETURNING
        VALUE(rs_i18n_params)  TYPE zif_abapgit_definitions=>ty_i18n_params
      RAISING
        zcx_abapgit_exception.
    CLASS-METHODS get_extra_from_filename
      IMPORTING
        !iv_filename    TYPE string
      RETURNING
        VALUE(rv_extra) TYPE string.
ENDCLASS.

CLASS zcl_abapinst_persistence DEFINITION

  CREATE PUBLIC.

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !iv_tabname TYPE tabname DEFAULT zif_abapinst_definitions=>c_tabname
        !iv_lock    TYPE viewname DEFAULT zif_abapinst_definitions=>c_lock.

    CLASS-METHODS get_instance
      IMPORTING
        !iv_tabname  TYPE tabname DEFAULT zif_abapinst_definitions=>c_tabname
        !iv_lock     TYPE viewname DEFAULT zif_abapinst_definitions=>c_lock
      RETURNING
        VALUE(ro_db) TYPE REF TO zcl_abapinst_persistence.

    METHODS select
      IMPORTING
        !iv_name       TYPE zif_abapinst_definitions=>ty_name
        !iv_pack       TYPE zif_abapinst_definitions=>ty_pack
      RETURNING
        VALUE(rs_inst) TYPE zif_abapinst_definitions=>ty_inst
      RAISING
        zcx_abapinst_exception.

    METHODS insert
      IMPORTING
        !is_inst TYPE zif_abapinst_definitions=>ty_inst
      RAISING
        zcx_abapinst_exception ##SHADOW[INSERT].

    METHODS update
      IMPORTING
        !is_inst TYPE zif_abapinst_definitions=>ty_inst
      RAISING
        zcx_abapinst_exception.

    METHODS delete
      IMPORTING
        !iv_name TYPE zif_abapinst_definitions=>ty_name
        !iv_pack TYPE zif_abapinst_definitions=>ty_pack
      RAISING
        zcx_abapinst_exception.

    METHODS last
      RETURNING
        VALUE(rs_inst) TYPE zif_abapinst_definitions=>ty_inst
      RAISING
        zcx_abapinst_exception.

    METHODS list
      RETURNING
        VALUE(rt_list) TYPE zif_abapinst_definitions=>ty_list
      RAISING
        zcx_abapinst_exception.

    METHODS list_by_name
      IMPORTING
        !iv_name       TYPE zif_abapinst_definitions=>ty_name
        !iv_pack       TYPE zif_abapinst_definitions=>ty_pack OPTIONAL
      RETURNING
        VALUE(rt_list) TYPE zif_abapinst_definitions=>ty_list
      RAISING
        zcx_abapinst_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA go_db TYPE REF TO zcl_abapinst_persistence.

    DATA:
      mv_update_function TYPE funcname,
      mv_tabname         TYPE tabname,
      mv_lock            TYPE viewname.

    METHODS _update_function
      RETURNING
        VALUE(rv_funcname) TYPE funcname.

    METHODS _content_to_list
      IMPORTING
        !it_content    TYPE zif_abapinst_definitions=>ty_contents
      RETURNING
        VALUE(rt_list) TYPE zif_abapinst_definitions=>ty_list
      RAISING
        zcx_abapinst_exception.

    METHODS _content_to_inst
      IMPORTING
        !is_content    TYPE zif_abapinst_definitions=>ty_content
      RETURNING
        VALUE(rs_inst) TYPE zif_abapinst_definitions=>ty_inst
      RAISING
        zcx_abapinst_exception.

    METHODS _list_to_content
      IMPORTING
        !is_inst          TYPE zif_abapinst_definitions=>ty_inst
      RETURNING
        VALUE(rs_content) TYPE zif_abapinst_definitions=>ty_content
      RAISING
        zcx_abapinst_exception.

    METHODS _lock
      IMPORTING
        !iv_name TYPE zif_abapinst_definitions=>ty_name
        !iv_pack TYPE zif_abapinst_definitions=>ty_pack
        !iv_mode TYPE enqmode DEFAULT 'E'
      RAISING
        zcx_abapinst_exception.

ENDCLASS.

CLASS zcl_abapinst_repo_status DEFINITION

  FINAL
  CREATE PRIVATE .

  PUBLIC SECTION.

    CLASS-METHODS calculate
      IMPORTING
        !iv_package         TYPE devclass
        !it_local           TYPE zif_abapgit_definitions=>ty_files_item_tt
        !it_local_checksums TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt
        !it_remote          TYPE zif_abapgit_git_definitions=>ty_files_tt
        !io_dot             TYPE REF TO zcl_abapgit_dot_abapgit
        !ii_log             TYPE REF TO zif_abapgit_log OPTIONAL
      RETURNING
        VALUE(rt_results)   TYPE zif_abapgit_definitions=>ty_results_tt
      RAISING
        zcx_abapgit_exception.

    METHODS constructor
      IMPORTING
        !iv_root_package TYPE devclass
        !io_dot          TYPE REF TO zcl_abapgit_dot_abapgit.

  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA mv_root_package TYPE devclass.
    DATA mo_dot          TYPE REF TO zcl_abapgit_dot_abapgit.

    METHODS calculate_status
      IMPORTING
        !it_local         TYPE zif_abapgit_definitions=>ty_files_item_tt
        !it_remote        TYPE zif_abapgit_git_definitions=>ty_files_tt
        !it_cur_state     TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt
      RETURNING
        VALUE(rt_results) TYPE zif_abapgit_definitions=>ty_results_tt
      RAISING
        zcx_abapgit_exception.

    METHODS process_local
      IMPORTING
        !it_local     TYPE zif_abapgit_definitions=>ty_files_item_tt
        !it_state_idx TYPE zif_abapgit_git_definitions=>ty_file_signatures_ts
      CHANGING
        !ct_remote    TYPE zif_abapgit_git_definitions=>ty_files_tt
        !ct_items     TYPE zif_abapgit_definitions=>ty_items_tt
        !ct_results   TYPE zif_abapgit_definitions=>ty_results_tt
      RAISING
        zcx_abapgit_exception.

    METHODS process_items
      IMPORTING
        !it_unprocessed_remote TYPE zif_abapgit_git_definitions=>ty_files_tt
      CHANGING
        !ct_items              TYPE zif_abapgit_definitions=>ty_items_tt
      RAISING
        zcx_abapgit_exception.

    METHODS process_remote
      IMPORTING
        !it_local              TYPE zif_abapgit_definitions=>ty_files_item_tt
        !it_unprocessed_remote TYPE zif_abapgit_git_definitions=>ty_files_tt
        !it_state_idx          TYPE zif_abapgit_git_definitions=>ty_file_signatures_ts
        !it_items_idx          TYPE zif_abapgit_definitions=>ty_items_ts
      CHANGING
        !ct_results            TYPE zif_abapgit_definitions=>ty_results_tt
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS build_existing
      IMPORTING
        !is_local        TYPE zif_abapgit_definitions=>ty_file_item
        !is_remote       TYPE zif_abapgit_git_definitions=>ty_file
        !it_state        TYPE zif_abapgit_git_definitions=>ty_file_signatures_ts
      RETURNING
        VALUE(rs_result) TYPE zif_abapgit_definitions=>ty_result.

    CLASS-METHODS build_new_local
      IMPORTING
        !is_local        TYPE zif_abapgit_definitions=>ty_file_item
      RETURNING
        VALUE(rs_result) TYPE zif_abapgit_definitions=>ty_result.

    METHODS build_new_remote
      IMPORTING
        !is_remote       TYPE zif_abapgit_git_definitions=>ty_file
        !it_items_idx    TYPE zif_abapgit_definitions=>ty_items_ts
        !it_state_idx    TYPE zif_abapgit_git_definitions=>ty_file_signatures_ts
      RETURNING
        VALUE(rs_result) TYPE zif_abapgit_definitions=>ty_result
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS get_object_package
      IMPORTING
        !iv_object         TYPE tadir-object
        !iv_obj_name       TYPE tadir-obj_name
      RETURNING
        VALUE(rv_devclass) TYPE devclass
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS check_local_remote_consistency
      IMPORTING
        !is_local  TYPE zif_abapgit_definitions=>ty_file_item
        !is_remote TYPE zif_abapgit_git_definitions=>ty_file
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS ensure_state
      IMPORTING
        !it_local       TYPE zif_abapgit_definitions=>ty_files_item_tt
        !it_cur_state   TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt
      RETURNING
        VALUE(rt_state) TYPE zif_abapgit_git_definitions=>ty_file_signatures_tt.

ENDCLASS.

CLASS zcl_abapinst_requirements DEFINITION

  FINAL
  CREATE PUBLIC.

* Copy of zcl_abapgit_requirements_helper without UI component

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_requirement_status,
        met               TYPE abap_bool,
        component         TYPE tdevc-dlvunit,
        description       TYPE string,
        installed_release TYPE saprelease,
        installed_patch   TYPE sappatchlv,
        required_release  TYPE saprelease,
        required_patch    TYPE sappatchlv,
      END OF ty_requirement_status.
    TYPES:
      ty_requirement_status_tt TYPE STANDARD TABLE OF ty_requirement_status WITH DEFAULT KEY.

    CLASS-METHODS is_requirements_met
      IMPORTING
        !it_requirements TYPE zif_abapgit_dot_abapgit=>ty_requirement_tt
      RETURNING
        VALUE(rv_status) TYPE zif_abapgit_definitions=>ty_yes_no
      RAISING
        zcx_abapgit_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-METHODS get_requirement_met_status
      IMPORTING
        !it_requirements TYPE zif_abapgit_dot_abapgit=>ty_requirement_tt
      RETURNING
        VALUE(rt_status) TYPE ty_requirement_status_tt
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS version_greater_or_equal
      IMPORTING
        !is_status     TYPE ty_requirement_status
      RETURNING
        VALUE(rv_true) TYPE abap_bool.

ENDCLASS.

CLASS zcl_abapinst_screen DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    CLASS-METHODS modify
      IMPORTING
        !iv_options TYPE abap_bool
        !iv_zip_i   TYPE abap_bool
        !iv_zip_f   TYPE abap_bool
        !iv_zip_s   TYPE abap_bool
        !iv_sap_l   TYPE abap_bool
        !iv_sap_t   TYPE abap_bool
        !iv_tsp_e   TYPE abap_bool
        !iv_conn_o  TYPE abap_bool
        !iv_prox_o  TYPE abap_bool
        !iv_mbt     TYPE abap_bool DEFAULT abap_false.

    CLASS-METHODS header
      IMPORTING
        !iv_icon         TYPE icon_d
        !iv_text         TYPE clike
      RETURNING
        VALUE(rv_header) TYPE fieldname.

    CLASS-METHODS icon
      IMPORTING
        !iv_name       TYPE clike
        !iv_text       TYPE clike
        !iv_info       TYPE clike
      RETURNING
        VALUE(rv_icon) TYPE string.

    CLASS-METHODS copyright
      RETURNING
        VALUE(rv_copyright) TYPE string.

    CLASS-METHODS browser
      IMPORTING
        !iv_url TYPE csequence.

    CLASS-METHODS f4_file
      RETURNING
        VALUE(rv_file) TYPE char255.

    CLASS-METHODS f4_transport
      IMPORTING
        !iv_package         TYPE devclass
        !iv_layer           TYPE devlayer OPTIONAL
        !iv_transport       TYPE trkorr OPTIONAL
      RETURNING
        VALUE(rv_transport) TYPE trkorr.

    CLASS-METHODS banner
      IMPORTING
        !iv_show TYPE abap_bool DEFAULT abap_true
        !iv_id   TYPE csequence OPTIONAL
        !iv_top  TYPE i DEFAULT 4
        !iv_left TYPE i DEFAULT 20
        !it_base TYPE zif_abapinst_definitions=>ty_base_tab OPTIONAL.

    CLASS-METHODS default_layer
      RETURNING
        VALUE(rv_layer) TYPE devlayer.

  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES ty_url TYPE c LENGTH 255.

    CLASS-DATA:
      go_banner_dock TYPE REF TO cl_gui_docking_container,
      go_banner      TYPE REF TO cl_gui_picture,
      gv_banner_url  TYPE ty_url.

ENDCLASS.

CLASS zcl_abapinst_setup DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    CLASS-METHODS run
      IMPORTING
        !iv_tabname TYPE tabname DEFAULT zif_abapinst_definitions=>c_tabname
        !iv_lock    TYPE viewname DEFAULT zif_abapinst_definitions=>c_lock
        !iv_text    TYPE ddtext DEFAULT 'Generated by abapinst'
      RAISING
        zcx_abapinst_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.

    CLASS-DATA:
      gv_text    TYPE string VALUE 'Generated by abapInst' ##NO_TEXT,
      gv_tabname TYPE tabname,
      gv_lock    TYPE viewname.

    CLASS-METHODS _table_create
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _table_exists
      RETURNING
        VALUE(rv_exists) TYPE abap_bool.

    CLASS-METHODS _lock_create
      RAISING
        zcx_abapinst_exception.

    CLASS-METHODS _lock_exists
      RETURNING
        VALUE(rv_exists) TYPE abap_bool.

    CLASS-METHODS _get_package
      RETURNING
        VALUE(rv_package) TYPE devclass.

ENDCLASS.

CLASS zcl_abapinst_textpool DEFINITION

  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !iv_program TYPE progname.

    METHODS set
      IMPORTING
        !iv_param TYPE csequence.

    METHODS save.

  PROTECTED SECTION.
  PRIVATE SECTION.

    DATA:
      mv_program  TYPE progname,
      mt_text_old TYPE TABLE OF textpool,
      mt_text_new TYPE TABLE OF textpool.

    METHODS _load.

ENDCLASS.

CLASS zcl_abapgit_abap_language_vers IMPLEMENTATION.

  METHOD check_abap_language_version.

    " Check if ABAP language version matches repository setting
    IF is_item-abap_language_version IS NOT INITIAL AND iv_abap_language_version <> is_item-abap_language_version.
      zcx_abapgit_exception=>raise(
        |Object { is_item-obj_type } { is_item-obj_name } has { get_description( iv_abap_language_version ) }| &&
        | but repository is set to { get_description( is_item-abap_language_version ) }| ).
    ENDIF.

  ENDMETHOD.

  METHOD constructor.

    mo_dot_abapgit = io_dot_abapgit.

    IF zcl_abapgit_feature=>is_enabled( c_feature_flag ) = abap_false.
      mv_has_abap_language_vers = abap_undefined.
    ELSEIF get_abap_language_vers_by_repo( ) = zif_abapgit_dot_abapgit=>c_abap_language_version-undefined.
      mv_has_abap_language_vers = abap_undefined.
    ELSEIF get_abap_language_vers_by_repo( ) = zif_abapgit_dot_abapgit=>c_abap_language_version-ignore.
      mv_has_abap_language_vers = abap_false.
    ELSE.
      mv_has_abap_language_vers = abap_true.
    ENDIF.

  ENDMETHOD.

  METHOD get_abap_language_vers_by_devc.

    DATA lv_class TYPE string.
    DATA lv_abap_lang_version_devc TYPE string.
    DATA lo_abap_language_version_cfg TYPE REF TO object.

    lv_class = 'CL_ABAP_LANGUAGE_VERSION_CFG'.

    TRY.
        CALL METHOD (lv_class)=>('GET_INSTANCE')
          RECEIVING
            ro_instance = lo_abap_language_version_cfg.

        " For non-existing packages, GET_PACKAGE_DEFAULT_VERSION returns "standard"
        " but we want to return "undefined" in this case to allow any new packages
        IF zcl_abapinst_factory=>get_sap_package( iv_package )->exists( ) = abap_true.
          CALL METHOD lo_abap_language_version_cfg->('IF_ABAP_LANGUAGE_VERSION_CFG~GET_PACKAGE_DEFAULT_VERSION')
            EXPORTING
              iv_package_name             = iv_package
            RECEIVING
              rv_default_language_version = lv_abap_lang_version_devc.
        ELSE.
          lv_abap_lang_version_devc = '-'.
        ENDIF.

        CASE lv_abap_lang_version_devc.
          WHEN zif_abapgit_aff_types_v1=>co_abap_language_version-standard.
            rv_abap_language_version = zif_abapgit_dot_abapgit=>c_abap_language_version-standard.
          WHEN zif_abapgit_aff_types_v1=>co_abap_language_version-key_user.
            rv_abap_language_version = zif_abapgit_dot_abapgit=>c_abap_language_version-key_user.
          WHEN zif_abapgit_aff_types_v1=>co_abap_language_version-cloud_development.
            rv_abap_language_version = zif_abapgit_dot_abapgit=>c_abap_language_version-cloud_development.
          WHEN OTHERS.
            rv_abap_language_version = zif_abapgit_dot_abapgit=>c_abap_language_version-undefined.
        ENDCASE.

      CATCH cx_root.
        rv_abap_language_version = zif_abapgit_dot_abapgit=>c_abap_language_version-undefined.
    ENDTRY.

  ENDMETHOD.

  METHOD get_abap_language_vers_by_objt.

    DATA lv_class TYPE string.
    DATA lo_abap_language_version TYPE REF TO object.

    IF mv_has_abap_language_vers = abap_undefined.
      rv_allowed_abap_langu_version = c_any_abap_language_version.
    ELSEIF mv_has_abap_language_vers = abap_false.
      rv_allowed_abap_langu_version = c_no_abap_language_version.
    ELSE. " abap_true

      lv_class = 'CL_ABAP_LANGUAGE_VERSION'.

      TRY.
          CALL METHOD (lv_class)=>('GET_INSTANCE')
            RECEIVING
              ro_version_handler = lo_abap_language_version.

          CALL METHOD lo_abap_language_version->('IF_ABAP_LANGUAGE_VERSION~GET_DEFAULT_VERSION')
            EXPORTING
              iv_object_type     = iv_object_type
              iv_package         = iv_package
            RECEIVING
              rv_default_version = rv_allowed_abap_langu_version.

        CATCH cx_root.
          rv_allowed_abap_langu_version = get_default_abap_language_vers( iv_object_type ).
      ENDTRY.

    ENDIF.

  ENDMETHOD.

  METHOD get_abap_language_vers_by_repo.
    rv_abap_language_version = mo_dot_abapgit->get_abap_language_version( ).
    IF rv_abap_language_version IS INITIAL.
      rv_abap_language_version = zif_abapgit_dot_abapgit=>c_abap_language_version-undefined.
    ENDIF.
  ENDMETHOD.

  METHOD get_default_abap_language_vers.

    IF zcl_abapinst_factory=>get_environment( )->is_sap_cloud_platform( ) = abap_true.
      " On BTP, default to ABAP for Cloud Development
      rv_abap_language_version = zif_abapgit_aff_types_v1=>co_abap_language_version_cloud-cloud_development.
    ELSE.
      " Differentiate between source code object and non-source code objects
      CASE iv_object_type.
        WHEN 'BDEF' OR 'CLAS' OR 'FUGR' OR 'FUGS' OR 'INTF' OR 'PROG' OR 'TYPE'.
          rv_abap_language_version = zif_abapgit_aff_types_v1=>co_abap_language_version_src-standard.
        WHEN OTHERS.
          rv_abap_language_version = zif_abapgit_aff_types_v1=>co_abap_language_version-standard.
      ENDCASE.
    ENDIF.

  ENDMETHOD.

  METHOD get_description.

    CASE iv_abap_language_version.
      WHEN zif_abapgit_aff_types_v1=>co_abap_language_version-standard
        OR zif_abapgit_aff_types_v1=>co_abap_language_version_src-standard.
        rv_description = 'Standard ABAP'.
      WHEN zif_abapgit_aff_types_v1=>co_abap_language_version-key_user
        OR zif_abapgit_aff_types_v1=>co_abap_language_version_src-key_user.
        rv_description = 'ABAP for Key Users'.
      WHEN zif_abapgit_aff_types_v1=>co_abap_language_version-cloud_development
        OR zif_abapgit_aff_types_v1=>co_abap_language_version_src-cloud_development.
        rv_description = 'ABAP for Cloud Development'.
      WHEN OTHERS.
        rv_description = 'Undefined'.
    ENDCASE.

    rv_description = |ABAP language version "{ rv_description }"|.

  ENDMETHOD.

  METHOD get_repo_abap_language_version.

    DATA lv_abap_language_version TYPE string.

    IF mv_has_abap_language_vers <> abap_undefined. " abap_true or abap_false
      lv_abap_language_version = mo_dot_abapgit->get_abap_language_version( ).
    ENDIF.

    CASE lv_abap_language_version.
      WHEN zif_abapgit_dot_abapgit=>c_abap_language_version-standard.
        rv_abap_language_version = zif_abapgit_aff_types_v1=>co_abap_language_version_src-standard.
      WHEN zif_abapgit_dot_abapgit=>c_abap_language_version-key_user.
        rv_abap_language_version = zif_abapgit_aff_types_v1=>co_abap_language_version_src-key_user.
      WHEN zif_abapgit_dot_abapgit=>c_abap_language_version-cloud_development.
        rv_abap_language_version = zif_abapgit_aff_types_v1=>co_abap_language_version_src-cloud_development.
      WHEN zif_abapgit_dot_abapgit=>c_abap_language_version-ignore.
        rv_abap_language_version = c_no_abap_language_version.
      WHEN OTHERS. " undefined or feature off
        rv_abap_language_version = c_any_abap_language_version.
    ENDCASE.

  ENDMETHOD.

  METHOD is_import_allowed.

    DATA lv_package_version TYPE string.

    lv_package_version = get_abap_language_vers_by_devc( iv_package ).

    CASE get_abap_language_vers_by_repo( ).
      WHEN zif_abapgit_dot_abapgit=>c_abap_language_version-undefined
        OR zif_abapgit_dot_abapgit=>c_abap_language_version-ignore.
        rv_allowed = abap_true.
      WHEN OTHERS.
        IF get_abap_language_vers_by_repo( ) = lv_package_version.
          " allow packages that match repo setting
          rv_allowed = abap_true.
        ELSEIF lv_package_version = zif_abapgit_dot_abapgit=>c_abap_language_version-undefined.
          " always allow new packages
          rv_allowed = abap_true.
        ELSE.
          rv_allowed = abap_false.
        ENDIF.
    ENDCASE.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_adt_link IMPLEMENTATION.

  METHOD link_transport.
* call to CL_CTS_ADT_TM_URI_BUILDER=>CREATE_ADT_URI replaced with logic that works on all systems,
    rv_link = |adt://{ sy-sysid }/sap/bc/adt/cts/transportrequests/{ iv_transport }|.
  ENDMETHOD.

  METHOD generate.

    DATA: lv_adt_link       TYPE string.
    DATA: lo_adt_uri_mapper TYPE REF TO object.
    DATA: lo_adt_objref     TYPE REF TO object.
    DATA: lo_adt_sub_objref TYPE REF TO object.
    DATA: lv_program        TYPE progname.
    DATA: lv_include        TYPE progname.

    FIELD-SYMBOLS: <lv_uri> TYPE string.

    get_adt_objects_and_names(
      EXPORTING
        iv_obj_name       = iv_obj_name
        iv_obj_type       = iv_obj_type
      IMPORTING
        eo_adt_uri_mapper = lo_adt_uri_mapper
        eo_adt_objectref  = lo_adt_objref
        ev_program        = lv_program
        ev_include        = lv_include ).

    TRY.
        IF iv_sub_obj_name IS NOT INITIAL.

          IF ( lv_program <> iv_obj_name AND lv_include IS INITIAL ) OR
             ( lv_program = lv_include AND iv_sub_obj_name IS NOT INITIAL ).
            lv_include = iv_sub_obj_name.
          ENDIF.

          CALL METHOD lo_adt_uri_mapper->('IF_ADT_URI_MAPPER~MAP_INCLUDE_TO_OBJREF')
            EXPORTING
              program     = lv_program
              include     = lv_include
              line        = iv_line_number
              line_offset = 0
              end_line    = iv_line_number
              end_offset  = 1
            RECEIVING
              result      = lo_adt_sub_objref.
          IF lo_adt_sub_objref IS NOT INITIAL.
            lo_adt_objref = lo_adt_sub_objref.
          ENDIF.

        ENDIF.

        ASSIGN ('LO_ADT_OBJREF->REF_DATA-URI') TO <lv_uri>.
        ASSERT sy-subrc = 0.

        CONCATENATE 'adt://' sy-sysid <lv_uri> INTO lv_adt_link.

        rv_result = lv_adt_link.

      CATCH cx_root.
        zcx_abapgit_exception=>raise( 'ADT Jump Error' ).
    ENDTRY.

  ENDMETHOD.

  METHOD get_adt_objects_and_names.

    DATA lv_obj_type       TYPE trobjtype.
    DATA lv_obj_name       TYPE trobj_name.
    DATA lo_object         TYPE REF TO cl_wb_object.
    DATA lo_adt            TYPE REF TO object.

    FIELD-SYMBOLS <lv_uri> TYPE string.

    lv_obj_name = iv_obj_name.
    lv_obj_type = iv_obj_type.

    TRY.
        cl_wb_object=>create_from_transport_key(
          EXPORTING
            p_object    = lv_obj_type
            p_obj_name  = lv_obj_name
          RECEIVING
            p_wb_object = lo_object
          EXCEPTIONS
            OTHERS      = 1 ).
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise( 'ADT Jump Error' ).
        ENDIF.

        CALL METHOD ('CL_ADT_TOOLS_CORE_FACTORY')=>('GET_INSTANCE')
          RECEIVING
            result = lo_adt.

        IF is_adt_jump_possible( io_object = lo_object
                                 io_adt    = lo_adt ) = abap_false.
          zcx_abapgit_exception=>raise( 'ADT Jump Error' ).
        ENDIF.

        CALL METHOD lo_adt->('IF_ADT_TOOLS_CORE_FACTORY~GET_URI_MAPPER')
          RECEIVING
            result = eo_adt_uri_mapper.

        CALL METHOD eo_adt_uri_mapper->('IF_ADT_URI_MAPPER~MAP_WB_OBJECT_TO_OBJREF')
          EXPORTING
            wb_object = lo_object
          RECEIVING
            result    = eo_adt_objectref.

        ASSIGN ('EO_ADT_OBJECTREF->REF_DATA-URI') TO <lv_uri>.
        ASSERT sy-subrc = 0.

        CALL METHOD eo_adt_uri_mapper->('IF_ADT_URI_MAPPER~MAP_OBJREF_TO_INCLUDE')
          EXPORTING
            uri     = <lv_uri>
          IMPORTING
            program = ev_program
            include = ev_include.

      CATCH cx_root.
        zcx_abapgit_exception=>raise( 'ADT Jump Error' ).
    ENDTRY.

  ENDMETHOD.

  METHOD is_adt_jump_possible.

    DATA: lo_wb_request         TYPE REF TO cl_wb_request,
          lo_adt_uri_mapper_vit TYPE REF TO object,
          lv_vit_wb_request     TYPE abap_bool.

    cl_wb_request=>create_from_object_ref(
      EXPORTING
        p_wb_object       = io_object
      RECEIVING
        p_wb_request      = lo_wb_request
      EXCEPTIONS
        illegal_operation = 1
        cancelled         = 2
        OTHERS            = 3 ).

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'ADT Jump Error' ).
    ENDIF.

    TRY.
        CALL METHOD io_adt->('IF_ADT_TOOLS_CORE_FACTORY~GET_URI_MAPPER_VIT')
          RECEIVING
            result = lo_adt_uri_mapper_vit.

        CALL METHOD lo_adt_uri_mapper_vit->('IF_ADT_URI_MAPPER_VIT~IS_VIT_WB_REQUEST')
          EXPORTING
            wb_request = lo_wb_request
          RECEIVING
            result     = lv_vit_wb_request.

        rv_is_adt_jump_possible = boolc( NOT lv_vit_wb_request = abap_true ).

      CATCH cx_root.
        zcx_abapgit_exception=>raise( 'ADT Jump Error' ).
    ENDTRY.

  ENDMETHOD.

  METHOD jump.

    DATA lv_adt_link TYPE string.

    TRY.
        lv_adt_link = generate(
          iv_obj_name     = iv_obj_name
          iv_obj_type     = iv_obj_type
          iv_sub_obj_name = iv_sub_obj_name
          iv_line_number  = iv_line_number ).

        zcl_abapinst_factory=>get_frontend_services( )->execute( iv_document = lv_adt_link ).

      CATCH cx_root.
        zcx_abapgit_exception=>raise( 'ADT Jump Error' ).
    ENDTRY.

  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_AFF_REGISTRY IMPLEMENTATION.

  METHOD constructor.
    mv_aff_enabled = zcl_abapgit_feature=>is_enabled( c_aff_feature ).
  ENDMETHOD.

  METHOD initialize_registry_table.
    register( 'APLO' ).
    register( 'BGQC' ).
    register( 'CDBO' ).
    register( 'CHKC' ).
    register( 'CHKO' ).
    register( 'CHKV' ).
    register( 'COTA' ).
    register( 'DRTY' ).
    register( 'DTEB' ).
    register( 'DSFI' ).
    register( 'DRAS' ).
    register( 'DSFD' ).
    register( 'EVTB' ).
    register( 'EEEC' ).
    register( 'GSMP' ).
    register( iv_obj_type     = 'INTF'
              iv_experimental = abap_true ).
    register( 'SAJT' ).
    register( 'SAJC' ).
    register( 'SMBC' ).
    register( 'SWCR' ).
    register( 'NONT' ).
    register( 'RONT' ).
    register( 'UIAD' ).
    register( 'UIPG' ).
    register( 'UIST' ).
  ENDMETHOD.

  METHOD register.
    DATA ls_registry_entry TYPE ty_registry_entry.

    ls_registry_entry-obj_type = iv_obj_type.
    ls_registry_entry-experimental = iv_experimental.
    INSERT ls_registry_entry INTO TABLE gt_registry.
  ENDMETHOD.

  METHOD zif_abapgit_aff_registry~is_supported_object_type.

    DATA ls_registry_entry TYPE ty_registry_entry.

    IF gt_registry IS INITIAL.
      initialize_registry_table( ).
    ENDIF.

    READ TABLE gt_registry WITH TABLE KEY obj_type = iv_obj_type INTO ls_registry_entry.
    IF sy-subrc = 0 AND ls_registry_entry-experimental = abap_false.
      rv_result = abap_true.
    ELSEIF sy-subrc = 0 AND mv_aff_enabled = abap_true.
      rv_result = abap_true.
    ELSE.
      rv_result = abap_false.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

**********************************************************************
* UTILS
**********************************************************************

INTERFACE lif_kind.

  TYPES ty_kind TYPE c LENGTH 1.

  CONSTANTS:
    any         TYPE ty_kind VALUE cl_abap_typedescr=>typekind_any,
    date        TYPE ty_kind VALUE cl_abap_typedescr=>typekind_date,
    time        TYPE ty_kind VALUE cl_abap_typedescr=>typekind_time,
    packed      TYPE ty_kind VALUE cl_abap_typedescr=>typekind_packed,
    table       TYPE ty_kind VALUE cl_abap_typedescr=>typekind_table,
    struct_flat TYPE ty_kind VALUE cl_abap_typedescr=>typekind_struct1,
    struct_deep TYPE ty_kind VALUE cl_abap_typedescr=>typekind_struct2,
    data_ref    TYPE ty_kind VALUE cl_abap_typedescr=>typekind_dref,
    object_ref  TYPE ty_kind VALUE cl_abap_typedescr=>typekind_oref,
    enum        TYPE ty_kind VALUE 'k'. " cl_abap_typedescr=>typekind_enum not in lower releases

  CONSTANTS:
    BEGIN OF numeric,
      int1       TYPE ty_kind VALUE cl_abap_typedescr=>typekind_int1,
      int2       TYPE ty_kind VALUE cl_abap_typedescr=>typekind_int2,
      int4       TYPE ty_kind VALUE cl_abap_typedescr=>typekind_int,
      int8       TYPE ty_kind VALUE '8', " cl_abap_typedescr=>typekind_int8 not in lower releases
      float      TYPE ty_kind VALUE cl_abap_typedescr=>typekind_float,
      packed     TYPE ty_kind VALUE cl_abap_typedescr=>typekind_packed,
      decfloat16 TYPE ty_kind VALUE cl_abap_typedescr=>typekind_decfloat16,
      decfloat34 TYPE ty_kind VALUE cl_abap_typedescr=>typekind_decfloat34,
    END OF numeric.

  CONSTANTS:
    BEGIN OF texts,
      char   TYPE ty_kind VALUE cl_abap_typedescr=>typekind_char,
      numc   TYPE ty_kind VALUE cl_abap_typedescr=>typekind_num,
      string TYPE ty_kind VALUE cl_abap_typedescr=>typekind_string,
    END OF texts.

  CONSTANTS:
    BEGIN OF binary,
      hex     TYPE ty_kind VALUE cl_abap_typedescr=>typekind_hex,
      xstring TYPE ty_kind VALUE cl_abap_typedescr=>typekind_xstring,
    END OF binary.

  CONSTANTS:
    BEGIN OF deep_targets,
      table       TYPE ty_kind VALUE cl_abap_typedescr=>typekind_table,
      struct_flat TYPE ty_kind VALUE cl_abap_typedescr=>typekind_struct1,
      struct_deep TYPE ty_kind VALUE cl_abap_typedescr=>typekind_struct2,
      data_ref    TYPE ty_kind VALUE cl_abap_typedescr=>typekind_dref,
      object_ref  TYPE ty_kind VALUE cl_abap_typedescr=>typekind_oref,
    END OF deep_targets.

ENDINTERFACE.

CLASS lcl_utils DEFINITION FINAL.
  PUBLIC SECTION.

    CLASS-METHODS normalize_path
      IMPORTING
        iv_path        TYPE string
      RETURNING
        VALUE(rv_path) TYPE string.
    CLASS-METHODS split_path
      IMPORTING
        iv_path             TYPE string
      RETURNING
        VALUE(rv_path_name) TYPE zif_abapgit_ajson_types=>ty_path_name.
    CLASS-METHODS validate_array_index
      IMPORTING
        iv_path         TYPE string
        iv_index        TYPE string
      RETURNING
        VALUE(rv_index) TYPE i
      RAISING
        zcx_abapgit_ajson_error.
    CLASS-METHODS string_to_xstring_utf8
      IMPORTING
        iv_str         TYPE string
      RETURNING
        VALUE(rv_xstr) TYPE xstring.
    CLASS-METHODS xstring_to_string_utf8
      IMPORTING
        iv_xstr       TYPE xstring
      RETURNING
        VALUE(rv_str) TYPE string.
    CLASS-METHODS any_to_xstring
      IMPORTING
        iv_data        TYPE any
      RETURNING
        VALUE(rv_xstr) TYPE xstring
      RAISING
        zcx_abapgit_ajson_error.
    CLASS-METHODS any_to_string
      IMPORTING
        iv_data       TYPE any
      RETURNING
        VALUE(rv_str) TYPE string
      RAISING
        zcx_abapgit_ajson_error.

ENDCLASS.

CLASS lcl_utils IMPLEMENTATION.

  METHOD string_to_xstring_utf8.

    DATA lo_conv TYPE REF TO object.
    DATA lv_out_ce TYPE string.

    lv_out_ce = 'CL_ABAP_CONV_OUT_CE'.

    TRY.
        CALL METHOD ('CL_ABAP_CONV_CODEPAGE')=>create_out
        RECEIVING
          instance = lo_conv.
        CALL METHOD lo_conv->('IF_ABAP_CONV_OUT~CONVERT')
        EXPORTING
          source = iv_str
        RECEIVING
          result = rv_xstr.
      CATCH cx_sy_dyn_call_illegal_class.
        CALL METHOD (lv_out_ce)=>create
        EXPORTING
          encoding = 'UTF-8'
        RECEIVING
          conv = lo_conv.
        CALL METHOD lo_conv->('CONVERT')
        EXPORTING
          data = iv_str
        IMPORTING
          buffer = rv_xstr.
    ENDTRY.

  ENDMETHOD.

  METHOD xstring_to_string_utf8.

    DATA lo_conv TYPE REF TO object.
    DATA lv_in_ce TYPE string.

    lv_in_ce = 'CL_ABAP_CONV_IN_CE'.

    TRY.
        CALL METHOD ('CL_ABAP_CONV_CODEPAGE')=>create_in
        RECEIVING
          instance = lo_conv.
        CALL METHOD lo_conv->('IF_ABAP_CONV_IN~CONVERT')
        EXPORTING
          source = iv_xstr
        RECEIVING
          result = rv_str.
      CATCH cx_sy_dyn_call_illegal_class.
        CALL METHOD (lv_in_ce)=>create
        EXPORTING
          encoding = 'UTF-8'
        RECEIVING
          conv = lo_conv.
        CALL METHOD lo_conv->('CONVERT')
        EXPORTING
          data = iv_xstr
        IMPORTING
          buffer = rv_str.
    ENDTRY.

  ENDMETHOD.

  METHOD validate_array_index.

    IF NOT iv_index CO '0123456789'.
      zcx_abapgit_ajson_error=>raise( |Cannot add non-numeric key [{ iv_index }] to array [{ iv_path }]| ).
    ENDIF.
    rv_index = iv_index.
    IF rv_index = 0.
      zcx_abapgit_ajson_error=>raise( |Cannot add zero key to array [{ iv_path }]| ).
    ENDIF.

  ENDMETHOD.

  METHOD normalize_path.

    rv_path = iv_path.
    IF strlen( rv_path ) = 0.
      rv_path = '/'.
    ENDIF.
    IF rv_path+0(1) <> '/'.
      rv_path = '/' && rv_path.
    ENDIF.
    IF substring( val = rv_path
                  off = strlen( rv_path ) - 1 ) <> '/'.
      rv_path = rv_path && '/'.
    ENDIF.

  ENDMETHOD.

  METHOD split_path.

    DATA lv_offs TYPE i.
    DATA lv_len TYPE i.
    DATA lv_trim_slash TYPE i.

    lv_len = strlen( iv_path ).
    IF lv_len = 0 OR iv_path = '/'.
      RETURN. " empty path is the alias for root item = '' + ''
    ENDIF.

    IF substring( val = iv_path
                  off = lv_len - 1 ) = '/'.
      lv_trim_slash = 1. " ignore last '/'
    ENDIF.

    lv_offs = find( val = reverse( iv_path )
                    sub = '/'
                    off = lv_trim_slash ).
    IF lv_offs = -1.
      lv_offs  = lv_len. " treat whole string as the 'name' part
    ENDIF.
    lv_offs = lv_len - lv_offs.

    rv_path_name-path = normalize_path( substring( val = iv_path
                                                   len = lv_offs ) ).
    rv_path_name-name = substring( val = iv_path
                                   off = lv_offs
                                   len = lv_len - lv_offs - lv_trim_slash ).

  ENDMETHOD.

  METHOD any_to_xstring.
    " supports xstring, char, string, or string_table as input

    DATA lo_type TYPE REF TO cl_abap_typedescr.
    DATA lo_table_type TYPE REF TO cl_abap_tabledescr.
    DATA lv_str TYPE string.

    FIELD-SYMBOLS: <data> TYPE STANDARD TABLE.

    lo_type = cl_abap_typedescr=>describe_by_data( iv_data ).

    CASE lo_type->type_kind.
      WHEN lif_kind=>binary-xstring.
        rv_xstr = iv_data.
      WHEN lif_kind=>texts-string OR lif_kind=>texts-char.
        rv_xstr = string_to_xstring_utf8( iv_data ).
      WHEN lif_kind=>table.
        lo_table_type ?= lo_type.
        IF lo_table_type->table_kind <> cl_abap_tabledescr=>tablekind_std.
          zcx_abapgit_ajson_error=>raise( 'Unsupported type of input table (must be standard table)' ).
        ENDIF.
        TRY.
            ASSIGN iv_data TO <data>.
            lv_str = concat_lines_of( table = <data>
                                      sep = cl_abap_char_utilities=>newline ).
            rv_xstr = string_to_xstring_utf8( lv_str ).
          CATCH cx_root.
            zcx_abapgit_ajson_error=>raise( 'Error converting input table (should be string_table)' ).
        ENDTRY.
      WHEN OTHERS.
        zcx_abapgit_ajson_error=>raise( 'Unsupported type of input (must be char, string, string_table, or xstring)' ).
    ENDCASE.

  ENDMETHOD.

  METHOD any_to_string.
    " supports xstring, char, string, or string_table as input

    DATA lo_type TYPE REF TO cl_abap_typedescr.
    DATA lo_table_type TYPE REF TO cl_abap_tabledescr.

    FIELD-SYMBOLS: <data> TYPE STANDARD TABLE.

    lo_type = cl_abap_typedescr=>describe_by_data( iv_data ).

    CASE lo_type->type_kind.
      WHEN lif_kind=>binary-xstring.
        rv_str = xstring_to_string_utf8( iv_data ).
      WHEN lif_kind=>texts-string OR lif_kind=>texts-char.
        rv_str = iv_data.
      WHEN lif_kind=>table.
        lo_table_type ?= lo_type.
        IF lo_table_type->table_kind <> cl_abap_tabledescr=>tablekind_std.
          zcx_abapgit_ajson_error=>raise( 'Unsupported type of input table (must be standard table)' ).
        ENDIF.
        TRY.
            ASSIGN iv_data TO <data>.
            rv_str = concat_lines_of( table = <data>
                                      sep = cl_abap_char_utilities=>newline ).
          CATCH cx_root.
            zcx_abapgit_ajson_error=>raise( 'Error converting input table (should be string_table)' ).
        ENDTRY.
      WHEN OTHERS.
        zcx_abapgit_ajson_error=>raise( 'Unsupported type of input (must be char, string, string_table, or xstring)' ).
    ENDCASE.

  ENDMETHOD.

ENDCLASS.

**********************************************************************
* PARSER
**********************************************************************

CLASS lcl_json_parser DEFINITION FINAL.
  PUBLIC SECTION.

    METHODS parse
      IMPORTING
        iv_json             TYPE any
        iv_keep_item_order  TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(rt_json_tree) TYPE zif_abapgit_ajson_types=>ty_nodes_tt
      RAISING
        zcx_abapgit_ajson_error.

  PRIVATE SECTION.

    TYPES:
      ty_stack_tt TYPE STANDARD TABLE OF REF TO zif_abapgit_ajson_types=>ty_node.

    DATA mt_stack TYPE ty_stack_tt.
    DATA mv_stack_path TYPE string.
    DATA mv_keep_item_order TYPE abap_bool.

    METHODS raise
      IMPORTING
        iv_error TYPE string
      RAISING
        zcx_abapgit_ajson_error.

    METHODS _parse
      IMPORTING
        iv_json             TYPE xstring
      RETURNING
        VALUE(rt_json_tree) TYPE zif_abapgit_ajson_types=>ty_nodes_tt
      RAISING
        zcx_abapgit_ajson_error cx_dynamic_check. " cx_sxml_error is not released on Steampunk #153

    METHODS _get_location
      IMPORTING
        iv_json            TYPE string
        iv_offset          TYPE i
      RETURNING
        VALUE(rv_location) TYPE string.

ENDCLASS.

CLASS lcl_json_parser IMPLEMENTATION.

  METHOD parse.
    DATA lx_sxml_parse TYPE REF TO cx_sxml_parse_error.
    DATA lx_sxml TYPE REF TO cx_dynamic_check.
    DATA lv_location TYPE string.
    DATA lv_json TYPE xstring.

    mv_keep_item_order = iv_keep_item_order.

    lv_json = lcl_utils=>any_to_xstring( iv_json ).

    TRY.
      " TODO sane JSON check:
      " JSON can be true,false,null,(-)digits
      " or start from " or from {
        rt_json_tree = _parse( lv_json ).
      CATCH cx_sxml_parse_error INTO lx_sxml_parse.
        lv_location = _get_location(
        iv_json   = lcl_utils=>any_to_string( iv_json )
        iv_offset = lx_sxml_parse->xml_offset ).
        zcx_abapgit_ajson_error=>raise(
        iv_msg      = |Json parsing error (SXML): { lx_sxml_parse->get_text( ) }|
        iv_location = lv_location ).
      CATCH cx_dynamic_check INTO lx_sxml. " cx_sxml_error
        zcx_abapgit_ajson_error=>raise(
        iv_msg      = |Json parsing error (SXML): { lx_sxml->get_text( ) }|
        iv_location = '@PARSER' ).
    ENDTRY.

  ENDMETHOD.

  METHOD _get_location.

    DATA lv_json TYPE string.
    DATA lv_offset TYPE i.
    DATA lt_text TYPE TABLE OF string.
    DATA lv_text TYPE string.
    DATA lv_line TYPE i.
    DATA lv_pos TYPE i.

    lv_offset = iv_offset.
    IF lv_offset < 0.
      lv_offset = 0.
    ENDIF.
    IF lv_offset > strlen( iv_json ).
      lv_offset = strlen( iv_json ).
    ENDIF.

    lv_json = iv_json(lv_offset).

    REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>cr_lf
      IN lv_json WITH cl_abap_char_utilities=>newline.

    SPLIT lv_json AT cl_abap_char_utilities=>newline INTO TABLE lt_text.

    lv_line = lines( lt_text ).
    IF lv_line = 0.
      lv_line = 1.
      lv_pos = 1.
    ELSE.
      READ TABLE lt_text INDEX lv_line INTO lv_text.
      lv_pos = strlen( lv_text ) + 1.
    ENDIF.

    rv_location = |Line { lv_line }, Offset { lv_pos }|.

  ENDMETHOD.

  METHOD _parse.

    DATA lo_reader TYPE REF TO if_sxml_reader.
    DATA lr_stack_top LIKE LINE OF mt_stack.
    DATA lo_node TYPE REF TO if_sxml_node.
    FIELD-SYMBOLS <item> LIKE LINE OF rt_json_tree.

    CLEAR mt_stack.
    CLEAR mv_stack_path.
    IF iv_json IS INITIAL.
      RETURN.
    ENDIF.
    lo_reader = cl_sxml_string_reader=>create( iv_json ).

    " TODO: self protection, check non-empty, check starting from object ...

    DO.
      lo_node = lo_reader->read_next_node( ).
      IF lo_node IS NOT BOUND.
        EXIT.
      ENDIF.

      CASE lo_node->type.
        WHEN if_sxml_node=>co_nt_element_open.
          DATA lt_attributes TYPE if_sxml_attribute=>attributes.
          DATA lo_attr LIKE LINE OF lt_attributes.
          DATA lo_open TYPE REF TO if_sxml_open_element.
          lo_open ?= lo_node.

          APPEND INITIAL LINE TO rt_json_tree ASSIGNING <item>.

          <item>-type = lo_open->qname-name.

          READ TABLE mt_stack INDEX 1 INTO lr_stack_top.
          IF sy-subrc = 0.
            " Using string is faster than rebuilding path from stack
            <item>-path = mv_stack_path.
            lr_stack_top->children = lr_stack_top->children + 1.

            IF lr_stack_top->type = `array`. " This is parser type not ajson type
              <item>-name = |{ lr_stack_top->children }|.
              <item>-index = lr_stack_top->children.
            ELSE.
              lt_attributes = lo_open->get_attributes( ).
              LOOP AT lt_attributes INTO lo_attr.
                IF lo_attr->qname-name = 'name' AND lo_attr->value_type = if_sxml_value=>co_vt_text.
                  <item>-name = lo_attr->get_value( ).
                ENDIF.
              ENDLOOP.
              IF mv_keep_item_order = abap_true.
                <item>-order = lr_stack_top->children.
              ENDIF.
            ENDIF.
            IF <item>-name IS INITIAL.
              raise( 'Node without name (maybe not JSON)' ).
            ENDIF.
          ENDIF.

          GET REFERENCE OF <item> INTO lr_stack_top.
          INSERT lr_stack_top INTO mt_stack INDEX 1.
          " add path component
          mv_stack_path = mv_stack_path && <item>-name && '/'.

        WHEN if_sxml_node=>co_nt_element_close.
          DATA lo_close TYPE REF TO if_sxml_close_element.
          lo_close ?= lo_node.

          READ TABLE mt_stack INDEX 1 INTO lr_stack_top.
          DELETE mt_stack INDEX 1.
          IF lo_close->qname-name <> lr_stack_top->type.
            raise( 'Unexpected closing node type' ).
          ENDIF.

          " remove last path component
          mv_stack_path = substring( val = mv_stack_path
                                     len = find( val = mv_stack_path sub = '/' occ = -2 ) + 1 ).
        WHEN if_sxml_node=>co_nt_value.
          DATA lo_value TYPE REF TO if_sxml_value_node.
          lo_value ?= lo_node.

          <item>-value = lo_value->get_value( ).

        WHEN OTHERS.
          raise( 'Unexpected node type' ).
      ENDCASE.
    ENDDO.

    IF lines( mt_stack ) > 0.
      raise( 'Unexpected end of data' ).
    ENDIF.

  ENDMETHOD.

  METHOD raise.

    zcx_abapgit_ajson_error=>raise(
      iv_location = mv_stack_path
      iv_msg      = |JSON PARSER: { iv_error } @ { mv_stack_path }| ).

  ENDMETHOD.

ENDCLASS.

**********************************************************************
* SERIALIZER
**********************************************************************

CLASS lcl_json_serializer DEFINITION FINAL CREATE PRIVATE.
  PUBLIC SECTION.

    CLASS-METHODS stringify
      IMPORTING
        it_json_tree          TYPE zif_abapgit_ajson_types=>ty_nodes_ts
        iv_indent             TYPE i DEFAULT 0
        iv_keep_item_order    TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(rv_json_string) TYPE string
      RAISING
        zcx_abapgit_ajson_error.

    CLASS-METHODS class_constructor.

  PRIVATE SECTION.

    CLASS-DATA gv_comma_with_lf TYPE string.

    DATA mt_json_tree TYPE zif_abapgit_ajson_types=>ty_nodes_ts.
    DATA mv_keep_item_order TYPE abap_bool.
    DATA mt_buffer TYPE string_table.
    DATA mv_indent_step TYPE i.
    DATA mv_level TYPE i.

    CLASS-METHODS escape_string
      IMPORTING
        iv_unescaped      TYPE string
      RETURNING
        VALUE(rv_escaped) TYPE string.

    METHODS _stringify
      RETURNING
        VALUE(rv_json_string) TYPE string
      RAISING
        zcx_abapgit_ajson_error.

    METHODS stringify_node
      IMPORTING
        is_node TYPE zif_abapgit_ajson_types=>ty_node
      RAISING
        zcx_abapgit_ajson_error.

    METHODS stringify_set
      IMPORTING
        iv_parent_path TYPE string
        iv_array       TYPE abap_bool
      RAISING
        zcx_abapgit_ajson_error.

ENDCLASS.

CLASS lcl_json_serializer IMPLEMENTATION.

  METHOD class_constructor.
    gv_comma_with_lf = ',' && cl_abap_char_utilities=>newline.
  ENDMETHOD.

  METHOD stringify.

    DATA lo TYPE REF TO lcl_json_serializer.
    CREATE OBJECT lo.
    lo->mt_json_tree = it_json_tree.
    lo->mv_indent_step = iv_indent.
    lo->mv_keep_item_order = iv_keep_item_order.
    rv_json_string = lo->_stringify( ).

  ENDMETHOD.

  METHOD _stringify.

    FIELD-SYMBOLS <n> LIKE LINE OF mt_json_tree.
    READ TABLE mt_json_tree ASSIGNING <n>
      WITH KEY
        path = ''
        name = ''. " Root
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    stringify_node( <n> ).

    rv_json_string = concat_lines_of( table = mt_buffer ).

  ENDMETHOD.

  METHOD stringify_node.

    DATA lv_item TYPE string.
    DATA lv_indent_prefix TYPE string.

    IF mv_indent_step > 0.
      lv_indent_prefix = repeat( val = ` `
                                 occ = mv_indent_step * mv_level ).
      lv_item = lv_indent_prefix.
    ENDIF.

    IF is_node-name IS NOT INITIAL AND is_node-index IS INITIAL. " Not root, not array item
      IF mv_indent_step > 0.
        lv_item = lv_item && |"{ is_node-name }": |.
      ELSE.
        lv_item = |"{ is_node-name }":|.
      ENDIF.
    ENDIF.

    CASE is_node-type.
      WHEN zif_abapgit_ajson_types=>node_type-array.
        lv_item = lv_item && '['.
      WHEN zif_abapgit_ajson_types=>node_type-object.
        lv_item = lv_item && '{'.
      WHEN zif_abapgit_ajson_types=>node_type-string.
        lv_item = lv_item && |"{ escape_string( is_node-value ) }"|.
      WHEN zif_abapgit_ajson_types=>node_type-boolean OR zif_abapgit_ajson_types=>node_type-number.
        lv_item = lv_item && is_node-value.
      WHEN zif_abapgit_ajson_types=>node_type-null.
        lv_item = lv_item && 'null'.
      WHEN OTHERS.
        zcx_abapgit_ajson_error=>raise(
          iv_msg = |Unexpected type [{ is_node-type }]|
          iv_location = is_node-path && is_node-name ).
    ENDCASE.

    IF mv_indent_step > 0
      AND ( is_node-type = zif_abapgit_ajson_types=>node_type-array OR is_node-type = zif_abapgit_ajson_types=>node_type-object )
      AND is_node-children > 0.
      mv_level = mv_level + 1.
      lv_item = lv_item && cl_abap_char_utilities=>newline.
    ENDIF.

    APPEND lv_item TO mt_buffer.

    " finish complex item

    IF is_node-type = zif_abapgit_ajson_types=>node_type-array OR is_node-type = zif_abapgit_ajson_types=>node_type-object.
      DATA lv_children_path TYPE string.
      DATA lv_tail TYPE string.

      lv_children_path = is_node-path && is_node-name && '/'. " for root: path = '' and name = '', so result is '/'

      CASE is_node-type.
        WHEN zif_abapgit_ajson_types=>node_type-array.
          IF is_node-children > 0.
            stringify_set(
              iv_parent_path = lv_children_path
              iv_array       = abap_true ).
          ENDIF.
          lv_tail = ']'.
        WHEN zif_abapgit_ajson_types=>node_type-object.
          IF is_node-children > 0.
            stringify_set(
              iv_parent_path = lv_children_path
              iv_array       = abap_false ).
          ENDIF.
          lv_tail = '}'.
      ENDCASE.

      IF mv_indent_step > 0 AND is_node-children > 0.
        lv_tail = lv_indent_prefix && lv_tail.
        mv_level = mv_level - 1.
      ENDIF.
      APPEND lv_tail TO mt_buffer.
    ENDIF.

  ENDMETHOD.

  METHOD stringify_set.

    DATA lv_tab_key TYPE string.
    DATA lv_first_done TYPE abap_bool.
    FIELD-SYMBOLS <n> LIKE LINE OF mt_json_tree.

    IF iv_array = abap_true.
      lv_tab_key = 'array_index'. " path + index
    ELSEIF mv_keep_item_order = abap_true.
      lv_tab_key = 'item_order'. " path + order
    ELSE.
      lv_tab_key = 'primary_key'. " path + name
    ENDIF.

    LOOP AT mt_json_tree ASSIGNING <n> USING KEY (lv_tab_key) WHERE path = iv_parent_path.
      IF lv_first_done = abap_false.
        lv_first_done = abap_true.
      ELSEIF mv_indent_step > 0.
        APPEND gv_comma_with_lf TO mt_buffer.
      ELSE.
        APPEND ',' TO mt_buffer.
      ENDIF.
      stringify_node( <n> ).
    ENDLOOP.

    IF mv_indent_step > 0 AND lv_first_done = abap_true. " only of items were in the list
      APPEND cl_abap_char_utilities=>newline TO mt_buffer.
    ENDIF.

  ENDMETHOD.

  METHOD escape_string.

    rv_escaped = iv_unescaped.
    IF rv_escaped CA |"\\\t\n\r|.
      " TODO consider performance ...
      " see also https://www.json.org/json-en.html
      rv_escaped = replace(
        val = rv_escaped
        sub = '\'
        with = '\\'
        occ = 0 ).
      rv_escaped = replace(
        val = rv_escaped
        sub = |\n|
        with = '\n'
        occ = 0 ).
      rv_escaped = replace(
        val = rv_escaped
        sub = |\r|
        with = '\r'
        occ = 0 ).
      rv_escaped = replace(
        val = rv_escaped
        sub = |\t|
        with = '\t'
        occ = 0 ).
      rv_escaped = replace(
        val = rv_escaped
        sub = '"'
        with = '\"'
        occ = 0 ).

    ENDIF.

  ENDMETHOD.

ENDCLASS.

**********************************************************************
* JSON_TO_ABAP
**********************************************************************

CLASS lcl_json_to_abap DEFINITION FINAL.
  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        !iv_corresponding  TYPE abap_bool DEFAULT abap_false
        !ii_custom_mapping TYPE REF TO zif_abapgit_ajson_mapping OPTIONAL.

    METHODS to_abap
      IMPORTING
        it_nodes    TYPE zif_abapgit_ajson_types=>ty_nodes_ts
      CHANGING
        c_container TYPE any
      RAISING
        zcx_abapgit_ajson_error.

    METHODS to_timestamp
      IMPORTING
        iv_value         TYPE zif_abapgit_ajson_types=>ty_node-value
      RETURNING
        VALUE(rv_result) TYPE timestamp
      RAISING
        zcx_abapgit_ajson_error.

    METHODS to_date
      IMPORTING
        iv_value         TYPE zif_abapgit_ajson_types=>ty_node-value
      RETURNING
        VALUE(rv_result) TYPE d
      RAISING
        zcx_abapgit_ajson_error.

    METHODS to_time
      IMPORTING
        iv_value         TYPE zif_abapgit_ajson_types=>ty_node-value
      RETURNING
        VALUE(rv_result) TYPE t
      RAISING
        zcx_abapgit_ajson_error.

  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_type_cache,
        type_path         TYPE string,
        target_field_name TYPE string,
        dd                TYPE REF TO cl_abap_datadescr,
        type_kind         LIKE lif_kind=>any,
        tab_item_buf      TYPE REF TO data,
      END OF ty_type_cache.
    DATA mt_node_type_cache TYPE HASHED TABLE OF ty_type_cache WITH UNIQUE KEY type_path.

    DATA mr_nodes TYPE REF TO zif_abapgit_ajson_types=>ty_nodes_ts.
    DATA mi_custom_mapping TYPE REF TO zif_abapgit_ajson_mapping.
    DATA mv_corresponding TYPE abap_bool.

    METHODS any_to_abap
      IMPORTING
        iv_path         TYPE string
        is_parent_type  TYPE ty_type_cache OPTIONAL
        i_container_ref TYPE REF TO data
      RAISING
        zcx_abapgit_ajson_error.

    METHODS value_to_abap
      IMPORTING
        is_node         TYPE zif_abapgit_ajson_types=>ty_node
        is_node_type    TYPE ty_type_cache
        i_container_ref TYPE REF TO data
      RAISING
        zcx_abapgit_ajson_error
        cx_sy_conversion_no_number.

    METHODS get_node_type
      IMPORTING
        is_node             TYPE zif_abapgit_ajson_types=>ty_node OPTIONAL " Empty for root
        is_parent_type      TYPE ty_type_cache OPTIONAL
        i_container_ref     TYPE REF TO data OPTIONAL
      RETURNING
        VALUE(rs_node_type) TYPE ty_type_cache
      RAISING
        zcx_abapgit_ajson_error.

ENDCLASS.

CLASS lcl_json_to_abap IMPLEMENTATION.

  METHOD constructor.
    mi_custom_mapping = ii_custom_mapping.
    mv_corresponding  = iv_corresponding.
  ENDMETHOD.

  METHOD to_abap.

    DATA lr_ref TYPE REF TO data.

    CLEAR c_container. " what about data/obj refs ?
    CLEAR mt_node_type_cache.

    GET REFERENCE OF c_container INTO lr_ref.
    GET REFERENCE OF it_nodes INTO mr_nodes.

    get_node_type( i_container_ref = lr_ref ). " Pre-cache root node type

    any_to_abap(
      iv_path         = ''
      i_container_ref = lr_ref ).

  ENDMETHOD.

  METHOD get_node_type.

    DATA lv_node_type_path TYPE string.
    DATA lo_sdescr TYPE REF TO cl_abap_structdescr.
    DATA lo_tdescr TYPE REF TO cl_abap_tabledescr.
    DATA lo_ddescr TYPE REF TO cl_abap_datadescr.

    " Calculate type path
    IF is_parent_type-type_kind = lif_kind=>table.
      lv_node_type_path = is_parent_type-type_path && '/-'. " table item type
    ELSEIF is_parent_type-type_kind IS NOT INITIAL.
      lv_node_type_path = is_parent_type-type_path && '/' && is_node-name.
    ENDIF. " For root node lv_node_type_path remains ''

    " Get or create cached
    READ TABLE mt_node_type_cache INTO rs_node_type WITH KEY type_path = lv_node_type_path.
    IF sy-subrc <> 0.

      rs_node_type-type_path         = lv_node_type_path.

      IF mi_custom_mapping IS BOUND.
        rs_node_type-target_field_name = to_upper( mi_custom_mapping->to_abap(
          iv_path = is_node-path
          iv_name = is_node-name ) ).
        IF rs_node_type-target_field_name IS INITIAL.
          rs_node_type-target_field_name = to_upper( is_node-name ).
        ENDIF.
      ELSE.
        rs_node_type-target_field_name = to_upper( is_node-name ).
      ENDIF.

      CASE is_parent_type-type_kind.
        WHEN lif_kind=>table.
          lo_tdescr ?= is_parent_type-dd.
          rs_node_type-dd = lo_tdescr->get_table_line_type( ).

        WHEN lif_kind=>struct_flat OR lif_kind=>struct_deep.
          lo_sdescr ?= is_parent_type-dd.
          lo_sdescr->get_component_type(
            EXPORTING
              p_name      = rs_node_type-target_field_name
            RECEIVING
              p_descr_ref = rs_node_type-dd
            EXCEPTIONS
              component_not_found = 4 ).
          IF sy-subrc <> 0.
            IF mv_corresponding = abap_false.
              zcx_abapgit_ajson_error=>raise( |Path not found| ).
            ELSE.
              CLEAR rs_node_type.
              RETURN.
            ENDIF.
          ENDIF.

        WHEN ''. " Root node
          rs_node_type-dd ?= cl_abap_typedescr=>describe_by_data_ref( i_container_ref ).

        WHEN OTHERS.
          zcx_abapgit_ajson_error=>raise( |Unexpected parent type| ).
      ENDCASE.

      rs_node_type-type_kind         = rs_node_type-dd->type_kind. " for caching and cleaner uninitialized access
      IF rs_node_type-type_kind = lif_kind=>table.
        lo_tdescr ?= rs_node_type-dd.
        IF lo_tdescr->table_kind <> cl_abap_tabledescr=>tablekind_std.
          lo_ddescr = lo_tdescr->get_table_line_type( ).
          CREATE DATA rs_node_type-tab_item_buf TYPE HANDLE lo_ddescr.
        ENDIF.
      ENDIF.

      INSERT rs_node_type INTO TABLE mt_node_type_cache.
    ENDIF.

  ENDMETHOD.

  METHOD any_to_abap.

    DATA ls_node_type LIKE LINE OF mt_node_type_cache.
    DATA lx_ajson TYPE REF TO zcx_abapgit_ajson_error.
    DATA lx_root TYPE REF TO cx_root.
    DATA lr_target_field TYPE REF TO data.

    FIELD-SYMBOLS <n> TYPE zif_abapgit_ajson_types=>ty_node.
    FIELD-SYMBOLS <parent_stdtab> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <parent_anytab> TYPE ANY TABLE.
    FIELD-SYMBOLS <parent_struc> TYPE any.
    FIELD-SYMBOLS <tab_item> TYPE any.

    " Assign container
    CASE is_parent_type-type_kind.
      WHEN lif_kind=>table.
        IF is_parent_type-tab_item_buf IS BOUND. " Indirect hint that table was sorted/hashed, see get_node_type.
          ASSIGN i_container_ref->* TO <parent_anytab>.
          ASSERT sy-subrc = 0.

          lr_target_field = is_parent_type-tab_item_buf. " For hashed/sorted table - same buffer for all children
          ASSIGN is_parent_type-tab_item_buf->* TO <tab_item>.
          ASSERT sy-subrc = 0.

        ELSE.
          ASSIGN i_container_ref->* TO <parent_stdtab>.
          ASSERT sy-subrc = 0.
        ENDIF.

      WHEN lif_kind=>struct_flat OR lif_kind=>struct_deep.
        ASSIGN i_container_ref->* TO <parent_struc>.
        ASSERT sy-subrc = 0.
    ENDCASE.

    TRY.

      " array_index because stringified index goes in wrong order [1, 10, 2 ...]
        LOOP AT mr_nodes->* ASSIGNING <n> USING KEY array_index WHERE path = iv_path.

        " Get or create type cache record
          IF is_parent_type-type_kind <> lif_kind=>table OR ls_node_type-type_kind IS INITIAL.
          " table records are the same, no need to refetch twice

            ls_node_type = get_node_type(
            is_node        = <n>
            is_parent_type = is_parent_type ).

            IF mv_corresponding = abap_true AND ls_node_type IS INITIAL.
              CONTINUE.
            ENDIF.

          ENDIF.

        " Validate node type
          IF ls_node_type-type_kind = lif_kind=>data_ref OR
           ls_node_type-type_kind = lif_kind=>object_ref.
          " TODO maybe in future
            zcx_abapgit_ajson_error=>raise( 'Cannot assign to ref' ).
          ENDIF.

        " Find target field reference
          CASE is_parent_type-type_kind.
            WHEN lif_kind=>table.
              IF NOT ls_node_type-target_field_name CO '0123456789'.
              " Does not affect anything actually but for integrity
                zcx_abapgit_ajson_error=>raise( 'Need index to access tables' ).
              ENDIF.

              IF is_parent_type-tab_item_buf IS NOT BOUND. " Indirect hint that table was srt/hsh, see get_node_type
                APPEND INITIAL LINE TO <parent_stdtab> REFERENCE INTO lr_target_field.
                ASSERT sy-subrc = 0.
              ELSE.
                CLEAR <tab_item>.
              ENDIF.

            WHEN lif_kind=>struct_flat OR lif_kind=>struct_deep.
              FIELD-SYMBOLS <field> TYPE any.
              ASSIGN COMPONENT ls_node_type-target_field_name OF STRUCTURE <parent_struc> TO <field>.
              ASSERT sy-subrc = 0.
              GET REFERENCE OF <field> INTO lr_target_field.

            WHEN ''. " Root node
              lr_target_field = i_container_ref.

            WHEN OTHERS.
              zcx_abapgit_ajson_error=>raise( 'Unexpected parent type' ).
          ENDCASE.

        " Process value assignment
          CASE <n>-type.
            WHEN zif_abapgit_ajson_types=>node_type-object.
              IF ls_node_type-type_kind <> lif_kind=>struct_flat AND
               ls_node_type-type_kind <> lif_kind=>struct_deep.
                zcx_abapgit_ajson_error=>raise( 'Expected structure' ).
              ENDIF.
              any_to_abap(
              iv_path         = <n>-path && <n>-name && '/'
              is_parent_type  = ls_node_type
              i_container_ref = lr_target_field ).

            WHEN zif_abapgit_ajson_types=>node_type-array.
              IF NOT ls_node_type-type_kind = lif_kind=>table.
                zcx_abapgit_ajson_error=>raise( 'Expected table' ).
              ENDIF.
              any_to_abap(
              iv_path         = <n>-path && <n>-name && '/'
              is_parent_type  = ls_node_type
              i_container_ref = lr_target_field ).

            WHEN OTHERS.
              value_to_abap(
              is_node         = <n>
              is_node_type    = ls_node_type
              i_container_ref = lr_target_field ).
          ENDCASE.

          IF is_parent_type-tab_item_buf IS BOUND. " Indirect hint that table was sorted/hashed, see get_node_type.
            TRY.
                INSERT <tab_item> INTO TABLE <parent_anytab>.
                IF sy-subrc <> 0.
                  zcx_abapgit_ajson_error=>raise( 'Duplicate insertion' ).
                ENDIF.
              CATCH cx_sy_itab_duplicate_key.
                zcx_abapgit_ajson_error=>raise( 'Duplicate insertion' ).
            ENDTRY.
          ENDIF.

        ENDLOOP.

      CATCH zcx_abapgit_ajson_error INTO lx_ajson.
        IF lx_ajson->location IS INITIAL.
          lx_ajson->set_location( <n>-path && <n>-name ).
        ENDIF.
        RAISE EXCEPTION lx_ajson.
      CATCH cx_sy_conversion_no_number.
        zcx_abapgit_ajson_error=>raise(
        iv_msg = 'Source is not a number'
        iv_location = <n>-path && <n>-name ).
      CATCH cx_root INTO lx_root.
        zcx_abapgit_ajson_error=>raise(
        iv_msg = lx_root->get_text( )
        iv_location = <n>-path && <n>-name ).
    ENDTRY.

  ENDMETHOD.

  METHOD value_to_abap.

    FIELD-SYMBOLS <container> TYPE any.

    IF is_node_type-type_kind CA lif_kind=>deep_targets.
      zcx_abapgit_ajson_error=>raise( |Unsupported target for value [{ is_node_type-type_kind }]| ).
    ENDIF.

    ASSIGN i_container_ref->* TO <container>.
    ASSERT sy-subrc = 0.

    CASE is_node-type.
      WHEN zif_abapgit_ajson_types=>node_type-null.
        " Do nothing
      WHEN zif_abapgit_ajson_types=>node_type-boolean.
        " TODO: check type ?
        <container> = boolc( is_node-value = 'true' ).
      WHEN zif_abapgit_ajson_types=>node_type-number.
        " TODO: check type ?
        <container> = is_node-value.

      WHEN zif_abapgit_ajson_types=>node_type-string.
        " TODO: check type ?
        IF is_node-value IS NOT INITIAL.
          IF is_node_type-type_kind = lif_kind=>date.
            <container> = to_date( is_node-value ).
          ELSEIF is_node_type-type_kind = lif_kind=>time.
            <container> = to_time( is_node-value ).
          ELSEIF is_node_type-dd->absolute_name = '\TYPE=TIMESTAMP'
            OR is_node_type-dd->absolute_name = '\TYPE=TIMESTAMPL'.
            <container> = to_timestamp( is_node-value ).
          ELSEIF is_node_type-type_kind = lif_kind=>packed. " Number as a string, but not a timestamp
            <container> = is_node-value.
          ELSE.
            <container> = is_node-value.
          ENDIF.
        ELSE.
          <container> = is_node-value.
        ENDIF.
      WHEN OTHERS.
        zcx_abapgit_ajson_error=>raise( |Unexpected JSON type [{ is_node-type }]| ).
    ENDCASE.

  ENDMETHOD.

  METHOD to_date.

    DATA lv_y TYPE c LENGTH 4.
    DATA lv_m TYPE c LENGTH 2.
    DATA lv_d TYPE c LENGTH 2.

    FIND FIRST OCCURRENCE OF REGEX '^(\d{4})-(\d{2})-(\d{2})(T|$)'
      IN iv_value
      SUBMATCHES lv_y lv_m lv_d.
    IF sy-subrc <> 0.
      zcx_abapgit_ajson_error=>raise( 'Unexpected date format' ).
    ENDIF.
    CONCATENATE lv_y lv_m lv_d INTO rv_result.

  ENDMETHOD.

  METHOD to_timestamp.

    CONSTANTS lc_utc TYPE c LENGTH 6 VALUE 'UTC'.
    CONSTANTS lc_regex_ts_with_hour TYPE string
      VALUE `^(\d{4})-(\d{2})-(\d{2})(T)(\d{2}):(\d{2}):(\d{2})(\+)(\d{2}):(\d{2})`.
    CONSTANTS lc_regex_ts_utc TYPE string
      VALUE `^(\d{4})-(\d{2})-(\d{2})(T)(\d{2}):(\d{2}):(\d{2})(Z|$)`.

    DATA:
      BEGIN OF ls_timestamp,
        year         TYPE c LENGTH 4,
        month        TYPE c LENGTH 2,
        day          TYPE c LENGTH 2,
        t            TYPE c LENGTH 1,
        hour         TYPE c LENGTH 2,
        minute       TYPE c LENGTH 2,
        second       TYPE c LENGTH 2,
        local_sign   TYPE c LENGTH 1,
        local_hour   TYPE c LENGTH 2,
        local_minute TYPE c LENGTH 2,
      END OF ls_timestamp.

    DATA lv_date TYPE d.
    DATA lv_time TYPE t.
    DATA lv_seconds_conv TYPE i.
    DATA lv_timestamp TYPE timestampl.

    FIND FIRST OCCURRENCE OF REGEX lc_regex_ts_with_hour
      IN iv_value SUBMATCHES
        ls_timestamp-year ls_timestamp-month ls_timestamp-day ls_timestamp-t
        ls_timestamp-hour ls_timestamp-minute ls_timestamp-second
        ls_timestamp-local_sign ls_timestamp-local_hour ls_timestamp-local_minute.

    IF sy-subrc = 0.

      lv_seconds_conv = ( ls_timestamp-local_hour * 3600 ) + ( ls_timestamp-local_minute * 60 ).

    ELSE.

      FIND FIRST OCCURRENCE OF REGEX lc_regex_ts_utc
        IN iv_value SUBMATCHES
          ls_timestamp-year ls_timestamp-month ls_timestamp-day ls_timestamp-t
          ls_timestamp-hour ls_timestamp-minute ls_timestamp-second.

      IF sy-subrc <> 0.
        zcx_abapgit_ajson_error=>raise( 'Unexpected timestamp format' ).
      ENDIF.

    ENDIF.

    CONCATENATE ls_timestamp-year ls_timestamp-month ls_timestamp-day INTO lv_date.
    CONCATENATE ls_timestamp-hour ls_timestamp-minute ls_timestamp-second INTO lv_time.

    CONVERT DATE lv_date TIME lv_time INTO TIME STAMP lv_timestamp TIME ZONE lc_utc.

    TRY.

        CASE ls_timestamp-local_sign.
          WHEN '-'.
            lv_timestamp = cl_abap_tstmp=>add(
            tstmp = lv_timestamp
            secs  = lv_seconds_conv ).
          WHEN '+'.
            lv_timestamp = cl_abap_tstmp=>subtractsecs(
            tstmp = lv_timestamp
            secs  = lv_seconds_conv ).
        ENDCASE.

      CATCH cx_parameter_invalid_range cx_parameter_invalid_type.
        zcx_abapgit_ajson_error=>raise( 'Unexpected error calculating timestamp' ).
    ENDTRY.

    IF lv_timestamp IS NOT INITIAL.
      cl_abap_tstmp=>move(
        EXPORTING
          tstmp_src = lv_timestamp
        IMPORTING
          tstmp_tgt = rv_result ).
    ENDIF.

  ENDMETHOD.

  METHOD to_time.

    DATA lv_h TYPE c LENGTH 2.
    DATA lv_m TYPE c LENGTH 2.
    DATA lv_s TYPE c LENGTH 2.

    FIND FIRST OCCURRENCE OF REGEX '^(\d{2}):(\d{2}):(\d{2})(T|$)'
      IN iv_value
      SUBMATCHES lv_h lv_m lv_s.
    IF sy-subrc <> 0.
      zcx_abapgit_ajson_error=>raise( 'Unexpected time format' ).
    ENDIF.
    CONCATENATE lv_h lv_m lv_s INTO rv_result.

  ENDMETHOD.

ENDCLASS.

**********************************************************************
* ABAP_TO_JSON
**********************************************************************

CLASS lcl_abap_to_json DEFINITION FINAL.
  PUBLIC SECTION.

    CLASS-METHODS convert
      IMPORTING
        iv_data           TYPE any
        is_prefix         TYPE zif_abapgit_ajson_types=>ty_path_name OPTIONAL
        iv_array_index    TYPE i DEFAULT 0
        ii_custom_mapping TYPE REF TO zif_abapgit_ajson_mapping OPTIONAL
        is_opts           TYPE zif_abapgit_ajson=>ty_opts OPTIONAL
        iv_item_order     TYPE i DEFAULT 0
      RETURNING
        VALUE(rt_nodes)   TYPE zif_abapgit_ajson_types=>ty_nodes_tt
      RAISING
        zcx_abapgit_ajson_error.

    CLASS-METHODS insert_with_type
      IMPORTING
        iv_data           TYPE any
        iv_type           TYPE zif_abapgit_ajson_types=>ty_node_type
        is_prefix         TYPE zif_abapgit_ajson_types=>ty_path_name OPTIONAL
        iv_array_index    TYPE i DEFAULT 0
        ii_custom_mapping TYPE REF TO zif_abapgit_ajson_mapping OPTIONAL
        is_opts           TYPE zif_abapgit_ajson=>ty_opts OPTIONAL
        iv_item_order     TYPE i DEFAULT 0
      RETURNING
        VALUE(rt_nodes)   TYPE zif_abapgit_ajson_types=>ty_nodes_tt
      RAISING
        zcx_abapgit_ajson_error.

    CLASS-METHODS format_date
      IMPORTING
        iv_date       TYPE d
      RETURNING
        VALUE(rv_str) TYPE string.
    CLASS-METHODS format_time
      IMPORTING
        iv_time       TYPE t
      RETURNING
        VALUE(rv_str) TYPE string.
    CLASS-METHODS format_timestamp
      IMPORTING
        iv_ts         TYPE timestamp
      RETURNING
        VALUE(rv_str) TYPE string.

    CLASS-METHODS class_constructor.

  PRIVATE SECTION.

    CLASS-DATA gv_ajson_absolute_type_name TYPE string.
    DATA mi_custom_mapping TYPE REF TO zif_abapgit_ajson_mapping.
    DATA mv_keep_item_order TYPE abap_bool.
    DATA mv_format_datetime TYPE abap_bool.

    METHODS convert_any
      IMPORTING
        iv_data       TYPE any
        io_type       TYPE REF TO cl_abap_typedescr
        is_prefix     TYPE zif_abapgit_ajson_types=>ty_path_name
        iv_index      TYPE i DEFAULT 0
        iv_item_order TYPE i DEFAULT 0
      CHANGING
        ct_nodes      TYPE zif_abapgit_ajson_types=>ty_nodes_tt
      RAISING
        zcx_abapgit_ajson_error.

    METHODS convert_ajson
      IMPORTING
        io_json       TYPE REF TO zif_abapgit_ajson
        is_prefix     TYPE zif_abapgit_ajson_types=>ty_path_name
        iv_index      TYPE i DEFAULT 0
        iv_item_order TYPE i DEFAULT 0
      CHANGING
        ct_nodes      TYPE zif_abapgit_ajson_types=>ty_nodes_tt
      RAISING
        zcx_abapgit_ajson_error.

    METHODS convert_value
      IMPORTING
        iv_data       TYPE any
        io_type       TYPE REF TO cl_abap_typedescr
        is_prefix     TYPE zif_abapgit_ajson_types=>ty_path_name
        iv_index      TYPE i DEFAULT 0
        iv_item_order TYPE i DEFAULT 0
      CHANGING
        ct_nodes      TYPE zif_abapgit_ajson_types=>ty_nodes_tt
      RAISING
        zcx_abapgit_ajson_error.

    METHODS convert_ref
      IMPORTING
        iv_data       TYPE any
        is_prefix     TYPE zif_abapgit_ajson_types=>ty_path_name
        iv_index      TYPE i DEFAULT 0
        iv_item_order TYPE i DEFAULT 0
      CHANGING
        ct_nodes      TYPE zif_abapgit_ajson_types=>ty_nodes_tt
      RAISING
        zcx_abapgit_ajson_error.

    METHODS convert_struc
      IMPORTING
        iv_data       TYPE any
        io_type       TYPE REF TO cl_abap_typedescr
        is_prefix     TYPE zif_abapgit_ajson_types=>ty_path_name
        iv_index      TYPE i DEFAULT 0
        iv_item_order TYPE i DEFAULT 0
      CHANGING
        ct_nodes      TYPE zif_abapgit_ajson_types=>ty_nodes_tt
      RAISING
        zcx_abapgit_ajson_error.

    METHODS convert_table
      IMPORTING
        iv_data       TYPE any
        io_type       TYPE REF TO cl_abap_typedescr
        is_prefix     TYPE zif_abapgit_ajson_types=>ty_path_name
        iv_index      TYPE i DEFAULT 0
        iv_item_order TYPE i DEFAULT 0
      CHANGING
        ct_nodes      TYPE zif_abapgit_ajson_types=>ty_nodes_tt
      RAISING
        zcx_abapgit_ajson_error.

    METHODS insert_value_with_type
      IMPORTING
        iv_data       TYPE any
        iv_type       TYPE zif_abapgit_ajson_types=>ty_node_type
        io_type       TYPE REF TO cl_abap_typedescr
        is_prefix     TYPE zif_abapgit_ajson_types=>ty_path_name
        iv_index      TYPE i DEFAULT 0
        iv_item_order TYPE i DEFAULT 0
      CHANGING
        ct_nodes      TYPE zif_abapgit_ajson_types=>ty_nodes_tt
      RAISING
        zcx_abapgit_ajson_error.

ENDCLASS.

CLASS lcl_abap_to_json IMPLEMENTATION.

  METHOD class_constructor.

    DATA lo_dummy TYPE REF TO zcl_abapgit_ajson.
    DATA lo_type TYPE REF TO cl_abap_refdescr.
    lo_type ?= cl_abap_typedescr=>describe_by_data( lo_dummy ).
    gv_ajson_absolute_type_name = lo_type->get_referenced_type( )->absolute_name.

  ENDMETHOD.

  METHOD convert.

    DATA lo_type TYPE REF TO cl_abap_typedescr.
    DATA lo_converter TYPE REF TO lcl_abap_to_json.

    lo_type = cl_abap_typedescr=>describe_by_data( iv_data ).

    CREATE OBJECT lo_converter.
    lo_converter->mi_custom_mapping  = ii_custom_mapping.
    lo_converter->mv_keep_item_order = is_opts-keep_item_order.
    lo_converter->mv_format_datetime = is_opts-format_datetime.

    lo_converter->convert_any(
      EXPORTING
        iv_data       = iv_data
        io_type       = lo_type
        is_prefix     = is_prefix
        iv_index      = iv_array_index
        iv_item_order = iv_item_order
      CHANGING
        ct_nodes = rt_nodes ).

  ENDMETHOD.

  METHOD convert_any.

    CASE io_type->kind.
      WHEN cl_abap_typedescr=>kind_elem.
        convert_value(
          EXPORTING
            iv_data   = iv_data
            io_type   = io_type
            is_prefix = is_prefix
            iv_index  = iv_index
            iv_item_order = iv_item_order
          CHANGING
            ct_nodes = ct_nodes ).

      WHEN cl_abap_typedescr=>kind_struct.
        convert_struc(
          EXPORTING
            iv_data   = iv_data
            io_type   = io_type
            is_prefix = is_prefix
            iv_index  = iv_index
            iv_item_order = iv_item_order
          CHANGING
            ct_nodes = ct_nodes ).

      WHEN cl_abap_typedescr=>kind_table.
        convert_table(
          EXPORTING
            iv_data   = iv_data
            io_type   = io_type
            is_prefix = is_prefix
            iv_index  = iv_index
            iv_item_order = iv_item_order
          CHANGING
            ct_nodes = ct_nodes ).

      WHEN OTHERS.

        IF io_type->type_kind = lif_kind=>data_ref OR iv_data IS INITIAL.
          " Convert data references and initial references to other types (like ref to class or interface)
          " Initial references will result in "null"
          convert_ref(
            EXPORTING
              iv_data   = iv_data
              is_prefix = is_prefix
              iv_index  = iv_index
              iv_item_order = iv_item_order
            CHANGING
              ct_nodes = ct_nodes ).

        ELSEIF io_type->type_kind = lif_kind=>object_ref
          AND cl_abap_typedescr=>describe_by_object_ref( iv_data )->absolute_name = gv_ajson_absolute_type_name.
          convert_ajson(
            EXPORTING
              io_json   = iv_data
              is_prefix = is_prefix
              iv_index  = iv_index
              iv_item_order = iv_item_order
            CHANGING
              ct_nodes = ct_nodes ).
        ELSE.
          zcx_abapgit_ajson_error=>raise( |Unsupported type [{ io_type->type_kind
            }] @{ is_prefix-path && is_prefix-name }| ).
        ENDIF.

    ENDCASE.

  ENDMETHOD.

  METHOD convert_ajson.

    FIELD-SYMBOLS <src> LIKE LINE OF ct_nodes.
    FIELD-SYMBOLS <dst> LIKE LINE OF ct_nodes.

    IF io_json IS NOT BOUND.
      RETURN.
    ENDIF.

    LOOP AT io_json->mt_json_tree ASSIGNING <src>.
      APPEND <src> TO ct_nodes ASSIGNING <dst>.

      IF <dst>-path IS INITIAL AND <dst>-name IS INITIAL. " root node
        <dst>-path  = is_prefix-path.
        <dst>-name  = is_prefix-name.
        <dst>-index = iv_index.
        <dst>-order = iv_item_order.
      ELSE.
        <dst>-path = is_prefix-path && is_prefix-name && <dst>-path.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD format_date.
    IF iv_date IS NOT INITIAL.
      rv_str = iv_date+0(4) && '-' && iv_date+4(2) && '-' && iv_date+6(2).
    ENDIF.
  ENDMETHOD.

  METHOD format_time.
    IF iv_time IS NOT INITIAL.
      rv_str = iv_time+0(2) && ':' && iv_time+2(2) && ':' && iv_time+4(2).
    ENDIF.
  ENDMETHOD.

  METHOD format_timestamp.

    CONSTANTS lc_utc TYPE c LENGTH 6 VALUE 'UTC'.

    DATA lv_date TYPE d.
    DATA lv_time TYPE t.

    CONVERT TIME STAMP iv_ts TIME ZONE lc_utc
      INTO DATE lv_date TIME lv_time.

    rv_str =
      lv_date+0(4) && '-' && lv_date+4(2) && '-' && lv_date+6(2) &&
      'T' &&
      lv_time+0(2) && ':' && lv_time+2(2) && ':' && lv_time+4(2) &&
      'Z'.

  ENDMETHOD.

  METHOD convert_value.

    DATA ls_node LIKE LINE OF ct_nodes.

    ls_node-path  = is_prefix-path.
    ls_node-name  = is_prefix-name.
    ls_node-index = iv_index.
    ls_node-order = iv_item_order.

    IF ls_node-name IS INITIAL.
      ls_node-name  = is_prefix-name.
    ENDIF.

    IF io_type->absolute_name = '\TYPE-POOL=ABAP\TYPE=ABAP_BOOL'
        OR io_type->absolute_name = '\TYPE=ABAP_BOOLEAN'
        OR io_type->absolute_name = '\TYPE=XSDBOOLEAN'
        OR io_type->absolute_name = '\TYPE=FLAG'
        OR io_type->absolute_name = '\TYPE=XFELD'.
      ls_node-type = zif_abapgit_ajson_types=>node_type-boolean.
      IF iv_data IS NOT INITIAL.
        ls_node-value = 'true'.
      ELSE.
        ls_node-value = 'false'.
      ENDIF.
    ELSEIF io_type->absolute_name = '\TYPE=TIMESTAMP'.
      IF mv_format_datetime = abap_true.
        ls_node-type  = zif_abapgit_ajson_types=>node_type-string.
        ls_node-value = format_timestamp( iv_data ).
      ELSE.
        ls_node-type  = zif_abapgit_ajson_types=>node_type-number.
        ls_node-value = |{ iv_data }|.
      ENDIF.
    ELSEIF io_type->type_kind CO lif_kind=>texts OR
           io_type->type_kind CO lif_kind=>binary OR
           io_type->type_kind CO lif_kind=>enum.
      ls_node-type = zif_abapgit_ajson_types=>node_type-string.
      ls_node-value = |{ iv_data }|.
    ELSEIF io_type->type_kind = lif_kind=>date.
      ls_node-type = zif_abapgit_ajson_types=>node_type-string.
      IF mv_format_datetime = abap_true.
        ls_node-value = format_date( iv_data ).
      ELSE.
        ls_node-value = |{ iv_data }|.
      ENDIF.
    ELSEIF io_type->type_kind = lif_kind=>time.
      ls_node-type = zif_abapgit_ajson_types=>node_type-string.
      IF mv_format_datetime = abap_true.
        ls_node-value = format_time( iv_data ).
      ELSE.
        ls_node-value = |{ iv_data }|.
      ENDIF.
    ELSEIF io_type->type_kind CO lif_kind=>numeric.
      ls_node-type = zif_abapgit_ajson_types=>node_type-number.
      ls_node-value = |{ iv_data }|.
    ELSE.
      zcx_abapgit_ajson_error=>raise( |Unexpected elementary type [{
        io_type->type_kind }] @{ is_prefix-path && is_prefix-name }| ).
    ENDIF.

    APPEND ls_node TO ct_nodes.

  ENDMETHOD.

  METHOD convert_ref.

    DATA ls_node LIKE LINE OF ct_nodes.

    ls_node-path  = is_prefix-path.
    ls_node-name  = is_prefix-name.
    ls_node-index = iv_index.
    ls_node-order = iv_item_order.

    IF mi_custom_mapping IS BOUND.
      ls_node-name = mi_custom_mapping->to_json(
        iv_path = is_prefix-path
        iv_name = is_prefix-name ).
    ENDIF.

    IF ls_node-name IS INITIAL.
      ls_node-name  = is_prefix-name.
    ENDIF.

    IF iv_data IS INITIAL.
      ls_node-type  = zif_abapgit_ajson_types=>node_type-null.
      ls_node-value = 'null'.
    ELSE.
      " TODO support data references
      zcx_abapgit_ajson_error=>raise( |Unexpected reference @{ is_prefix-path && is_prefix-name }| ).
    ENDIF.

    APPEND ls_node TO ct_nodes.

  ENDMETHOD.

  METHOD convert_struc.

    DATA lo_struc TYPE REF TO cl_abap_structdescr.
    DATA lt_comps TYPE cl_abap_structdescr=>included_view.
    DATA ls_next_prefix LIKE is_prefix.
    DATA lv_mapping_prefix_name LIKE is_prefix-name.
    DATA lv_item_order TYPE i.
    DATA ls_root LIKE LINE OF ct_nodes.

    FIELD-SYMBOLS <root> LIKE ls_root.
    FIELD-SYMBOLS <c> LIKE LINE OF lt_comps.
    FIELD-SYMBOLS <val> TYPE any.

    " Object root

    ls_root-path  = is_prefix-path.
    ls_root-name  = is_prefix-name.
    ls_root-type  = zif_abapgit_ajson_types=>node_type-object.
    ls_root-index = iv_index.

    IF mi_custom_mapping IS BOUND.
      ls_root-name = mi_custom_mapping->to_json(
        iv_path = is_prefix-path
        iv_name = is_prefix-name ).
    ENDIF.

    IF ls_root-name IS INITIAL.
      ls_root-name  = is_prefix-name.
    ENDIF.

    ls_root-order = iv_item_order.

    APPEND ls_root TO ct_nodes ASSIGNING <root>.

    " Object attributes

    lo_struc ?= io_type.
    lt_comps = lo_struc->get_included_view( ).
    " replaced call to get_components() with get_included_view() to avoid problems with suffixes in includes.
    " get_components is potentially much slower than lo_struc->components
    " but ! we still need it to identify booleans
    " and rtti seems to cache type descriptions really well (https://github.com/sbcgua/benchmarks.git)
    " the structures will be repeated in real life

    ls_next_prefix-path = is_prefix-path && <root>-name && '/'.

    LOOP AT lt_comps ASSIGNING <c>.
      CLEAR lv_mapping_prefix_name.

      <root>-children = <root>-children + 1.
      ls_next_prefix-name = to_lower( <c>-name ).
      ASSIGN COMPONENT <c>-name OF STRUCTURE iv_data TO <val>.
      ASSERT sy-subrc = 0.

      IF mi_custom_mapping IS BOUND AND <c>-type->kind = cl_abap_typedescr=>kind_elem.
        lv_mapping_prefix_name = mi_custom_mapping->to_json( iv_path = ls_next_prefix-path
                                                             iv_name = ls_next_prefix-name ).
      ENDIF.

      IF lv_mapping_prefix_name IS NOT INITIAL.
        ls_next_prefix-name = lv_mapping_prefix_name.
      ENDIF.

      IF mv_keep_item_order = abap_true.
        lv_item_order = <root>-children.
      ENDIF.

      convert_any(
        EXPORTING
          iv_data   = <val>
          io_type   = <c>-type
          is_prefix = ls_next_prefix
          iv_item_order = lv_item_order
        CHANGING
          ct_nodes = ct_nodes ).

    ENDLOOP.

  ENDMETHOD.

  METHOD convert_table.

    DATA lo_table TYPE REF TO cl_abap_tabledescr.
    DATA lo_ltype TYPE REF TO cl_abap_typedescr.
    DATA ls_next_prefix LIKE is_prefix.
    DATA lv_tabix TYPE sy-tabix.
    DATA ls_root LIKE LINE OF ct_nodes.

    FIELD-SYMBOLS <root> LIKE ls_root.
    FIELD-SYMBOLS <tab> TYPE ANY TABLE.
    FIELD-SYMBOLS <val> TYPE any.

    " Array root

    ls_root-path  = is_prefix-path.
    ls_root-name  = is_prefix-name.
    ls_root-type  = zif_abapgit_ajson_types=>node_type-array.
    ls_root-index = iv_index.
    ls_root-order = iv_item_order.

    IF mi_custom_mapping IS BOUND.
      ls_root-name = mi_custom_mapping->to_json(
        iv_path = is_prefix-path
        iv_name = is_prefix-name ).
    ENDIF.

    IF ls_root-name IS INITIAL.
      ls_root-name  = is_prefix-name.
    ENDIF.

    APPEND ls_root TO ct_nodes ASSIGNING <root>.

    " Array items

    lo_table ?= io_type.
    lo_ltype  = lo_table->get_table_line_type( ).

    ls_next_prefix-path = is_prefix-path && <root>-name && '/'.
    ASSIGN iv_data TO <tab>.

    lv_tabix = 1.
    LOOP AT <tab> ASSIGNING <val>.
      ls_next_prefix-name = to_lower( |{ lv_tabix }| ).

      convert_any(
        EXPORTING
          iv_data   = <val>
          io_type   = lo_ltype
          is_prefix = ls_next_prefix
          iv_index  = <root>-children + 1
        CHANGING
          ct_nodes = ct_nodes ).

      <root>-children = <root>-children + 1.
      lv_tabix = lv_tabix + 1.
    ENDLOOP.

  ENDMETHOD.

  METHOD insert_with_type.

    DATA lo_type TYPE REF TO cl_abap_typedescr.
    DATA lo_converter TYPE REF TO lcl_abap_to_json.

    lo_type = cl_abap_typedescr=>describe_by_data( iv_data ).

    CREATE OBJECT lo_converter.
    lo_converter->mi_custom_mapping  = ii_custom_mapping.
    lo_converter->mv_keep_item_order = is_opts-keep_item_order.
    lo_converter->mv_format_datetime = is_opts-format_datetime.

    lo_converter->insert_value_with_type(
      EXPORTING
        iv_data       = iv_data
        iv_type       = iv_type
        io_type       = lo_type
        is_prefix     = is_prefix
        iv_index      = iv_array_index
        iv_item_order = iv_item_order
      CHANGING
        ct_nodes = rt_nodes ).

  ENDMETHOD.

  METHOD insert_value_with_type.

    DATA lv_prefix TYPE string.
    DATA ls_node LIKE LINE OF ct_nodes.

    lv_prefix = is_prefix-path && is_prefix-name.
    IF io_type->type_kind CO lif_kind=>texts OR
       io_type->type_kind CO lif_kind=>date OR
       io_type->type_kind CO lif_kind=>time.
      IF iv_type = zif_abapgit_ajson_types=>node_type-boolean AND iv_data <> 'true' AND iv_data <> 'false'.
        zcx_abapgit_ajson_error=>raise( |Unexpected boolean value [{ iv_data }] @{ lv_prefix }| ).
      ELSEIF iv_type = zif_abapgit_ajson_types=>node_type-null AND iv_data IS NOT INITIAL.
        zcx_abapgit_ajson_error=>raise( |Unexpected null value [{ iv_data }] @{ lv_prefix }| ).
      ELSEIF iv_type = zif_abapgit_ajson_types=>node_type-number AND iv_data CN '0123456789. E+-'.
        zcx_abapgit_ajson_error=>raise( |Unexpected numeric value [{ iv_data }] @{ lv_prefix }| ).
      ELSEIF iv_type <> zif_abapgit_ajson_types=>node_type-string AND iv_type <> zif_abapgit_ajson_types=>node_type-boolean
        AND iv_type <> zif_abapgit_ajson_types=>node_type-null AND iv_type <> zif_abapgit_ajson_types=>node_type-number.
        zcx_abapgit_ajson_error=>raise( |Unexpected type for value [{ iv_type },{ iv_data }] @{ lv_prefix }| ).
      ENDIF.
    ELSEIF io_type->type_kind CO lif_kind=>numeric.
      IF iv_type <> zif_abapgit_ajson_types=>node_type-number.
        zcx_abapgit_ajson_error=>raise( |Unexpected value for numeric [{ iv_data }] @{ lv_prefix }| ).
      ENDIF.
    ELSE.
      zcx_abapgit_ajson_error=>raise( |Unexpected type [{ io_type->type_kind }] @{ lv_prefix }| ).
    ENDIF.

    ls_node-path  = is_prefix-path.
    ls_node-name  = is_prefix-name.
    ls_node-index = iv_index.
    ls_node-value = iv_data.
    ls_node-type  = iv_type.
    ls_node-order = iv_item_order.

    IF mi_custom_mapping IS BOUND.
      ls_node-name = mi_custom_mapping->to_json(
        iv_path = is_prefix-path
        iv_name = is_prefix-name ).
    ENDIF.

    IF ls_node-name IS INITIAL.
      ls_node-name  = is_prefix-name.
    ENDIF.

    APPEND ls_node TO ct_nodes.

  ENDMETHOD.

ENDCLASS.

**********************************************************************
* MUTATOR INTERFACE
**********************************************************************

INTERFACE lif_mutator_runner.
  METHODS run
    IMPORTING
      it_source_tree TYPE zif_abapgit_ajson_types=>ty_nodes_ts
    EXPORTING
      et_dest_tree   TYPE zif_abapgit_ajson_types=>ty_nodes_ts
    RAISING
      zcx_abapgit_ajson_error.
ENDINTERFACE.

**********************************************************************
* FILTER RUNNER
**********************************************************************

CLASS lcl_filter_runner DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES lif_mutator_runner.
    CLASS-METHODS new
      IMPORTING
        ii_filter          TYPE REF TO zif_abapgit_ajson_filter
      RETURNING
        VALUE(ro_instance) TYPE REF TO lcl_filter_runner.
    METHODS constructor
      IMPORTING
        ii_filter TYPE REF TO zif_abapgit_ajson_filter.

  PRIVATE SECTION.
    DATA mi_filter TYPE REF TO zif_abapgit_ajson_filter.
    DATA mr_source_tree TYPE REF TO zif_abapgit_ajson_types=>ty_nodes_ts.
    DATA mr_dest_tree TYPE REF TO zif_abapgit_ajson_types=>ty_nodes_ts.

    METHODS walk
      IMPORTING
        iv_path   TYPE string
      CHANGING
        cs_parent TYPE zif_abapgit_ajson_types=>ty_node OPTIONAL
      RAISING
        zcx_abapgit_ajson_error.

ENDCLASS.

CLASS lcl_filter_runner IMPLEMENTATION.

  METHOD new.
    CREATE OBJECT ro_instance EXPORTING ii_filter = ii_filter.
  ENDMETHOD.

  METHOD constructor.
    ASSERT ii_filter IS BOUND.
    mi_filter = ii_filter.
  ENDMETHOD.

  METHOD lif_mutator_runner~run.

    CLEAR et_dest_tree.
    GET REFERENCE OF it_source_tree INTO mr_source_tree.
    GET REFERENCE OF et_dest_tree INTO mr_dest_tree.

    walk( iv_path = '' ).

  ENDMETHOD.

  METHOD walk.

    DATA ls_node TYPE zif_abapgit_ajson_types=>ty_node.
    DATA lv_tab_key TYPE string.

    IF cs_parent-type = zif_abapgit_ajson_types=>node_type-array.
      lv_tab_key = 'array_index'. " path + index
    ENDIF.

    LOOP AT mr_source_tree->* INTO ls_node USING KEY (lv_tab_key) WHERE path = iv_path.
      CASE ls_node-type.
        WHEN zif_abapgit_ajson_types=>node_type-boolean OR zif_abapgit_ajson_types=>node_type-null
          OR zif_abapgit_ajson_types=>node_type-number OR zif_abapgit_ajson_types=>node_type-string.

          IF mi_filter->keep_node( ls_node ) = abap_false.
            CONTINUE.
          ENDIF.

        WHEN zif_abapgit_ajson_types=>node_type-array OR zif_abapgit_ajson_types=>node_type-object.

          IF mi_filter->keep_node(
              is_node  = ls_node
              iv_visit = zif_abapgit_ajson_filter=>visit_type-open ) = abap_false.
            CONTINUE.
          ENDIF.

          " Intentionally clear AFTER "open"
          CLEAR ls_node-children.

          walk(
            EXPORTING
              iv_path = iv_path && ls_node-name && `/`
            CHANGING
              cs_parent    = ls_node ).

          IF mi_filter->keep_node(
              is_node  = ls_node
              iv_visit = zif_abapgit_ajson_filter=>visit_type-close ) = abap_false.
            CONTINUE.
          ENDIF.

        WHEN OTHERS.
          zcx_abapgit_ajson_error=>raise( |Unexpected node type { ls_node-type }| ).
      ENDCASE.

      IF cs_parent IS SUPPLIED.
        cs_parent-children = cs_parent-children + 1.
        IF cs_parent-type = zif_abapgit_ajson_types=>node_type-array.
          ls_node-name  = |{ cs_parent-children }|.
          ls_node-index = cs_parent-children.
        ENDIF.
      ENDIF.
      INSERT ls_node INTO TABLE mr_dest_tree->*.

    ENDLOOP.

  ENDMETHOD.

ENDCLASS.

**********************************************************************
* MAPPER RUNNER
**********************************************************************

CLASS lcl_mapper_runner DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES lif_mutator_runner.
    CLASS-METHODS new
      IMPORTING
        ii_mapper          TYPE REF TO zif_abapgit_ajson_mapping
      RETURNING
        VALUE(ro_instance) TYPE REF TO lcl_mapper_runner.
    METHODS constructor
      IMPORTING
        ii_mapper TYPE REF TO zif_abapgit_ajson_mapping.

  PRIVATE SECTION.
    DATA mi_mapper TYPE REF TO zif_abapgit_ajson_mapping.
    DATA mr_source_tree TYPE REF TO zif_abapgit_ajson_types=>ty_nodes_ts.
    DATA mr_dest_tree TYPE REF TO zif_abapgit_ajson_types=>ty_nodes_ts.

    METHODS process_deep_node
      IMPORTING
        iv_path         TYPE string
        iv_renamed_path TYPE string
        iv_node_type    TYPE zif_abapgit_ajson_types=>ty_node-type
      RAISING
        zcx_abapgit_ajson_error.

ENDCLASS.

CLASS lcl_mapper_runner IMPLEMENTATION.

  METHOD new.
    CREATE OBJECT ro_instance EXPORTING ii_mapper = ii_mapper.
  ENDMETHOD.

  METHOD constructor.
    ASSERT ii_mapper IS BOUND.
    mi_mapper = ii_mapper.
  ENDMETHOD.

  METHOD lif_mutator_runner~run.

    FIELD-SYMBOLS <root> LIKE LINE OF it_source_tree.

    READ TABLE it_source_tree WITH KEY path = `` name = `` ASSIGNING <root>.
    IF sy-subrc <> 0
      OR NOT ( <root>-type = zif_abapgit_ajson_types=>node_type-array OR <root>-type = zif_abapgit_ajson_types=>node_type-object ).
      " empty or one-value-only tree
      et_dest_tree = it_source_tree.
      RETURN.
    ENDIF.

    CLEAR et_dest_tree.
    GET REFERENCE OF it_source_tree INTO mr_source_tree.
    GET REFERENCE OF et_dest_tree INTO mr_dest_tree.
    INSERT <root> INTO TABLE et_dest_tree.

    process_deep_node(
      iv_path         = `/`
      iv_renamed_path = `/`
      iv_node_type    = <root>-type ).

  ENDMETHOD.

  METHOD process_deep_node.

    FIELD-SYMBOLS <item> LIKE LINE OF mr_source_tree->*.
    DATA ls_renamed_node LIKE <item>.

    LOOP AT mr_source_tree->* ASSIGNING <item> WHERE path = iv_path.
      ls_renamed_node = <item>.
      IF iv_node_type <> zif_abapgit_ajson_types=>node_type-array.
        " don't rename array item names -> they are numeric index
        mi_mapper->rename_node(
          EXPORTING
            is_node = <item>
          CHANGING
            cv_name = ls_renamed_node-name ).
        IF ls_renamed_node-name IS INITIAL.
          zcx_abapgit_ajson_error=>raise(
            iv_msg  = 'Renamed node name cannot be empty'
            is_node = <item> ).
        ENDIF.
      ENDIF.
      ls_renamed_node-path = iv_renamed_path.

      INSERT ls_renamed_node INTO TABLE mr_dest_tree->*.
      IF sy-subrc <> 0. " = 4 ?
        zcx_abapgit_ajson_error=>raise(
          iv_msg  = 'Renamed node has a duplicate'
          is_node = ls_renamed_node ).
      ENDIF.

      " maybe also catch CX_SY_ITAB_DUPLICATE_KEY but secondary keys are not changed here, so not for now

      IF <item>-type = zif_abapgit_ajson_types=>node_type-array OR <item>-type = zif_abapgit_ajson_types=>node_type-object.
        process_deep_node(
          iv_path         = iv_path && <item>-name && `/`
          iv_renamed_path = iv_renamed_path && ls_renamed_node-name && `/`
          iv_node_type    = <item>-type ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

ENDCLASS.

**********************************************************************
* MUTATOR QUEUE
**********************************************************************

CLASS lcl_mutator_queue DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES lif_mutator_runner.
    CLASS-METHODS new
      RETURNING
        VALUE(ro_instance) TYPE REF TO lcl_mutator_queue.
    METHODS add
      IMPORTING
        ii_mutator     TYPE REF TO lif_mutator_runner
      RETURNING
        VALUE(ro_self) TYPE REF TO lcl_mutator_queue.

  PRIVATE SECTION.
    DATA mt_queue TYPE STANDARD TABLE OF REF TO lif_mutator_runner.

ENDCLASS.

CLASS lcl_mutator_queue IMPLEMENTATION.

  METHOD add.
    IF ii_mutator IS BOUND.
      APPEND ii_mutator TO mt_queue.
    ENDIF.
    ro_self = me.
  ENDMETHOD.

  METHOD new.
    CREATE OBJECT ro_instance.
  ENDMETHOD.

  METHOD lif_mutator_runner~run.

    DATA li_mutator TYPE REF TO lif_mutator_runner.
    DATA lv_qsize TYPE i.
    FIELD-SYMBOLS <from> LIKE it_source_tree.
    FIELD-SYMBOLS <to> LIKE it_source_tree.
    DATA lr_buf TYPE REF TO zif_abapgit_ajson_types=>ty_nodes_ts.

    lv_qsize = lines( mt_queue ).

    IF lv_qsize = 0.
      et_dest_tree = it_source_tree.
      RETURN.
    ENDIF.

    LOOP AT mt_queue INTO li_mutator.
      IF sy-tabix = 1.
        ASSIGN it_source_tree TO <from>.
      ELSE.
        ASSIGN lr_buf->* TO <from>.
      ENDIF.

      IF sy-tabix = lv_qsize.
        ASSIGN et_dest_tree TO <to>.
      ELSE.
        CREATE DATA lr_buf.
        ASSIGN lr_buf->* TO <to>.
      ENDIF.

      li_mutator->run(
        EXPORTING
          it_source_tree = <from>
        IMPORTING
          et_dest_tree = <to> ).
    ENDLOOP.

  ENDMETHOD.

ENDCLASS.

CLASS zcl_abapgit_ajson IMPLEMENTATION.

  METHOD constructor.
    ms_opts-keep_item_order = iv_keep_item_order.
    ms_opts-to_abap_corresponding_only = iv_to_abap_corresponding_only.
    format_datetime( iv_format_datetime ).
  ENDMETHOD.

  METHOD create_empty.
    CREATE OBJECT ro_instance
      EXPORTING
        iv_to_abap_corresponding_only = iv_to_abap_corresponding_only
        iv_format_datetime = iv_format_datetime
        iv_keep_item_order = iv_keep_item_order.
    ro_instance->mi_custom_mapping = ii_custom_mapping.
  ENDMETHOD.

  METHOD create_from.

    DATA lo_mutator_queue TYPE REF TO lcl_mutator_queue.

    IF ii_source_json IS NOT BOUND.
      zcx_abapgit_ajson_error=>raise( 'Source not bound' ).
    ENDIF.

    CREATE OBJECT ro_instance
      EXPORTING
        iv_to_abap_corresponding_only = ii_source_json->opts( )-to_abap_corresponding_only
        iv_format_datetime = ii_source_json->opts( )-format_datetime
        iv_keep_item_order = ii_source_json->opts( )-keep_item_order.

    IF ii_filter IS NOT BOUND AND ii_mapper IS NOT BOUND.
      ro_instance->mt_json_tree = ii_source_json->mt_json_tree.
    ELSE.
      CREATE OBJECT lo_mutator_queue.
      IF ii_mapper IS BOUND.
        " Mapping goes first. But maybe it should be a freely definable queue of processors ?
        lo_mutator_queue->add( lcl_mapper_runner=>new( ii_mapper ) ).
      ENDIF.
      IF ii_filter IS BOUND.
        lo_mutator_queue->add( lcl_filter_runner=>new( ii_filter ) ).
      ENDIF.
      lo_mutator_queue->lif_mutator_runner~run(
        EXPORTING
          it_source_tree = ii_source_json->mt_json_tree
        IMPORTING
          et_dest_tree = ro_instance->mt_json_tree ).
    ENDIF.

  ENDMETHOD.

  METHOD delete_subtree.

    DATA lv_parent_path TYPE string.
    DATA lr_parent LIKE ir_parent.

    READ TABLE mt_json_tree INTO rs_top_node
      WITH KEY
        path = iv_path
        name = iv_name.
    IF sy-subrc <> 0.
      RETURN. " Not found ? nothing to delete !
    ENDIF.

    DELETE mt_json_tree INDEX sy-tabix. " where path = iv_path and name = iv_name.

    IF rs_top_node-children > 0. " only for objects and arrays
      lv_parent_path = iv_path && iv_name && '/*'.
      DELETE mt_json_tree WHERE path CP lv_parent_path.
    ENDIF.

    " decrement parent children
    IF ir_parent IS SUPPLIED.
      ir_parent->children = ir_parent->children - 1.
    ELSE.
      lr_parent = get_item( iv_path ).
      IF lr_parent IS NOT INITIAL.
        lr_parent->children = lr_parent->children - 1.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD get_item.

    FIELD-SYMBOLS <item> LIKE LINE OF mt_json_tree.
    DATA ls_path_name TYPE zif_abapgit_ajson_types=>ty_path_name.
    ls_path_name = lcl_utils=>split_path( iv_path ).

    READ TABLE mt_json_tree
      ASSIGNING <item>
      WITH KEY
        path = ls_path_name-path
        name = ls_path_name-name.
    IF sy-subrc = 0.
      GET REFERENCE OF <item> INTO rv_item.
    ENDIF.

  ENDMETHOD.

  METHOD new.
    CREATE OBJECT ro_instance
      EXPORTING
        iv_to_abap_corresponding_only = iv_to_abap_corresponding_only
        iv_format_datetime = iv_format_datetime
        iv_keep_item_order = iv_keep_item_order.
  ENDMETHOD.

  METHOD parse.

    DATA lo_parser TYPE REF TO lcl_json_parser.

    CREATE OBJECT ro_instance.
    CREATE OBJECT lo_parser.
    ro_instance->mt_json_tree = lo_parser->parse(
      iv_json            = iv_json
      iv_keep_item_order = iv_keep_item_order ).
    ro_instance->mi_custom_mapping = ii_custom_mapping.
    ro_instance->ms_opts-keep_item_order = iv_keep_item_order.

    IF iv_freeze = abap_true.
      ro_instance->freeze( ).
    ENDIF.

  ENDMETHOD.

  METHOD prove_path_exists.

    DATA lt_path TYPE string_table.
    DATA lr_node_parent LIKE rr_end_node.
    DATA lv_cur_path TYPE string.
    DATA lv_cur_name TYPE string.
    DATA ls_new_node LIKE LINE OF mt_json_tree.

    SPLIT iv_path AT '/' INTO TABLE lt_path.
    DELETE lt_path WHERE table_line IS INITIAL.

    DO.
      lr_node_parent = rr_end_node.
      READ TABLE mt_json_tree REFERENCE INTO rr_end_node
        WITH KEY
          path = lv_cur_path
          name = lv_cur_name.
      IF sy-subrc <> 0. " New node, assume it is always object as it has a named child, use touch_array to init array
        CLEAR ls_new_node.
        IF lr_node_parent IS NOT INITIAL. " if has parent
          lr_node_parent->children = lr_node_parent->children + 1.
          IF lr_node_parent->type = zif_abapgit_ajson_types=>node_type-array.
            ls_new_node-index = lcl_utils=>validate_array_index(
              iv_path  = lv_cur_path
              iv_index = lv_cur_name ).
          ENDIF.
        ENDIF.
        ls_new_node-path = lv_cur_path.
        ls_new_node-name = lv_cur_name.
        ls_new_node-type = zif_abapgit_ajson_types=>node_type-object.
        INSERT ls_new_node INTO TABLE mt_json_tree REFERENCE INTO rr_end_node.
      ENDIF.
      lv_cur_path = lv_cur_path && lv_cur_name && '/'.
      READ TABLE lt_path INDEX sy-index INTO lv_cur_name.
      IF sy-subrc <> 0.
        EXIT. " no more segments
      ENDIF.
    ENDDO.

  ENDMETHOD.

  METHOD read_only_watchdog.
    IF ms_opts-read_only = abap_true.
      zcx_abapgit_ajson_error=>raise( 'This json instance is read only' ).
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_ajson~array_to_string_table.

    DATA lv_normalized_path TYPE string.
    DATA lr_node TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    FIELD-SYMBOLS <item> LIKE LINE OF mt_json_tree.

    lv_normalized_path = lcl_utils=>normalize_path( iv_path ).
    lr_node = get_item( iv_path ).

    IF lr_node IS INITIAL.
      zcx_abapgit_ajson_error=>raise( |Path not found: { iv_path }| ).
    ENDIF.
    IF lr_node->type <> zif_abapgit_ajson_types=>node_type-array.
      zcx_abapgit_ajson_error=>raise( |Array expected at: { iv_path }| ).
    ENDIF.

    LOOP AT mt_json_tree ASSIGNING <item> WHERE path = lv_normalized_path.
      CASE <item>-type.
        WHEN zif_abapgit_ajson_types=>node_type-number OR zif_abapgit_ajson_types=>node_type-string.
          APPEND <item>-value TO rt_string_table.
        WHEN zif_abapgit_ajson_types=>node_type-null.
          APPEND '' TO rt_string_table.
        WHEN zif_abapgit_ajson_types=>node_type-boolean.
          DATA lv_tmp TYPE string.
          IF <item>-value = 'true'.
            lv_tmp = abap_true.
          ELSE.
            CLEAR lv_tmp.
          ENDIF.
          APPEND lv_tmp TO rt_string_table.
        WHEN OTHERS.
          zcx_abapgit_ajson_error=>raise( |Cannot convert [{ <item>-type
            }] to string at [{ <item>-path }{ <item>-name }]| ).
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~clear.

    read_only_watchdog( ).
    CLEAR mt_json_tree.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~clone.
    ri_json = create_from( me ).
  ENDMETHOD.

  METHOD zif_abapgit_ajson~delete.

    read_only_watchdog( ).

    DATA ls_split_path TYPE zif_abapgit_ajson_types=>ty_path_name.
    ls_split_path = lcl_utils=>split_path( iv_path ).

    delete_subtree(
      iv_path = ls_split_path-path
      iv_name = ls_split_path-name ).

    ri_json = me.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~exists.
    rv_exists = boolc( get_item( iv_path ) IS NOT INITIAL ).
  ENDMETHOD.

  METHOD zif_abapgit_ajson~filter.
    ri_json = create_from(
      ii_source_json = me
      ii_filter      = ii_filter ).
  ENDMETHOD.

  METHOD zif_abapgit_ajson~format_datetime.
    ms_opts-format_datetime = iv_use_iso.
    ri_json = me.
  ENDMETHOD.

  METHOD zif_abapgit_ajson~freeze.
    ms_opts-read_only = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_ajson~get.

    DATA lr_item TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    lr_item = get_item( iv_path ).
    IF lr_item IS NOT INITIAL.
      rv_value = lr_item->value.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~get_boolean.

    DATA lr_item TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    lr_item = get_item( iv_path ).
    IF lr_item IS INITIAL OR lr_item->type = zif_abapgit_ajson_types=>node_type-null.
      RETURN.
    ELSEIF lr_item->type = zif_abapgit_ajson_types=>node_type-boolean.
      rv_value = boolc( lr_item->value = 'true' ).
    ELSEIF lr_item->value IS NOT INITIAL.
      rv_value = abap_true.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~get_date.

    DATA lr_item TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    DATA lv_y TYPE c LENGTH 4.
    DATA lv_m TYPE c LENGTH 2.
    DATA lv_d TYPE c LENGTH 2.

    lr_item = get_item( iv_path ).

    IF lr_item IS NOT INITIAL AND lr_item->type = zif_abapgit_ajson_types=>node_type-string.
      FIND FIRST OCCURRENCE OF REGEX '^(\d{4})-(\d{2})-(\d{2})(T|$)'
        IN lr_item->value
        SUBMATCHES lv_y lv_m lv_d.
      CONCATENATE lv_y lv_m lv_d INTO rv_value.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~get_integer.

    DATA lr_item TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    lr_item = get_item( iv_path ).
    IF lr_item IS NOT INITIAL AND lr_item->type = zif_abapgit_ajson_types=>node_type-number.
      rv_value = lr_item->value.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~get_node_type.

    DATA lr_item TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    lr_item = get_item( iv_path ).
    IF lr_item IS NOT INITIAL.
      rv_node_type = lr_item->type.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~get_number.

    DATA lr_item TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    lr_item = get_item( iv_path ).
    IF lr_item IS NOT INITIAL AND lr_item->type = zif_abapgit_ajson_types=>node_type-number.
      rv_value = lr_item->value.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~get_string.

    DATA lr_item TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    lr_item = get_item( iv_path ).
    IF lr_item IS NOT INITIAL AND lr_item->type <> zif_abapgit_ajson_types=>node_type-null.
      rv_value = lr_item->value.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~get_timestamp.

    DATA lo_to_abap TYPE REF TO lcl_json_to_abap.
    DATA lr_item TYPE REF TO zif_abapgit_ajson_types=>ty_node.

    lr_item = get_item( iv_path ).

    IF lr_item IS INITIAL.
      RETURN.
    ENDIF.

    CREATE OBJECT lo_to_abap.

    TRY.
        rv_value = lo_to_abap->to_timestamp( lr_item->value ).
      CATCH zcx_abapgit_ajson_error.
        RETURN.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~is_empty.
    rv_yes = boolc( lines( mt_json_tree ) = 0 ).
  ENDMETHOD.

  METHOD zif_abapgit_ajson~keep_item_order.
    ms_opts-keep_item_order = abap_true.
    ri_json = me.
  ENDMETHOD.

  METHOD zif_abapgit_ajson~map.
    ri_json = create_from(
      ii_source_json = me
      ii_mapper      = ii_mapper ).
  ENDMETHOD.

  METHOD zif_abapgit_ajson~members.

    DATA lv_normalized_path TYPE string.
    FIELD-SYMBOLS <item> LIKE LINE OF mt_json_tree.

    lv_normalized_path = lcl_utils=>normalize_path( iv_path ).

    LOOP AT mt_json_tree ASSIGNING <item> WHERE path = lv_normalized_path.
      APPEND <item>-name TO rt_members.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~opts.
    rs_opts = ms_opts.
  ENDMETHOD.

  METHOD zif_abapgit_ajson~push.

    DATA lr_parent TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    DATA lr_new_node TYPE REF TO zif_abapgit_ajson_types=>ty_node.

    read_only_watchdog( ).

    lr_parent = get_item( iv_path ).

    IF lr_parent IS INITIAL.
      zcx_abapgit_ajson_error=>raise( |Path [{ iv_path }] does not exist| ).
    ENDIF.

    IF lr_parent->type <> zif_abapgit_ajson_types=>node_type-array.
      zcx_abapgit_ajson_error=>raise( |Path [{ iv_path }] is not array| ).
    ENDIF.

    DATA lt_new_nodes TYPE zif_abapgit_ajson_types=>ty_nodes_tt.
    DATA ls_new_path TYPE zif_abapgit_ajson_types=>ty_path_name.
    DATA lv_new_index TYPE i.

    lv_new_index     = lr_parent->children + 1.
    ls_new_path-path = lcl_utils=>normalize_path( iv_path ).
    ls_new_path-name = |{ lv_new_index }|.

    lt_new_nodes = lcl_abap_to_json=>convert(
      is_opts            = ms_opts
      iv_data   = iv_val
      is_prefix = ls_new_path ).
    READ TABLE lt_new_nodes INDEX 1 REFERENCE INTO lr_new_node. " assume first record is the array item - not ideal !
    ASSERT sy-subrc = 0.
    lr_new_node->index = lv_new_index.

    " update data
    lr_parent->children = lv_new_index.
    INSERT LINES OF lt_new_nodes INTO TABLE mt_json_tree.

    ri_json = me.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~set.

    DATA ls_split_path TYPE zif_abapgit_ajson_types=>ty_path_name.
    DATA lr_parent TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    DATA ls_deleted_node TYPE zif_abapgit_ajson_types=>ty_node.
    DATA lv_item_order TYPE zif_abapgit_ajson_types=>ty_node-order.

    read_only_watchdog( ).

    ri_json = me.

    IF iv_val IS INITIAL AND iv_ignore_empty = abap_true AND iv_node_type IS INITIAL.
      RETURN. " nothing to assign
    ENDIF.

    IF iv_node_type IS NOT INITIAL
      AND iv_node_type <> zif_abapgit_ajson_types=>node_type-boolean AND iv_node_type <> zif_abapgit_ajson_types=>node_type-null
      AND iv_node_type <> zif_abapgit_ajson_types=>node_type-number AND iv_node_type <> zif_abapgit_ajson_types=>node_type-string.
      zcx_abapgit_ajson_error=>raise( |Unexpected type { iv_node_type }| ).
    ENDIF.

    ls_split_path = lcl_utils=>split_path( iv_path ).
    IF ls_split_path IS INITIAL. " Assign root, exceptional processing
      IF iv_node_type IS NOT INITIAL.
        mt_json_tree = lcl_abap_to_json=>insert_with_type(
          is_opts            = ms_opts
          iv_data            = iv_val
          iv_type            = iv_node_type
          is_prefix          = ls_split_path
          ii_custom_mapping  = mi_custom_mapping ).
      ELSE.
        mt_json_tree = lcl_abap_to_json=>convert(
          is_opts            = ms_opts
          iv_data            = iv_val
          is_prefix          = ls_split_path
          ii_custom_mapping  = mi_custom_mapping ).
      ENDIF.
      RETURN.
    ENDIF.

    " Ensure whole path exists
    lr_parent = prove_path_exists( ls_split_path-path ).
    ASSERT lr_parent IS NOT INITIAL.

    " delete if exists with subtree
    ls_deleted_node = delete_subtree(
      ir_parent = lr_parent
      iv_path   = ls_split_path-path
      iv_name   = ls_split_path-name ).
    lv_item_order = ls_deleted_node-order.

    " convert to json
    DATA lt_new_nodes TYPE zif_abapgit_ajson_types=>ty_nodes_tt.
    DATA lv_array_index TYPE i.

    IF lr_parent->type = zif_abapgit_ajson_types=>node_type-array.
      lv_array_index = lcl_utils=>validate_array_index(
        iv_path  = ls_split_path-path
        iv_index = ls_split_path-name ).
    ELSEIF lr_parent->type = zif_abapgit_ajson_types=>node_type-object
      AND lv_item_order = 0 AND ms_opts-keep_item_order = abap_true.
      lv_item_order = lr_parent->children + 1.
    ENDIF.

    IF iv_node_type IS NOT INITIAL.
      lt_new_nodes = lcl_abap_to_json=>insert_with_type(
        is_opts            = ms_opts
        iv_item_order      = lv_item_order
        iv_data            = iv_val
        iv_type            = iv_node_type
        iv_array_index     = lv_array_index
        is_prefix          = ls_split_path
        ii_custom_mapping  = mi_custom_mapping ).
    ELSE.
      lt_new_nodes = lcl_abap_to_json=>convert(
        is_opts            = ms_opts
        iv_item_order      = lv_item_order
        iv_data            = iv_val
        iv_array_index     = lv_array_index
        is_prefix          = ls_split_path
        ii_custom_mapping  = mi_custom_mapping ).
    ENDIF.

    " update nodes
    IF lines( lt_new_nodes ) > 0.
      lr_parent->children = lr_parent->children + 1.
      INSERT LINES OF lt_new_nodes INTO TABLE mt_json_tree.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~setx.

    DATA lv_path TYPE string.
    DATA lv_val TYPE string.
    DATA lv_int TYPE i.
    DATA lv_dec TYPE decfloat34.
    DATA lv_last TYPE i.

    IF iv_param IS INITIAL.
      ri_json = me.
      RETURN.
    ENDIF.

    SPLIT iv_param AT ':' INTO lv_path lv_val.
    CONDENSE lv_path.
    CONDENSE lv_val.

    IF lv_val IS INITIAL.
      ri_json = me.
      RETURN. " Hmm ? or empty string ? or null ?
    ENDIF.

    IF go_float_regex IS NOT BOUND.
      CREATE OBJECT go_float_regex EXPORTING pattern = '^([1-9][0-9]*|0)\.[0-9]+$'.
      " expects fractional, because ints are detected separately
    ENDIF.

    IF lv_val = 'null'.
      zif_abapgit_ajson~set_null( lv_path ).
    ELSEIF lv_val = 'true'.
      zif_abapgit_ajson~set_boolean(
        iv_path = lv_path
        iv_val  = abap_true ).
    ELSEIF lv_val = 'false'.
      zif_abapgit_ajson~set_boolean(
        iv_path = lv_path
        iv_val  = abap_false ).
    ELSEIF lv_val CO '0123456789'.
      lv_int = lv_val.
      zif_abapgit_ajson~set_integer(
        iv_path = lv_path
        iv_val  = lv_int ).
    ELSEIF lv_val CO '0123456789.' AND go_float_regex->create_matcher( text = lv_val )->match( ) = abap_true.
      lv_dec = lv_val.
      zif_abapgit_ajson~set(
        iv_path = lv_path
        iv_val  = lv_dec ).
    ELSEIF lv_val+0(1) = '{' OR lv_val+0(1) = '['.
      "Expect object/array, but no further checks, parser will catch errors
      zif_abapgit_ajson~set(
        iv_path = lv_path
        iv_val  = parse(
          iv_json = lv_val
          iv_keep_item_order = ms_opts-keep_item_order ) ).
    ELSE. " string
      lv_last = strlen( lv_val ) - 1.
      IF lv_val+0(1) = '"' AND lv_val+lv_last(1) = '"'.
        lv_val = substring(
          val = lv_val
          off = 1
          len = lv_last - 1 ).
      ENDIF.
      zif_abapgit_ajson~set_string(
        iv_path = lv_path
        iv_val  = lv_val ).
    ENDIF.

    ri_json = me.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~set_boolean.

    ri_json = me.

    DATA lv_bool TYPE abap_bool.
    lv_bool = boolc( iv_val IS NOT INITIAL ).
    zif_abapgit_ajson~set(
      iv_ignore_empty = abap_false
      iv_path = iv_path
      iv_val  = lv_bool ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson~set_date.

    ri_json = me.

    DATA lv_val TYPE string.
    lv_val = lcl_abap_to_json=>format_date( iv_val ).

    zif_abapgit_ajson~set(
      iv_ignore_empty = abap_false
      iv_path = iv_path
      iv_val  = lv_val ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson~set_integer.

    ri_json = me.

    zif_abapgit_ajson~set(
      iv_ignore_empty = abap_false
      iv_path = iv_path
      iv_val  = iv_val ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson~set_null.

    ri_json = me.

    DATA lv_null_ref TYPE REF TO data.
    zif_abapgit_ajson~set(
      iv_ignore_empty = abap_false
      iv_path = iv_path
      iv_val  = lv_null_ref ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson~set_string.

    ri_json = me.

    DATA lv_val TYPE string.
    lv_val = iv_val.
    zif_abapgit_ajson~set(
      iv_ignore_empty = abap_false
      iv_path = iv_path
      iv_val  = lv_val ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson~set_timestamp.

    ri_json = me.

    DATA lv_timestamp_iso TYPE string.
    lv_timestamp_iso = lcl_abap_to_json=>format_timestamp( iv_val ).

    zif_abapgit_ajson~set(
      iv_ignore_empty = abap_false
      iv_path = iv_path
      iv_val  = lv_timestamp_iso ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson~slice.

    DATA lo_section         TYPE REF TO zcl_abapgit_ajson.
    DATA ls_item            LIKE LINE OF mt_json_tree.
    DATA lv_normalized_path TYPE string.
    DATA ls_path_parts      TYPE zif_abapgit_ajson_types=>ty_path_name.
    DATA lv_path_len        TYPE i.
    DATA lv_path_pattern    TYPE string.

    CREATE OBJECT lo_section.
    lo_section->mi_custom_mapping = mi_custom_mapping.

    lv_normalized_path = lcl_utils=>normalize_path( iv_path ).
    lv_path_len        = strlen( lv_normalized_path ).
    ls_path_parts      = lcl_utils=>split_path( lv_normalized_path ).

    READ TABLE mt_json_tree INTO ls_item
      WITH KEY path = ls_path_parts-path name = ls_path_parts-name.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    CLEAR: ls_item-path, ls_item-name, ls_item-order. " this becomes a new root
    INSERT ls_item INTO TABLE lo_section->mt_json_tree.

    lv_path_pattern = lv_normalized_path && `*`.

    LOOP AT mt_json_tree INTO ls_item WHERE path CP lv_path_pattern.

      ls_item-path = substring( val = ls_item-path
                                off = lv_path_len - 1 ). " less closing '/'
      INSERT ls_item INTO TABLE lo_section->mt_json_tree.

    ENDLOOP.

    ri_json = lo_section.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~stringify.

    rv_json = lcl_json_serializer=>stringify(
      it_json_tree       = mt_json_tree
      iv_keep_item_order = ms_opts-keep_item_order
      iv_indent          = iv_indent ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson~touch_array.

    DATA lr_node TYPE REF TO zif_abapgit_ajson_types=>ty_node.
    DATA ls_deleted_node TYPE zif_abapgit_ajson_types=>ty_node.
    DATA ls_new_node LIKE LINE OF mt_json_tree.
    DATA ls_split_path TYPE zif_abapgit_ajson_types=>ty_path_name.

    read_only_watchdog( ).

    ls_split_path = lcl_utils=>split_path( iv_path ).
    IF ls_split_path IS INITIAL. " Assign root, exceptional processing
      ls_new_node-path = ls_split_path-path.
      ls_new_node-name = ls_split_path-name.
      ls_new_node-type = zif_abapgit_ajson_types=>node_type-array.
      INSERT ls_new_node INTO TABLE mt_json_tree.
      RETURN.
    ENDIF.

    IF iv_clear = abap_true.
      ls_deleted_node = delete_subtree(
        iv_path = ls_split_path-path
        iv_name = ls_split_path-name ).
    ELSE.
      lr_node = get_item( iv_path ).
    ENDIF.

    IF lr_node IS INITIAL. " Or node was cleared

      DATA lr_parent TYPE REF TO zif_abapgit_ajson_types=>ty_node.
      lr_parent = prove_path_exists( ls_split_path-path ).
      ASSERT lr_parent IS NOT INITIAL.

      lr_parent->children = lr_parent->children + 1.

      ls_new_node-path = ls_split_path-path.
      ls_new_node-name = ls_split_path-name.
      ls_new_node-type = zif_abapgit_ajson_types=>node_type-array.

      IF ms_opts-keep_item_order = abap_true.
        IF ls_deleted_node IS NOT INITIAL.
          ls_new_node-order = ls_deleted_node-order.
        ELSE.
          ls_new_node-order = lr_parent->children.
        ENDIF.
      ENDIF.

      INSERT ls_new_node INTO TABLE mt_json_tree.

    ELSEIF lr_node->type <> zif_abapgit_ajson_types=>node_type-array.
      zcx_abapgit_ajson_error=>raise( |Path [{ iv_path }] already used and is not array| ).
    ENDIF.

    ri_json = me.

  ENDMETHOD.

  METHOD zif_abapgit_ajson~to_abap.

    DATA lo_to_abap TYPE REF TO lcl_json_to_abap.

    CLEAR ev_container.
    CREATE OBJECT lo_to_abap
      EXPORTING
        iv_corresponding  = boolc( iv_corresponding = abap_true OR ms_opts-to_abap_corresponding_only = abap_true )
        ii_custom_mapping = mi_custom_mapping.

    lo_to_abap->to_abap(
      EXPORTING
        it_nodes    = zif_abapgit_ajson~mt_json_tree
      CHANGING
        c_container = ev_container ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson~to_abap_corresponding_only.
    ms_opts-to_abap_corresponding_only = iv_enable.
    ri_json = me.
  ENDMETHOD.
ENDCLASS.

**********************************************************************
*  FILTER EMPTY VALUES
**********************************************************************

CLASS lcl_empty_filter DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES zif_abapgit_ajson_filter.
ENDCLASS.

CLASS lcl_empty_filter IMPLEMENTATION.
  METHOD zif_abapgit_ajson_filter~keep_node.

    rv_keep = boolc(
      ( iv_visit = zif_abapgit_ajson_filter=>visit_type-value AND is_node-value IS NOT INITIAL ) OR
      ( iv_visit <> zif_abapgit_ajson_filter=>visit_type-value AND is_node-children > 0 ) ).
    " children = 0 on open for initially empty nodes and on close for filtered ones

  ENDMETHOD.
ENDCLASS.

**********************************************************************
*  FILTER PREDEFINED PATHS
**********************************************************************

CLASS lcl_paths_filter DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES zif_abapgit_ajson_filter.
    METHODS constructor
      IMPORTING
        it_skip_paths     TYPE string_table OPTIONAL
        iv_skip_paths     TYPE string OPTIONAL
        iv_pattern_search TYPE abap_bool
      RAISING
        zcx_abapgit_ajson_error.
  PRIVATE SECTION.
    DATA mt_skip_paths TYPE HASHED TABLE OF string WITH UNIQUE KEY table_line.
    DATA mv_pattern_search TYPE abap_bool.
ENDCLASS.

CLASS lcl_paths_filter IMPLEMENTATION.

  METHOD zif_abapgit_ajson_filter~keep_node.

    DATA lv_full_path TYPE string.
    FIELD-SYMBOLS <p> LIKE LINE OF mt_skip_paths.

    lv_full_path = is_node-path && is_node-name.

    IF mv_pattern_search = abap_true.
      rv_keep = abap_true.
      LOOP AT mt_skip_paths ASSIGNING <p>.
        IF lv_full_path CP <p>.
          rv_keep = abap_false.
          EXIT.
        ENDIF.
      ENDLOOP.
    ELSE.
      READ TABLE mt_skip_paths WITH KEY table_line = lv_full_path TRANSPORTING NO FIELDS.
      rv_keep = boolc( sy-subrc <> 0 ).
    ENDIF.

  ENDMETHOD.

  METHOD constructor.

    DATA lv_s TYPE string.
    DATA lt_tab TYPE string_table.
    FIELD-SYMBOLS <s> TYPE string.

    IF boolc( iv_skip_paths IS INITIAL ) = boolc( it_skip_paths IS INITIAL ). " XOR
      zcx_abapgit_ajson_error=>raise( 'no filter path specified' ).
    ENDIF.

    LOOP AT it_skip_paths INTO lv_s.
      lv_s = condense( lv_s ).
      APPEND lv_s TO lt_tab.
    ENDLOOP.

    IF iv_skip_paths IS NOT INITIAL.
      SPLIT iv_skip_paths AT ',' INTO TABLE lt_tab.
      LOOP AT lt_tab ASSIGNING <s>.
        IF <s> IS INITIAL.
          DELETE lt_tab INDEX sy-tabix.
          CONTINUE.
        ENDIF.
        <s> = condense( <s> ).
      ENDLOOP.
    ENDIF.

    SORT lt_tab BY table_line.
    DELETE ADJACENT DUPLICATES FROM lt_tab.

    mt_skip_paths = lt_tab.
    mv_pattern_search = iv_pattern_search.

  ENDMETHOD.

ENDCLASS.

**********************************************************************
* MULTI FILTER
**********************************************************************

CLASS lcl_and_filter DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES zif_abapgit_ajson_filter.
    METHODS constructor
      IMPORTING
        it_filters TYPE zif_abapgit_ajson_filter=>ty_filter_tab
      RAISING
        zcx_abapgit_ajson_error.
  PRIVATE SECTION.
    DATA mt_filters TYPE zif_abapgit_ajson_filter=>ty_filter_tab.
ENDCLASS.

CLASS lcl_and_filter IMPLEMENTATION.

  METHOD zif_abapgit_ajson_filter~keep_node.

    DATA li_filter LIKE LINE OF mt_filters.

    rv_keep = abap_true.
    LOOP AT mt_filters INTO li_filter.
      rv_keep = li_filter->keep_node(
        is_node  = is_node
        iv_visit = iv_visit ).
      IF rv_keep = abap_false.
        RETURN.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD constructor.

    DATA li_filter LIKE LINE OF it_filters.

    LOOP AT it_filters INTO li_filter WHERE table_line IS BOUND.
      APPEND li_filter TO mt_filters.
    ENDLOOP.

  ENDMETHOD.

ENDCLASS.

CLASS zcl_abapgit_ajson_filter_lib IMPLEMENTATION.

  METHOD create_and_filter.
    CREATE OBJECT ri_filter TYPE lcl_and_filter
      EXPORTING
        it_filters = it_filters.
  ENDMETHOD.

  METHOD create_empty_filter.
    CREATE OBJECT ri_filter TYPE lcl_empty_filter.
  ENDMETHOD.

  METHOD create_path_filter.
    CREATE OBJECT ri_filter TYPE lcl_paths_filter
      EXPORTING
        iv_pattern_search = iv_pattern_search
        it_skip_paths = it_skip_paths
        iv_skip_paths = iv_skip_paths.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_mapping_fields IMPLEMENTATION. "DEPRECATED

  METHOD constructor.

    DATA ls_mapping_field LIKE LINE OF mt_mapping_fields.

    LOOP AT it_mapping_fields INTO ls_mapping_field.
      ls_mapping_field-abap = to_upper( ls_mapping_field-abap ).
      INSERT ls_mapping_field INTO TABLE mt_mapping_fields.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_abap.

    DATA ls_mapping_field LIKE LINE OF mt_mapping_fields.

    READ TABLE mt_mapping_fields INTO ls_mapping_field
      WITH KEY json COMPONENTS json = iv_name.
    IF sy-subrc = 0.
      rv_result = ls_mapping_field-abap.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_json.

    DATA lv_field TYPE string.
    DATA ls_mapping_field LIKE LINE OF mt_mapping_fields.

    lv_field = to_upper( iv_name ).

    READ TABLE mt_mapping_fields INTO ls_mapping_field
      WITH KEY abap COMPONENTS abap = lv_field.
    IF sy-subrc = 0.
      rv_result = ls_mapping_field-json.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~rename_node.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_rename IMPLEMENTATION.

  METHOD constructor.
    mt_rename_map = it_rename_map.
    mv_rename_by = iv_rename_by.
  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_abap.
  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_json.
  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~rename_node.

    DATA lv_full_path TYPE string.
    DATA lv_pair_found TYPE abap_bool.
    FIELD-SYMBOLS <r> LIKE LINE OF mt_rename_map.

    CASE mv_rename_by.
      WHEN zcl_abapgit_ajson_mapping=>rename_by-attr_name.
        READ TABLE mt_rename_map ASSIGNING <r> WITH TABLE KEY by_name COMPONENTS from = cv_name.
        lv_pair_found = boolc( sy-subrc = 0 ).
      WHEN zcl_abapgit_ajson_mapping=>rename_by-full_path.
        lv_full_path = is_node-path && cv_name.
        READ TABLE mt_rename_map ASSIGNING <r> WITH TABLE KEY by_name COMPONENTS from = lv_full_path.
        lv_pair_found = boolc( sy-subrc = 0 ).
      WHEN zcl_abapgit_ajson_mapping=>rename_by-pattern.
        lv_full_path = is_node-path && cv_name.
        LOOP AT mt_rename_map ASSIGNING <r>.
          IF lv_full_path CP <r>-from.
            lv_pair_found = abap_true.
            EXIT.
          ENDIF.
        ENDLOOP.
      WHEN OTHERS.
        lv_pair_found = abap_false. " No rename
    ENDCASE.

    IF lv_pair_found = abap_true.
      cv_name = <r>-to.
    ENDIF.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_mapping_to_upper IMPLEMENTATION.

  METHOD constructor.

    mi_mapping_fields = zcl_abapgit_ajson_mapping=>create_field_mapping( it_mapping_fields ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_abap.

    rv_result = mi_mapping_fields->to_abap( iv_path = iv_path
                                            iv_name = iv_name ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_json.

    rv_result = mi_mapping_fields->to_json( iv_path = iv_path
                                            iv_name = iv_name ).

    IF rv_result IS NOT INITIAL. " Mapping found
      RETURN.
    ENDIF.

    rv_result = to_upper( iv_name ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~rename_node.

    cv_name = to_upper( cv_name ).

  ENDMETHOD.

ENDCLASS.

CLASS lcl_mapping_to_lower IMPLEMENTATION.

  METHOD constructor.

    mi_mapping_fields = zcl_abapgit_ajson_mapping=>create_field_mapping( it_mapping_fields ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_abap.

    rv_result = mi_mapping_fields->to_abap( iv_path = iv_path
                                            iv_name = iv_name ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_json.

    rv_result = mi_mapping_fields->to_json( iv_path = iv_path
                                            iv_name = iv_name ).

    IF rv_result IS NOT INITIAL. " Mapping found
      RETURN.
    ENDIF.

    rv_result = to_lower( iv_name ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~rename_node.

    cv_name = to_lower( cv_name ).

  ENDMETHOD.

ENDCLASS.

CLASS lcl_mapping_camel IMPLEMENTATION. "DEPRECATED

  METHOD constructor.

    mi_mapping_fields   = zcl_abapgit_ajson_mapping=>create_field_mapping( it_mapping_fields ).
    mv_first_json_upper = iv_first_json_upper.

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_abap.

    rv_result = mi_mapping_fields->to_abap( iv_path = iv_path
                                            iv_name = iv_name ).

    IF rv_result IS NOT INITIAL. " Mapping found
      RETURN.
    ENDIF.

    rv_result = iv_name.

    REPLACE ALL OCCURRENCES OF REGEX `([a-z])([A-Z])` IN rv_result WITH `$1_$2`.

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_json.

    TYPES ty_token TYPE c LENGTH 255.
    DATA lt_tokens TYPE STANDARD TABLE OF ty_token.
    DATA lv_from TYPE i.
    FIELD-SYMBOLS <token> LIKE LINE OF lt_tokens.

    rv_result = mi_mapping_fields->to_json( iv_path = iv_path
                                            iv_name = iv_name ).

    IF rv_result IS NOT INITIAL. " Mapping found
      RETURN.
    ENDIF.

    rv_result = iv_name.

    REPLACE ALL OCCURRENCES OF `__` IN rv_result WITH `*`.

    TRANSLATE rv_result TO LOWER CASE.
    TRANSLATE rv_result USING `/_:_~_`.

    IF mv_first_json_upper = abap_true.
      lv_from = 1.
    ELSE.
      lv_from = 2.
    ENDIF.

    SPLIT rv_result AT `_` INTO TABLE lt_tokens.
    LOOP AT lt_tokens ASSIGNING <token> FROM lv_from.
      TRANSLATE <token>(1) TO UPPER CASE.
    ENDLOOP.

    CONCATENATE LINES OF lt_tokens INTO rv_result.
    REPLACE ALL OCCURRENCES OF `*` IN rv_result WITH `_`.

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~rename_node.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_compound_mapper IMPLEMENTATION.

  METHOD constructor.
    mt_queue = it_queue.
  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~rename_node.

    DATA ls_node LIKE is_node.
    DATA li_mapper LIKE LINE OF mt_queue.

    ls_node = is_node.

    LOOP AT mt_queue INTO li_mapper.
      li_mapper->rename_node(
        EXPORTING
          is_node = ls_node
        CHANGING
          cv_name = cv_name ).
      ls_node-name = cv_name.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_abap.

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_json.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_to_snake IMPLEMENTATION.

  METHOD zif_abapgit_ajson_mapping~rename_node.

    REPLACE ALL OCCURRENCES OF REGEX `([a-z])([A-Z])` IN cv_name WITH `$1_$2`.
    cv_name = to_lower( cv_name ).

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_abap.

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_json.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_to_camel IMPLEMENTATION.

  METHOD constructor.
    mv_first_json_upper = iv_first_json_upper.
  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~rename_node.

    TYPES lty_token TYPE c LENGTH 255.
    CONSTANTS lc_forced_underscore_marker TYPE c LENGTH 1 VALUE cl_abap_char_utilities=>horizontal_tab.

    DATA lt_tokens TYPE STANDARD TABLE OF lty_token.
    DATA lv_from TYPE i.
    FIELD-SYMBOLS <token> LIKE LINE OF lt_tokens.

    IF mv_first_json_upper = abap_true.
      lv_from = 1.
    ELSE.
      lv_from = 2.
    ENDIF.
    REPLACE ALL OCCURRENCES OF `__` IN cv_name WITH lc_forced_underscore_marker. " Force underscore

    SPLIT cv_name AT `_` INTO TABLE lt_tokens.
    DELETE lt_tokens WHERE table_line IS INITIAL.
    LOOP AT lt_tokens ASSIGNING <token> FROM lv_from.
      TRANSLATE <token>+0(1) TO UPPER CASE.
    ENDLOOP.

    CONCATENATE LINES OF lt_tokens INTO cv_name.
    REPLACE ALL OCCURRENCES OF lc_forced_underscore_marker IN cv_name WITH `_`.

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_abap.

  ENDMETHOD.

  METHOD zif_abapgit_ajson_mapping~to_json.

  ENDMETHOD.

ENDCLASS.

CLASS zcl_abapgit_ajson_mapping IMPLEMENTATION.

  METHOD create_camel_case.

    CREATE OBJECT ri_mapping TYPE lcl_mapping_camel
      EXPORTING
        it_mapping_fields   = it_mapping_fields
        iv_first_json_upper = iv_first_json_upper.

  ENDMETHOD.

  METHOD create_compound_mapper.

    DATA lt_queue TYPE zif_abapgit_ajson_mapping=>ty_table_of.

    APPEND ii_mapper1 TO lt_queue.
    APPEND ii_mapper2 TO lt_queue.
    APPEND ii_mapper3 TO lt_queue.
    APPEND LINES OF it_more TO lt_queue.
    DELETE lt_queue WHERE table_line IS INITIAL.

    CREATE OBJECT ri_mapping TYPE lcl_compound_mapper
      EXPORTING
        it_queue = lt_queue.

  ENDMETHOD.

  METHOD create_field_mapping.

    CREATE OBJECT ri_mapping TYPE lcl_mapping_fields
      EXPORTING
        it_mapping_fields = it_mapping_fields.

  ENDMETHOD.

  METHOD create_lower_case.

    CREATE OBJECT ri_mapping TYPE lcl_mapping_to_lower
      EXPORTING
        it_mapping_fields = it_mapping_fields.

  ENDMETHOD.

  METHOD create_rename.

    CREATE OBJECT ri_mapping TYPE lcl_rename
      EXPORTING
        it_rename_map = it_rename_map
        iv_rename_by = iv_rename_by.

  ENDMETHOD.

  METHOD create_to_camel_case.

    CREATE OBJECT ri_mapping TYPE lcl_to_camel
      EXPORTING
        iv_first_json_upper = iv_first_json_upper.

  ENDMETHOD.

  METHOD create_to_snake_case.

    CREATE OBJECT ri_mapping TYPE lcl_to_snake.

  ENDMETHOD.

  METHOD create_upper_case.

    CREATE OBJECT ri_mapping TYPE lcl_mapping_to_upper
      EXPORTING
        it_mapping_fields = it_mapping_fields.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_ajson_utilities IMPLEMENTATION.

  METHOD delete_empty_nodes.

    DATA ls_json_tree LIKE LINE OF io_json->mt_json_tree.
    DATA lv_done TYPE abap_bool.

    DO.
      lv_done = abap_true.

      IF iv_keep_empty_arrays = abap_false.
        LOOP AT io_json->mt_json_tree INTO ls_json_tree
          WHERE type = zif_abapgit_ajson_types=>node_type-array AND children = 0.

          io_json->delete( ls_json_tree-path && ls_json_tree-name ).

        ENDLOOP.
        IF sy-subrc = 0.
          lv_done = abap_false.
        ENDIF.
      ENDIF.

      LOOP AT io_json->mt_json_tree INTO ls_json_tree
        WHERE type = zif_abapgit_ajson_types=>node_type-object AND children = 0.

        io_json->delete( ls_json_tree-path && ls_json_tree-name ).

      ENDLOOP.
      IF sy-subrc = 0.
        lv_done = abap_false.
      ENDIF.

      IF lv_done = abap_true.
        EXIT. " nothing else to delete
      ENDIF.
    ENDDO.

  ENDMETHOD.

  METHOD diff.

    mo_json_a = normalize_input(
      iv_json = iv_json_a
      io_json = io_json_a ).

    mo_json_b = normalize_input(
      iv_json = iv_json_b
      io_json = io_json_b ).

    mo_insert = zcl_abapgit_ajson=>create_empty( ).
    mo_delete = zcl_abapgit_ajson=>create_empty( ).
    mo_change = zcl_abapgit_ajson=>create_empty( ).

    diff_a_b( '/' ).
    diff_b_a( '/' ).

    eo_insert ?= mo_insert.
    eo_delete ?= mo_delete.
    eo_change ?= mo_change.

    delete_empty_nodes(
      io_json              = eo_insert
      iv_keep_empty_arrays = iv_keep_empty_arrays ).
    delete_empty_nodes(
      io_json              = eo_delete
      iv_keep_empty_arrays = iv_keep_empty_arrays ).
    delete_empty_nodes(
      io_json              = eo_change
      iv_keep_empty_arrays = iv_keep_empty_arrays ).

  ENDMETHOD.

  METHOD diff_a_b.

    DATA:
      lv_path_a TYPE string,
      lv_path_b TYPE string.

    FIELD-SYMBOLS:
      <node_a> LIKE LINE OF mo_json_a->mt_json_tree,
      <node_b> LIKE LINE OF mo_json_a->mt_json_tree.

    LOOP AT mo_json_a->mt_json_tree ASSIGNING <node_a> WHERE path = iv_path.
      lv_path_a = <node_a>-path && <node_a>-name && '/'.

      READ TABLE mo_json_b->mt_json_tree ASSIGNING <node_b>
        WITH TABLE KEY path = <node_a>-path name = <node_a>-name.
      IF sy-subrc = 0.
        lv_path_b = <node_b>-path && <node_b>-name && '/'.

        IF <node_a>-type = <node_b>-type.
          CASE <node_a>-type.
            WHEN zif_abapgit_ajson_types=>node_type-array.
              mo_insert->touch_array( lv_path_a ).
              mo_change->touch_array( lv_path_a ).
              mo_delete->touch_array( lv_path_a ).
              diff_a_b( lv_path_a ).
            WHEN zif_abapgit_ajson_types=>node_type-object.
              diff_a_b( lv_path_a ).
            WHEN OTHERS.
              IF <node_a>-value <> <node_b>-value.
                " save as changed value
                mo_change->set(
                  iv_path      = lv_path_b
                  iv_val       = <node_b>-value
                  iv_node_type = <node_b>-type ).
              ENDIF.
          ENDCASE.
        ELSE.
          " save changed type as delete + insert
          CASE <node_a>-type.
            WHEN zif_abapgit_ajson_types=>node_type-array.
              mo_delete->touch_array( lv_path_a ).
              diff_a_b( lv_path_a ).
            WHEN zif_abapgit_ajson_types=>node_type-object.
              diff_a_b( lv_path_a ).
            WHEN OTHERS.
              mo_delete->set(
                iv_path      = lv_path_a
                iv_val       = <node_a>-value
                iv_node_type = <node_a>-type ).
          ENDCASE.
          CASE <node_b>-type.
            WHEN zif_abapgit_ajson_types=>node_type-array.
              mo_insert->touch_array( lv_path_b ).
              diff_b_a( lv_path_b ).
            WHEN zif_abapgit_ajson_types=>node_type-object.
              diff_b_a( lv_path_b ).
            WHEN OTHERS.
              mo_insert->set(
                iv_path      = lv_path_b
                iv_val       = <node_b>-value
                iv_node_type = <node_b>-type ).
          ENDCASE.
        ENDIF.
      ELSE.
        " save as delete
        CASE <node_a>-type.
          WHEN zif_abapgit_ajson_types=>node_type-array.
            mo_delete->touch_array( lv_path_a ).
            diff_a_b( lv_path_a ).
          WHEN zif_abapgit_ajson_types=>node_type-object.
            diff_a_b( lv_path_a ).
          WHEN OTHERS.
            mo_delete->set(
              iv_path      = lv_path_a
              iv_val       = <node_a>-value
              iv_node_type = <node_a>-type ).
        ENDCASE.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD diff_b_a.

    DATA lv_path TYPE string.

    FIELD-SYMBOLS <node_b> LIKE LINE OF mo_json_b->mt_json_tree.

    LOOP AT mo_json_b->mt_json_tree ASSIGNING <node_b> WHERE path = iv_path.
      lv_path = <node_b>-path && <node_b>-name && '/'.

      CASE <node_b>-type.
        WHEN zif_abapgit_ajson_types=>node_type-array.
          mo_insert->touch_array( lv_path ).
          diff_b_a(
            iv_path  = lv_path
            iv_array = abap_true ).
        WHEN zif_abapgit_ajson_types=>node_type-object.
          diff_b_a( lv_path ).
        WHEN OTHERS.
          IF iv_array = abap_false.
            READ TABLE mo_json_a->mt_json_tree TRANSPORTING NO FIELDS
              WITH TABLE KEY path = <node_b>-path name = <node_b>-name.
            IF sy-subrc <> 0.
              " save as insert
              mo_insert->set(
                iv_path      = lv_path
                iv_val       = <node_b>-value
                iv_node_type = <node_b>-type ).
            ENDIF.
          ELSE.
            READ TABLE mo_insert->mt_json_tree TRANSPORTING NO FIELDS
              WITH KEY path = <node_b>-path value = <node_b>-value.
            IF sy-subrc <> 0.
              " save as new array value
              mo_insert->push(
                iv_path = iv_path
                iv_val  = <node_b>-value ).
            ENDIF.
          ENDIF.
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.

  METHOD is_equal.

    DATA li_ins TYPE REF TO zif_abapgit_ajson.
    DATA li_del TYPE REF TO zif_abapgit_ajson.
    DATA li_mod TYPE REF TO zif_abapgit_ajson.

    diff(
      EXPORTING
        iv_json_a = iv_json_a
        iv_json_b = iv_json_b
        io_json_a = ii_json_a
        io_json_b = ii_json_b
      IMPORTING
        eo_insert = li_ins
        eo_delete = li_del
        eo_change = li_mod ).

    rv_yes = boolc(
      li_ins->is_empty( ) = abap_true AND
      li_del->is_empty( ) = abap_true AND
      li_mod->is_empty( ) = abap_true ).

  ENDMETHOD.

  METHOD merge.

    mo_json_a = normalize_input(
      iv_json = iv_json_a
      io_json = io_json_a ).

    mo_json_b = normalize_input(
      iv_json = iv_json_b
      io_json = io_json_b ).

    " Start with first JSON...
    mo_insert = mo_json_a.

    " ...and add all nodes from second JSON
    diff_b_a( '/' ).

    ro_json ?= mo_insert.

    delete_empty_nodes(
      io_json              = ro_json
      iv_keep_empty_arrays = iv_keep_empty_arrays ).

  ENDMETHOD.

  METHOD new.
    CREATE OBJECT ro_instance.
  ENDMETHOD.

  METHOD normalize_input.

    IF boolc( iv_json IS INITIAL ) = boolc( io_json IS INITIAL ).
      zcx_abapgit_ajson_error=>raise( 'Either supply JSON string or instance, but not both' ).
    ENDIF.

    IF iv_json IS NOT INITIAL.
      ro_json = zcl_abapgit_ajson=>parse( iv_json ).
    ELSEIF io_json IS NOT INITIAL.
      ro_json = io_json.
    ELSE.
      zcx_abapgit_ajson_error=>raise( 'Supply either JSON string or instance' ).
    ENDIF.

  ENDMETHOD.

  METHOD sort.

    DATA lo_json TYPE REF TO zif_abapgit_ajson.

    lo_json = normalize_input(
      iv_json = iv_json
      io_json = io_json ).

    " Nodes are parsed into a sorted table, so no explicit sorting required
    rv_sorted = lo_json->stringify( 2 ).

  ENDMETHOD.
ENDCLASS.

CLASS lcl_in DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS convert
      IMPORTING
        !iv_data         TYPE xsequence
        !iv_length       TYPE i OPTIONAL
      RETURNING
        VALUE(rv_string) TYPE string
      RAISING
        zcx_abapgit_exception.
  PRIVATE SECTION.
    CLASS-DATA go_conv_new TYPE REF TO object.
    CLASS-DATA go_conv_old TYPE REF TO object.
ENDCLASS.

CLASS lcl_in IMPLEMENTATION.
  METHOD convert.

    DATA lv_class TYPE string.
    DATA lx_error TYPE REF TO cx_root.

    IF go_conv_new IS INITIAL AND go_conv_old IS INITIAL.
      TRY.
          CALL METHOD ('CL_ABAP_CONV_CODEPAGE')=>create_in
            RECEIVING
              instance = go_conv_new.
        CATCH cx_sy_dyn_call_illegal_class.
          lv_class = 'CL_ABAP_CONV_IN_CE'.
          CALL METHOD (lv_class)=>create
            EXPORTING
              encoding = 'UTF-8'
            RECEIVING
              conv     = go_conv_old.
      ENDTRY.
    ENDIF.

    TRY.
        IF go_conv_new IS NOT INITIAL.
          CALL METHOD go_conv_new->('IF_ABAP_CONV_IN~CONVERT')
            EXPORTING
              source = iv_data
            RECEIVING
              result = rv_string.
        ELSE.
          CALL METHOD go_conv_old->('CONVERT')
            EXPORTING
              input = iv_data
              n     = iv_length
            IMPORTING
              data  = rv_string.
        ENDIF.
      CATCH cx_parameter_invalid_range
        cx_sy_codepage_converter_init
        cx_sy_conversion_codepage
        cx_parameter_invalid_type INTO lx_error.
        zcx_abapgit_exception=>raise_with_text( lx_error ).
    ENDTRY.

  ENDMETHOD.
ENDCLASS.

CLASS lcl_out DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS convert
      IMPORTING
        !iv_string        TYPE string
      RETURNING
        VALUE(rv_xstring) TYPE xstring
      RAISING
        zcx_abapgit_exception.
  PRIVATE SECTION.
    CLASS-DATA go_conv_new TYPE REF TO object.
    CLASS-DATA go_conv_old TYPE REF TO object.
ENDCLASS.

CLASS lcl_out IMPLEMENTATION.
  METHOD convert.
    DATA lx_error TYPE REF TO cx_root.
    DATA lv_class TYPE string.

    IF go_conv_new IS INITIAL AND go_conv_old IS INITIAL.
      TRY.
          CALL METHOD ('CL_ABAP_CONV_CODEPAGE')=>create_out
            RECEIVING
              instance = go_conv_new.
        CATCH cx_sy_dyn_call_illegal_class.
          lv_class = 'CL_ABAP_CONV_OUT_CE'.
          CALL METHOD (lv_class)=>create
            EXPORTING
              encoding = 'UTF-8'
            RECEIVING
              conv     = go_conv_old.
      ENDTRY.
    ENDIF.

    TRY.
        IF go_conv_new IS NOT INITIAL.
          CALL METHOD go_conv_new->('IF_ABAP_CONV_OUT~CONVERT')
            EXPORTING
              source = iv_string
            RECEIVING
              result = rv_xstring.
        ELSE.
          CALL METHOD go_conv_old->('CONVERT')
            EXPORTING
              data   = iv_string
            IMPORTING
              buffer = rv_xstring.
        ENDIF.
      CATCH cx_parameter_invalid_range
            cx_sy_codepage_converter_init
            cx_sy_conversion_codepage
            cx_parameter_invalid_type INTO lx_error.
        zcx_abapgit_exception=>raise_with_text( lx_error ).
    ENDTRY.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_bcp47_language_table DEFINITION CREATE PRIVATE.

  PUBLIC SECTION.
    TYPES: BEGIN OF ty_language_mapping,
             sap1_code  TYPE sy-langu,
             sap2_code  TYPE laiso,
             bcp47_code TYPE string,
           END OF ty_language_mapping,
           ty_language_mappings TYPE STANDARD TABLE OF ty_language_mapping WITH DEFAULT KEY.
    CLASS-DATA gt_language_mappings TYPE ty_language_mappings.
    CLASS-METHODS:
      sap1_to_sap2
        IMPORTING
          im_sap1        TYPE sy-langu
        RETURNING
          VALUE(re_sap2) TYPE laiso
        RAISING
          zcx_abapgit_exception,
      sap2_to_sap1
        IMPORTING
          im_sap2        TYPE laiso
        RETURNING
          VALUE(re_sap1) TYPE sy-langu
        RAISING
          zcx_abapgit_exception,
      sap1_to_bcp47
        IMPORTING
          im_sap1         TYPE sy-langu
        RETURNING
          VALUE(re_bcp47) TYPE string
        RAISING
          zcx_abapgit_exception,
      bcp47_to_sap1
        IMPORTING
          im_bcp47       TYPE string
        RETURNING
          VALUE(re_sap1) TYPE sy-langu
        RAISING
          zcx_abapgit_exception.
  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-METHODS fill_language_mappings.
    CLASS-METHODS fill_language_mappings_1.
    CLASS-METHODS fill_language_mappings_2.
    CLASS-METHODS
      fill_language_mapping
        IMPORTING
          im_sap1  TYPE string
          im_sap2  TYPE string
          im_bcp47 TYPE string.

ENDCLASS.

CLASS lcl_bcp47_language_table IMPLEMENTATION.

  METHOD sap1_to_bcp47.
    DATA lv_language_mapping TYPE ty_language_mapping.

    IF gt_language_mappings IS INITIAL OR lines( gt_language_mappings ) = 0.
      fill_language_mappings( ).
    ENDIF.

    LOOP AT gt_language_mappings INTO lv_language_mapping WHERE sap1_code = im_sap1.
      IF re_bcp47 IS INITIAL OR strlen( re_bcp47 ) > strlen( lv_language_mapping-bcp47_code ).
        re_bcp47 = lv_language_mapping-bcp47_code.
      ENDIF.
    ENDLOOP.

    IF re_bcp47 IS INITIAL.
      zcx_abapgit_exception=>raise( |Could not map SAP1 language code { im_sap1 } to BCP47 language code.| ).
    ENDIF.
  ENDMETHOD.

  METHOD bcp47_to_sap1.
    DATA lv_language_mapping TYPE ty_language_mapping.

    IF gt_language_mappings IS INITIAL OR lines( gt_language_mappings ) = 0.
      fill_language_mappings( ).
    ENDIF.

    LOOP AT gt_language_mappings INTO lv_language_mapping.
      IF to_lower( lv_language_mapping-bcp47_code ) = to_lower( im_bcp47 ) AND re_sap1 IS INITIAL.
        re_sap1 = lv_language_mapping-sap1_code.
      ENDIF.
    ENDLOOP.

    IF re_sap1 IS INITIAL.
      zcx_abapgit_exception=>raise( |Could not map BCP47 language code { im_bcp47 } to SAP1 language code.| ).
    ENDIF.
  ENDMETHOD.

  METHOD sap1_to_sap2.
    DATA lv_language_mapping TYPE ty_language_mapping.

    IF gt_language_mappings IS INITIAL.
      fill_language_mappings( ).
    ENDIF.

    READ TABLE gt_language_mappings WITH KEY sap1_code = im_sap1 INTO lv_language_mapping.
    re_sap2 = lv_language_mapping-sap2_code.

    IF re_sap2 IS INITIAL.
      zcx_abapgit_exception=>raise( |Could not map SAP1 language code { im_sap1 } to SAP2 language code.| ).
    ENDIF.
  ENDMETHOD.

  METHOD sap2_to_sap1.
    DATA lv_language_mapping TYPE ty_language_mapping.

    IF gt_language_mappings IS INITIAL.
      fill_language_mappings( ).
    ENDIF.

    READ TABLE gt_language_mappings WITH KEY sap2_code = im_sap2 INTO lv_language_mapping.
    re_sap1 = lv_language_mapping-sap1_code.

    IF re_sap1 IS INITIAL.
      zcx_abapgit_exception=>raise( |Could not map SAP2 language code { im_sap2 } to SAP1 language code.| ).
    ENDIF.
  ENDMETHOD.

  METHOD fill_language_mapping.
    DATA lv_line TYPE ty_language_mapping.
    DATA lv_sap1 TYPE sy-langu.

    IF strlen( im_sap1 ) = 4.
      TRY.
          lv_sap1 = zcl_abapgit_convert=>uccp( im_sap1 ).
        CATCH cx_root.
          " Language is not supported in this system -> ignore it
          " Should someone try to use the language in a repo, it will result in an error (see above)
          RETURN.
      ENDTRY.
    ELSEIF strlen( im_sap1 ) = 1.
      lv_sap1 = im_sap1.
    ENDIF.

    lv_line-bcp47_code = im_bcp47.
    lv_line-sap2_code = im_sap2.
    lv_line-sap1_code = lv_sap1.

    APPEND lv_line TO gt_language_mappings.
    CLEAR lv_line.
  ENDMETHOD.

  METHOD fill_language_mappings.
    " table is filled with two separate methods to comply
    " with https://rules.abaplint.org/method_length/
    fill_language_mappings_1( ).
    fill_language_mappings_2( ).
  ENDMETHOD.

  METHOD fill_language_mappings_1.
    fill_language_mapping( im_sap1  = 'a'
                           im_sap2  = 'AF'
                           im_bcp47 = 'af' ).

    fill_language_mapping( im_sap1  = 'BF51'
                           im_sap2  = 'SQ'
                           im_bcp47 = 'sq' ).

    fill_language_mapping( im_sap1  = 'BA15'
                           im_sap2  = 'EU'
                           im_bcp47 = 'eu' ).

    fill_language_mapping( im_sap1  = 'B8F3'
                           im_sap2  = 'BS'
                           im_bcp47 = 'bs' ).

    fill_language_mapping( im_sap1  = 'W'
                           im_sap2  = 'BG'
                           im_bcp47 = 'bg' ).

    fill_language_mapping( im_sap1  = 'c'
                           im_sap2  = 'CA'
                           im_bcp47 = 'ca' ).

    fill_language_mapping( im_sap1  = '1'
                           im_sap2  = 'ZH'
                           im_bcp47 = 'zh' ).

    fill_language_mapping( im_sap1  = '1'
                           im_sap2  = 'ZH'
                           im_bcp47 = 'zh-Hans' ).

    fill_language_mapping( im_sap1  = 'B343'
                           im_sap2  = '3C'
                           im_bcp47 = 'zh-SG' ).

    fill_language_mapping( im_sap1  = 'M'
                           im_sap2  = 'ZF'
                           im_bcp47 = 'zh-Hant' ).

    fill_language_mapping( im_sap1  = '6'
                           im_sap2  = 'HR'
                           im_bcp47 = 'hr' ).

    fill_language_mapping( im_sap1  = 'C'
                           im_sap2  = 'CS'
                           im_bcp47 = 'cs' ).

    fill_language_mapping( im_sap1  = 'K'
                           im_sap2  = 'DA'
                           im_bcp47 = 'da' ).

    fill_language_mapping( im_sap1  = 'N'
                           im_sap2  = 'NL'
                           im_bcp47 = 'nl' ).

    fill_language_mapping( im_sap1  = 'N'
                           im_sap2  = 'NL'
                           im_bcp47 = 'nl-NL' ).

    fill_language_mapping( im_sap1  = 'B284'
                           im_sap2  = '1D'
                           im_bcp47 = 'nl-BE' ).

    fill_language_mapping( im_sap1  = 'E'
                           im_sap2  = 'EN'
                           im_bcp47 = 'en' ).

    fill_language_mapping( im_sap1  = 'E'
                           im_sap2  = 'EN'
                           im_bcp47 = 'en-US' ).

    fill_language_mapping( im_sap1  = 'B46E'
                           im_sap2  = '6N'
                           im_bcp47 = 'en-GB' ).

    fill_language_mapping( im_sap1  = 'B285'
                           im_sap2  = '1E'
                           im_bcp47 = 'en-AU' ).

    fill_language_mapping( im_sap1  = 'B2E5'
                           im_sap2  = '2E'
                           im_bcp47 = 'en-BZ' ).

    fill_language_mapping( im_sap1  = 'B345'
                           im_sap2  = '3E'
                           im_bcp47 = 'en-CA' ).

    fill_language_mapping( im_sap1  = 'B405'
                           im_sap2  = '5E'
                           im_bcp47 = 'en-HK' ).

    fill_language_mapping( im_sap1  = 'B465'
                           im_sap2  = '6E'
                           im_bcp47 = 'en-IN' ).

    fill_language_mapping( im_sap1  = 'B4C5'
                           im_sap2  = '7E'
                           im_bcp47 = 'en-ID' ).

    fill_language_mapping( im_sap1  = 'B525'
                           im_sap2  = '8E'
                           im_bcp47 = 'en-IE' ).

    fill_language_mapping( im_sap1  = 'B585'
                           im_sap2  = '9E'
                           im_bcp47 = 'en-JM' ).

    fill_language_mapping( im_sap1  = 'B225'
                           im_sap2  = '0E'
                           im_bcp47 = 'en-MY' ).

    fill_language_mapping( im_sap1  = 'B28E'
                           im_sap2  = '1N'
                           im_bcp47 = 'en-NZ' ).

    fill_language_mapping( im_sap1  = 'B2EE'
                           im_sap2  = '2N'
                           im_bcp47 = 'en-PH' ).

    fill_language_mapping( im_sap1  = 'B34E'
                           im_sap2  = '3N'
                           im_bcp47 = 'en-SG' ).

    fill_language_mapping( im_sap1  = 'B3AE'
                           im_sap2  = '4N'
                           im_bcp47 = 'en-ZA' ).

    fill_language_mapping( im_sap1  = 'B40E'
                           im_sap2  = '5N'
                           im_bcp47 = 'en-TT' ).

    fill_language_mapping( im_sap1  = 'B4CE'
                           im_sap2  = '7N'
                           im_bcp47 = 'en-ZW' ).

    fill_language_mapping( im_sap1  = '9'
                           im_sap2  = 'ET'
                           im_bcp47 = 'et' ).

    fill_language_mapping( im_sap1  = 'U'
                           im_sap2  = 'FI'
                           im_bcp47 = 'fi' ).

    fill_language_mapping( im_sap1  = 'F'
                           im_sap2  = 'FR'
                           im_bcp47 = 'fr' ).

    fill_language_mapping( im_sap1  = 'F'
                           im_sap2  = 'FR'
                           im_bcp47 = 'fr-FR' ).

    fill_language_mapping( im_sap1  = 'B286'
                           im_sap2  = '1F'
                           im_bcp47 = 'fr-BE' ).

    fill_language_mapping( im_sap1  = 'B2E6'
                           im_sap2  = '2F'
                           im_bcp47 = 'fr-CM' ).
  ENDMETHOD.

  METHOD fill_language_mappings_2.
    fill_language_mapping( im_sap1  = 'B346'
                           im_sap2  = '3F'
                           im_bcp47 = 'fr-CA' ).

    fill_language_mapping( im_sap1  = 'B3A6'
                           im_sap2  = '4F'
                           im_bcp47 = 'fr-CG' ).

    fill_language_mapping( im_sap1  = 'B406'
                           im_sap2  = '5F'
                           im_bcp47 = 'fr-CI' ).

    fill_language_mapping( im_sap1  = 'B466'
                           im_sap2  = '6F'
                           im_bcp47 = 'fr-HT' ).

    fill_language_mapping( im_sap1  = 'B4C6'
                           im_sap2  = '7F'
                           im_bcp47 = 'fr-LU' ).

    fill_language_mapping( im_sap1  = 'B526'
                           im_sap2  = '8F'
                           im_bcp47 = 'fr-ML' ).

    fill_language_mapping( im_sap1  = 'B586'
                           im_sap2  = '9F'
                           im_bcp47 = 'fr-MC' ).

    fill_language_mapping( im_sap1  = 'B288'
                           im_sap2  = '1H'
                           im_bcp47 = 'fr-MA' ).

    fill_language_mapping( im_sap1  = 'B2E8'
                           im_sap2  = '2H'
                           im_bcp47 = 'fr-RE' ).

    fill_language_mapping( im_sap1  = 'B348'
                           im_sap2  = '3H'
                           im_bcp47 = 'fr-SN' ).

    fill_language_mapping( im_sap1  = 'B3A8'
                           im_sap2  = '4H'
                           im_bcp47 = 'fr-CH' ).

    fill_language_mapping( im_sap1  = 'BAC4'
                           im_sap2  = 'GD'
                           im_bcp47 = 'gd' ).

    fill_language_mapping( im_sap1  = 'BACC'
                           im_sap2  = 'GL'
                           im_bcp47 = 'gl' ).

    fill_language_mapping( im_sap1  = 'D'
                           im_sap2  = 'DE'
                           im_bcp47 = 'de' ).

    fill_language_mapping( im_sap1  = 'D'
                           im_sap2  = 'DE'
                           im_bcp47 = 'de-DE' ).

    fill_language_mapping( im_sap1  = 'B287'
                           im_sap2  = '1G'
                           im_bcp47 = 'de-AT' ).

    fill_language_mapping( im_sap1  = 'B2E7'
                           im_sap2  = '2G'
                           im_bcp47 = 'de-LI' ).

    fill_language_mapping( im_sap1  = 'B347'
                           im_sap2  = '3G'
                           im_bcp47 = 'de-LU' ).

    fill_language_mapping( im_sap1  = 'B3A7'
                           im_sap2  = '4G'
                           im_bcp47 = 'de-CH' ).

    fill_language_mapping( im_sap1  = 'G'
                           im_sap2  = 'EL'
                           im_bcp47 = 'el' ).

    fill_language_mapping( im_sap1  = 'B'
                           im_sap2  = 'HE'
                           im_bcp47 = 'he' ).

    fill_language_mapping( im_sap1  = 'H'
                           im_sap2  = 'HU'
                           im_bcp47 = 'hu' ).

    fill_language_mapping( im_sap1  = 'b'
                           im_sap2  = 'IS'
                           im_bcp47 = 'is' ).

    fill_language_mapping( im_sap1  = 'i'
                           im_sap2  = 'ID'
                           im_bcp47 = 'id' ).

    fill_language_mapping( im_sap1  = 'BAC1'
                           im_sap2  = 'GA'
                           im_bcp47 = 'ga' ).

    fill_language_mapping( im_sap1  = 'I'
                           im_sap2  = 'IT'
                           im_bcp47 = 'it' ).

    fill_language_mapping( im_sap1  = 'I'
                           im_sap2  = 'IT'
                           im_bcp47 = 'it-IT' ).

    fill_language_mapping( im_sap1  = 'B289'
                           im_sap2  = '1I'
                           im_bcp47 = 'it-CH' ).

    fill_language_mapping( im_sap1  = 'J'
                           im_sap2  = 'JA'
                           im_bcp47 = 'ja' ).

    fill_language_mapping( im_sap1  = '3'
                           im_sap2  = 'KO'
                           im_bcp47 = 'ko' ).

    fill_language_mapping( im_sap1  = '3'
                           im_sap2  = 'KO'
                           im_bcp47 = 'ko-KR' ).

    fill_language_mapping( im_sap1  = 'Y'
                           im_sap2  = 'LV'
                           im_bcp47 = 'lv' ).

    fill_language_mapping( im_sap1  = 'X'
                           im_sap2  = 'LT'
                           im_bcp47 = 'lt' ).

    fill_language_mapping( im_sap1  = '7'
                           im_sap2  = 'MS'
                           im_bcp47 = 'ms' ).

    fill_language_mapping( im_sap1  = '7'
                           im_sap2  = 'MS'
                           im_bcp47 = 'ms-MY' ).

    fill_language_mapping( im_sap1  = 'B28D'
                           im_sap2  = '1M'
                           im_bcp47 = 'ms-BN' ).

    fill_language_mapping( im_sap1  = 'O'
                           im_sap2  = 'NO'
                           im_bcp47 = 'no' ).

    fill_language_mapping( im_sap1  = 'L'
                           im_sap2  = 'PL'
                           im_bcp47 = 'pl' ).

    fill_language_mapping( im_sap1  = 'P'
                           im_sap2  = 'PT'
                           im_bcp47 = 'pt' ).

    fill_language_mapping( im_sap1  = 'P'
                           im_sap2  = 'PT'
                           im_bcp47 = 'pt-BR' ).

    fill_language_mapping( im_sap1  = 'BEED'
                           im_sap2  = 'RM'
                           im_bcp47 = 'rm' ).

    fill_language_mapping( im_sap1  = '4'
                           im_sap2  = 'RO'
                           im_bcp47 = 'ro' ).

    fill_language_mapping( im_sap1  = '4'
                           im_sap2  = 'RO'
                           im_bcp47 = 'ro-RO' ).

    fill_language_mapping( im_sap1  = 'R'
                           im_sap2  = 'RU'
                           im_bcp47 = 'ru-RU' ).

    fill_language_mapping( im_sap1  = '0'
                           im_sap2  = 'SR'
                           im_bcp47 = 'sr' ).

    fill_language_mapping( im_sap1  = '0'
                           im_sap2  = 'SR'
                           im_bcp47 = 'sr-Cyrl' ).

    fill_language_mapping( im_sap1  = 'd'
                           im_sap2  = 'SH'
                           im_bcp47 = 'sr-Latn' ).

    fill_language_mapping( im_sap1  = 'Q'
                           im_sap2  = 'SK'
                           im_bcp47 = 'sk' ).

    fill_language_mapping( im_sap1  = '5'
                           im_sap2  = 'SL'
                           im_bcp47 = 'sl' ).

    fill_language_mapping( im_sap1  = 'BF42'
                           im_sap2  = 'SB'
                           im_bcp47 = 'wen' ).

    fill_language_mapping( im_sap1  = 'B9B3'
                           im_sap2  = 'DS'
                           im_bcp47 = 'dsb' ).

    fill_language_mapping( im_sap1  = 'BB33'
                           im_sap2  = 'HS'
                           im_bcp47 = 'hsb' ).

    fill_language_mapping( im_sap1  = 'S'
                           im_sap2  = 'ES'
                           im_bcp47 = 'es' ).

    fill_language_mapping( im_sap1  = 'S'
                           im_sap2  = 'ES'
                           im_bcp47 = 'es-ES' ).

    fill_language_mapping( im_sap1  = 'B293'
                           im_sap2  = '1S'
                           im_bcp47 = 'es-AR' ).

    fill_language_mapping( im_sap1  = 'B2F3'
                           im_sap2  = '2S'
                           im_bcp47 = 'es-BO' ).

    fill_language_mapping( im_sap1  = 'B353'
                           im_sap2  = '3S'
                           im_bcp47 = 'es-CL' ).

    fill_language_mapping( im_sap1  = 'B233'
                           im_sap2  = '0S'
                           im_bcp47 = 'es-CO' ).

    fill_language_mapping( im_sap1  = 'B3B3'
                           im_sap2  = '4S'
                           im_bcp47 = 'es-CR' ).

    fill_language_mapping( im_sap1  = 'B413'
                           im_sap2  = '5S'
                           im_bcp47 = 'es-DO' ).

    fill_language_mapping( im_sap1  = 'B473'
                           im_sap2  = '6S'
                           im_bcp47 = 'es-EC' ).

    fill_language_mapping( im_sap1  = 'B4D3'
                           im_sap2  = '7S'
                           im_bcp47 = 'es-SV' ).

    fill_language_mapping( im_sap1  = 'B533'
                           im_sap2  = '8S'
                           im_bcp47 = 'es-GT' ).

    fill_language_mapping( im_sap1  = 'B593'
                           im_sap2  = '9S'
                           im_bcp47 = 'es-HN' ).

    fill_language_mapping( im_sap1  = 'B298'
                           im_sap2  = '1X'
                           im_bcp47 = 'es-MX' ).

    fill_language_mapping( im_sap1  = 'B2F8'
                           im_sap2  = '2X'
                           im_bcp47 = 'es-NI' ).

    fill_language_mapping( im_sap1  = 'B358'
                           im_sap2  = '3X'
                           im_bcp47 = 'es-PA' ).

    fill_language_mapping( im_sap1  = 'B3B8'
                           im_sap2  = '4X'
                           im_bcp47 = 'es-PY' ).

    fill_language_mapping( im_sap1  = 'B418'
                           im_sap2  = '5X'
                           im_bcp47 = 'es-PE' ).

    fill_language_mapping( im_sap1  = 'B478'
                           im_sap2  = '6X'
                           im_bcp47 = 'es-PR' ).

    fill_language_mapping( im_sap1  = 'B4D8'
                           im_sap2  = '7X'
                           im_bcp47 = 'es-UY' ).

    fill_language_mapping( im_sap1  = 'B538'
                           im_sap2  = '8X'
                           im_bcp47 = 'es-VE' ).

    fill_language_mapping( im_sap1  = 'BF57'
                           im_sap2  = 'SW'
                           im_bcp47 = 'sw' ).

    fill_language_mapping( im_sap1  = 'V'
                           im_sap2  = 'SV'
                           im_bcp47 = 'sv' ).

    fill_language_mapping( im_sap1  = 'BFAC'
                           im_sap2  = 'TL'
                           im_bcp47 = 'tl' ).

    fill_language_mapping( im_sap1  = '2'
                           im_sap2  = 'TH'
                           im_bcp47 = 'th' ).

    fill_language_mapping( im_sap1  = 'T'
                           im_sap2  = 'TR'
                           im_bcp47 = 'tr' ).

    fill_language_mapping( im_sap1  = '8'
                           im_sap2  = 'UK'
                           im_bcp47 = 'uk' ).

    fill_language_mapping( im_sap1  = 'C069'
                           im_sap2  = 'VI'
                           im_bcp47 = 'vi' ).

    fill_language_mapping( im_sap1  = 'C0C1'
                           im_sap2  = 'WA'
                           im_bcp47 = 'wa' ).

    fill_language_mapping( im_sap1  = 'A'
                           im_sap2  = 'AR'
                           im_bcp47 = 'ar-SA' ).
  ENDMETHOD.

ENDCLASS.

CLASS zcl_abapgit_convert IMPLEMENTATION.

  METHOD base64_to_xstring.

    rv_xstr = cl_http_utility=>decode_x_base64( iv_base64 ).

  ENDMETHOD.

  METHOD bitbyte_to_int.

    DATA: lv_bitbyte TYPE string,
          lv_len     TYPE i,
          lv_offset  TYPE i.

    lv_bitbyte = iv_bits.
    SHIFT lv_bitbyte LEFT DELETING LEADING '0 '.
    lv_len     = strlen( lv_bitbyte ).
    lv_offset  = lv_len - 1.

    rv_int = 0.
    DO lv_len TIMES.

      IF sy-index = 1.
        "Initialize
        IF lv_bitbyte+lv_offset(1) = '1'.
          rv_int = 1.
        ENDIF.
      ELSEIF lv_bitbyte+lv_offset(1) = '1'.
        rv_int = rv_int + ( 2 ** ( sy-index - 1 ) ).
      ENDIF.

      lv_offset = lv_offset - 1. "Move Cursor

    ENDDO.

  ENDMETHOD.

  METHOD conversion_exit_isola_output.

    language_sap1_to_sap2(
      EXPORTING
        im_lang_sap1  = iv_spras
      RECEIVING
        re_lang_sap2  = rv_spras
      EXCEPTIONS
        no_assignment = 1
        OTHERS        = 2 ).                              "#EC CI_SUBRC

    TRANSLATE rv_spras TO UPPER CASE.

  ENDMETHOD.

  METHOD int_to_xstring4.
* returns xstring of length 4 containing the integer value iv_i

    DATA lv_x TYPE x LENGTH 4.

    lv_x = iv_i.
    rv_xstring = lv_x.

  ENDMETHOD.

  METHOD language_bcp47_to_sap1.
    DATA lv_converter_instance TYPE REF TO object.
    DATA lv_converter_class_name TYPE string VALUE `CL_AFF_LANGUAGE_CONVERTER`.
    DATA lv_regex TYPE REF TO cl_abap_regex.
    DATA lv_abap_matcher TYPE REF TO cl_abap_matcher.

    DATA lv_sap2_lang_code TYPE laiso.

    TRY.
        CALL METHOD (lv_converter_class_name)=>create_instance
          RECEIVING
            result = lv_converter_instance.

        TRY.
            CALL METHOD lv_converter_instance->(`IF_AFF_LANGUAGE_CONVERTER~BCP47_TO_SAP1`)
              EXPORTING
                language = im_lang_bcp47
              RECEIVING
                result   = re_lang_sap1.

          CATCH cx_static_check.
            RAISE no_assignment.
        ENDTRY.

      CATCH cx_sy_dyn_call_error.
        TRY.
            re_lang_sap1 = lcl_bcp47_language_table=>bcp47_to_sap1( im_lang_bcp47 ).
          CATCH zcx_abapgit_exception.

            CREATE OBJECT lv_regex EXPORTING pattern = `[A-Z0-9]{2}`.
            lv_abap_matcher = lv_regex->create_matcher( text = im_lang_bcp47 ).

            IF abap_true = lv_abap_matcher->match( ).
              "Fallback try to convert from SAP language
              lv_sap2_lang_code = im_lang_bcp47.

              language_sap2_to_sap1(
                EXPORTING
                  im_lang_sap2  = lv_sap2_lang_code
                RECEIVING
                  re_lang_sap1  = re_lang_sap1
                EXCEPTIONS
                  no_assignment = 1
                  OTHERS        = 2 ).
              IF sy-subrc <> 0.
                RAISE no_assignment.
              ENDIF.

            ELSE.
              RAISE no_assignment.
            ENDIF.
        ENDTRY.
    ENDTRY.
  ENDMETHOD.

  METHOD language_sap1_to_bcp47.
    DATA lv_converter_instance TYPE REF TO object.
    DATA lv_converter_class_name TYPE string VALUE `CL_AFF_LANGUAGE_CONVERTER`.

    TRY.
        CALL METHOD (lv_converter_class_name)=>create_instance
          RECEIVING
            result = lv_converter_instance.

        TRY.
            CALL METHOD lv_converter_instance->(`IF_AFF_LANGUAGE_CONVERTER~SAP1_TO_BCP47`)
              EXPORTING
                language = im_lang_sap1
              RECEIVING
                result   = re_lang_bcp47.
          CATCH cx_static_check.
            RAISE no_assignment.
        ENDTRY.
      CATCH cx_sy_dyn_call_error.
        TRY.
            re_lang_bcp47 = lcl_bcp47_language_table=>sap1_to_bcp47( im_lang_sap1 ).
          CATCH zcx_abapgit_exception.
            RAISE no_assignment.
        ENDTRY.
    ENDTRY.
  ENDMETHOD.

  METHOD language_sap1_to_sap2.

    TRY.
        re_lang_sap2 = lcl_bcp47_language_table=>sap1_to_sap2( im_lang_sap1 ).
      CATCH zcx_abapgit_exception.
        RAISE no_assignment.
    ENDTRY.

  ENDMETHOD.

  METHOD language_sap2_to_sap1.

    TRY.
        re_lang_sap1 = lcl_bcp47_language_table=>sap2_to_sap1( im_lang_sap2 ).
      CATCH zcx_abapgit_exception.
        RAISE no_assignment.
    ENDTRY.

  ENDMETHOD.

  METHOD split_string.

    FIND FIRST OCCURRENCE OF cl_abap_char_utilities=>cr_lf IN iv_string.

    " Convert string into table depending on separator type CR_LF vs. LF
    IF sy-subrc = 0.
      SPLIT iv_string AT cl_abap_char_utilities=>cr_lf INTO TABLE rt_lines.
    ELSE.
      SPLIT iv_string AT cl_abap_char_utilities=>newline INTO TABLE rt_lines.
    ENDIF.

  ENDMETHOD.

  METHOD string_to_tab.

    DATA lv_length TYPE i.
    DATA lv_iterations TYPE i.
    DATA lv_offset TYPE i.

    FIELD-SYMBOLS <lg_line> TYPE any.

    CLEAR et_tab.
    ev_size = strlen( iv_str ).

    APPEND INITIAL LINE TO et_tab ASSIGNING <lg_line>.
    <lg_line> = iv_str.
    lv_length = cl_abap_typedescr=>describe_by_data( <lg_line> )->length / cl_abap_char_utilities=>charsize.
    lv_iterations = ev_size DIV lv_length.

    DO lv_iterations TIMES.
      lv_offset = sy-index * lv_length.
      APPEND INITIAL LINE TO et_tab ASSIGNING <lg_line>.
      <lg_line> = iv_str+lv_offset.
    ENDDO.

  ENDMETHOD.

  METHOD string_to_xstring.

    rv_xstr = string_to_xstring_utf8( iv_str ).

  ENDMETHOD.

  METHOD string_to_xstring_utf8.

    rv_xstring = lcl_out=>convert( iv_string ).

  ENDMETHOD.

  METHOD string_to_xstring_utf8_bom.

    IF iv_string IS INITIAL.
      RETURN.
    ENDIF.

    rv_xstring = string_to_xstring_utf8( iv_string ).

    " Add UTF-8 BOM
    IF xstrlen( rv_xstring ) < 3 OR rv_xstring(3) <> cl_abap_char_utilities=>byte_order_mark_utf8.
      rv_xstring = cl_abap_char_utilities=>byte_order_mark_utf8 && rv_xstring.
    ENDIF.

  ENDMETHOD.

  METHOD uccp.

    DATA lv_class    TYPE string.
    DATA lv_xstr     TYPE xstring.
    DATA lo_instance TYPE REF TO object.

    lv_class = 'CL_ABAP_CONV_IN_CE'.

    TRY.
        CALL METHOD (lv_class)=>uccp
          EXPORTING
            uccp = iv_uccp
          RECEIVING
            char = rv_char.
      CATCH cx_sy_dyn_call_illegal_class.
        lv_xstr = iv_uccp.

        CALL METHOD ('CL_ABAP_CONV_CODEPAGE')=>create_in
          EXPORTING
            codepage = 'UTF-16'
          RECEIVING
            instance = lo_instance.

* convert endianness
        CONCATENATE lv_xstr+1(1) lv_xstr(1) INTO lv_xstr IN BYTE MODE.

        CALL METHOD lo_instance->('IF_ABAP_CONV_IN~CONVERT')
          EXPORTING
            source = lv_xstr
          RECEIVING
            result = rv_char.
    ENDTRY.

  ENDMETHOD.

  METHOD xstring_remove_bom.

    rv_xstr = iv_xstr.

    " cl_abap_conv_in_ce does not handle BOM in non-Unicode systems, so we remove it
    IF cl_abap_char_utilities=>charsize = 1 AND xstrlen( rv_xstr ) > 3
        AND rv_xstr(3) = cl_abap_char_utilities=>byte_order_mark_utf8.

      rv_xstr = rv_xstr+3.

    ENDIF.

  ENDMETHOD.

  METHOD xstring_to_bintab.

    DATA lv_length TYPE i.
    DATA lv_iterations TYPE i.
    DATA lv_offset TYPE i.
    DATA lv_struct TYPE abap_bool.

    FIELD-SYMBOLS <lg_line> TYPE any.

    CLEAR et_bintab.
    ev_size = xstrlen( iv_xstr ).

    IF iv_xstr IS INITIAL.
      RETURN.
    ENDIF.

    APPEND INITIAL LINE TO et_bintab ASSIGNING <lg_line>.
    lv_struct = boolc(
      cl_abap_typedescr=>describe_by_data( <lg_line> )->type_kind = cl_abap_typedescr=>typekind_struct1 ).
    IF lv_struct = abap_true.
      ASSIGN COMPONENT 1 OF STRUCTURE <lg_line> TO <lg_line>.
    ENDIF.
    <lg_line> = iv_xstr.

    lv_length = cl_abap_typedescr=>describe_by_data( <lg_line> )->length.
    ASSERT lv_length > 0.

    lv_iterations = ( ev_size - 1 ) DIV lv_length.

    DO lv_iterations TIMES.
      lv_offset = sy-index * lv_length.
      APPEND INITIAL LINE TO et_bintab ASSIGNING <lg_line>.
      IF lv_struct = abap_true.
        ASSIGN COMPONENT 1 OF STRUCTURE <lg_line> TO <lg_line>.
      ENDIF.
      <lg_line> = iv_xstr+lv_offset.
    ENDDO.

  ENDMETHOD.

  METHOD xstring_to_int.

* use the built-in type conversion
    rv_i = iv_xstring.

  ENDMETHOD.

  METHOD xstring_to_string_utf8.

    DATA lv_data   TYPE xstring.
    DATA lv_length TYPE i.

    " Remove BOM for non-Unicode systems
    lv_data = xstring_remove_bom( iv_data ).

    lv_length = iv_length.
    IF lv_length <= 0.
      lv_length = xstrlen( lv_data ).
    ENDIF.

    rv_string = lcl_in=>convert(
      iv_data   = lv_data
      iv_length = lv_length ).

  ENDMETHOD.

  METHOD xstring_to_string_utf8_bom.

    DATA lv_xstring TYPE xstring.

    IF iv_xstring IS INITIAL.
      RETURN.
    ENDIF.

    lv_xstring = iv_xstring.
    " Add UTF-8 BOM
    IF xstrlen( lv_xstring ) < 3 OR lv_xstring(3) <> cl_abap_char_utilities=>byte_order_mark_utf8.
      lv_xstring = cl_abap_char_utilities=>byte_order_mark_utf8 && lv_xstring.
    ENDIF.

    rv_string = xstring_to_string_utf8( lv_xstring ).

  ENDMETHOD.

  METHOD x_to_bitbyte.

    CLEAR rv_bitbyte.

    GET BIT 1 OF iv_x INTO rv_bitbyte+0(1).
    GET BIT 2 OF iv_x INTO rv_bitbyte+1(1).
    GET BIT 3 OF iv_x INTO rv_bitbyte+2(1).
    GET BIT 4 OF iv_x INTO rv_bitbyte+3(1).
    GET BIT 5 OF iv_x INTO rv_bitbyte+4(1).
    GET BIT 6 OF iv_x INTO rv_bitbyte+5(1).
    GET BIT 7 OF iv_x INTO rv_bitbyte+6(1).
    GET BIT 8 OF iv_x INTO rv_bitbyte+7(1).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_cts_api IMPLEMENTATION.

  METHOD get_current_transport_for_obj.
    DATA: lv_object_lockable   TYPE abap_bool,
          lv_locked            TYPE abap_bool,
          lv_transport_request TYPE trkorr,
          ls_tlock             TYPE tlock,
          lt_tlock             TYPE STANDARD TABLE OF tlock WITH DEFAULT KEY,
          lt_transports        TYPE STANDARD TABLE OF trkorr WITH DEFAULT KEY,
          lv_task              TYPE trkorr,
          lv_tr_object_name    TYPE trobj_name.

    lv_tr_object_name = iv_object_name.

    CALL FUNCTION 'TR_CHECK_OBJECT_LOCK'
      EXPORTING
        wi_pgmid             = iv_program_id
        wi_object            = iv_object_type
        wi_objname           = lv_tr_object_name
      IMPORTING
        we_lockable_object   = lv_object_lockable
        we_locked            = lv_locked
        we_lock_order        = lv_transport_request
        we_lock_task         = lv_task
      TABLES
        wt_tlock             = lt_tlock
      EXCEPTIONS
        empty_key            = 1
        no_systemname        = 2
        no_systemtype        = 3
        unallowed_lock_order = 4
        OTHERS               = 5.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    IF lv_locked = abap_false.
      zcx_abapgit_exception=>raise( |Object { iv_program_id }-{ iv_object_type }-{ iv_object_name } is not locked| ).
    ENDIF.

    IF lv_object_lockable = abap_false.
      zcx_abapgit_exception=>raise( |Object type { iv_program_id }-{ iv_object_type } not lockable| ).
    ENDIF.

    LOOP AT lt_tlock INTO ls_tlock.
      COLLECT ls_tlock-trkorr INTO lt_transports.
    ENDLOOP.

    IF lines( lt_transports ) = 1.
      rv_transport = lv_transport_request.
    ELSE.
      rv_transport = zif_abapgit_definitions=>c_multiple_transports.
    ENDIF.

  ENDMETHOD.

  METHOD get_current_transport_from_db.

    " This method is used for objects that are included in transports but not locked
    " for example, namespaces (NSPC)
    SELECT SINGLE a~trkorr FROM e070 AS a JOIN e071 AS b ON a~trkorr = b~trkorr
      INTO rv_transport
      WHERE ( a~trstatus = 'D' OR a~trstatus = 'L' )
        AND a~trfunction <> 'G'
        AND b~pgmid = iv_program_id AND b~object = iv_object_type AND b~obj_name = iv_object_name.

  ENDMETHOD.

  METHOD is_object_locked_in_transport.
    DATA: ls_object_key        TYPE e071,
          lv_type_check_result TYPE c LENGTH 1,
          ls_lock_key          TYPE tlock_int,
          lv_lock_flag         TYPE c LENGTH 1.

    ls_object_key-pgmid = iv_program_id.
    ls_object_key-object = iv_object_type.
    ls_object_key-obj_name = iv_object_name.

    CALL FUNCTION 'TR_CHECK_TYPE'
      EXPORTING
        wi_e071     = ls_object_key
      IMPORTING
        pe_result   = lv_type_check_result
        we_lock_key = ls_lock_key.

    IF lv_type_check_result <> 'L'.
      zcx_abapgit_exception=>raise( |Object type { iv_program_id }-{ iv_object_type } not lockable| ).
    ENDIF.

    CALL FUNCTION 'TRINT_CHECK_LOCKS'
      EXPORTING
        wi_lock_key = ls_lock_key
      IMPORTING
        we_lockflag = lv_lock_flag
      EXCEPTIONS
        empty_key   = 1
        OTHERS      = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    rv_locked = boolc( lv_lock_flag <> space ).
  ENDMETHOD.

  METHOD is_object_type_lockable.
    DATA: ls_object_key        TYPE e071,
          lv_type_check_result TYPE c LENGTH 1.

    ls_object_key-pgmid = iv_program_id.
    ls_object_key-object = iv_object_type.
    ls_object_key-obj_name = '_'. " Dummy value #2071

    CALL FUNCTION 'TR_CHECK_TYPE'
      EXPORTING
        wi_e071   = ls_object_key
      IMPORTING
        pe_result = lv_type_check_result.

    rv_lockable = boolc( lv_type_check_result = 'L' ).
  ENDMETHOD.

  METHOD is_object_type_transportable.
    DATA: ls_object_key        TYPE e071,
          lv_type_check_result TYPE c LENGTH 1.

    ls_object_key-pgmid = iv_program_id.
    ls_object_key-object = iv_object_type.
    ls_object_key-obj_name = '_'. " Dummy value #2071

    CALL FUNCTION 'TR_CHECK_TYPE'
      EXPORTING
        wi_e071   = ls_object_key
      IMPORTING
        pe_result = lv_type_check_result.

    rv_transportable = boolc( lv_type_check_result CA 'RTL' OR iv_object_type = 'TABU' ).
  ENDMETHOD.

  METHOD zif_abapgit_cts_api~change_transport_type.

    DATA:
      ls_request_header  TYPE trwbo_request_header,
      lt_request_headers TYPE trwbo_request_headers.

    CALL FUNCTION 'ENQUEUE_E_TRKORR'
      EXPORTING
        trkorr         = iv_transport_request
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    CALL FUNCTION 'TR_READ_REQUEST_WITH_TASKS'
      EXPORTING
        iv_trkorr          = iv_transport_request
      IMPORTING
        et_request_headers = lt_request_headers
      EXCEPTIONS
        invalid_input      = 1
        OTHERS             = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    LOOP AT lt_request_headers INTO ls_request_header WHERE trfunction = iv_transport_type_from.

      CALL FUNCTION 'TRINT_READ_REQUEST_HEADER'
        EXPORTING
          iv_read_e070   = abap_true
          iv_read_e070c  = abap_true
        CHANGING
          cs_request     = ls_request_header
        EXCEPTIONS
          empty_trkorr   = 1
          not_exist_e070 = 2
          OTHERS         = 3.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      CALL FUNCTION 'TRINT_CHANGE_TRFUNCTION'
        EXPORTING
          iv_new_trfunction      = iv_transport_type_to
        CHANGING
          cs_request_header      = ls_request_header
        EXCEPTIONS
          action_aborted_by_user = 1
          change_not_allowed     = 2
          db_access_error        = 3
          OTHERS                 = 4.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

    ENDLOOP.

    CALL FUNCTION 'DEQUEUE_E_TRKORR'
      EXPORTING
        trkorr = iv_transport_request.

  ENDMETHOD.

  METHOD zif_abapgit_cts_api~confirm_transport_messages.

    TYPES: BEGIN OF ty_s_message,
             id TYPE symsgid,
             ty TYPE symsgty,
             no TYPE symsgno,
             v1 TYPE symsgv,
             v2 TYPE symsgv,
             v3 TYPE symsgv,
             v4 TYPE symsgv,
           END OF ty_s_message.

    DATA ls_message TYPE ty_s_message.

    FIELD-SYMBOLS: <lt_confirmed_messages> TYPE STANDARD TABLE.

    IF mv_confirm_transp_msgs_called = abap_true.
      RETURN.
    ENDIF.

    " remember the call to avoid duplicates in GT_CONFIRMED_MESSAGES
    mv_confirm_transp_msgs_called = abap_true.

    " Auto-confirm certain messages (requires SAP Note 1609940)
    PERFORM dummy IN PROGRAM saplstrd IF FOUND.  "load function group STRD once into memory

    ASSIGN ('(SAPLSTRD)GT_CONFIRMED_MESSAGES') TO <lt_confirmed_messages>.

    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    " Object can only be created in package of namespace
    ls_message-id = 'TR'.
    ls_message-no = '007'.
    INSERT ls_message INTO TABLE <lt_confirmed_messages>.

    " Original system set to "SAP"
    ls_message-id = 'TR'.
    ls_message-no = '013'.
    INSERT ls_message INTO TABLE <lt_confirmed_messages>.

    " Make repairs in foreign namespaces only if they are urgent
    ls_message-id = 'TR'.
    ls_message-no = '852'.
    INSERT ls_message INTO TABLE <lt_confirmed_messages>.

    " Make repairs in foreign namespaces only if they are urgent
    ls_message-id = 'TK'.
    ls_message-no = '016'.
    INSERT ls_message INTO TABLE <lt_confirmed_messages>.

    rv_messages_confirmed = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_cts_api~create_transport_entries.

    DATA lt_tables      TYPE tredt_objects.
    DATA lt_table_keys  TYPE STANDARD TABLE OF e071k.
    DATA lv_with_dialog TYPE abap_bool.

    FIELD-SYMBOLS <ls_table> LIKE LINE OF lt_tables.
    FIELD-SYMBOLS <ls_table_key> LIKE LINE OF lt_table_keys.

    cl_table_utilities_brf=>create_transport_entries(
      EXPORTING
        it_table_ins = it_table_ins
        it_table_upd = it_table_upd
        it_table_del = it_table_del
        iv_tabname   = iv_tabname
      CHANGING
        ct_e071      = lt_tables
        ct_e071k     = lt_table_keys ).

    " cl_table_utilities_brf=>write_transport_entries does not allow passing a request

    CALL FUNCTION 'TR_OBJECTS_CHECK'
      TABLES
        wt_ko200                = lt_tables
        wt_e071k                = lt_table_keys
      EXCEPTIONS
        cancel_edit_other_error = 1
        show_only_other_error   = 2
        OTHERS                  = 3.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    IF iv_transport IS INITIAL.
      lv_with_dialog = abap_true.
    ENDIF.

    READ TABLE lt_tables ASSIGNING <ls_table> INDEX 1.
    ASSERT sy-subrc = 0.

    LOOP AT lt_table_keys ASSIGNING <ls_table_key>.
      <ls_table_key>-objfunc = <ls_table>-objfunc.
    ENDLOOP.

    CALL FUNCTION 'TR_OBJECT_INSERT'
      EXPORTING
        wi_order                = iv_transport
        wi_ko200                = <ls_table>
        iv_no_show_option       = abap_true
      TABLES
        wt_e071k                = lt_table_keys
      EXCEPTIONS
        cancel_edit_other_error = 1
        show_only_other_error   = 2
        OTHERS                  = 3.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_cts_api~get_r3tr_obj_for_limu_obj.

    CLEAR ev_object.
    CLEAR ev_obj_name.

    IF iv_object = 'MESS'.
      ev_object = 'MSAG'.
      ev_obj_name = substring( val = iv_obj_name
                               len = strlen( iv_obj_name ) - 3 ).
      RETURN.
    ENDIF.

    CALL FUNCTION 'GET_R3TR_OBJECT_FROM_LIMU_OBJ'
      EXPORTING
        p_limu_objtype = iv_object
        p_limu_objname = iv_obj_name
      IMPORTING
        p_r3tr_objtype = ev_object
        p_r3tr_objname = ev_obj_name
      EXCEPTIONS
        no_mapping     = 1
        OTHERS         = 2.
    IF sy-subrc <> 0 OR ev_obj_name IS INITIAL.
      zcx_abapgit_exception=>raise( |No R3TR Object found for { iv_object } { iv_obj_name }| ).
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_cts_api~get_transports_for_list.

    DATA lv_request TYPE trkorr.
    DATA lt_tlock TYPE SORTED TABLE OF tlock WITH NON-UNIQUE KEY object hikey.
    DATA ls_object_key TYPE e071.
    DATA lv_type_check_result TYPE c LENGTH 1.
    DATA ls_lock_key TYPE tlock_int.
    DATA ls_transport LIKE LINE OF rt_transports.

    FIELD-SYMBOLS <ls_item> LIKE LINE OF it_items.
    FIELD-SYMBOLS <ls_tlock> LIKE LINE OF lt_tlock.

* Workarounds to improve performance, note that IT_ITEMS might
* contain 1000s of rows, see standard logic in function module
* TR_CHECK_OBJECT_LOCK

* avoid database lookups in TLOCK for each item,
    SELECT * FROM tlock INTO TABLE lt_tlock.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    LOOP AT it_items ASSIGNING <ls_item>.
      CLEAR lv_request.

      ls_object_key-pgmid = 'R3TR'.
      ls_object_key-object = <ls_item>-obj_type.
      ls_object_key-obj_name = <ls_item>-obj_name.

      CALL FUNCTION 'TR_CHECK_TYPE'
        EXPORTING
          wi_e071     = ls_object_key
        IMPORTING
          we_lock_key = ls_lock_key
          pe_result   = lv_type_check_result.

      IF lv_type_check_result = 'L'.
        LOOP AT lt_tlock ASSIGNING <ls_tlock>
            WHERE object = ls_lock_key-obj
            AND hikey >= ls_lock_key-low
            AND lokey <= ls_lock_key-hi.                  "#EC PORTABLE
          IF lv_request IS INITIAL.
            lv_request = <ls_tlock>-trkorr.
          ELSE.
            lv_request = zif_abapgit_definitions=>c_multiple_transports.
            EXIT.
          ENDIF.
        ENDLOOP.
      ELSEIF is_object_type_transportable( <ls_item>-obj_type ) = abap_true.
        lv_request = get_current_transport_from_db(
          iv_object_type = <ls_item>-obj_type
          iv_object_name = <ls_item>-obj_name ).
      ENDIF.

      IF lv_request IS NOT INITIAL.
        ls_transport-obj_type = <ls_item>-obj_type.
        ls_transport-obj_name = <ls_item>-obj_name.
        ls_transport-trkorr = lv_request.
        INSERT ls_transport INTO TABLE rt_transports.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_cts_api~get_transport_for_object.

    IF is_item-obj_type IS NOT INITIAL AND is_item-obj_name IS NOT INITIAL.

      IF is_object_type_lockable( is_item-obj_type ) = abap_true AND
         is_object_locked_in_transport(
           iv_object_type = is_item-obj_type
           iv_object_name = is_item-obj_name ) = abap_true.

        rv_transport = get_current_transport_for_obj(
          iv_object_type = is_item-obj_type
          iv_object_name = is_item-obj_name ).

      ELSEIF is_object_type_transportable( is_item-obj_type ) = abap_true.

        rv_transport = get_current_transport_from_db(
          iv_object_type = is_item-obj_type
          iv_object_name = is_item-obj_name ).

      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_cts_api~insert_transport_object.

    CALL FUNCTION 'RS_CORR_INSERT'
      EXPORTING
        object              = iv_obj_name
        object_class        = iv_object
        devclass            = iv_package
        master_language     = iv_language
        mode                = iv_mode
        global_lock         = abap_true
        suppress_dialog     = abap_true
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_cts_api~is_chrec_possible_for_package.
    IF iv_package IS NOT INITIAL.
      rv_possible = zcl_abapinst_factory=>get_sap_package( iv_package )->are_changes_recorded_in_tr_req( ).
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_cts_api~list_open_requests_by_user.

    TYPES: BEGIN OF ty_e070,
             trkorr     TYPE e070-trkorr,
             trfunction TYPE e070-trfunction,
             strkorr    TYPE e070-strkorr,
           END OF ty_e070.
    DATA lt_e070 TYPE STANDARD TABLE OF ty_e070 WITH DEFAULT KEY.

* find all tasks first
    SELECT trkorr trfunction strkorr
      FROM e070 INTO TABLE lt_e070
      WHERE as4user = sy-uname
      AND trstatus = zif_abapgit_cts_api=>c_transport_status-modifiable
      AND strkorr <> ''
      ORDER BY PRIMARY KEY.

    IF lines( lt_e070 ) > 0.
      SELECT trkorr FROM e070
        INTO TABLE rt_trkorr
        FOR ALL ENTRIES IN lt_e070
        WHERE trkorr = lt_e070-strkorr
        AND trfunction = zif_abapgit_cts_api=>c_transport_type-wb_request.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_cts_api~list_r3tr_by_request.

    TYPES: BEGIN OF ty_contents,
             trkorr   TYPE e071-trkorr,
             as4pos   TYPE e071-as4pos,
             pgmid    TYPE e071-pgmid,
             object   TYPE e071-object,
             obj_name TYPE e071-obj_name,
           END OF ty_contents.

    DATA lt_tasks    TYPE STANDARD TABLE OF trkorr WITH DEFAULT KEY.
    DATA lt_contents TYPE STANDARD TABLE OF ty_contents WITH DEFAULT KEY.
    DATA ls_contents LIKE LINE OF lt_contents.
    DATA ls_list     LIKE LINE OF rt_list.

    SELECT trkorr FROM e070 INTO TABLE lt_tasks
      WHERE strkorr = iv_request
      ORDER BY PRIMARY KEY.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    SELECT trkorr as4pos pgmid object obj_name FROM e071
      INTO TABLE lt_contents
      FOR ALL ENTRIES IN lt_tasks
      WHERE trkorr = lt_tasks-table_line
      ORDER BY PRIMARY KEY.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    LOOP AT lt_contents INTO ls_contents.
      CASE ls_contents-pgmid.
        WHEN 'R3TR'.
          ls_list-object = ls_contents-object.
          ls_list-obj_name = ls_contents-obj_name.
          INSERT ls_list INTO TABLE rt_list.
        WHEN 'LIMU'.
          TRY.
              zif_abapgit_cts_api~get_r3tr_obj_for_limu_obj(
                EXPORTING
                  iv_object   = ls_contents-object
                  iv_obj_name = ls_contents-obj_name
                IMPORTING
                  ev_object   = ls_list-object
                  ev_obj_name = ls_list-obj_name ).
              INSERT ls_list INTO TABLE rt_list.
            CATCH zcx_abapgit_exception ##NO_HANDLER.
          ENDTRY.
      ENDCASE.
    ENDLOOP.

    SORT rt_list BY object obj_name.
    DELETE ADJACENT DUPLICATES FROM rt_list COMPARING object obj_name.

  ENDMETHOD.

  METHOD zif_abapgit_cts_api~read.

    DATA ls_request TYPE trwbo_request.
    DATA ls_key     LIKE LINE OF ls_request-keys.

    FIELD-SYMBOLS <ls_key> LIKE LINE OF rs_request-keys.

    ls_request-h-trkorr = iv_trkorr.

    CALL FUNCTION 'TRINT_READ_REQUEST'
      EXPORTING
        iv_read_e070       = abap_true
        iv_read_e07t       = abap_true
        iv_read_e070c      = abap_true
        iv_read_e070m      = abap_true
        iv_read_objs_keys  = abap_true
        iv_read_objs       = abap_true
        iv_read_attributes = abap_true
      CHANGING
        cs_request         = ls_request
      EXCEPTIONS
        error_occured      = 1
        OTHERS             = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

* move to output structure
    rs_request-trstatus = ls_request-h-trstatus.
    LOOP AT ls_request-keys INTO ls_key.
      APPEND INITIAL LINE TO rs_request-keys ASSIGNING <ls_key>.
      MOVE-CORRESPONDING ls_key TO <ls_key>.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_cts_api~read_description.

    SELECT SINGLE as4text FROM e07t
      INTO rv_description
      WHERE trkorr = iv_trkorr
      AND langu = sy-langu ##SUBRC_OK.

  ENDMETHOD.

  METHOD zif_abapgit_cts_api~read_user.

    SELECT SINGLE as4user FROM e070 INTO rv_uname
      WHERE trkorr = iv_trkorr ##SUBRC_OK.

  ENDMETHOD.

  METHOD zif_abapgit_cts_api~validate_transport_request.

    CONSTANTS:
      BEGIN OF c_tr_status,
        modifiable           TYPE trstatus VALUE 'D',
        modifiable_protected TYPE trstatus VALUE 'L',
      END OF c_tr_status.

    DATA ls_request TYPE zif_abapgit_cts_api=>ty_transport_data.

    ls_request = zif_abapgit_cts_api~read( iv_transport_request ).

    IF ls_request-trstatus <> c_tr_status-modifiable
        AND ls_request-trstatus <> c_tr_status-modifiable_protected.
      " Task/request &1 has already been released
      MESSAGE e064(tk) WITH iv_transport_request INTO zcx_abapgit_exception=>null.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_data_config IMPLEMENTATION.

  METHOD dump.

    DATA lo_ajson TYPE REF TO zcl_abapgit_ajson.
    DATA lx_ajson TYPE REF TO zcx_abapgit_ajson_error.

    TRY.
        lo_ajson = zcl_abapgit_ajson=>create_empty( ).
        lo_ajson->zif_abapgit_ajson~set(
          iv_path = '/'
          iv_val  = is_config ).
        rv_json = zcl_abapgit_convert=>string_to_xstring_utf8( lo_ajson->stringify( 2 ) ).
      CATCH zcx_abapgit_ajson_error INTO lx_ajson.
        zcx_abapgit_exception=>raise( lx_ajson->get_text( ) ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_data_config~add_config.

    DATA lv_where TYPE string.

    FIELD-SYMBOLS <ls_config> LIKE LINE OF mt_config.

    ASSERT is_config-type IS NOT INITIAL.
    ASSERT is_config-name IS NOT INITIAL.
    ASSERT is_config-name = to_upper( is_config-name ).

    INSERT is_config INTO TABLE mt_config.
    IF sy-subrc <> 0.
* append to existing
      READ TABLE mt_config ASSIGNING <ls_config> WITH KEY type = is_config-type name = is_config-name.
      ASSERT sy-subrc = 0.
      LOOP AT is_config-where INTO lv_where.
        READ TABLE <ls_config>-where TRANSPORTING NO FIELDS WITH KEY table_line = lv_where.
        IF sy-subrc <> 0.
          INSERT lv_where INTO TABLE <ls_config>-where.
        ENDIF.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_data_config~from_json.

    DATA ls_file LIKE LINE OF it_files.
    DATA ls_config TYPE zif_abapgit_data_config=>ty_config.
    DATA lo_ajson TYPE REF TO zcl_abapgit_ajson.
    DATA lx_ajson TYPE REF TO zcx_abapgit_ajson_error.

    CLEAR mt_config.
    LOOP AT it_files INTO ls_file
        USING KEY file_path
        WHERE path = zif_abapgit_data_config=>c_default_path
        AND filename CP |*.{ zif_abapgit_data_config=>c_config }.{ zif_abapgit_data_config=>c_default_format }|.
      TRY.
          lo_ajson = zcl_abapgit_ajson=>parse( zcl_abapgit_convert=>xstring_to_string_utf8( ls_file-data ) ).
          lo_ajson->zif_abapgit_ajson~to_abap( IMPORTING ev_container = ls_config ).
        CATCH zcx_abapgit_ajson_error INTO lx_ajson.
          zcx_abapgit_exception=>raise( lx_ajson->get_text( ) ).
      ENDTRY.

      zif_abapgit_data_config~add_config( ls_config ).
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_data_config~get_configs.
    rt_configs = mt_config.
  ENDMETHOD.

  METHOD zif_abapgit_data_config~remove_config.

    ASSERT is_config-type IS NOT INITIAL.
    ASSERT is_config-name IS NOT INITIAL.
    ASSERT is_config-name = to_upper( is_config-name ).

    DELETE mt_config WHERE name = is_config-name AND type = is_config-type.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'Not found' ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_data_config~to_json.

    DATA ls_config LIKE LINE OF mt_config.
    DATA ls_file LIKE LINE OF rt_files.

    ls_file-path = zif_abapgit_data_config=>c_default_path.

    LOOP AT mt_config INTO ls_config.
      ls_file-data = dump( ls_config ).
      ls_file-sha1 = zcl_abapgit_hash=>sha1_blob( ls_file-data ).
      ls_config-type = zif_abapgit_data_config=>c_config.
      ls_file-filename = zcl_abapgit_data_utils=>build_data_filename( ls_config ).
      APPEND ls_file TO rt_files.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_data_config~update_config.

    zif_abapgit_data_config~remove_config( is_config ).
    zif_abapgit_data_config~add_config( is_config ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_data_deserializer IMPLEMENTATION.

  METHOD convert_json_to_itab.

    DATA lo_ajson TYPE REF TO zcl_abapgit_ajson.
    DATA lx_ajson TYPE REF TO zcx_abapgit_ajson_error.

    FIELD-SYMBOLS <lg_tab> TYPE ANY TABLE.

    ASSIGN ir_data->* TO <lg_tab>.

    TRY.
        lo_ajson = zcl_abapgit_ajson=>parse( zcl_abapgit_convert=>xstring_to_string_utf8( is_file-data ) ).
        lo_ajson->zif_abapgit_ajson~to_abap( IMPORTING ev_container = <lg_tab> ).
      CATCH zcx_abapgit_ajson_error INTO lx_ajson.
        zcx_abapgit_exception=>raise( lx_ajson->get_text( ) ).
    ENDTRY.

  ENDMETHOD.

  METHOD determine_transport_request.

    DATA li_exit TYPE REF TO zif_abapgit_exit.

    li_exit = zcl_abapgit_exit=>get_instance( ).

    " Use transport from repo settings if maintained, or determine via user exit.
    " If transport keeps empty here, it'll requested later via popup.
    rv_transport_request = io_repo->get_local_settings( )-customizing_request.

    li_exit->determine_transport_request(
      EXPORTING
        io_repo              = io_repo
        iv_transport_type    = iv_transport_type
      CHANGING
        cv_transport_request = rv_transport_request ).

  ENDMETHOD.

  METHOD is_table_allowed_to_edit.

    " Is the object supported (by default or based on exit)?
    rv_allowed_to_edit = zcl_abapgit_data_factory=>get_supporter( )->is_object_supported(
      iv_type = is_result-type
      iv_name = is_result-name ).

  ENDMETHOD.

  METHOD preview_database_changes.

* method currently distinguishes between records be deleted and inserted (comparison of complete record)

    FIELD-SYMBOLS <lg_old> TYPE ANY TABLE.
    FIELD-SYMBOLS <lg_new> TYPE ANY TABLE.
    FIELD-SYMBOLS <ls_del> TYPE any.
    FIELD-SYMBOLS <ls_ins> TYPE any.
    FIELD-SYMBOLS <lg_del> TYPE ANY TABLE.
    FIELD-SYMBOLS <lg_ins> TYPE ANY TABLE.
    FIELD-SYMBOLS <lg_upd> TYPE ANY TABLE.

    ASSIGN ir_db_data->* TO <lg_old>.
    ASSIGN ir_lc_data->* TO <lg_new>.

    rs_result-type = zif_abapgit_data_config=>c_data_type-tabu.
    rs_result-name = iv_name.
    rs_result-deletes = zcl_abapgit_data_utils=>build_table_itab( iv_name ).
    rs_result-inserts = zcl_abapgit_data_utils=>build_table_itab( iv_name ).
    rs_result-updates = zcl_abapgit_data_utils=>build_table_itab( iv_name ).
    ASSIGN rs_result-deletes->* TO <lg_del>.
    ASSIGN rs_result-inserts->* TO <lg_ins>.
    ASSIGN rs_result-updates->* TO <lg_upd>.

    <lg_del> = <lg_old>.
    <lg_ins> = <lg_new>.

    " Remove identical records
    LOOP AT <lg_del> ASSIGNING <ls_del>.
      READ TABLE <lg_ins> ASSIGNING <ls_ins> FROM <ls_del>.
      IF sy-subrc = 0.
        IF <ls_del> <> <ls_ins>.
          " Identical key but not identical component values
          INSERT <ls_ins> INTO TABLE <lg_upd>.
        ENDIF.
        DELETE TABLE <lg_del> FROM <ls_del>.
        DELETE TABLE <lg_ins> FROM <ls_ins>.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD read_database_table.

    DATA lv_where LIKE LINE OF it_where.

    FIELD-SYMBOLS <lg_tab> TYPE ANY TABLE.

    rr_data = zcl_abapgit_data_utils=>build_table_itab( iv_name ).
    ASSIGN rr_data->* TO <lg_tab>.

    LOOP AT it_where INTO lv_where.
      SELECT * FROM (iv_name) APPENDING TABLE <lg_tab> WHERE (lv_where) ORDER BY PRIMARY KEY.
    ENDLOOP.
    IF lines( it_where ) = 0.
      SELECT * FROM (iv_name) INTO TABLE <lg_tab> ORDER BY PRIMARY KEY.
    ENDIF.

  ENDMETHOD.

  METHOD write_database_table.

    FIELD-SYMBOLS <lg_del> TYPE ANY TABLE.
    FIELD-SYMBOLS <lg_ins> TYPE ANY TABLE.
    FIELD-SYMBOLS <lg_upd> TYPE ANY TABLE.

    IF zcl_abapgit_data_utils=>does_table_exist( iv_name ) = abap_false.
      zcx_abapgit_exception=>raise( |Table { iv_name } not found for data deserialization| ).
    ENDIF.

    ASSIGN ir_del->* TO <lg_del>.
    ASSIGN ir_ins->* TO <lg_ins>.
    ASSIGN ir_upd->* TO <lg_upd>.

    IF lines( <lg_del> ) > 0.
      DELETE (iv_name) FROM TABLE <lg_del>.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( |Error deleting { lines( <lg_del> ) } records from table { iv_name }| ).
      ENDIF.
    ENDIF.

    IF lines( <lg_ins> ) > 0.
      INSERT (iv_name) FROM TABLE <lg_ins>.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( |Error inserting { lines( <lg_ins> ) } records into table { iv_name }| ).
      ENDIF.
    ENDIF.

    IF lines( <lg_upd> ) > 0.
      UPDATE (iv_name) FROM TABLE <lg_upd>.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( |Error updating { lines( <lg_upd> ) } records into table { iv_name }| ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_data_deserializer~actualize.

* this method updates the database

    DATA ls_result  LIKE LINE OF it_result.
    DATA li_cts_api TYPE REF TO zif_abapgit_cts_api.

    FIELD-SYMBOLS:
      <lt_ins> TYPE ANY TABLE,
      <lt_del> TYPE ANY TABLE,
      <lt_upd> TYPE ANY TABLE.

    LOOP AT it_result INTO ls_result.
      ASSERT ls_result-type = zif_abapgit_data_config=>c_data_type-tabu. " todo
      ASSERT ls_result-name IS NOT INITIAL.

      " Did the user flagged this object for update?
      READ TABLE is_checks-overwrite TRANSPORTING NO FIELDS
        WITH KEY object_type_and_name
        COMPONENTS
          obj_type = ls_result-type
          obj_name = ls_result-name
          decision = zif_abapgit_definitions=>c_yes.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

      IF is_table_allowed_to_edit( ls_result ) = abap_false.
        zcx_abapgit_exception=>raise( |Table { ls_result-name } not supported for updating data| ).
      ENDIF.

      write_database_table(
        iv_name = ls_result-name
        ir_del  = ls_result-deletes
        ir_ins  = ls_result-inserts
        ir_upd  = ls_result-updates ).

      ASSIGN ls_result-inserts->* TO <lt_ins>.
      ASSIGN ls_result-deletes->* TO <lt_del>.
      ASSIGN ls_result-updates->* TO <lt_upd>.

      IF zcl_abapgit_data_utils=>is_customizing_table( ls_result-name ) = abap_true.
        IF li_cts_api IS INITIAL.
          li_cts_api = zcl_abapinst_factory=>get_cts_api( ).
        ENDIF.

        li_cts_api->create_transport_entries(
          iv_transport = is_checks-customizing-transport
          it_table_ins = <lt_ins>
          it_table_upd = <lt_upd>
          it_table_del = <lt_del>
          iv_tabname   = |{ ls_result-name }| ).
      ENDIF.

      INSERT ls_result-file INTO TABLE rt_accessed_files. " data file
      INSERT ls_result-config INTO TABLE rt_accessed_files. " config file
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_data_deserializer~deserialize.

* this method does not persist any changes to the database

    DATA lt_configs TYPE zif_abapgit_data_config=>ty_config_tt.
    DATA ls_config  LIKE LINE OF lt_configs.
    DATA lr_lc_data TYPE REF TO data.
    DATA lr_db_data TYPE REF TO data.
    DATA ls_file    LIKE LINE OF it_files.
    DATA ls_result  LIKE LINE OF rt_result.

    lt_configs = ii_config->get_configs( ).

    LOOP AT lt_configs INTO ls_config.
      ASSERT ls_config-type = zif_abapgit_data_config=>c_data_type-tabu. " todo
      ASSERT ls_config-name IS NOT INITIAL.

      lr_lc_data = zcl_abapgit_data_utils=>build_table_itab( ls_config-name ).

      READ TABLE it_files INTO ls_file
        WITH KEY file_path
        COMPONENTS path     = zif_abapgit_data_config=>c_default_path
                   filename = zcl_abapgit_data_utils=>build_data_filename( ls_config ).
      IF sy-subrc = 0.
        convert_json_to_itab(
          ir_data = lr_lc_data
          is_file = ls_file ).

        lr_db_data = read_database_table(
          iv_name  = ls_config-name
          it_where = ls_config-where ).

        ls_result = preview_database_changes(
          iv_name    = ls_config-name
          ir_lc_data = lr_lc_data
          ir_db_data = lr_db_data ).

        MOVE-CORRESPONDING ls_file TO ls_result-file. " data file

        READ TABLE it_files INTO ls_file
          WITH KEY file_path
          COMPONENTS path     = zif_abapgit_data_config=>c_default_path
                     filename = zcl_abapgit_data_utils=>build_config_filename( ls_config ).
        ASSERT sy-subrc = 0.

        MOVE-CORRESPONDING ls_file TO ls_result-config. " config file

        INSERT ls_result INTO TABLE rt_result.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_data_deserializer~deserialize_check.

    DATA lt_configs TYPE zif_abapgit_data_config=>ty_config_tt.

    lt_configs = ii_config->get_configs( ).

    IF lt_configs IS NOT INITIAL.
      rs_checks-required     = abap_true.
      rs_checks-type-request = zif_abapgit_cts_api=>c_transport_type-cust_request.
      rs_checks-type-task    = zif_abapgit_cts_api=>c_transport_type-cust_task.
      rs_checks-transport    = determine_transport_request(
                                 io_repo           = io_repo
                                 iv_transport_type = rs_checks-type ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_data_serializer IMPLEMENTATION.

  METHOD convert_itab_to_json.

    DATA lo_ajson  TYPE REF TO zcl_abapgit_ajson.
    DATA lv_string TYPE string.
    DATA lx_ajson  TYPE REF TO zcx_abapgit_ajson_error.

    FIELD-SYMBOLS <lg_tab> TYPE ANY TABLE.

    ASSIGN ir_data->* TO <lg_tab>.

    TRY.
        lo_ajson = zcl_abapgit_ajson=>create_empty( ).
        lo_ajson->keep_item_order( ).
        lo_ajson->set(
          iv_path = '/'
          iv_val = <lg_tab> ).

        IF iv_skip_initial = abap_true.
          lo_ajson = zcl_abapgit_ajson=>create_from(
            ii_source_json = lo_ajson
            ii_filter = zcl_abapgit_ajson_filter_lib=>create_empty_filter( ) ).
        ENDIF.

        lv_string = lo_ajson->stringify( 2 ).
      CATCH zcx_abapgit_ajson_error INTO lx_ajson.
        zcx_abapgit_exception=>raise( lx_ajson->get_text( ) ).
    ENDTRY.

    rv_data = zcl_abapgit_convert=>string_to_xstring_utf8( lv_string ).

  ENDMETHOD.

  METHOD read_database_table.

    DATA lv_records TYPE i.
    DATA lv_where LIKE LINE OF it_where.
    DATA lx_sql TYPE REF TO cx_sy_sql_error.

    FIELD-SYMBOLS <lg_tab> TYPE ANY TABLE.

    rr_data = zcl_abapgit_data_utils=>build_table_itab( iv_name ).
    ASSIGN rr_data->* TO <lg_tab>.

    TRY.
        LOOP AT it_where INTO lv_where.
          SELECT * FROM (iv_name) APPENDING TABLE <lg_tab> WHERE (lv_where) ORDER BY PRIMARY KEY.
        ENDLOOP.
        IF lines( it_where ) = 0.
          SELECT * FROM (iv_name) INTO TABLE <lg_tab> ORDER BY PRIMARY KEY.
        ENDIF.
      CATCH cx_sy_sql_error INTO lx_sql.
        zcx_abapgit_exception=>raise(
          iv_text     = lx_sql->get_text( )
          ix_previous = lx_sql ).
    ENDTRY.

    lv_records = lines( <lg_tab> ).
    IF lv_records > c_max_records.
      zcx_abapgit_exception=>raise( |Too many records selected from table { iv_name
        } (selected { lv_records }, max { c_max_records })| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_data_serializer~serialize.

    DATA lt_configs TYPE zif_abapgit_data_config=>ty_config_tt.
    DATA ls_config  LIKE LINE OF lt_configs.
    DATA ls_file    LIKE LINE OF rt_files.
    DATA lr_data    TYPE REF TO data.

    ls_file-path = zif_abapgit_data_config=>c_default_path.
    lt_configs = ii_config->get_configs( ).

    LOOP AT lt_configs INTO ls_config.
      ASSERT ls_config-type = zif_abapgit_data_config=>c_data_type-tabu. " todo
      ASSERT ls_config-name IS NOT INITIAL.

      IF zcl_abapgit_data_utils=>does_table_exist( ls_config-name ) = abap_true.
        lr_data = read_database_table(
          iv_name  = ls_config-name
          it_where = ls_config-where ).

        ls_file-data = convert_itab_to_json(
          ir_data         = lr_data
          iv_skip_initial = ls_config-skip_initial ).
      ELSE.
        ls_file-data = zcl_abapgit_convert=>string_to_xstring_utf8( '[]' ).
      ENDIF.

      ls_file-filename = zcl_abapgit_data_utils=>build_data_filename( ls_config ).
      ls_file-sha1 = zcl_abapgit_hash=>sha1_blob( ls_file-data ).
      APPEND ls_file TO rt_files.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_data_supporter IMPLEMENTATION.

  METHOD get_supported_objects.

    DATA:
      lt_tables  TYPE STANDARD TABLE OF tabname,
      lv_tabname TYPE tabname,
      ls_object  LIKE LINE OF mt_supported_objects,
      li_exit    TYPE REF TO zif_abapgit_exit.

    " For safety reasons, by default only customer-defined customizing tables are supported
    SELECT dd02l~tabname
      FROM dd09l JOIN dd02l
        ON dd09l~tabname = dd02l~tabname
        AND dd09l~as4local = dd02l~as4local
        AND dd09l~as4vers = dd02l~as4vers
      INTO TABLE lt_tables
      WHERE dd02l~tabclass = 'TRANSP'
        AND dd09l~tabart = 'APPL2'
        AND dd09l~as4user <> 'SAP'
        AND dd09l~as4local = 'A' "Only active tables
        AND dd02l~contflag = 'C' "Only customizing tables
      ORDER BY dd02l~tabname.

    LOOP AT lt_tables INTO lv_tabname.
      ls_object-type = zif_abapgit_data_config=>c_data_type-tabu.
      ls_object-name = lv_tabname.
      INSERT ls_object INTO TABLE mt_supported_objects.
    ENDLOOP.

    " The list of supported objects can be enhanced using an exit
    " Name patterns are allowed. For example, TABU T009*
    li_exit = zcl_abapgit_exit=>get_instance( ).
    li_exit->change_supported_data_objects( CHANGING ct_objects = mt_supported_objects ).

  ENDMETHOD.

  METHOD zif_abapgit_data_supporter~is_object_supported.

    FIELD-SYMBOLS <ls_object> LIKE LINE OF mt_supported_objects.

    IF mt_supported_objects IS INITIAL.
      get_supported_objects( ).
    ENDIF.

    READ TABLE mt_supported_objects TRANSPORTING NO FIELDS
      WITH TABLE KEY type = iv_type name = iv_name.
    IF sy-subrc = 0.
      rv_supported = abap_true.
    ELSE.
      " Check if object name matches pattern
      LOOP AT mt_supported_objects ASSIGNING <ls_object> WHERE type = iv_type.
        IF iv_name CP <ls_object>-name.
          rv_supported = abap_true.
          RETURN.
        ENDIF.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_data_factory IMPLEMENTATION.

  METHOD get_config.
    CREATE OBJECT ri_config TYPE zcl_abapgit_data_config.
  ENDMETHOD.

  METHOD get_deserializer.

    IF gi_deserializer IS INITIAL.
      CREATE OBJECT gi_deserializer TYPE zcl_abapgit_data_deserializer.
    ENDIF.

    ri_deserializer = gi_deserializer.

  ENDMETHOD.

  METHOD get_serializer.

    IF gi_serializer IS INITIAL.
      CREATE OBJECT gi_serializer TYPE zcl_abapgit_data_serializer.
    ENDIF.

    ri_serializer = gi_serializer.

  ENDMETHOD.

  METHOD get_supporter.

    IF gi_supporter IS INITIAL.
      CREATE OBJECT gi_supporter TYPE zcl_abapgit_data_supporter.
    ENDIF.

    ri_supporter = gi_supporter.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_data_injector IMPLEMENTATION.

  METHOD set_deserializer.
    zcl_abapgit_data_factory=>gi_deserializer = ii_deserializer.
  ENDMETHOD.

  METHOD set_serializer.
    zcl_abapgit_data_factory=>gi_serializer = ii_serializer.
  ENDMETHOD.

  METHOD set_supporter.
    zcl_abapgit_data_factory=>gi_supporter = ii_supporter.
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_data_utils IMPLEMENTATION.

  METHOD build_config_filename.

    rv_filename = to_lower( |{ is_config-name }.{ zif_abapgit_data_config=>c_config }|
      && |.{ zif_abapgit_data_config=>c_default_format }| ).

    REPLACE ALL OCCURRENCES OF '/' IN rv_filename WITH '#'.

  ENDMETHOD.

  METHOD build_data_filename.

    rv_filename = to_lower( |{ is_config-name }.{ is_config-type }|
      && |.{ zif_abapgit_data_config=>c_default_format }| ).

    REPLACE ALL OCCURRENCES OF '/' IN rv_filename WITH '#'.

  ENDMETHOD.

  METHOD build_table_itab.

    DATA lo_type   TYPE REF TO cl_abap_typedescr.
    DATA lo_data   TYPE REF TO cl_abap_structdescr.
    DATA lo_table  TYPE REF TO cl_abap_tabledescr.
    DATA lt_keys   TYPE abap_table_keydescr_tab.
    DATA lt_names  TYPE ty_names.

    FIELD-SYMBOLS <lv_name>      LIKE LINE OF lt_names.
    FIELD-SYMBOLS <ls_key>       LIKE LINE OF lt_keys.
    FIELD-SYMBOLS <ls_component> LIKE LINE OF <ls_key>-components.

    cl_abap_structdescr=>describe_by_name(
      EXPORTING
        p_name         = iv_name
      RECEIVING
        p_descr_ref    = lo_type
      EXCEPTIONS
        type_not_found = 1 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Table { iv_name } not found for data serialization| ).
    ENDIF.

    TRY.
        lo_data ?= lo_type.

        " Get primary key to ensure unique entries
        IF lo_data->is_ddic_type( ) = abap_true.
          lt_names = list_key_fields( iv_name ).

          APPEND INITIAL LINE TO lt_keys ASSIGNING <ls_key>.
          <ls_key>-access_kind = cl_abap_tabledescr=>tablekind_hashed.
          <ls_key>-key_kind    = cl_abap_tabledescr=>keydefkind_user.
          <ls_key>-is_primary  = abap_true.
          <ls_key>-is_unique   = abap_true.

          LOOP AT lt_names ASSIGNING <lv_name>.
            APPEND INITIAL LINE TO <ls_key>-components ASSIGNING <ls_component>.
            <ls_component>-name = <lv_name>.
          ENDLOOP.
        ENDIF.

        IF lines( lt_names ) = 0.
          lo_table = cl_abap_tabledescr=>get( lo_data ).
        ELSE.
          lo_table = cl_abap_tabledescr=>get_with_keys(
            p_line_type = lo_data
            p_keys      = lt_keys ).
        ENDIF.

        CREATE DATA rr_data TYPE HANDLE lo_table.

      CATCH cx_root.
        zcx_abapgit_exception=>raise( |Error creating internal table for data serialization| ).
    ENDTRY.

  ENDMETHOD.

  METHOD does_table_exist.

    " This is slow but ensures that the table actually exists and is not just buffered by RTTI
    " If we just rely on RTTI, uninstalling and reinstalling a table in the same session will lead to dumps
    TRY.
        build_table_itab( iv_name ).
        rv_exists = abap_true.
      CATCH zcx_abapgit_exception ##NO_HANDLER.
    ENDTRY.

  ENDMETHOD.

  METHOD is_customizing_table.

    DATA lv_contflag       TYPE c LENGTH 1.
    DATA lo_table          TYPE REF TO object.
    DATA lo_content        TYPE REF TO object.
    DATA lo_delivery_class TYPE REF TO object.
    FIELD-SYMBOLS <ls_any> TYPE any.

    TRY.
        CALL METHOD ('XCO_CP_ABAP_DICTIONARY')=>database_table
          EXPORTING
            iv_name           = iv_name(16)
          RECEIVING
            ro_database_table = lo_table.
        CALL METHOD lo_table->('IF_XCO_DATABASE_TABLE~CONTENT')
          RECEIVING
            ro_content = lo_content.
        CALL METHOD lo_content->('IF_XCO_DBT_CONTENT~GET_DELIVERY_CLASS')
          RECEIVING
            ro_delivery_class = lo_delivery_class.
        ASSIGN lo_delivery_class->('VALUE') TO <ls_any>.
        lv_contflag = <ls_any>.
      CATCH cx_sy_dyn_call_illegal_class cx_no_check.
        " Catching SAP standard exception CX_NO_CHECK,
        " because of the expected exception CX_XCO_RUNTIME_EXCEPTION
        " could not be used here directly to keep the indirect usage approach.
        SELECT SINGLE contflag FROM ('DD02L') INTO lv_contflag WHERE tabname = iv_name.
    ENDTRY.

    IF lv_contflag = 'C'.
      rv_customizing = abap_true.
    ELSEIF lv_contflag IS NOT INITIAL.
      rv_customizing = abap_false.
    ELSE.
      rv_customizing = abap_undefined. " table does not exist
    ENDIF.

  ENDMETHOD.

  METHOD jump.

    " Run SE16 with authorization check
    CALL FUNCTION 'RS_TABLE_LIST_CREATE'
      EXPORTING
        table_name         = is_item-obj_name
      EXCEPTIONS
        table_is_structure = 1
        table_not_exists   = 2
        db_not_exists      = 3
        no_permission      = 4
        no_change_allowed  = 5
*        table_is_gtt       = 6 " not in lower releases
        OTHERS             = 7.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Table { is_item-obj_name } cannot be displayed| ).
    ENDIF.

  ENDMETHOD.

  METHOD list_key_fields.
    DATA lo_obj        TYPE REF TO object.
    DATA lv_tabname    TYPE c LENGTH 16.
    DATA lr_ddfields   TYPE REF TO data.
    DATA lv_workaround TYPE c LENGTH 20.
    DATA lr_struct     TYPE REF TO cl_abap_structdescr.
    FIELD-SYMBOLS <lg_any> TYPE any.
    FIELD-SYMBOLS <lv_field> TYPE simple.
    FIELD-SYMBOLS <lt_ddfields> TYPE ANY TABLE.

* convert to correct type,
    lv_tabname = iv_name.

    TRY.
        CALL METHOD ('XCO_CP_ABAP_DICTIONARY')=>database_table
          EXPORTING
            iv_name           = lv_tabname
          RECEIVING
            ro_database_table = lo_obj.
        ASSIGN lo_obj->('IF_XCO_DATABASE_TABLE~FIELDS->IF_XCO_DBT_FIELDS_FACTORY~KEY') TO <lg_any>.
        IF sy-subrc  <> 0.
* fallback to RTTI, KEY field does not exist in S/4 2020
          RAISE EXCEPTION TYPE cx_sy_dyn_call_illegal_class.
        ENDIF.
        lo_obj = <lg_any>.
        CALL METHOD lo_obj->('IF_XCO_DBT_FIELDS~GET_NAMES')
          RECEIVING
            rt_names = rt_names.
      CATCH cx_sy_dyn_call_illegal_class cx_no_check.
        lv_workaround = 'DDFIELDS'.
        CREATE DATA lr_ddfields TYPE (lv_workaround).
        ASSIGN lr_ddfields->* TO <lt_ddfields>.
        ASSERT sy-subrc = 0.
        lr_struct ?= cl_abap_typedescr=>describe_by_name( lv_tabname ).
        lr_struct->get_ddic_field_list(
          RECEIVING
            p_field_list = <lt_ddfields>
          EXCEPTIONS
            not_found    = 1
            no_ddic_type = 2 ).
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise( |Table { iv_name } not found| ).
        ENDIF.
        LOOP AT <lt_ddfields> ASSIGNING <lg_any>.
          ASSIGN COMPONENT 'KEYFLAG' OF STRUCTURE <lg_any> TO <lv_field>.
          IF sy-subrc <> 0 OR <lv_field> <> abap_true.
            CONTINUE.
          ENDIF.
          ASSIGN COMPONENT 'FIELDNAME' OF STRUCTURE <lg_any> TO <lv_field>.
          ASSERT sy-subrc = 0.
          APPEND <lv_field> TO rt_names.
        ENDLOOP.
    ENDTRY.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_default_transport IMPLEMENTATION.

  METHOD clear.

    CALL FUNCTION 'TR_TASK_RESET'
      EXPORTING
        iv_username      = is_default_task-username
        iv_order         = is_default_task-ordernum
        iv_task          = is_default_task-tasknum
        iv_dialog        = abap_false
      EXCEPTIONS
        invalid_username = 1
        invalid_order    = 2
        invalid_task     = 3
        OTHERS           = 4.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD constructor.

    store( ).

  ENDMETHOD.

  METHOD restore.

    IF ms_save IS INITIAL.
      " There wasn't a default transport request before
      " so we needn't restore anything.
      RETURN.
    ENDIF.

    CALL FUNCTION 'TR_TASK_SET'
      EXPORTING
        iv_order          = ms_save-ordernum
        iv_task           = ms_save-tasknum
      EXCEPTIONS
        invalid_username  = 1
        invalid_category  = 2
        invalid_client    = 3
        invalid_validdays = 4
        invalid_order     = 5
        invalid_task      = 6
        OTHERS            = 7.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD set_internal.

    CALL FUNCTION 'TR_TASK_SET'
      EXPORTING
        iv_order          = iv_transport
        iv_validdays      = 1
      EXCEPTIONS
        invalid_username  = 1
        invalid_category  = 2
        invalid_client    = 3
        invalid_validdays = 4
        invalid_order     = 5
        invalid_task      = 6
        OTHERS            = 7.

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD store.

    TRY.
        ms_save = zif_abapgit_default_transport~get( ).
      CATCH zcx_abapgit_exception.
        CLEAR ms_save.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_default_transport~get.

    DATA lt_e070use TYPE STANDARD TABLE OF e070use WITH DEFAULT KEY.
    DATA ls_line    LIKE LINE OF lt_e070use.

    CALL FUNCTION 'TR_TASK_GET'
      TABLES
        tt_e070use       = lt_e070use
      EXCEPTIONS
        invalid_username = 1
        invalid_category = 2
        invalid_client   = 3
        OTHERS           = 4.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    READ TABLE lt_e070use INTO ls_line INDEX 1.
    IF sy-subrc = 0.
      MOVE-CORRESPONDING ls_line TO rs_default_task.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_default_transport~reset.

    DATA: ls_default_task TYPE e070use.

    IF mv_is_set_by_abapgit = abap_false.
      " if the default transport request task isn't set
      " by us there is nothing to do.
      RETURN.
    ENDIF.

    CLEAR mv_is_set_by_abapgit.

    ls_default_task = zif_abapgit_default_transport~get( ).

    IF ls_default_task IS NOT INITIAL.

      clear( ls_default_task ).

    ENDIF.

    restore( ).

  ENDMETHOD.

  METHOD zif_abapgit_default_transport~set.

    " checks whether object changes of the package are reordered in transport
    " requests. If true then we set the default task, so that no annoying
    " transport request popups are shown while deserializing.

    IF mv_is_set_by_abapgit = abap_true.
      " the default transport request task is already set by us
      " -> no reason to do it again.
      RETURN.
    ENDIF.

    IF iv_transport IS INITIAL.
      zcx_abapgit_exception=>raise( |No transport request was supplied| ).
    ENDIF.

    set_internal( iv_transport ).

    mv_is_set_by_abapgit = abap_true.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_dependencies IMPLEMENTATION.

  METHOD get_ddls_dependencies.

    DATA: lt_ddls_name TYPE TABLE OF ddsymtab,
          ls_ddls_name TYPE ddsymtab.

    ls_ddls_name-name = iv_ddls_name.
    INSERT ls_ddls_name INTO TABLE lt_ddls_name.

    PERFORM ('DDLS_GET_DEP') IN PROGRAM ('RADMASDL')
                             TABLES lt_ddls_name rt_dependency ##PERF_NO_FORM.

  ENDMETHOD.

  METHOD resolve.

    DATA: lv_tabclass TYPE dd02l-tabclass.

    FIELD-SYMBOLS: <ls_tadir> LIKE LINE OF ct_tadir.

    " misuse field KORRNUM to fix deletion sequence
    " higher value means later deletion

    LOOP AT ct_tadir ASSIGNING <ls_tadir>.
      CASE <ls_tadir>-object.
        WHEN 'DEVC'.
          " Packages last
          <ls_tadir>-korrnum = '999000'.
        WHEN 'DOMA'.
          <ls_tadir>-korrnum = '900000'.
        WHEN 'SPRX'.
          <ls_tadir>-korrnum = '850000'.
        WHEN 'WEBI'.
          <ls_tadir>-korrnum = '840000'.
        WHEN 'PARA'.
          " PARA after DTEL
          <ls_tadir>-korrnum = '810000'.
        WHEN 'DTEL'.
          <ls_tadir>-korrnum = '800000'.
        WHEN 'SHLP'.
          " SHLP after TABL
          <ls_tadir>-korrnum = '760000'.
        WHEN 'TTYP' OR 'TABL' OR 'VIEW'.
          SELECT SINGLE tabclass FROM dd02l
            INTO lv_tabclass
            WHERE tabname = <ls_tadir>-obj_name
            AND as4local = 'A'
            AND as4vers = '0000'.
          IF sy-subrc = 0 AND lv_tabclass = 'APPEND'.
            " delete append structures before database tables
            <ls_tadir>-korrnum = '730000'.
          ELSE.
            <ls_tadir>-korrnum = '750000'.
          ENDIF.
        WHEN 'ENQU'.
          " ENQU before TABL
          <ls_tadir>-korrnum = '725000'.
        WHEN 'DDLS'.
          " DDLS after DCLS but before other DDIC
          <ls_tadir>-korrnum = '720000'.
        WHEN 'DDLX'.
          " DDLX before DDLS
          <ls_tadir>-korrnum = '719000'.
        WHEN 'AUTH'.
          " AUTH after DCLS
          <ls_tadir>-korrnum = '715000'.
        WHEN 'SUSH'.
          " SUSH after SUSC and SRVB
          <ls_tadir>-korrnum = '712000'.
        WHEN 'SUSC'.
          " SUSC after SUSO
          <ls_tadir>-korrnum = '711000'.
        WHEN 'SUSO'.
          " SUSO after DCLS
          <ls_tadir>-korrnum = '710000'.
        WHEN 'DCLS'.
          " AUTH and SUSO after DCLS
          <ls_tadir>-korrnum = '705000'.
        WHEN 'G4BA' OR 'G4BS' OR 'IWMO' OR 'IWSV' OR 'IWVB'.
          " after SRVB
          <ls_tadir>-korrnum = '610000'.
        WHEN 'SRVB'.
          " after SRVD
          <ls_tadir>-korrnum = '600500'.
        WHEN 'SRVD'.
          <ls_tadir>-korrnum = '600000'.
        WHEN 'IASP'.
          <ls_tadir>-korrnum = '552000'.
        WHEN 'IARP'.
          <ls_tadir>-korrnum = '551000'.
        WHEN 'IATU'.
          <ls_tadir>-korrnum = '550000'.
        WHEN 'ACID'.
          " ACID after PROG/FUGR/CLAS
          <ls_tadir>-korrnum = '300000'.
        WHEN 'FUGR'.
          <ls_tadir>-korrnum = '260000'.
        WHEN 'PROG'.
          " delete includes after main programs
          SELECT COUNT(*) FROM reposrc
            WHERE progname = <ls_tadir>-obj_name
            AND r3state = 'A'
            AND subc = 'I'.
          IF sy-subrc = 0.
            <ls_tadir>-korrnum = '250000'.
          ELSE.
            <ls_tadir>-korrnum = '240000'.
          ENDIF.
        WHEN 'INTF'.
          <ls_tadir>-korrnum = '230000'.
        WHEN 'CLAS'.
          <ls_tadir>-korrnum = '220000'.
        WHEN 'IDOC'.
          <ls_tadir>-korrnum = '200000'.
        WHEN 'IOBJ'.
          <ls_tadir>-korrnum = '195000'.
        WHEN 'ODSO'.
          <ls_tadir>-korrnum = '190000'.
        WHEN 'WDCA'.
          <ls_tadir>-korrnum = '174000'.
        WHEN 'WDYA'.
          <ls_tadir>-korrnum = '173000'.
        WHEN 'WDCC'.
          <ls_tadir>-korrnum = '172000'.
        WHEN 'WDYN'.
          <ls_tadir>-korrnum = '171000'.
        WHEN 'IEXT'.
          <ls_tadir>-korrnum = '150000'.
        WHEN 'SAPC'.
          " SAPC after SICF
          <ls_tadir>-korrnum = '140000'.
        WHEN 'PINF'.
          " PINF before exposed objects
          <ls_tadir>-korrnum = '130000'.
        WHEN OTHERS.
          <ls_tadir>-korrnum = '100000'.
      ENDCASE.
    ENDLOOP.

    resolve_ddic( CHANGING ct_tadir = ct_tadir ).
    resolve_packages( CHANGING ct_tadir = ct_tadir ).

    SORT ct_tadir BY korrnum ASCENDING.

  ENDMETHOD.

  METHOD resolve_ddic.
* this will make sure the deletion sequence of structures/tables work
* in case they have dependencies with .INCLUDE

    TYPES: BEGIN OF ty_edge,
             from TYPE ty_item,
             to   TYPE ty_item,
           END OF ty_edge.

    DATA: lt_nodes        TYPE TABLE OF ty_item,
          lt_edges        TYPE TABLE OF ty_edge,
          lt_findstrings  TYPE TABLE OF rsfind,
          lv_plus         TYPE i VALUE 1,
          lv_find_obj_cls TYPE euobj-id,
          lv_index        TYPE i,
          lv_before       TYPE i,
          lt_founds       TYPE TABLE OF rsfindlst,
          lt_scope        TYPE STANDARD TABLE OF seu_obj,
          lt_dependency   TYPE ty_dedenpencies.

    FIELD-SYMBOLS: <ls_tadir_ddls>      TYPE zif_abapgit_definitions=>ty_tadir,
                   <ls_dependency>      TYPE ty_dependency,
                   <ls_tadir_dependent> TYPE zif_abapgit_definitions=>ty_tadir,
                   <ls_tadir>           LIKE LINE OF ct_tadir,
                   <ls_edge>            LIKE LINE OF lt_edges,
                   <ls_found>           LIKE LINE OF lt_founds,
                   <ls_node>            LIKE LINE OF lt_nodes.

    " build nodes
    LOOP AT ct_tadir ASSIGNING <ls_tadir>
        WHERE object = 'TABL'
        OR object = 'VIEW'
        OR object = 'TTYP'.
      APPEND INITIAL LINE TO lt_nodes ASSIGNING <ls_node>.
      <ls_node>-obj_name = <ls_tadir>-obj_name.
      <ls_node>-obj_type = <ls_tadir>-object.
    ENDLOOP.

    APPEND 'TABL' TO lt_scope.
    APPEND 'VIEW' TO lt_scope.
    APPEND 'STRU' TO lt_scope.
    APPEND 'TTYP' TO lt_scope.

    " build edges
    LOOP AT lt_nodes ASSIGNING <ls_node>.

      CLEAR lt_findstrings.
      APPEND <ls_node>-obj_name TO lt_findstrings.
      lv_find_obj_cls = <ls_node>-obj_type.

      CALL FUNCTION 'RS_EU_CROSSREF'
        EXPORTING
          i_find_obj_cls           = lv_find_obj_cls
        TABLES
          i_findstrings            = lt_findstrings
          o_founds                 = lt_founds
          i_scope_object_cls       = lt_scope
        EXCEPTIONS
          not_executed             = 1
          not_found                = 2
          illegal_object           = 3
          no_cross_for_this_object = 4
          batch                    = 5
          batchjob_error           = 6
          wrong_type               = 7
          object_not_exist         = 8
          OTHERS                   = 9.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

      LOOP AT lt_founds ASSIGNING <ls_found>.
        APPEND INITIAL LINE TO lt_edges ASSIGNING <ls_edge>.
        <ls_edge>-from = <ls_node>.

        <ls_edge>-to-obj_name   = <ls_found>-object.
        CASE <ls_found>-object_cls.
          WHEN 'DS'
              OR 'DT'.
            <ls_edge>-to-obj_type = 'TABL'.
          WHEN 'DV'.
            <ls_edge>-to-obj_type = 'VIEW'.
          WHEN 'DA'.
            <ls_edge>-to-obj_type = 'TTYP'.
          WHEN OTHERS.
            zcx_abapgit_exception=>raise( 'resolve_ddic, unknown object_cls' ).
        ENDCASE.
      ENDLOOP.

    ENDLOOP.

    " build DDLS edges
    SORT ct_tadir. "binary search
    LOOP AT ct_tadir ASSIGNING <ls_tadir_ddls>
                     WHERE object = 'DDLS'.

      CLEAR: lt_dependency.

      APPEND INITIAL LINE TO lt_nodes ASSIGNING <ls_node>.
      <ls_node>-obj_name = <ls_tadir_ddls>-obj_name.
      <ls_node>-obj_type = <ls_tadir_ddls>-object.

      lt_dependency = get_ddls_dependencies( <ls_tadir_ddls>-obj_name ).

      LOOP AT lt_dependency ASSIGNING <ls_dependency>
                            WHERE deptyp = 'DDLS'
                            AND refname = <ls_tadir_ddls>-obj_name.

        READ TABLE ct_tadir ASSIGNING <ls_tadir_dependent>
                            WITH KEY pgmid    = 'R3TR'
                                     object   = 'DDLS'
                                     obj_name = <ls_dependency>-depname
                            BINARY SEARCH.
        CHECK sy-subrc = 0.

        APPEND INITIAL LINE TO lt_edges ASSIGNING <ls_edge>.
        <ls_edge>-from = <ls_node>.
        <ls_edge>-to-obj_name = <ls_dependency>-depname.
        <ls_edge>-to-obj_type = 'DDLS'.

      ENDLOOP.

    ENDLOOP.

    DO.
      lv_before = lines( lt_nodes ).
      LOOP AT lt_nodes ASSIGNING <ls_node>.
        lv_index = sy-tabix.
        READ TABLE lt_edges WITH KEY
          from-obj_name = <ls_node>-obj_name
          from-obj_type = <ls_node>-obj_type
          TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          LOOP AT ct_tadir ASSIGNING <ls_tadir>
              WHERE obj_name = <ls_node>-obj_name
              AND object = <ls_node>-obj_type.
            <ls_tadir>-korrnum = <ls_tadir>-korrnum + lv_plus.
            CONDENSE <ls_tadir>-korrnum.
          ENDLOOP.
          DELETE lt_edges
            WHERE to-obj_name = <ls_node>-obj_name
            AND to-obj_type = <ls_node>-obj_type.
          DELETE lt_nodes INDEX lv_index.
          EXIT. " make sure the sequence is fixed
        ENDIF.
      ENDLOOP.
      IF lv_before = lines( lt_nodes ).
        EXIT.
      ENDIF.
      lv_plus = lv_plus + 1.
    ENDDO.

  ENDMETHOD.

  METHOD resolve_packages.

    DATA: lt_subpackages TYPE zif_abapgit_sap_package=>ty_devclass_tt.

    FIELD-SYMBOLS: <ls_tadir>            LIKE LINE OF ct_tadir,
                   <lv_subpackage>       LIKE LINE OF lt_subpackages,
                   <ls_tadir_subpackage> LIKE LINE OF ct_tadir.

    " List subpackage before corresponding superpackage

    LOOP AT ct_tadir ASSIGNING <ls_tadir>
                     WHERE object = 'DEVC'.

      lt_subpackages = zcl_abapinst_factory=>get_sap_package( |{ <ls_tadir>-obj_name }| )->list_subpackages( ).

      LOOP AT lt_subpackages ASSIGNING <lv_subpackage>.

        READ TABLE ct_tadir ASSIGNING <ls_tadir_subpackage>
                            WITH KEY object   = 'DEVC'
                                     obj_name = <lv_subpackage>.
        IF sy-subrc = 0.
          <ls_tadir_subpackage>-korrnum = condense( |{ <ls_tadir_subpackage>-korrnum - 1 }| ).
        ENDIF.

      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_dot_abapgit IMPLEMENTATION.

  METHOD add_ignore.

    DATA: lv_name TYPE string.

    FIELD-SYMBOLS: <lv_ignore> LIKE LINE OF ms_data-ignore.

    lv_name = iv_path && iv_filename.

    READ TABLE ms_data-ignore FROM lv_name TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      RETURN.
    ENDIF.

    APPEND INITIAL LINE TO ms_data-ignore ASSIGNING <lv_ignore>.
    <lv_ignore> = lv_name.

  ENDMETHOD.

  METHOD build_default.

    DATA: ls_data TYPE zif_abapgit_dot_abapgit=>ty_dot_abapgit.

    ls_data-master_language = sy-langu.
    ls_data-starting_folder = '/src/'.
    ls_data-folder_logic    = zif_abapgit_dot_abapgit=>c_folder_logic-prefix.

    CREATE OBJECT ro_dot_abapgit
      EXPORTING
        is_data = ls_data.

  ENDMETHOD.

  METHOD constructor.
    ms_data = is_data.
  ENDMETHOD.

  METHOD deserialize.

    DATA: lv_xml  TYPE string,
          ls_data TYPE zif_abapgit_dot_abapgit=>ty_dot_abapgit.

    lv_xml = zcl_abapgit_convert=>xstring_to_string_utf8( iv_xstr ).

    ls_data = from_xml( lv_xml ).

    CREATE OBJECT ro_dot_abapgit
      EXPORTING
        is_data = ls_data.

  ENDMETHOD.

  METHOD determine_i18n_parameters.

    rs_i18n_params-main_language         = get_main_language( ).
    rs_i18n_params-use_lxe               = use_lxe( ).
    rs_i18n_params-main_language_only    = iv_main_language_only.
    rs_i18n_params-translation_languages = zcl_abapgit_lxe_texts=>get_translation_languages(
      iv_main_language  = get_main_language( )
      it_i18n_languages = get_i18n_languages( ) ).

  ENDMETHOD.

  METHOD from_xml.

    DATA: lv_xml TYPE string.

    lv_xml = iv_xml.

    CALL TRANSFORMATION id
      OPTIONS value_handling = 'accept_data_loss'
      SOURCE XML lv_xml
      RESULT data = rs_data.

* downward compatibility
    IF rs_data-folder_logic IS INITIAL.
      rs_data-folder_logic = zif_abapgit_dot_abapgit=>c_folder_logic-prefix.
    ENDIF.

  ENDMETHOD.

  METHOD get_abap_language_version.
    rv_abap_language_version = ms_data-abap_language_version.
  ENDMETHOD.

  METHOD get_data.
    rs_data = ms_data.
  ENDMETHOD.

  METHOD get_folder_logic.
    rv_logic = ms_data-folder_logic.
  ENDMETHOD.

  METHOD get_i18n_languages.
    rt_languages = ms_data-i18n_languages.
  ENDMETHOD.

  METHOD get_main_language.
    rv_language = ms_data-master_language.
    IF rv_language IS INITIAL.
      rv_language = sy-langu.
    ENDIF.
  ENDMETHOD.

  METHOD get_name.
    rv_name = ms_data-name.
  ENDMETHOD.

  METHOD get_original_system.
    rv_original_system = ms_data-original_system.
  ENDMETHOD.

  METHOD get_packaging.

    FIELD-SYMBOLS <ls_dependency> LIKE LINE OF rs_packaging-dependencies.

    rs_packaging = ms_data-packaging.

    rs_packaging-sem_version = zcl_abapgit_version=>conv_str_to_version( rs_packaging-version ).

    LOOP AT rs_packaging-dependencies ASSIGNING <ls_dependency>.
      <ls_dependency>-sem_version = zcl_abapgit_version=>conv_str_to_version( <ls_dependency>-version ).
    ENDLOOP.

  ENDMETHOD.

  METHOD get_requirements.
    rt_requirements = ms_data-requirements.
  ENDMETHOD.

  METHOD get_signature.

    rs_signature-path     = zif_abapgit_definitions=>c_root_dir.
    rs_signature-filename = zif_abapgit_definitions=>c_dot_abapgit.
    rs_signature-sha1     = zcl_abapgit_hash=>sha1_blob( serialize( ) ).

  ENDMETHOD.

  METHOD get_starting_folder.
    rv_path = ms_data-starting_folder.
  ENDMETHOD.

  METHOD get_version_constant.
    rv_version_constant = ms_data-version_constant.
  ENDMETHOD.

  METHOD is_ignored.

    DATA: lv_name     TYPE string,
          lv_starting TYPE string,
          lv_dot      TYPE string,
          lv_ignore   TYPE string.

    lv_name = iv_path && iv_filename.

    CONCATENATE ms_data-starting_folder '*' INTO lv_starting.

    " Always allow .abapgit.xml and .apack-manifest.xml
    CONCATENATE '/' zif_abapgit_definitions=>c_dot_abapgit INTO lv_dot.
    IF lv_name = lv_dot.
      RETURN.
    ENDIF.
    CONCATENATE '/' zif_abapgit_apack_definitions=>c_dot_apack_manifest INTO lv_dot.
    IF lv_name = lv_dot.
      RETURN.
    ENDIF.

    " Ignore all files matching pattern in ignore list
    LOOP AT ms_data-ignore INTO lv_ignore.
      IF lv_name CP lv_ignore.
        rv_ignored = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.

    " Ignore all files outside of starting folder tree
    IF ms_data-starting_folder <> '/' AND NOT lv_name CP lv_starting.
      rv_ignored = abap_true.
    ENDIF.

    IF iv_path = zif_abapgit_data_config=>c_default_path.
      rv_ignored = abap_false.
    ENDIF.

  ENDMETHOD.

  METHOD remove_ignore.

    DATA: lv_name TYPE string.

    lv_name = iv_path && iv_filename.

    DELETE TABLE ms_data-ignore FROM lv_name.

  ENDMETHOD.

  METHOD serialize.

    DATA lv_xml TYPE string.

    lv_xml = to_xml( ms_data ).

    rv_xstr = zcl_abapgit_convert=>string_to_xstring_utf8_bom( lv_xml ).

  ENDMETHOD.

  METHOD set_abap_language_version.
    ms_data-abap_language_version = iv_abap_language_version.
  ENDMETHOD.

  METHOD set_folder_logic.
    ms_data-folder_logic = iv_logic.
  ENDMETHOD.

  METHOD set_i18n_languages.
    ms_data-i18n_languages = it_languages.
  ENDMETHOD.

  METHOD set_name.
    ms_data-name = iv_name.
  ENDMETHOD.

  METHOD set_original_system.
    ms_data-original_system = iv_original_system.
  ENDMETHOD.

  METHOD set_packaging.

    FIELD-SYMBOLS <ls_dependency> LIKE LINE OF ms_data-packaging-dependencies.

    ms_data-packaging = is_packaging.

    CLEAR ms_data-packaging-sem_version.

    LOOP AT ms_data-packaging-dependencies ASSIGNING <ls_dependency>.
      CLEAR <ls_dependency>-sem_version.
    ENDLOOP.

  ENDMETHOD.

  METHOD set_requirements.
    ms_data-requirements = it_requirements.
  ENDMETHOD.

  METHOD set_starting_folder.
    ms_data-starting_folder = iv_path.
  ENDMETHOD.

  METHOD set_version_constant.
    ms_data-version_constant = iv_version_constant.
  ENDMETHOD.

  METHOD to_file.
    rs_file-path     = zif_abapgit_definitions=>c_root_dir.
    rs_file-filename = zif_abapgit_definitions=>c_dot_abapgit.
    rs_file-data     = serialize( ).
    rs_file-sha1     = zcl_abapgit_hash=>sha1_blob( rs_file-data ).
  ENDMETHOD.

  METHOD to_xml.

    CALL TRANSFORMATION id
      OPTIONS initial_components = 'suppress'
      SOURCE data = is_data
      RESULT XML rv_xml.

    rv_xml = zcl_abapgit_xml_pretty=>print( rv_xml ).

    REPLACE FIRST OCCURRENCE
      OF REGEX '<\?xml version="1\.0" encoding="[\w-]+"\?>'
      IN rv_xml
      WITH '<?xml version="1.0" encoding="utf-8"?>'.
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD use_lxe.

    IF iv_yes <> abap_undefined.
      ms_data-use_lxe = iv_yes.
    ENDIF.

    rv_yes = ms_data-use_lxe.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_environment IMPLEMENTATION.

  METHOD is_system_changes_allowed.

    DATA:
      lv_systemedit         TYPE tadir-edtflag,
      lv_sys_cliinddep_edit TYPE t000-ccnocliind,
      lv_is_shadow          TYPE abap_bool,
      ls_upginfo            TYPE uvers,
      lv_is_upgrade         TYPE abap_bool.

    CALL FUNCTION 'TR_SYS_PARAMS'
      IMPORTING
        systemedit         = lv_systemedit
        sys_cliinddep_edit = lv_sys_cliinddep_edit
      EXCEPTIONS
        no_systemname      = 1
        no_systemtype      = 2
        OTHERS             = 3.
    IF sy-subrc <> 0.
      " Assume system can't be changed
      RETURN.
    ENDIF.

    CALL FUNCTION 'UPG_IS_SHADOW_SYSTEM'
      IMPORTING
        ev_shadow = lv_is_shadow.

    CALL FUNCTION 'UPG_GET_ACTIVE_COMP_UPGRADE'
      EXPORTING
        iv_component = 'SAP_BASIS'
        iv_upgtype   = 'A'
        iv_buffered  = abap_false
      IMPORTING
        ev_upginfo   = ls_upginfo
      EXCEPTIONS
        OTHERS       = 4.
    IF sy-subrc = 0 AND ls_upginfo-putstatus NA 'ITU'.
      lv_is_upgrade = abap_true.
    ENDIF.

    " SAP system has status 'not modifiable' (TK 102)
    " Changes to repository objects are not permitted in this client (TK 729)
    " Shadow system
    " Running upgrade
    rv_result = boolc(
      lv_systemedit <> 'N' AND
      lv_sys_cliinddep_edit NA '23' AND
      lv_is_shadow <> abap_true AND
      lv_is_upgrade <> abap_true ).

  ENDMETHOD.

  METHOD zif_abapgit_environment~check_parallel_processing.

    " If check fails, see transactions RZ12
    DATA:
      lt_setup      TYPE STANDARD TABLE OF rzllitab,
      ls_setup      LIKE LINE OF lt_setup,
      lt_erfc_setup TYPE STANDARD TABLE OF rzlliclass,
      lt_instances  TYPE STANDARD TABLE OF msxxlist WITH DEFAULT KEY.

    " Check if server group for parallel processing exists
    CALL FUNCTION 'SMLG_GET_SETUP'
      EXPORTING
        grouptype          = 'S'
      TABLES
        setup              = lt_setup
        erfc_setup         = lt_erfc_setup
      EXCEPTIONS
        foreign_lock       = 1
        system_failure     = 2
        invalid_group_type = 3
        OTHERS             = 4.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    READ TABLE lt_setup INTO ls_setup WITH KEY classname = iv_group.
    IF sy-subrc = 0 AND ls_setup-applserver IS NOT INITIAL.

      " Check if assigned server instance exists
      CALL FUNCTION 'TH_SERVER_LIST'
        TABLES
          list = lt_instances.

      READ TABLE lt_instances TRANSPORTING NO FIELDS WITH KEY name = ls_setup-applserver.
      IF sy-subrc = 0.
        rv_checked = abap_true.
      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_environment~compare_with_inactive.
    rv_result = zif_abapgit_environment~is_sap_cloud_platform( ).
  ENDMETHOD.

  METHOD zif_abapgit_environment~get_available_user_sessions.

    DATA:
      lv_act_sessions TYPE i,
      lv_max_sessions TYPE i,
      lv_subrc        TYPE sy-subrc.

    CALL FUNCTION 'TH_USER_INFO'
      IMPORTING
        act_sessions = lv_act_sessions
        max_sessions = lv_max_sessions
        rc           = lv_subrc.

    IF lv_subrc = 0.
      rv_sessions = lv_max_sessions - lv_act_sessions.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_environment~get_basis_release.

    SELECT SINGLE release extrelease FROM cvers INTO (rs_result-release, rs_result-sp)
      WHERE component = 'SAP_BASIS' ##SUBRC_OK.

  ENDMETHOD.

  METHOD zif_abapgit_environment~get_system_language_filter.
    DATA lv_translation_detective_lang TYPE spras.
    DATA lv_pseudo_translation_language TYPE spras.
    FIELD-SYMBOLS <ls_system_language_filter> LIKE LINE OF rt_system_language_filter.

    " Translation Object Detective
    " https://help.sap.com/docs/ABAP_PLATFORM_NEW/ceb25152cb0d4adba664cebea2bf4670/88a3d3cbccf64601975acabaccdfde45.html
    CALL FUNCTION 'CONVERSION_EXIT_ISOLA_INPUT'
      EXPORTING
        input            = '1Q'
      IMPORTING
        output           = lv_translation_detective_lang
      EXCEPTIONS
        unknown_language = 1
        OTHERS           = 2.
    IF sy-subrc = 1.
      " The language for Translation Object Detective was not setup
    ENDIF.
    IF NOT lv_translation_detective_lang IS INITIAL.
      APPEND INITIAL LINE TO rt_system_language_filter ASSIGNING <ls_system_language_filter>.
      <ls_system_language_filter>-sign = 'E'.
      <ls_system_language_filter>-option = 'EQ'.
      <ls_system_language_filter>-low = lv_translation_detective_lang.
    ENDIF.
    " 1943470 - Using technical language key 2Q to create pseudo-translations of ABAP developments
    " https://launchpad.support.sap.com/#/notes/1943470
    CALL FUNCTION 'CONVERSION_EXIT_ISOLA_INPUT'
      EXPORTING
        input            = '2Q'
      IMPORTING
        output           = lv_pseudo_translation_language
      EXCEPTIONS
        unknown_language = 1
        OTHERS           = 2.
    IF sy-subrc = 1.
      " The language for Pseudo Translation was not setup
    ENDIF.
    IF NOT lv_pseudo_translation_language IS INITIAL.
      APPEND INITIAL LINE TO rt_system_language_filter ASSIGNING <ls_system_language_filter>.
      <ls_system_language_filter>-sign = 'E'.
      <ls_system_language_filter>-option = 'EQ'.
      <ls_system_language_filter>-low = lv_pseudo_translation_language.
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_environment~init_parallel_processing.

    DATA: lv_group TYPE rzlli_apcl.

    lv_group = iv_group.

    " SPBT_INITIALIZE gives error PBT_ENV_ALREADY_INITIALIZED if called
    " multiple times in same session
    CALL FUNCTION 'SPBT_INITIALIZE'
      EXPORTING
        group_name                     = lv_group
      IMPORTING
        free_pbt_wps                   = rv_free_work_processes
      EXCEPTIONS
        invalid_group_name             = 1
        internal_error                 = 2
        pbt_env_already_initialized    = 3
        currently_no_resources_avail   = 4
        no_pbt_resources_found         = 5
        cant_init_different_pbt_groups = 6
        OTHERS                         = 7 ##FM_SUBRC_OK.
    " If SPBT_INITIALIZE fails, check transactions RZ12, SM50, SM21, SARFC

  ENDMETHOD.

  METHOD zif_abapgit_environment~is_merged.
    DATA lr_marker TYPE REF TO data ##NEEDED.

    IF mv_is_merged = abap_undefined.
      TRY.
          CREATE DATA lr_marker TYPE REF TO ('LIF_ABAPMERGE_MARKER').
          "No exception --> marker found
          mv_is_merged = abap_true.

        CATCH cx_sy_create_data_error.
          mv_is_merged = abap_false.
      ENDTRY.
    ENDIF.
    rv_result = mv_is_merged.
  ENDMETHOD.

  METHOD zif_abapgit_environment~is_repo_object_changes_allowed.
    IF mv_modifiable = abap_undefined.
      mv_modifiable = is_system_changes_allowed( ).
    ENDIF.
    rv_result = mv_modifiable.
  ENDMETHOD.

  METHOD zif_abapgit_environment~is_restart_required.
    " This method will be used in the context of SAP Cloud Platform:
    " Pull/Push operations are executed in background jobs.
    " In case of the respective application server needs to be restarted,
    " it is required to terminate the background job and reschedule again.
    rv_result = abap_false.
    TRY.
        CALL METHOD ('CL_APJ_SCP_TOOLS')=>('IS_RESTART_REQUIRED')
          RECEIVING
            restart_required = rv_result.
      CATCH cx_sy_dyn_call_illegal_method cx_sy_dyn_call_illegal_class.
        rv_result = abap_false.
    ENDTRY.
  ENDMETHOD.

  METHOD zif_abapgit_environment~is_sap_cloud_platform.
    IF mv_cloud = abap_undefined.
      TRY.
          CALL METHOD ('CL_COS_UTILITIES')=>('IS_SAP_CLOUD_PLATFORM')
            RECEIVING
              rv_is_sap_cloud_platform = mv_cloud.
        CATCH cx_sy_dyn_call_error.
          mv_cloud = abap_false.
      ENDTRY.
    ENDIF.
    rv_result = mv_cloud.
  ENDMETHOD.

  METHOD zif_abapgit_environment~is_sap_object_allowed.

    rv_allowed = cl_enh_badi_def_utility=>is_sap_system( ).
    IF rv_allowed = abap_true.
      RETURN.
    ENDIF.

    rv_allowed = zcl_abapgit_exit=>get_instance( )->allow_sap_objects( ).

  ENDMETHOD.

  METHOD zif_abapgit_environment~is_variant_maintenance.

    DATA:
      lt_variscreens TYPE STANDARD TABLE OF rsdynnr
                          WITH NON-UNIQUE DEFAULT KEY.

    " Memory is set in LSVARF08 / EXPORT_SCREEN_TABLES.
    IMPORT variscreens = lt_variscreens FROM MEMORY ID '%_SCRNR_%'.

    rv_is_variant_maintenance = boolc( lines( lt_variscreens ) > 0 ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_exit IMPLEMENTATION.

  METHOD get_instance.

    DATA lv_class_name TYPE string.

    IF gi_global_exit IS NOT INITIAL.
      ri_exit = gi_global_exit.
      RETURN.
    ENDIF.

    IF zcl_abapinst_factory=>get_environment( )->is_merged( ) = abap_true.
      " Prevent accidental usage of exit handlers in the developer version
      lv_class_name = |\\PROGRAM={ sy-repid }\\CLASS={ lv_class_name }|.
    ENDIF.

    " Prevent non-mocked exit calls in unit tests
    IF is_running_in_test_context( ) = abap_false.
      TRY.
          CREATE OBJECT gi_exit TYPE (lv_class_name).
        CATCH cx_sy_create_object_error ##NO_HANDLER.
      ENDTRY.
    ENDIF.

    CREATE OBJECT gi_global_exit TYPE zcl_abapgit_exit. " this class

    ri_exit = gi_global_exit.

  ENDMETHOD.

  METHOD is_running_in_test_context.

    IF sy-sysid = 'ABC'.
      " always run on open-abap
      rv_running_in_test_context = abap_true.
      RETURN.
    ENDIF.

    " Check if the local test class can be accessed by RTTI. If so the current process is running in a unit test.
    " Note this approach only works for the developer version. The standalone version will always report not running in
    " test context which should be fine as there are no unit tests delivered in it.
    cl_abap_typedescr=>describe_by_name(
      EXPORTING
        p_name         = |\\PROGRAM={ sy-repid }\\CLASS=LTCL_TEST|
      EXCEPTIONS
        type_not_found = 1
        OTHERS         = 2 ).
    rv_running_in_test_context = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_exit~adjust_display_commit_url.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->adjust_display_commit_url(
            EXPORTING
              iv_repo_url    = iv_repo_url
              iv_repo_name   = iv_repo_name
              iv_repo_key    = iv_repo_key
              iv_commit_hash = iv_commit_hash
            CHANGING
              cv_display_url = cv_display_url ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~adjust_display_filename.

    IF gi_exit IS NOT INITIAL.
      TRY.
          rv_filename = gi_exit->adjust_display_filename(
            is_repo_meta = is_repo_meta
            iv_filename  = iv_filename ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

    IF rv_filename IS INITIAL.
      rv_filename = iv_filename.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~allow_sap_objects.

    IF gi_exit IS NOT INITIAL.
      TRY.
          rv_allowed = gi_exit->allow_sap_objects( ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~change_local_host.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->change_local_host( CHANGING ct_hosts = ct_hosts ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~change_max_parallel_processes.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->change_max_parallel_processes(
            EXPORTING
              iv_package       = iv_package
            CHANGING
              cv_max_processes = cv_max_processes ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~change_proxy_authentication.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->change_proxy_authentication(
            EXPORTING
              iv_repo_url             = iv_repo_url
            CHANGING
              cv_proxy_authentication = cv_proxy_authentication ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~change_proxy_port.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->change_proxy_port(
            EXPORTING
              iv_repo_url   = iv_repo_url
            CHANGING
              cv_proxy_port = cv_proxy_port ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~change_proxy_url.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->change_proxy_url(
            EXPORTING
              iv_repo_url  = iv_repo_url
            CHANGING
              cv_proxy_url = cv_proxy_url ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~change_rfc_server_group.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->change_rfc_server_group( CHANGING cv_group = cv_group ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~change_supported_data_objects.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->change_supported_data_objects( CHANGING ct_objects = ct_objects ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~change_supported_object_types.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->change_supported_object_types( CHANGING ct_types = ct_types ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~change_tadir.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->change_tadir(
            EXPORTING
              iv_package            = iv_package
              ii_log                = ii_log
              is_dot_abapgit        = is_dot_abapgit
              iv_ignore_subpackages = iv_ignore_subpackages
              iv_only_local_objects = iv_only_local_objects
            CHANGING
              ct_tadir              = ct_tadir ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~create_http_client.

    IF gi_exit IS NOT INITIAL.
      TRY.
          ri_client = gi_exit->create_http_client( iv_url ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~custom_serialize_abap_clif.

    " This exit might be called twice per object
    " 1st call: it_source = initial
    "    Can be used for serializing complete source
    "    If source is returned, there will be no second call
    " 2nd call: it_source = code as serialized by abapGit
    "    Can be used for post-processing of source
    IF gi_exit IS NOT INITIAL.
      TRY.
          rt_source = gi_exit->custom_serialize_abap_clif(
            is_class_key = is_class_key
            it_source    = it_source ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

    IF rt_source IS INITIAL.
      rt_source = it_source.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~deserialize_postprocess.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->deserialize_postprocess( is_step = is_step
                                            ii_log  = ii_log ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~determine_transport_request.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->determine_transport_request(
            EXPORTING
              io_repo              = io_repo
              iv_transport_type    = iv_transport_type
            CHANGING
              cv_transport_request = cv_transport_request ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~enhance_any_toolbar.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->enhance_any_toolbar( io_menu ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~enhance_repo_toolbar.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->enhance_repo_toolbar(
            io_menu = io_menu
            iv_key  = iv_key
            iv_act  = iv_act ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~get_ci_tests.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->get_ci_tests(
            EXPORTING
              iv_object   = iv_object
            CHANGING
              ct_ci_repos = ct_ci_repos ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~get_ssl_id.

    IF gi_exit IS NOT INITIAL.
      TRY.
          rv_ssl_id = gi_exit->get_ssl_id( ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

    IF rv_ssl_id IS INITIAL.
      rv_ssl_id = 'ANONYM'.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~http_client.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->http_client(
            iv_url    = iv_url
            ii_client = ii_client ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~pre_calculate_repo_status.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->pre_calculate_repo_status(
            EXPORTING
              is_repo_meta = is_repo_meta
            CHANGING
              ct_local     = ct_local
              ct_remote    = ct_remote ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~serialize_postprocess.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->serialize_postprocess(
            EXPORTING
              iv_package = iv_package
              ii_log     = ii_log
            CHANGING
              ct_files   = ct_files ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_exit~validate_before_push.

    IF gi_exit IS NOT INITIAL.
      TRY.
          gi_exit->validate_before_push(
            is_comment = is_comment
            io_stage   = io_stage
            io_repo    = io_repo ).
        CATCH cx_sy_ref_is_initial cx_sy_dyn_call_illegal_method ##NO_HANDLER.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

ENDCLASS.

CLASS zcl_abapgit_filename_logic IMPLEMENTATION.

  METHOD detect_obj_definition.

    ev_is_xml  = boolc( iv_ext = to_upper( c_package_file-extension ) AND strlen( iv_type ) = 4 ).
    ev_is_json = boolc( iv_ext = to_upper( c_json_file-extension ) AND strlen( iv_type ) = 4 ).

  ENDMETHOD.

  METHOD file_to_object.

    DATA:
      lv_name TYPE string,
      lv_type TYPE string,
      lv_ext  TYPE string.

    " Guess object type and name
    SPLIT to_upper( iv_filename ) AT '.' INTO lv_name lv_type lv_ext.

    " Handle namespaces
    REPLACE ALL OCCURRENCES OF '#' IN lv_name WITH '/'.
    REPLACE ALL OCCURRENCES OF '#' IN lv_type WITH '/'.
    REPLACE ALL OCCURRENCES OF '#' IN lv_ext WITH '/'.

    " Assume AFF namespace convention
    IF go_aff_registry IS INITIAL.
      CREATE OBJECT go_aff_registry TYPE zcl_abapgit_aff_registry.
    ENDIF.

    IF go_aff_registry->is_supported_object_type( |{ lv_type }| ) = abap_true.
      REPLACE ALL OCCURRENCES OF '(' IN lv_name WITH '/'.
      REPLACE ALL OCCURRENCES OF ')' IN lv_name WITH '/'.
    ENDIF.

    " Get original object name
    lv_name = name_unescape( lv_name ).

    CLEAR es_item.
    es_item-obj_type = lv_type.
    es_item-obj_name = lv_name.

    " Get mapping specific to object type
    map_filename_to_object(
      EXPORTING
        iv_filename = iv_filename
        iv_path     = iv_path
        io_dot      = io_dot
        iv_package  = iv_devclass
      CHANGING
        cs_item     = es_item ).

    detect_obj_definition(
      EXPORTING
        iv_ext     = lv_ext
        iv_type    = lv_type
      IMPORTING
        ev_is_xml  = ev_is_xml
        ev_is_json = ev_is_json ).

  ENDMETHOD.

  METHOD i18n_file_to_object.

    DATA lo_dot TYPE REF TO zcl_abapgit_dot_abapgit.

    CLEAR: es_item, ev_lang, ev_ext.
    lo_dot = zcl_abapgit_dot_abapgit=>build_default( ).

    file_to_object(
      EXPORTING
        iv_filename = iv_filename
        iv_path     = iv_path
        io_dot      = lo_dot
      IMPORTING
        es_item     = es_item ).

    get_lang_and_ext(
      EXPORTING
        iv_filename = iv_filename
      IMPORTING
        ev_lang     = ev_lang
        ev_ext      = ev_ext ).

  ENDMETHOD.

  METHOD is_obj_definition_file.

    DATA:
      lv_xml  TYPE abap_bool,
      lv_json TYPE abap_bool,
      lv_name TYPE string,
      lv_type TYPE string,
      lv_ext  TYPE string.

    SPLIT to_upper( iv_filename ) AT '.' INTO lv_name lv_type lv_ext.

    detect_obj_definition(
      EXPORTING
        iv_ext     = lv_ext
        iv_type    = lv_type
      IMPORTING
        ev_is_xml  = lv_xml
        ev_is_json = lv_json ).

    rv_yes = boolc( lv_json = abap_true OR lv_xml = abap_true ).

  ENDMETHOD.

  METHOD map_filename_to_object.

    DATA lv_class TYPE seoclsname.

    " TODO: Add check for supported object types to avoid calls to non-existing classes
    " zcl_abapinst_objects=>is_type_supported( is_item-obj_type )
    " This will trigger class constructor of zcl_abapgit_objects_bridge reading table seometarel
    " which is currently not supported by abaplint test runner

    TRY.
        lv_class = 'ZCL_ABAPGIT_OBJECT_' && cs_item-obj_type.

        CALL METHOD (lv_class)=>('ZIF_ABAPGIT_OBJECT~MAP_FILENAME_TO_OBJECT')
          EXPORTING
            iv_filename = iv_filename
            iv_path     = iv_path
            io_dot      = io_dot
            iv_package  = iv_package
          CHANGING
            cs_item     = cs_item.
      CATCH cx_sy_dyn_call_illegal_class.
        " Map data config to TABU object type
        IF cs_item-obj_type = 'CONF'.
          cs_item-obj_type = 'TABU'.
        ENDIF.
    ENDTRY.

  ENDMETHOD.

  METHOD map_object_to_filename.

    DATA lv_class TYPE seoclsname.

    " TODO: Add check for supported object types to avoid calls to non-existing classes
    " zcl_abapinst_objects=>is_type_supported( is_item-obj_type )
    " This will trigger class constructor of zcl_abapgit_objects_bridge reading table seometarel
    " which is currently not supported by abaplint test runner

    TRY.
        lv_class = 'ZCL_ABAPGIT_OBJECT_' && is_item-obj_type.

        CALL METHOD (lv_class)=>('ZIF_ABAPGIT_OBJECT~MAP_OBJECT_TO_FILENAME')
          EXPORTING
            is_item     = is_item
            iv_ext      = iv_ext
            iv_extra    = iv_extra
          CHANGING
            cv_filename = cv_filename.
      CATCH cx_sy_dyn_call_illegal_class ##NO_HANDLER.
    ENDTRY.

  ENDMETHOD.

  METHOD name_escape.
    " Some characters in object names cause problems when identifying the object later
    " -> we escape these characters here
    " cl_http_utility=>escape_url doesn't do dots but escapes slash which we use for namespaces
    " -> we escape just some selected characters
    rv_name = iv_name.
    REPLACE ALL OCCURRENCES OF `#` IN rv_name WITH '%23'.
    REPLACE ALL OCCURRENCES OF `%` IN rv_name WITH '%25'.
    REPLACE ALL OCCURRENCES OF `.` IN rv_name WITH '%2e'.
    REPLACE ALL OCCURRENCES OF `<` IN rv_name WITH '%3c'.
    REPLACE ALL OCCURRENCES OF `=` IN rv_name WITH '%3d'.
    REPLACE ALL OCCURRENCES OF `>` IN rv_name WITH '%3e'.
    REPLACE ALL OCCURRENCES OF `?` IN rv_name WITH '%3f'.
  ENDMETHOD.

  METHOD name_unescape.
    " Replace all %xy with encoded character
    rv_name = cl_http_utility=>unescape_url( iv_name ).
  ENDMETHOD.

  METHOD object_to_file.

    DATA lv_obj_name TYPE string.
    DATA lv_obj_type TYPE string.
    DATA lv_nb_of_slash TYPE string.

    " Get escaped object name
    lv_obj_name = to_lower( name_escape( is_item-obj_name ) ).
    lv_obj_type = to_lower( is_item-obj_type ).

    IF iv_extra IS INITIAL.
      CONCATENATE lv_obj_name '.' lv_obj_type INTO rv_filename.
    ELSE.
      CONCATENATE lv_obj_name '.' lv_obj_type '.' iv_extra INTO rv_filename.
    ENDIF.

    IF iv_ext IS NOT INITIAL.
      CONCATENATE rv_filename '.' iv_ext INTO rv_filename.
    ENDIF.

    " Get mapping specific to object type
    TRY.
        map_object_to_filename(
          EXPORTING
            is_item     = is_item
            iv_ext      = iv_ext
            iv_extra    = iv_extra
          CHANGING
            cv_filename = rv_filename ).
      CATCH zcx_abapgit_exception ##NO_HANDLER.
    ENDTRY.

    " Handle namespaces
    CREATE OBJECT go_aff_registry TYPE zcl_abapgit_aff_registry.

    IF go_aff_registry->is_supported_object_type( is_item-obj_type ) = abap_true.
      FIND ALL OCCURRENCES OF `/` IN rv_filename MATCH COUNT lv_nb_of_slash.
      IF lv_nb_of_slash = 2.
        REPLACE FIRST OCCURRENCE OF `/` IN rv_filename WITH `(`.
        REPLACE `/` IN rv_filename WITH `)`.
      ENDIF.
    ELSE.
      REPLACE ALL OCCURRENCES OF '/' IN rv_filename WITH '#'.
    ENDIF.

    IF iv_ext = 'properties'.
      RETURN.
    ENDIF.

    TRANSLATE rv_filename TO LOWER CASE.

  ENDMETHOD.

  METHOD object_to_i18n_file.
    DATA: lv_langu_sap1 TYPE sy-langu,
          lv_langu_bcp47 TYPE string.

    lv_langu_sap1 = zcl_abapgit_convert=>language_sap2_to_sap1( to_upper( iv_lang ) ).
    lv_langu_bcp47 = zcl_abapgit_convert=>language_sap1_to_bcp47( lv_langu_sap1 ).

    rv_filename = object_to_file(
      is_item  = is_item
      iv_extra = |i18n.{ lv_langu_bcp47 }|
      iv_ext   = iv_ext ).

  ENDMETHOD.

  METHOD get_lang_and_ext.

    DATA lt_filename_elements TYPE string_table.
    DATA lv_langu_bcp47 TYPE string.
    DATA lv_sap1 TYPE sy-langu.

    SPLIT iv_filename AT '.' INTO TABLE lt_filename_elements.

    READ TABLE lt_filename_elements INDEX lines( lt_filename_elements ) INTO ev_ext.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Could not derive file extension of file { iv_filename }| ).
    ENDIF.

    READ TABLE lt_filename_elements WITH KEY table_line = `i18n` TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      READ TABLE lt_filename_elements INDEX ( sy-tabix + 1 ) INTO lv_langu_bcp47.
      IF sy-subrc = 0.
        lv_sap1 = zcl_abapgit_convert=>language_bcp47_to_sap1( lv_langu_bcp47 ).
        ev_lang = zcl_abapgit_convert=>language_sap1_to_sap2( lv_sap1 ). " actually it is to_upper( ISO-639 )

        " to not break existing PO file implementations
        IF ev_ext = `po`.
          ev_lang = to_lower( ev_lang ).
        ENDIF.
      ENDIF.
    ENDIF.

    IF ev_lang IS INITIAL.
      CLEAR ev_ext.
    ENDIF.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_package_to_path DEFINITION.

  PUBLIC SECTION.

    CLASS-METHODS get
      IMPORTING
        !iv_top        TYPE devclass
        !io_dot        TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_package    TYPE devclass
      RETURNING
        VALUE(rv_path) TYPE string.

    CLASS-METHODS add
      IMPORTING
        !iv_top     TYPE devclass
        !io_dot     TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_package TYPE devclass
        !iv_path    TYPE string.

  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_buffer,
        top             TYPE devclass,
        starting_folder TYPE string,
        folder_logic    TYPE string,
        package         TYPE devclass,
        path            TYPE string,
      END OF ty_buffer.

    CLASS-DATA gt_buffer
      TYPE HASHED TABLE OF ty_buffer
      WITH UNIQUE KEY top starting_folder folder_logic package.

ENDCLASS.

CLASS lcl_package_to_path IMPLEMENTATION.

  METHOD get.

    FIELD-SYMBOLS <ls_buffer> LIKE LINE OF gt_buffer.

    READ TABLE gt_buffer ASSIGNING <ls_buffer> WITH TABLE KEY
      top             = iv_top
      starting_folder = io_dot->get_starting_folder( )
      folder_logic    = io_dot->get_folder_logic( )
      package         = iv_package.
    IF sy-subrc = 0.
      rv_path = <ls_buffer>-path.
    ENDIF.

  ENDMETHOD.

  METHOD add.

    DATA ls_buffer LIKE LINE OF gt_buffer.

    CLEAR ls_buffer.
    ls_buffer-top             = iv_top.
    ls_buffer-starting_folder = io_dot->get_starting_folder( ).
    ls_buffer-folder_logic    = io_dot->get_folder_logic( ).
    ls_buffer-package         = iv_package.
    ls_buffer-path            = iv_path.
    INSERT ls_buffer INTO TABLE gt_buffer.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_path_to_package DEFINITION.

  PUBLIC SECTION.

    CLASS-METHODS get
      IMPORTING
        !iv_top           TYPE devclass
        !io_dot           TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_path          TYPE string
      RETURNING
        VALUE(rv_package) TYPE devclass.

    CLASS-METHODS add
      IMPORTING
        !iv_top     TYPE devclass
        !io_dot     TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_path    TYPE string
        !iv_package TYPE devclass.

  PRIVATE SECTION.

    TYPES:
      BEGIN OF ty_buffer,
        top             TYPE devclass,
        starting_folder TYPE string,
        folder_logic    TYPE string,
        path            TYPE string,
        package         TYPE devclass,
      END OF ty_buffer.

    CLASS-DATA gt_buffer
      TYPE HASHED TABLE OF ty_buffer
      WITH UNIQUE KEY top starting_folder folder_logic path.

ENDCLASS.

CLASS lcl_path_to_package IMPLEMENTATION.

  METHOD get.

    FIELD-SYMBOLS <ls_buffer> LIKE LINE OF gt_buffer.

    READ TABLE gt_buffer ASSIGNING <ls_buffer> WITH TABLE KEY
      top             = iv_top
      starting_folder = io_dot->get_starting_folder( )
      folder_logic    = io_dot->get_folder_logic( )
      path            = iv_path.
    IF sy-subrc = 0.
      rv_package = <ls_buffer>-package.
      RETURN.
    ENDIF.

  ENDMETHOD.

  METHOD add.

    DATA ls_buffer LIKE LINE OF gt_buffer.

    CLEAR ls_buffer.
    ls_buffer-top             = iv_top.
    ls_buffer-starting_folder = io_dot->get_starting_folder( ).
    ls_buffer-folder_logic    = io_dot->get_folder_logic( ).
    ls_buffer-path            = iv_path.
    ls_buffer-package         = iv_package.
    INSERT ls_buffer INTO TABLE gt_buffer.

  ENDMETHOD.

ENDCLASS.

CLASS zcl_abapgit_folder_logic IMPLEMENTATION.

  METHOD get_instance.
    CREATE OBJECT ro_instance.
  ENDMETHOD.

  METHOD get_parent.
    DATA: ls_parent LIKE LINE OF mt_parent.

    " Check that package is included in the TOP package hierarchy
    IF mt_top_subpackages IS INITIAL.
      mt_top_subpackages = zcl_abapinst_factory=>get_sap_package( iv_top )->list_subpackages( ).
    ENDIF.

    READ TABLE mt_top_subpackages TRANSPORTING NO FIELDS WITH KEY devclass = iv_package.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    "Determine Parent Package
    READ TABLE mt_parent INTO ls_parent
      WITH TABLE KEY devclass = iv_package.
    IF sy-subrc <> 0.
      rv_parent = zcl_abapinst_factory=>get_sap_package( iv_package )->read_parent( ).
      ls_parent-devclass = iv_package.
      ls_parent-parentcl = rv_parent.
      INSERT ls_parent INTO TABLE mt_parent.
    ELSE.
      rv_parent = ls_parent-parentcl.
    ENDIF.
  ENDMETHOD.

  METHOD package_to_path.

    DATA: lv_len          TYPE i,
          lv_path         TYPE string,
          lv_message      TYPE string,
          lv_parentcl     TYPE tdevc-parentcl,
          lv_folder_logic TYPE string.

    rv_path = lcl_package_to_path=>get(
      iv_top     = iv_top
      io_dot     = io_dot
      iv_package = iv_package ).
    IF rv_path IS NOT INITIAL.
      RETURN.
    ENDIF.

    IF iv_top = iv_package.
      rv_path = io_dot->get_starting_folder( ).
    ELSE.
      lv_parentcl = get_parent(
        iv_top     = iv_top
        iv_package = iv_package ).

      " If the parent package can not be determined, we return an initial path and handle
      " it outside of this class (in zcl_abapgit_file_status)
      IF lv_parentcl IS NOT INITIAL.
        lv_folder_logic = io_dot->get_folder_logic( ).
        CASE lv_folder_logic.
          WHEN zif_abapgit_dot_abapgit=>c_folder_logic-full.
            lv_len = 0.
            IF iv_package(1) = '$'.
              lv_len = 1.
            ENDIF.
          WHEN zif_abapgit_dot_abapgit=>c_folder_logic-prefix.
            lv_len = strlen( lv_parentcl ).

            IF iv_package(lv_len) <> lv_parentcl.
              " If abapGit project is installed in package ZZZ, all subpackages should be named
              " ZZZ_something. This will define the folder name in the zip file to be "something",
              " similarly with online projects. Alternatively change to FULL folder logic
              lv_message = |PREFIX: Unexpected package naming |
                        && |(top: { iv_top }, parent: { lv_parentcl }, child: { iv_package }). |
                        && |Try using the folder logic FULL|.
              zcx_abapgit_exception=>raise( lv_message ).
            ENDIF.
          WHEN zif_abapgit_dot_abapgit=>c_folder_logic-mixed.
            lv_len = strlen( iv_top ).

            IF iv_package(lv_len) <> iv_top.
              lv_message = |MIXED: Unexpected package naming |
                        && |(top: { iv_top }, parent: { lv_parentcl }, child: { iv_package }). |
                        && |Try using the folder logic FULL|.
              zcx_abapgit_exception=>raise( lv_message ).
            ENDIF.
          WHEN OTHERS.
            zcx_abapgit_exception=>raise( |Invalid folder logic: { lv_folder_logic }| ).
        ENDCASE.

        lv_path = iv_package+lv_len.
        IF strlen( lv_path ) = 0.
          zcx_abapgit_exception=>raise( |Folder logic: length = 0, parent: {
            lv_parentcl }, child: { iv_package }| ).
        ENDIF.

        IF lv_path(1) = '_'.
          lv_path = lv_path+1.
        ENDIF.
        IF strlen( lv_path ) = 0.
          zcx_abapgit_exception=>raise( |Folder logic: length = 0, parent: {
            lv_parentcl }, child: { iv_package }| ).
        ENDIF.

        TRANSLATE lv_path USING '/#'.
        TRANSLATE lv_path TO LOWER CASE.
        CONCATENATE lv_path '/' INTO lv_path.

        rv_path = package_to_path( iv_top     = iv_top
                                   io_dot     = io_dot
                                   iv_package = lv_parentcl ).

        CONCATENATE rv_path lv_path INTO rv_path.
      ENDIF.
    ENDIF.

    lcl_package_to_path=>add(
      iv_top     = iv_top
      io_dot     = io_dot
      iv_package = iv_package
      iv_path    = rv_path ).

  ENDMETHOD.

  METHOD path_to_package.

    DATA: lv_length               TYPE i,
          lv_parent               TYPE devclass,
          ls_package              TYPE zif_abapgit_sap_package=>ty_create,
          lv_new                  TYPE string,
          lv_path                 TYPE string,
          lv_absolute_name        TYPE string,
          lv_folder_logic         TYPE string,
          lt_unique_package_names TYPE HASHED TABLE OF devclass WITH UNIQUE KEY table_line.

    lv_length = strlen( io_dot->get_starting_folder( ) ).
    IF lv_length > strlen( iv_path ).
* treat as not existing locally
      RETURN.
    ENDIF.

    rv_package = lcl_path_to_package=>get(
      iv_top  = iv_top
      io_dot  = io_dot
      iv_path = iv_path ).
    IF rv_package IS NOT INITIAL AND iv_create_if_not_exists = abap_false.
      RETURN.
    ENDIF.

    lv_path    = iv_path+lv_length.
    lv_parent  = iv_top.
    rv_package = iv_top.

    " Automatically create package using minimal properties
    " Details will be updated during deserialization
    IF iv_create_if_not_exists = abap_true.
      IF iv_top(1) = '$'.
        zcl_abapinst_factory=>get_sap_package( iv_top )->create_local( ).
      ELSE.
        ls_package-devclass = iv_top.
        ls_package-ctext = iv_top.
        ls_package-as4user = sy-uname.
        zcl_abapinst_factory=>get_sap_package( iv_top )->create( ls_package ).
      ENDIF.
    ENDIF.

    INSERT iv_top INTO TABLE lt_unique_package_names.

    WHILE lv_path CA '/'.
      SPLIT lv_path AT '/' INTO lv_new lv_path.

      lv_folder_logic = io_dot->get_folder_logic( ).
      CASE lv_folder_logic.
        WHEN zif_abapgit_dot_abapgit=>c_folder_logic-full.
          lv_absolute_name = lv_new.
          TRANSLATE lv_absolute_name USING '#/'.
          IF iv_top(1) = '$'.
            CONCATENATE '$' lv_absolute_name INTO lv_absolute_name.
          ENDIF.
        WHEN zif_abapgit_dot_abapgit=>c_folder_logic-prefix.
          CONCATENATE rv_package '_' lv_new INTO lv_absolute_name.
        WHEN zif_abapgit_dot_abapgit=>c_folder_logic-mixed.
          CONCATENATE iv_top '_' lv_new INTO lv_absolute_name.
        WHEN OTHERS.
          zcx_abapgit_exception=>raise( |Invalid folder logic: { lv_folder_logic }| ).
      ENDCASE.

      TRANSLATE lv_absolute_name TO UPPER CASE.

      IF strlen( lv_absolute_name ) > 30.
        zcx_abapgit_exception=>raise( |Package { lv_absolute_name } exceeds ABAP 30-characters name limit| ).
      ENDIF.

      rv_package = lv_absolute_name.
      READ TABLE lt_unique_package_names TRANSPORTING NO FIELDS
        WITH TABLE KEY table_line = rv_package.
      IF sy-subrc = 0.
        zcx_abapgit_exception=>raise( |Package { rv_package } has a subpackage with the same name| ).
      ELSE.
        INSERT rv_package INTO TABLE lt_unique_package_names.
      ENDIF.

      IF zcl_abapinst_factory=>get_sap_package( rv_package )->exists( ) = abap_false AND
          iv_create_if_not_exists = abap_true.

        zcl_abapinst_factory=>get_sap_package( lv_parent )->create_child( rv_package ).
      ENDIF.

      lv_parent = rv_package.
    ENDWHILE.

    lcl_path_to_package=>add(
      iv_top     = iv_top
      io_dot     = io_dot
      iv_path    = iv_path
      iv_package = rv_package ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_frontend_services IMPLEMENTATION.

  METHOD get_path_from_fullname.

    DATA lv_len TYPE i.

    FIND FIRST OCCURRENCE OF REGEX '^/(.*/)?' IN iv_fullname MATCH LENGTH lv_len.
    IF sy-subrc = 0.
      rv_path = iv_fullname(lv_len).
    ELSE.
      FIND FIRST OCCURRENCE OF REGEX '^(.*\\)?' IN iv_fullname MATCH LENGTH lv_len.
      IF sy-subrc = 0.
        rv_path = iv_fullname(lv_len).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~clipboard_export.

    DATA lv_rc TYPE i.

    " Note: do not use a string table for 'it_data'!

    TRY.
        CALL METHOD cl_gui_frontend_services=>('CLIPBOARD_EXPORT')
          EXPORTING
            no_auth_check        = iv_no_auth_check " >= 740
          IMPORTING
            data                 = it_data
          CHANGING
            rc                   = lv_rc
          EXCEPTIONS
            cntl_error           = 1
            error_no_gui         = 2
            not_supported_by_gui = 3
            no_authority         = 4
            OTHERS               = 5.
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise_t100( ).
        ENDIF.

      CATCH cx_sy_dyn_call_param_missing.

        cl_gui_frontend_services=>clipboard_export(
          IMPORTING
            data                 = it_data
          CHANGING
            rc                   = lv_rc
          EXCEPTIONS
            cntl_error           = 1
            error_no_gui         = 2
            not_supported_by_gui = 3
            no_authority         = 4
          OTHERS               = 5 ).
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise_t100( ).
        ENDIF.

    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~directory_browse.

    IF iv_initial_folder IS NOT INITIAL.
      gv_initial_folder = iv_initial_folder.
    ENDIF.

    cl_gui_frontend_services=>directory_browse(
      EXPORTING
        window_title         = iv_window_title
        initial_folder       = gv_initial_folder
      CHANGING
        selected_folder      = cv_selected_folder
      EXCEPTIONS
        cntl_error           = 1
        error_no_gui         = 2
        not_supported_by_gui = 3
        OTHERS               = 4 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    gv_initial_folder = cv_selected_folder.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~directory_create.

    cl_gui_frontend_services=>directory_create(
      EXPORTING
        directory                = iv_directory
      CHANGING
        rc                       = cv_rc
      EXCEPTIONS
        directory_create_failed  = 1
        cntl_error               = 2
        error_no_gui             = 3
        directory_access_denied  = 4
        directory_already_exists = 5
        path_not_found           = 6
        unknown_error            = 7
        not_supported_by_gui     = 8
        wrong_parameter          = 9
        OTHERS                   = 10 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~directory_exist.

    cl_gui_frontend_services=>directory_exist(
      EXPORTING
        directory            = iv_directory
      RECEIVING
        result               = rv_exists
      EXCEPTIONS
        cntl_error           = 1
        error_no_gui         = 2
        wrong_parameter      = 3
        not_supported_by_gui = 4
        OTHERS               = 5 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~execute.

    cl_gui_frontend_services=>execute(
      EXPORTING
        document               = iv_document
        application            = iv_application
        parameter              = iv_parameter
        default_directory      = iv_default_directory
        maximized              = iv_maximized
        minimized              = iv_minimized
        synchronous            = iv_synchronous
        operation              = iv_operation
      EXCEPTIONS
        cntl_error             = 1
        error_no_gui           = 2
        bad_parameter          = 3
        file_not_found         = 4
        path_not_found         = 5
        file_extension_unknown = 6
        error_execute_failed   = 7
        synchronous_failed     = 8
        not_supported_by_gui   = 9
        OTHERS                 = 10 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~file_download.

    TYPES ty_hex TYPE x LENGTH 200.
    DATA lt_rawdata TYPE STANDARD TABLE OF ty_hex WITH DEFAULT KEY.

    zcl_abapgit_convert=>xstring_to_bintab(
      EXPORTING iv_xstr   = iv_xstr
      IMPORTING et_bintab = lt_rawdata ).

    cl_gui_frontend_services=>gui_download(
      EXPORTING
        bin_filesize              = xstrlen( iv_xstr )
        filename                  = iv_path
        filetype                  = 'BIN'
      CHANGING
        data_tab                  = lt_rawdata
      EXCEPTIONS
        file_write_error          = 1
        no_batch                  = 2
        gui_refuse_filetransfer   = 3
        invalid_type              = 4
        no_authority              = 5
        unknown_error             = 6
        header_not_allowed        = 7
        separator_not_allowed     = 8
        filesize_not_allowed      = 9
        header_too_long           = 10
        dp_error_create           = 11
        dp_error_send             = 12
        dp_error_write            = 13
        unknown_dp_error          = 14
        access_denied             = 15
        dp_out_of_memory          = 16
        disk_full                 = 17
        dp_timeout                = 18
        file_not_found            = 19
        dataprovider_exception    = 20
        control_flush_error       = 21
        not_supported_by_gui      = 22
        error_no_gui              = 23
        OTHERS                    = 24 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~file_upload.

    TYPES: ty_hex TYPE x LENGTH 255.

    DATA: lt_data   TYPE TABLE OF ty_hex WITH DEFAULT KEY,
          lv_length TYPE i.

    cl_gui_frontend_services=>gui_upload(
      EXPORTING
        filename                = iv_path
        filetype                = 'BIN'
      IMPORTING
        filelength              = lv_length
      CHANGING
        data_tab                = lt_data
      EXCEPTIONS
        file_open_error         = 1
        file_read_error         = 2
        no_batch                = 3
        gui_refuse_filetransfer = 4
        invalid_type            = 5
        no_authority            = 6
        unknown_error           = 7
        bad_data_format         = 8
        header_not_allowed      = 9
        separator_not_allowed   = 10
        header_too_long         = 11
        unknown_dp_error        = 12
        access_denied           = 13
        dp_out_of_memory        = 14
        disk_full               = 15
        dp_timeout              = 16
        not_supported_by_gui    = 17
        error_no_gui            = 18
        OTHERS                  = 19 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    CONCATENATE LINES OF lt_data INTO rv_xstr IN BYTE MODE.
    rv_xstr = rv_xstr(lv_length).

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~get_file_separator.

    cl_gui_frontend_services=>get_file_separator(
      CHANGING
        file_separator       = cv_file_separator
      EXCEPTIONS
        not_supported_by_gui = 1
        error_no_gui         = 2
        cntl_error           = 3
        OTHERS               = 4 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~get_gui_version.

    DATA:
      lt_version_table TYPE filetable,
      lv_rc            TYPE i,
      ls_version       LIKE LINE OF lt_version_table.

    cl_gui_frontend_services=>get_gui_version(
      CHANGING
        version_table            = lt_version_table
        rc                       = lv_rc
      EXCEPTIONS
        get_gui_version_failed   = 1
        cant_write_version_table = 2
        gui_no_version           = 3
        cntl_error               = 4
        error_no_gui             = 5
        not_supported_by_gui     = 6
        OTHERS                   = 7 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    READ TABLE lt_version_table INTO ls_version INDEX 1. " gui release
    ev_gui_release = ls_version-filename.
    READ TABLE lt_version_table INTO ls_version INDEX 2. " gui sp
    ev_gui_sp = ls_version-filename.
    READ TABLE lt_version_table INTO ls_version INDEX 3. " gui patch
    ev_gui_patch = ls_version-filename.

    ev_gui_version_string = |{ ev_gui_release }.{ condense( ev_gui_sp ) }.{ condense( ev_gui_patch ) }|.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~get_system_directory.

    cl_gui_frontend_services=>get_system_directory(
      CHANGING
        system_directory     = cv_system_directory
      EXCEPTIONS
        cntl_error           = 1
        error_no_gui         = 2
        not_supported_by_gui = 3
        OTHERS               = 4 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~gui_is_available.

    TRY.
        CALL FUNCTION 'GUI_IS_AVAILABLE'
          IMPORTING
            return = rv_gui_is_available.
      CATCH cx_sy_dyn_call_illegal_func.
* when running on open-abap
        RETURN.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~is_sapgui_for_java.

    TRY.
        CALL FUNCTION 'GUI_HAS_JAVABEANS'
          IMPORTING
            return = rv_result.
      CATCH cx_sy_dyn_call_illegal_func.
* when running on open-abap
        RETURN.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~is_sapgui_for_windows.

    TRY.
        CALL FUNCTION 'GUI_HAS_ACTIVEX'
          IMPORTING
            return = rv_result.
      CATCH cx_sy_dyn_call_illegal_func.
* when running on open-abap
        RETURN.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~is_webgui.

    TRY.
        CALL FUNCTION 'GUI_IS_ITS'
          IMPORTING
            return = rv_is_webgui.
      CATCH cx_sy_dyn_call_illegal_func.
* when running on open-abap
        RETURN.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~open_ie_devtools.

    DATA: lv_system_directory TYPE string,
          lv_exe_full_path    TYPE string.

    IF zif_abapgit_frontend_services~is_sapgui_for_windows( ) = abap_false.
      zcx_abapgit_exception=>raise( |IE DevTools not supported on frontend OS| ).
    ENDIF.

    zif_abapgit_frontend_services~get_system_directory( CHANGING cv_system_directory = lv_system_directory ).

    cl_gui_cfw=>flush( ).

    lv_exe_full_path = lv_system_directory && `\F12\IEChooser.exe`.

    zif_abapgit_frontend_services~execute( iv_application = lv_exe_full_path ).

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~show_file_open_dialog.

    DATA:
      lt_file_table TYPE filetable,
      ls_file_table LIKE LINE OF lt_file_table,
      lv_filter     TYPE string,
      lv_action     TYPE i,
      lv_rc         TYPE i.

    IF iv_extension = 'zip'.
      lv_filter = 'ZIP Files (*.zip)|*.zip|' && cl_gui_frontend_services=>filetype_all.
    ENDIF.

    cl_gui_frontend_services=>file_open_dialog(
      EXPORTING
        window_title            = iv_title
        default_filename        = iv_default_filename
        file_filter             = lv_filter
        initial_directory       = gv_initial_folder
      CHANGING
        file_table              = lt_file_table
        rc                      = lv_rc
        user_action             = lv_action
      EXCEPTIONS
        file_open_dialog_failed = 1
        cntl_error              = 2
        error_no_gui            = 3
        not_supported_by_gui    = 4
        OTHERS                  = 5 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.
    IF lv_action = cl_gui_frontend_services=>action_cancel.
      zcx_abapgit_exception=>raise( 'Cancelled' ).
    ENDIF.

    READ TABLE lt_file_table INDEX 1 INTO ls_file_table.
    ASSERT sy-subrc = 0.
    rv_path = ls_file_table-filename.

    gv_initial_folder = get_path_from_fullname( rv_path ).

  ENDMETHOD.

  METHOD zif_abapgit_frontend_services~show_file_save_dialog.

    DATA:
      lv_action   TYPE i,
      lv_filter   TYPE string,
      lv_filename TYPE string,
      lv_path     TYPE string.

    IF iv_extension = 'zip'.
      lv_filter = 'ZIP Files (*.zip)|*.zip|' && cl_gui_frontend_services=>filetype_all.
    ENDIF.

    cl_gui_frontend_services=>file_save_dialog(
      EXPORTING
        window_title         = iv_title
        default_extension    = iv_extension
        default_file_name    = iv_default_filename
        file_filter          = lv_filter
        initial_directory    = gv_initial_folder
      CHANGING
        filename             = lv_filename
        path                 = lv_path
        fullpath             = rv_path
        user_action          = lv_action
      EXCEPTIONS
        cntl_error           = 1
        error_no_gui         = 2
        not_supported_by_gui = 3
        OTHERS               = 4 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.
    IF lv_action = cl_gui_frontend_services=>action_cancel.
      zcx_abapgit_exception=>raise( 'Cancelled' ).
    ENDIF.

    gv_initial_folder = lv_path.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_function_module IMPLEMENTATION.

  METHOD zif_abapgit_function_module~function_exists.

    DATA lv_function_module_name TYPE c LENGTH 30.
    DATA lv_exists TYPE string.

    lv_function_module_name = iv_function_module_name.
    lv_exists = 'FUNCTION_EXISTS'.

    TRY.
        CALL FUNCTION lv_exists
          EXPORTING
            funcname           = lv_function_module_name
          EXCEPTIONS
            function_not_exist = 1
            OTHERS             = 2.
        rv_exists = boolc( sy-subrc = 0 ).
      CATCH cx_sy_dyn_call_illegal_func.
* then its running in ABAP Cloud Programming Model, assume nothing is released
* I could not find any way to check for this -Hvam
        rv_exists = abap_false.
    ENDTRY.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_gui_jumper IMPLEMENTATION.

  METHOD jump_bw.

    DATA:
      lv_exit  TYPE abap_bool,
      lv_tlogo TYPE c LENGTH 4, "rstlogo
      lv_objnm TYPE c LENGTH 40. "rsawbnobjnm

    lv_tlogo = is_item-obj_type.
    lv_objnm = is_item-obj_name.

    TRY.
        CALL METHOD ('CL_RSAWBN_AWB')=>('IS_SUPPORTED_NAVIGATION')
          EXPORTING
            i_tlogo               = lv_tlogo
            i_fcode               = 'DISPLAY'
          IMPORTING
            re_is_supported_fcode = lv_exit.

        IF lv_exit = abap_false.
          RETURN.
        ENDIF.
      CATCH cx_root.
        " Not a BW system
        RETURN.
    ENDTRY.

    TRY.
        CALL METHOD ('CL_RSAWBN_AWB')=>('NAVIGATE_FROM_APPLICATION')
          EXPORTING
            i_tlogo                = lv_tlogo
            i_objnm                = lv_objnm
            i_new_mode             = iv_new_window
          IMPORTING
            e_exit_own_application = lv_exit.

      CATCH cx_root.
        " Older release without i_new_mode
        CALL METHOD ('CL_RSAWBN_AWB')=>('NAVIGATE_FROM_APPLICATION')
          EXPORTING
            i_tlogo                = lv_tlogo
            i_objnm                = lv_objnm
          IMPORTING
            e_exit_own_application = lv_exit.
    ENDTRY.

    rv_exit = lv_exit.

  ENDMETHOD.

  METHOD jump_tr.

    DATA:
      lv_e071_object   TYPE e071-object,
      lv_e071_obj_name TYPE e071-obj_name.

    lv_e071_object   = is_item-obj_type.
    lv_e071_obj_name = is_item-obj_name.

    CALL FUNCTION 'TR_OBJECT_JUMP_TO_TOOL'
      EXPORTING
        iv_action         = 'SHOW'
        iv_pgmid          = 'R3TR'
        iv_object         = lv_e071_object
        iv_obj_name       = lv_e071_obj_name
      EXCEPTIONS
        jump_not_possible = 1
        OTHERS            = 2.

    rv_exit = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD jump_wb.

    CALL FUNCTION 'RS_TOOL_ACCESS'
      EXPORTING
        operation           = 'SHOW'
        object_name         = is_item-obj_name
        object_type         = is_item-obj_type
        devclass            = is_item-devclass
        in_new_window       = iv_new_window
      EXCEPTIONS
        not_executed        = 1
        invalid_object_type = 2
        OTHERS              = 3.

    rv_exit = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD jump_wb_line.

    IF iv_line_number IS NOT INITIAL AND iv_sub_obj_type IS NOT INITIAL AND iv_sub_obj_name IS NOT INITIAL.

      " For the line navigation we have to supply the sub object type (iv_sub_obj_type).
      " If we use is_item-obj_type it navigates only to the object.
      CALL FUNCTION 'RS_TOOL_ACCESS'
        EXPORTING
          operation           = 'SHOW'
          object_name         = is_item-obj_name
          object_type         = iv_sub_obj_type
          devclass            = is_item-devclass
          include             = iv_sub_obj_name
          position            = iv_line_number
          in_new_window       = iv_new_window
        EXCEPTIONS
          not_executed        = 1
          invalid_object_type = 2
          OTHERS              = 3.

      rv_exit = boolc( sy-subrc = 0 ).

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_gui_jumper~jump.

    " WebGUI cannot open windows or ADT
    IF zcl_abapinst_factory=>get_frontend_services( )->is_webgui( ) = abap_true.
      zcx_abapgit_exception=>raise( |Jump not possible in WebGUI| ).
    ENDIF.

    " Try all generic jump options

    " 1) ADT Jump
    rv_exit = zif_abapgit_gui_jumper~jump_adt(
      is_item         = is_item
      iv_sub_obj_name = is_sub_item-obj_name
      iv_line_number  = iv_line_number ).

    IF rv_exit = abap_true.
      RETURN.
    ENDIF.

    " 2) WB Jump with Line Number
    rv_exit = jump_wb_line(
      is_item         = is_item
      iv_sub_obj_name = is_sub_item-obj_name
      iv_sub_obj_type = is_sub_item-obj_type
      iv_line_number  = iv_line_number
      iv_new_window   = iv_new_window ).

    IF rv_exit = abap_true.
      RETURN.
    ENDIF.

    " 3) WB Jump without Line Number
    rv_exit = jump_wb(
      is_item       = is_item
      iv_new_window = iv_new_window ).

    IF rv_exit = abap_true.
      RETURN.
    ENDIF.

    " 4) Transport Tool Jump
    rv_exit = jump_tr( is_item ).

    IF rv_exit = abap_true.
      RETURN.
    ENDIF.

    " 5) BW Jump
    rv_exit = jump_bw(
      is_item       = is_item
      iv_new_window = iv_new_window ).

  ENDMETHOD.

  METHOD zif_abapgit_gui_jumper~jump_abapgit.

    DATA lt_spagpa        TYPE STANDARD TABLE OF rfc_spagpa.
    DATA ls_spagpa        LIKE LINE OF lt_spagpa.
    DATA lv_save_sy_langu TYPE sy-langu.
    DATA lv_subrc         TYPE syst-subrc.
    DATA lv_tcode         TYPE tcode.
    DATA lv_langu_text    TYPE string.
    DATA lv_msg           TYPE c LENGTH 200.

    " https://blogs.sap.com/2017/01/13/logon-language-sy-langu-and-rfc/

    lv_tcode = zcl_abapgit_services_abapgit=>get_abapgit_tcode( ).

    lv_save_sy_langu = sy-langu.
    SET LOCALE LANGUAGE iv_language.

    ls_spagpa-parid  = zif_abapgit_definitions=>c_spagpa_param_repo_key.
    ls_spagpa-parval = iv_key.
    INSERT ls_spagpa INTO TABLE lt_spagpa.

    CALL FUNCTION 'ABAP4_CALL_TRANSACTION'
      DESTINATION 'NONE'
      STARTING NEW TASK 'ABAPGIT'
      EXPORTING
        tcode                 = lv_tcode
      TABLES
        spagpa_tab            = lt_spagpa
      EXCEPTIONS
        communication_failure = 1 MESSAGE lv_msg
        system_failure        = 2 MESSAGE lv_msg
        resource_failure      = 3
        OTHERS                = 4.

    lv_subrc = sy-subrc.

    SET LOCALE LANGUAGE lv_save_sy_langu.

    CASE lv_subrc.
      WHEN 1.
        lv_msg = |Communication error { lv_msg }|.
      WHEN 2.
        SELECT SINGLE sptxt FROM t002t INTO lv_langu_text WHERE spras = sy-langu AND sprsl = iv_language.
        IF sy-subrc <> 0.
          lv_langu_text = iv_language.
        ENDIF.
        lv_msg = |Language { lv_langu_text } ({ zcl_abapgit_convert=>language_sap1_to_sap2( iv_language ) })|
              && | is not installed|.
      WHEN 3.
        lv_msg = |{ lv_subrc }|.
    ENDCASE.

    IF lv_msg IS INITIAL.
      MESSAGE 'Repository opened in a new window' TYPE 'S'.
    ELSE.
      zcx_abapgit_exception=>raise( |Error starting transaction { lv_tcode }: { lv_msg }| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_gui_jumper~jump_adt.

    " Open object in ADT (if enabled)

    DATA lv_adt_jump_enabled TYPE abap_bool.

    lv_adt_jump_enabled = zcl_abapgit_persist_factory=>get_settings( )->read( )->get_adt_jump_enabled( ).

    IF lv_adt_jump_enabled = abap_true.
      TRY.
          zcl_abapgit_adt_link=>jump(
            iv_obj_name     = is_item-obj_name
            iv_obj_type     = is_item-obj_type
            iv_sub_obj_name = iv_sub_obj_name
            iv_line_number  = iv_line_number ).

          rv_exit = abap_true.
        CATCH zcx_abapgit_exception ##NO_HANDLER.
          " Use fallback
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_gui_jumper~jump_batch_input.

    DATA lv_msg TYPE c LENGTH 80.

    IF iv_new_window = abap_true.
      CALL FUNCTION 'ABAP4_CALL_TRANSACTION'
        STARTING NEW TASK 'GIT'
        EXPORTING
          tcode                 = iv_tcode
          mode_val              = 'E'
        TABLES
          using_tab             = it_bdcdata
        EXCEPTIONS
          system_failure        = 1 MESSAGE lv_msg
          communication_failure = 2 MESSAGE lv_msg
          resource_failure      = 3
          OTHERS                = 4.
    ELSE.
      CALL FUNCTION 'ABAP4_CALL_TRANSACTION'
        EXPORTING
          tcode     = iv_tcode
          mode_val  = 'E'
        TABLES
          using_tab = it_bdcdata
        EXCEPTIONS
          OTHERS    = 4.
    ENDIF.

    CASE sy-subrc.
      WHEN 1 OR 2.
        zcx_abapgit_exception=>raise( |Batch input error for transaction { iv_tcode }: { lv_msg }| ).
      WHEN 3 OR 4.
        zcx_abapgit_exception=>raise( |Batch input error for transaction { iv_tcode }| ).
    ENDCASE.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_hash IMPLEMENTATION.

  METHOD adler32.

    CONSTANTS: lc_adler TYPE i VALUE 65521,
               lc_max_b TYPE i VALUE 1800000000.

    DATA: lv_index TYPE i,
          lv_a     TYPE i VALUE 1,
          lv_b     TYPE i VALUE 0,
          lv_x     TYPE x LENGTH 2,
          lv_ca    TYPE c LENGTH 4,
          lv_cb    TYPE c LENGTH 4,
          lv_char8 TYPE c LENGTH 8.

    DO xstrlen( iv_xstring ) TIMES.
      lv_index = sy-index - 1.

      lv_a = lv_a + iv_xstring+lv_index(1).
      lv_b = lv_b + lv_a.

* delay the MOD operation until the integer might overflow
* articles describe 5552 additions are allowed, but this assumes unsigned integers
* instead of allowing a fixed number of additions before running MOD, then
* just compare value of lv_b, this is 1 operation less than comparing and adding
      IF lv_b > lc_max_b.
        lv_a = lv_a MOD lc_adler.
        lv_b = lv_b MOD lc_adler.
      ENDIF.
    ENDDO.

    lv_a = lv_a MOD lc_adler.
    lv_b = lv_b MOD lc_adler.

    lv_x = lv_a.
    lv_ca = lv_x.

    lv_x = lv_b.
    lv_cb = lv_x.

    CONCATENATE lv_cb lv_ca INTO lv_char8.

    rv_checksum = lv_char8.

  ENDMETHOD.

  METHOD sha1.

    DATA: lv_len     TYPE i,
          lv_char10  TYPE c LENGTH 10,
          lv_string  TYPE string,
          lv_xstring TYPE xstring.

    lv_len = xstrlen( iv_data ).
    lv_char10 = lv_len.
    CONDENSE lv_char10.
    CONCATENATE iv_type lv_char10 INTO lv_string SEPARATED BY space.
    lv_xstring = zcl_abapgit_convert=>string_to_xstring_utf8( lv_string ).

    lv_string = lv_xstring.
    CONCATENATE lv_string '00' INTO lv_string.
    lv_xstring = lv_string.

    CONCATENATE lv_xstring iv_data INTO lv_xstring IN BYTE MODE.

    rv_sha1 = sha1_raw( lv_xstring ).

  ENDMETHOD.

  METHOD sha1_blob.
    rv_sha1 = sha1( iv_type = zif_abapgit_git_definitions=>c_type-blob
                    iv_data = iv_data ).
  ENDMETHOD.

  METHOD sha1_commit.
    rv_sha1 = sha1( iv_type = zif_abapgit_git_definitions=>c_type-commit
                    iv_data = iv_data ).
  ENDMETHOD.

  METHOD sha1_raw.

    DATA: lv_hash  TYPE string,
          lv_key   TYPE xstring,
          lx_error TYPE REF TO cx_abap_message_digest.
    TRY.
        cl_abap_hmac=>calculate_hmac_for_raw(
      EXPORTING
        if_key        = lv_key
        if_data       = iv_data
      IMPORTING
        ef_hmacstring = lv_hash ).
      CATCH cx_abap_message_digest INTO lx_error.
        zcx_abapgit_exception=>raise_with_text( lx_error ).
    ENDTRY.

    rv_sha1 = lv_hash.
    TRANSLATE rv_sha1 TO LOWER CASE.

  ENDMETHOD.

  METHOD sha1_string.

    DATA: lv_hash  TYPE string,
          lv_key   TYPE xstring,
          lx_error TYPE REF TO cx_abap_message_digest.
    TRY.
        cl_abap_hmac=>calculate_hmac_for_char(
      EXPORTING
        if_key        = lv_key
        if_data       = iv_data
      IMPORTING
        ef_hmacstring = lv_hash ).
      CATCH cx_abap_message_digest INTO lx_error.
        zcx_abapgit_exception=>raise_with_text( lx_error ).
    ENDTRY.

    rv_sha1 = lv_hash.
    TRANSLATE rv_sha1 TO LOWER CASE.

  ENDMETHOD.

  METHOD sha1_tag.
    rv_sha1 = sha1( iv_type = zif_abapgit_git_definitions=>c_type-tag
                    iv_data = iv_data ).
  ENDMETHOD.

  METHOD sha1_tree.
    rv_sha1 = sha1( iv_type = zif_abapgit_git_definitions=>c_type-tree
                    iv_data = iv_data ).
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_i18n_params IMPLEMENTATION.

  METHOD build_language_filter.
    IF mt_language_filter IS INITIAL.
      " translation_languages are includes, system langs are excludes, so the do not interfere
      IF ms_params-translation_languages IS NOT INITIAL.
        mt_language_filter = iso_langs_to_lang_filter( ms_params-translation_languages ).
      ELSE.
        mt_language_filter = zcl_abapinst_factory=>get_environment( )->get_system_language_filter( ).
      ENDIF.
    ENDIF.
    rt_language_filter = mt_language_filter.
  ENDMETHOD.

  METHOD constructor.
    IF is_params IS NOT INITIAL.
      ms_params = is_params.
    ELSE.
      ms_params-main_language         = iv_main_language.
      ms_params-main_language_only    = iv_main_language_only.
      ms_params-translation_languages = it_translation_langs.
      ms_params-use_lxe               = iv_use_lxe.
    ENDIF.
    ASSERT ms_params-main_language IS NOT INITIAL.
  ENDMETHOD.

  METHOD iso_langs_to_lang_filter.

    DATA lv_laiso LIKE LINE OF it_iso_filter.
    DATA lv_langu TYPE sy-langu.
    DATA ls_range LIKE LINE OF rt_language_filter.

    ls_range-sign = 'I'.
    ls_range-option = 'EQ'.

    LOOP AT it_iso_filter INTO lv_laiso.

      zcl_abapgit_convert=>language_sap2_to_sap1(
        EXPORTING
          im_lang_sap2  = lv_laiso
        RECEIVING
          re_lang_sap1  = lv_langu
        EXCEPTIONS
          no_assignment = 1
          OTHERS        = 2 ).
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

      ls_range-low = lv_langu.
      APPEND ls_range TO rt_language_filter.

    ENDLOOP.

  ENDMETHOD.

  METHOD is_lxe_applicable.

    rv_yes = boolc( ms_params-main_language_only = abap_false AND
       ms_params-use_lxe = abap_true AND
       ms_params-translation_languages IS NOT INITIAL ).

  ENDMETHOD.

  METHOD new.
    CREATE OBJECT ro_instance
      EXPORTING
        iv_main_language      = iv_main_language
        iv_main_language_only = iv_main_language_only
        it_translation_langs  = it_translation_langs
        iv_use_lxe            = iv_use_lxe
        is_params             = is_params.
  ENDMETHOD.

  METHOD trim_saplang_keyed_table.

    DATA lv_laiso TYPE laiso.
    DATA lv_index TYPE i.

    FIELD-SYMBOLS <ls_i> TYPE any.
    FIELD-SYMBOLS <lv_langu> TYPE sy-langu.

    IF ms_params-translation_languages IS INITIAL OR iv_lang_field_name IS INITIAL.
      RETURN. " Nothing to filter
    ENDIF.

    LOOP AT ct_tab ASSIGNING <ls_i>.
      lv_index = sy-tabix.
      ASSIGN COMPONENT iv_lang_field_name OF STRUCTURE <ls_i> TO <lv_langu>.
      ASSERT sy-subrc = 0.

      IF iv_keep_master_lang = abap_true AND <lv_langu> = ms_params-main_language.
        CONTINUE. " Just keep it
      ENDIF.

      zcl_abapgit_convert=>language_sap1_to_sap2(
        EXPORTING
          im_lang_sap1  = <lv_langu>
        RECEIVING
          re_lang_sap2  = lv_laiso
        EXCEPTIONS
          no_assignment = 1
          OTHERS        = 2 ).
      IF sy-subrc <> 0.
        DELETE ct_tab INDEX lv_index. " Not in the list anyway ...
        CONTINUE.
      ENDIF.

      " Not a sorted table, but presumably the list is small, so no significant performance flow
      READ TABLE ms_params-translation_languages TRANSPORTING NO FIELDS WITH KEY table_line = lv_laiso.
      IF sy-subrc <> 0.
        DELETE ct_tab INDEX lv_index.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD trim_saplang_list.

    DATA lv_langu TYPE sy-langu.
    DATA lv_laiso TYPE laiso.
    DATA lv_index TYPE i.

    IF ms_params-translation_languages IS INITIAL.
      RETURN. " Nothing to filter
    ENDIF.

    LOOP AT ct_sap_langs INTO lv_langu.
      lv_index = sy-tabix.

      zcl_abapgit_convert=>language_sap1_to_sap2(
        EXPORTING
          im_lang_sap1  = lv_langu
        RECEIVING
          re_lang_sap2  = lv_laiso
        EXCEPTIONS
          no_assignment = 1
          OTHERS        = 2 ).
      IF sy-subrc <> 0.
        DELETE ct_sap_langs INDEX lv_index. " Not in the list anyway ...
        CONTINUE.
      ENDIF.

      " Not a sorted table, but presumably the list is small, so no significant performance flow
      READ TABLE ms_params-translation_languages TRANSPORTING NO FIELDS WITH KEY table_line = lv_laiso.
      IF sy-subrc <> 0.
        DELETE ct_sap_langs INDEX lv_index.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_ITEM_GRAPH IMPLEMENTATION.

  METHOD add_edge.
    DATA ls_edge LIKE LINE OF mt_edges.
    ASSERT is_from IS NOT INITIAL.
    ASSERT is_to IS NOT INITIAL.
    ls_edge-from = is_from.
    ls_edge-to   = is_to.
    APPEND ls_edge TO mt_edges.
  ENDMETHOD.

  METHOD constructor.
    INSERT LINES OF it_items INTO TABLE mt_vertices.
  ENDMETHOD.

  METHOD get_next.
* find a vertex with no inbound edges, if it does not exist pick anything

    DATA ls_vertex LIKE LINE OF mt_vertices.
    DATA lv_index  TYPE i.

    LOOP AT mt_vertices INTO ls_vertex.
      lv_index = sy-tabix.
      READ TABLE mt_edges WITH KEY sec_to COMPONENTS
        to-obj_type = ls_vertex-obj_type
        to-obj_name = ls_vertex-obj_name
        TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        remove_vertex( lv_index ).
        rs_item = ls_vertex.
        RETURN.
      ENDIF.
    ENDLOOP.

    IF mv_warning = abap_false.
* only issue the warning once per graph
      ii_log->add_warning( |Cycle detected in item graph| ).
      mv_warning = abap_true.
    ENDIF.

    READ TABLE mt_vertices INTO rs_item INDEX 1.
    ASSERT sy-subrc = 0.
    remove_vertex( 1 ).

  ENDMETHOD.

  METHOD has_vertices.
    rv_bool = boolc( lines( mt_vertices ) > 0 ).
  ENDMETHOD.

  METHOD remove_vertex.
    DATA ls_vertex LIKE LINE OF mt_vertices.

    READ TABLE mt_vertices INDEX iv_index INTO ls_vertex.
    ASSERT sy-subrc = 0.

    DELETE mt_vertices INDEX iv_index.
    DELETE mt_edges USING KEY sec_from
      WHERE from-obj_type = ls_vertex-obj_type
      AND from-obj_name = ls_vertex-obj_name.

  ENDMETHOD.
ENDCLASS.

*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations

CLASS lcl_json_path DEFINITION CREATE PUBLIC.

  PUBLIC SECTION.
    METHODS:
      serialize_rec
        IMPORTING io_reader     TYPE REF TO if_sxml_reader
                  it_path       TYPE string_table
        CHANGING  ct_json_paths TYPE string_table.

    CLASS-METHODS: deserialize
      IMPORTING it_json_path     TYPE string_table
      RETURNING VALUE(rv_result) TYPE string
      RAISING   zcx_abapgit_exception.

  PROTECTED SECTION.
  PRIVATE SECTION.

    METHODS:
      is_array
        IMPORTING io_reader        TYPE REF TO if_sxml_reader
        RETURNING VALUE(rv_result) TYPE abap_bool.
    METHODS:
      is_string_open
        IMPORTING io_reader        TYPE REF TO if_sxml_reader
        RETURNING VALUE(rv_result) TYPE abap_bool.
    METHODS:
      is_object
        IMPORTING io_reader        TYPE REF TO if_sxml_reader
        RETURNING VALUE(rv_result) TYPE abap_bool.
    METHODS:
      serialize_rec_array
        IMPORTING io_reader     TYPE REF TO if_sxml_reader
                  it_path       TYPE string_table
        CHANGING  ct_json_paths TYPE string_table.
    METHODS:
      get_json_path
        IMPORTING it_path          TYPE string_table
        RETURNING VALUE(rv_result) TYPE string.
    CLASS-METHODS get_path_elements
      IMPORTING iv_path          TYPE string
      RETURNING VALUE(rt_result) TYPE string_table
      RAISING   zcx_abapgit_exception.
    CLASS-METHODS build_json
      IMPORTING it_path_elements TYPE string_table
                iv_value         TYPE string
      CHANGING  cv_json_string   TYPE string.
    CLASS-METHODS path_contains_array
      IMPORTING iv_path          TYPE string
      RETURNING VALUE(rv_result) TYPE abap_bool.
    CLASS-METHODS: to_json
      IMPORTING iv_json_path     TYPE string
      RETURNING VALUE(ro_result) TYPE REF TO zcl_abapgit_ajson
      RAISING   zcx_abapgit_ajson_error
                zcx_abapgit_exception.
    CLASS-METHODS: is_primitiv
      IMPORTING iv_string        TYPE string
      RETURNING VALUE(rv_result) TYPE abap_bool.
    CLASS-METHODS: is_comment_or_empty_line
      IMPORTING iv_line          TYPE string
      RETURNING VALUE(rv_result) TYPE abap_bool.

ENDCLASS.

CLASS lcl_json_path IMPLEMENTATION.

  METHOD to_json.
    DATA: lv_path          TYPE string,
          lv_value         TYPE string,
          lt_path_elements TYPE string_table,
          lv_json          TYPE string.

    FIND REGEX `(.*)=(.*$)` IN iv_json_path SUBMATCHES lv_path lv_value.

    IF path_contains_array( lv_path ) = abap_true.

      lt_path_elements = get_path_elements( lv_path ).

      build_json( EXPORTING it_path_elements = lt_path_elements
                            iv_value         = lv_value
                  CHANGING  cv_json_string   = lv_json ).

      ro_result = zcl_abapgit_ajson=>parse( lv_json ).
    ELSE.

      REPLACE FIRST OCCURRENCE OF '$.' IN lv_path WITH ''.
      REPLACE '.' IN lv_path WITH '/'.
      ro_result = zcl_abapgit_ajson=>create_empty( iv_keep_item_order = abap_true ).
      ro_result->set( iv_path = lv_path
                      iv_val  = lv_value ).
    ENDIF.

  ENDMETHOD.

  METHOD path_contains_array.
    DATA lv_array_pattern TYPE string VALUE `.*\[.*\].*`.
    rv_result = boolc( matches( val   = iv_path
                                regex = lv_array_pattern ) ).
  ENDMETHOD.

  METHOD build_json.
    DATA: lt_new_path_element TYPE string_table,
          lv_sub_match        TYPE string,
          lv_key_name         TYPE string,
          lv_key_value        TYPE string,
          lv_name             TYPE string,
          lv_first_elem       TYPE string.

    lt_new_path_element = it_path_elements.

    IF lines( lt_new_path_element ) = 0.
      RETURN.
    ENDIF.

    READ TABLE lt_new_path_element INTO lv_first_elem INDEX 1.

    IF lv_first_elem = `$`. " is root level

      DELETE lt_new_path_element INDEX 1.
      build_json( EXPORTING it_path_elements = lt_new_path_element
                            iv_value         = iv_value
                  CHANGING  cv_json_string   = cv_json_string ).

    ELSEIF is_primitiv( lv_first_elem ) = abap_true.

      cv_json_string = cv_json_string && | \{"{ lv_first_elem+1 }": |.

      DELETE lt_new_path_element INDEX 1.

      build_json( EXPORTING it_path_elements = lt_new_path_element
                            iv_value         = iv_value
                  CHANGING  cv_json_string   = cv_json_string ).

      cv_json_string = cv_json_string && ` }`.

    ELSE. " is array

      FIND REGEX `\[(.*)\]` IN lv_first_elem SUBMATCHES lv_sub_match.
      FIND REGEX `(\w+)(?==='([^']*)')` IN lv_sub_match SUBMATCHES lv_key_name lv_key_value.
      READ TABLE lt_new_path_element INTO lv_name INDEX 2.

      DELETE lt_new_path_element INDEX 1.
      DELETE lt_new_path_element INDEX 1.

      IF lines( lt_new_path_element ) = 0.

        cv_json_string = cv_json_string &&
          |[ \{ "{ lv_key_name }": "{ lv_key_value }", "{ lv_name+1 }": "{ iv_value }"\} ]|.

      ELSE.

        cv_json_string = cv_json_string && |[ \{ "{ lv_key_name }": "{ lv_key_value }", "{ lv_name+1 }":|.

        build_json( EXPORTING it_path_elements = lt_new_path_element
                              iv_value         = iv_value
                    CHANGING  cv_json_string   = cv_json_string ).

        cv_json_string = cv_json_string && `} ] `.

      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD is_primitiv.

    FIND REGEX `^.\w+` IN iv_string. " string start with .
    rv_result = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD get_path_elements.
    DATA: lv_pcre_pattern TYPE string,
          lt_match_result TYPE match_result_tab,
          lv_match        TYPE match_result,
          lv_hit          TYPE string,
          lx_find         TYPE REF TO cx_root.

    lv_pcre_pattern = `(^\$)|(\.\w+)|(\[[^\]]*\])`.

    TRY.
        FIND ALL OCCURRENCES OF REGEX lv_pcre_pattern IN iv_path RESULTS lt_match_result.
      CATCH cx_sy_find_infinite_loop cx_sy_range_out_of_bounds cx_sy_invalid_regex cx_sy_regex_too_complex INTO lx_find.
        zcx_abapgit_exception=>raise_with_text( lx_find ).
    ENDTRY.
    LOOP AT lt_match_result INTO lv_match.
      lv_hit = substring( val = iv_path
                          off = lv_match-offset
                          len = lv_match-length ).
      APPEND lv_hit TO rt_result.
    ENDLOOP.

  ENDMETHOD.

  METHOD is_array.
    rv_result = boolc( io_reader->name = 'array' ).
  ENDMETHOD.

  METHOD is_string_open.
    rv_result = boolc( io_reader->name = 'str' AND io_reader->node_type = if_sxml_node=>co_nt_element_open ).
  ENDMETHOD.

  METHOD is_object.
    rv_result = boolc( io_reader->name = 'object' ).
  ENDMETHOD.

  METHOD serialize_rec.
    DATA: lt_new_path TYPE string_table,
          lv_key      TYPE string.

    lt_new_path = it_path.

    IF io_reader->read_next_node( ) IS INITIAL.
      RETURN.
    ENDIF.

    IF is_string_open( io_reader ) = abap_true.

      APPEND io_reader->value TO lt_new_path.
      lv_key = get_json_path( lt_new_path ).

      io_reader->read_next_node( ).
      lv_key = |{ lv_key }={ io_reader->value }|.
      APPEND lv_key TO ct_json_paths.

      io_reader->read_next_node( ).
      DELETE lt_new_path INDEX lines( lt_new_path ).

      serialize_rec( EXPORTING io_reader     = io_reader
                               it_path       = lt_new_path
                     CHANGING  ct_json_paths = ct_json_paths ).

    ELSEIF is_object( io_reader ) = abap_true AND io_reader->node_type = if_sxml_node=>co_nt_element_open.

      APPEND io_reader->value TO lt_new_path.
      serialize_rec( EXPORTING io_reader     = io_reader
                               it_path       = lt_new_path
                     CHANGING  ct_json_paths = ct_json_paths ).

    ELSEIF is_array( io_reader ) = abap_true AND io_reader->node_type = if_sxml_node=>co_nt_element_open.

      APPEND io_reader->value TO lt_new_path.
      serialize_rec_array( EXPORTING io_reader     = io_reader
                                     it_path       = lt_new_path
                           CHANGING  ct_json_paths = ct_json_paths ).

    ELSEIF ( is_object( io_reader ) = abap_true OR is_array( io_reader ) = abap_true )
             AND io_reader->node_type = if_sxml_node=>co_nt_element_close.

      DELETE lt_new_path INDEX lines( lt_new_path ).
      serialize_rec( EXPORTING io_reader     = io_reader
                               it_path       = lt_new_path
                     CHANGING  ct_json_paths = ct_json_paths ).

    ENDIF.

  ENDMETHOD.

  METHOD serialize_rec_array.
    DATA: lt_new_path  TYPE string_table,
          lv_json_path TYPE string,
          lv_array_key TYPE string.

    lt_new_path = it_path.

    IF io_reader->read_next_node( ) IS INITIAL.
      RETURN.
    ENDIF.

    IF is_string_open( io_reader ) = abap_true.

      APPEND io_reader->value TO lt_new_path.
      lv_json_path = get_json_path( lt_new_path ).

      io_reader->read_next_node( ).
      lv_json_path = |{ lv_json_path }={ io_reader->value }|.
      APPEND lv_json_path TO ct_json_paths.
      io_reader->read_next_node( ).

      serialize_rec( EXPORTING io_reader     = io_reader
                               it_path       = lt_new_path
                     CHANGING  ct_json_paths = ct_json_paths ).

    ELSEIF is_object( io_reader ) = abap_true AND io_reader->node_type = if_sxml_node=>co_nt_element_open.

      io_reader->read_next_node( ).
      lv_array_key = io_reader->value.
      io_reader->read_next_node( ).
      lv_array_key = |[?(@.{ lv_array_key }=='{ io_reader->value }')]|.
      APPEND lv_array_key TO lt_new_path.
      io_reader->read_next_node( ).

      io_reader->read_next_node( ).
      APPEND io_reader->value TO lt_new_path.
      lv_json_path = get_json_path( lt_new_path ).

      io_reader->read_next_node( ).
      lv_json_path = |{ lv_json_path }={ io_reader->value }|.
      APPEND lv_json_path TO ct_json_paths.
      io_reader->read_next_node( ).

      DELETE lt_new_path INDEX lines( lt_new_path ).
      serialize_rec_array( EXPORTING io_reader     = io_reader
                                     it_path       = lt_new_path
                           CHANGING  ct_json_paths = ct_json_paths ).

    ELSEIF is_array( io_reader ) = abap_true AND io_reader->node_type = if_sxml_node=>co_nt_element_open.

      APPEND io_reader->value TO lt_new_path.
      serialize_rec_array( EXPORTING io_reader     = io_reader
                                     it_path       = lt_new_path
                           CHANGING  ct_json_paths = ct_json_paths ).

    ELSEIF ( is_object( io_reader ) = abap_true OR is_array( io_reader ) = abap_true )
             AND io_reader->node_type = if_sxml_node=>co_nt_element_close.

      DELETE lt_new_path INDEX lines( lt_new_path ).
      serialize_rec_array( EXPORTING io_reader     = io_reader
                                     it_path       = lt_new_path
                           CHANGING  ct_json_paths = ct_json_paths ).

    ENDIF.

  ENDMETHOD.

  METHOD get_json_path.
    rv_result = concat_lines_of( table = it_path
                                 sep   = `.` ).
    REPLACE ALL OCCURRENCES OF `.[` IN rv_result WITH `[`.

  ENDMETHOD.

  METHOD deserialize.

    DATA: lo_merged                 TYPE REF TO zif_abapgit_ajson,
          lv_json_path              TYPE string,
          lo_deserialization_result TYPE REF TO zif_abapgit_ajson,
          lx_ajson                  TYPE REF TO zcx_abapgit_ajson_error.

    TRY.
        lo_merged = zcl_abapgit_ajson=>parse( `` ).
      CATCH zcx_abapgit_ajson_error INTO lx_ajson.
        zcx_abapgit_exception=>raise_with_text( lx_ajson ).
    ENDTRY.

    LOOP AT it_json_path INTO lv_json_path.
      IF is_comment_or_empty_line( lv_json_path ) = abap_true.
        CONTINUE.
      ENDIF.

      TRY.
          lo_deserialization_result = to_json( lv_json_path ).
        CATCH zcx_abapgit_ajson_error INTO lx_ajson.
          zcx_abapgit_exception=>raise_with_text( lx_ajson ).
      ENDTRY.

      TRY.
          lo_merged = zcl_abapgit_ajson_utilities=>new( )->merge( io_json_a = lo_merged
                                                                  io_json_b = lo_deserialization_result ).
        CATCH zcx_abapgit_ajson_error INTO lx_ajson.
          zcx_abapgit_exception=>raise_with_text( lx_ajson ).
      ENDTRY.

    ENDLOOP.

    TRY.
        rv_result = lo_merged->stringify( 2 ).
      CATCH zcx_abapgit_ajson_error INTO lx_ajson.
        zcx_abapgit_exception=>raise_with_text( lx_ajson ).
    ENDTRY.
  ENDMETHOD.

  METHOD is_comment_or_empty_line.

    IF iv_line IS INITIAL.
      rv_result = abap_true.
      RETURN.
    ENDIF.

    FIND REGEX `^!` IN iv_line.
    IF sy-subrc = 0.
      rv_result = abap_true.
      RETURN.
    ENDIF.

    FIND REGEX `^#` IN iv_line.
    IF sy-subrc = 0.
      rv_result = abap_true.
      RETURN.
    ENDIF.

  ENDMETHOD.

ENDCLASS.

CLASS zcl_abapgit_json_path IMPLEMENTATION.

  METHOD deserialize.

    rv_result = lcl_json_path=>deserialize( it_json_path ).

  ENDMETHOD.

  METHOD serialize.
    DATA: lo_json_path    TYPE REF TO lcl_json_path,
          lv_json_xstring TYPE xstring,
          lt_root_path    TYPE string_table,
          lo_reader       TYPE REF TO if_sxml_reader,
          lx_parse_error  TYPE REF TO cx_sxml_parse_error.

    lv_json_xstring = zcl_abapgit_convert=>string_to_xstring_utf8( iv_json ).
    lo_reader = cl_sxml_string_reader=>create( input = lv_json_xstring ).

    TRY.
        IF lo_reader->read_next_node( ) IS INITIAL.
          RETURN.
        ENDIF.
      CATCH cx_sxml_parse_error INTO lx_parse_error.
        zcx_abapgit_exception=>raise_with_text( lx_parse_error ).
    ENDTRY.

    APPEND `$` TO lt_root_path.

    CREATE OBJECT lo_json_path.
    lo_json_path->serialize_rec( EXPORTING io_reader     = lo_reader
                                           it_path       = lt_root_path
                                 CHANGING  ct_json_paths = rt_result ).
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_language IMPLEMENTATION.

  METHOD class_constructor.

    DATA lv_dummy TYPE string.

    GET LOCALE LANGUAGE gv_login_language COUNTRY lv_dummy MODIFIER lv_dummy.

  ENDMETHOD.

  METHOD restore_login_language.

    SET LOCALE LANGUAGE gv_login_language.

  ENDMETHOD.

  METHOD set_current_language.

    SET LOCALE LANGUAGE iv_language.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_log IMPLEMENTATION.

  METHOD constructor.

    zif_abapgit_log~set_title( iv_title ).

  ENDMETHOD.

  METHOD from_exception.

    CREATE OBJECT ro_log.

    IF io_x IS BOUND.
      ro_log->zif_abapgit_log~add_exception( io_x ).
    ENDIF.

  ENDMETHOD.

  METHOD get_messages_status.

    DATA lr_msg TYPE REF TO zif_abapgit_log=>ty_msg.
    rv_status = 'S'.
    LOOP AT it_msg REFERENCE INTO lr_msg.
      CASE lr_msg->type.
        WHEN 'E' OR 'A' OR 'X'.
          rv_status = 'E'. "not okay
          EXIT.
        WHEN 'W'.
          rv_status = 'W'. "maybe
          CONTINUE.
        WHEN 'S' OR 'I'.
          IF rv_status <> 'W'.
            rv_status = 'S'. "okay
          ENDIF.
          CONTINUE.
        WHEN OTHERS. "unknown
          CONTINUE.
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_log~add.

    FIELD-SYMBOLS: <ls_log> LIKE LINE OF mt_log.

    APPEND INITIAL LINE TO mt_log ASSIGNING <ls_log>.
    <ls_log>-msg-text   = iv_msg.
    <ls_log>-msg-type   = iv_type.
    <ls_log>-msg-id     = iv_class.
    <ls_log>-msg-number = iv_number.
    <ls_log>-item       = is_item.
    <ls_log>-exception  = ix_exc.

    CASE iv_type.
      WHEN 'E' OR 'A' OR 'X'.
        <ls_log>-msg-level = zif_abapgit_log=>c_log_level-error.
      WHEN 'W'.
        <ls_log>-msg-level = zif_abapgit_log=>c_log_level-warning.
      WHEN 'S' OR 'I'.
        <ls_log>-msg-level = zif_abapgit_log=>c_log_level-info.
      WHEN OTHERS. "unknown
        ASSERT 0 = 1.
    ENDCASE.

  ENDMETHOD.

  METHOD zif_abapgit_log~add_error.

    zif_abapgit_log~add(
      iv_msg  = iv_msg
      iv_type = 'E'
      is_item = is_item ).

  ENDMETHOD.

  METHOD zif_abapgit_log~add_exception.

    DATA lx_exc TYPE REF TO cx_root.
    DATA lv_msg TYPE string.
    lx_exc = ix_exc.
    DO.
      lv_msg = lx_exc->get_text( ).
      zif_abapgit_log~add( iv_msg  = lv_msg
                           iv_type = 'E'
                           is_item = is_item
                           ix_exc  = lx_exc ).
      IF lx_exc->previous IS BOUND.
        lx_exc = lx_exc->previous.
      ELSE.
        EXIT.
      ENDIF.
    ENDDO.

  ENDMETHOD.

  METHOD zif_abapgit_log~add_info.

    zif_abapgit_log~add(
      iv_msg  = iv_msg
      iv_type = 'I'
      is_item = is_item ).

  ENDMETHOD.

  METHOD zif_abapgit_log~add_success.

    zif_abapgit_log~add(
      iv_msg  = iv_msg
      iv_type = 'S'
      is_item = is_item ).

  ENDMETHOD.

  METHOD zif_abapgit_log~add_warning.

    zif_abapgit_log~add(
      iv_msg  = iv_msg
      iv_type = 'W'
      is_item = is_item ).

  ENDMETHOD.

  METHOD zif_abapgit_log~clear.
    CLEAR mt_log.
  ENDMETHOD.

  METHOD zif_abapgit_log~clone.

    DATA lo_log TYPE REF TO zcl_abapgit_log.

    CREATE OBJECT lo_log EXPORTING iv_title = mv_title.
    lo_log->mt_log = mt_log.
    ri_log = lo_log.

  ENDMETHOD.

  METHOD zif_abapgit_log~count.
    rv_count = lines( mt_log ).
  ENDMETHOD.

  METHOD zif_abapgit_log~get_item_status.

    DATA lr_log         TYPE REF TO ty_log.
    DATA ls_msg         TYPE zif_abapgit_log=>ty_msg.
    DATA ls_item_status TYPE zif_abapgit_log=>ty_item_status_out.
    DATA lr_item_status TYPE REF TO zif_abapgit_log=>ty_item_status_out.

    "collect all message for all objects
    LOOP AT mt_log REFERENCE INTO lr_log.
      CLEAR ls_item_status.
      ls_item_status-item = lr_log->item.
      READ TABLE rt_item_status REFERENCE INTO lr_item_status
           WITH KEY item-obj_type = ls_item_status-item-obj_type
                    item-obj_name = ls_item_status-item-obj_name.
      IF sy-subrc <> 0.
        INSERT ls_item_status INTO TABLE rt_item_status.
        GET REFERENCE OF ls_item_status INTO lr_item_status.
      ENDIF.
      CLEAR ls_msg.
      ls_msg-type = lr_log->msg-type.
      ls_msg-text = lr_log->msg-text.
      INSERT ls_msg INTO TABLE lr_item_status->messages.
    ENDLOOP.

    "determine object status from object messages
    LOOP AT rt_item_status REFERENCE INTO lr_item_status.
      lr_item_status->status = get_messages_status( lr_item_status->messages ).
      IF lr_item_status->messages IS INITIAL.
        CLEAR ls_msg.
        ls_msg-type = 'I'.
        ls_msg-text = 'No message'.
        INSERT ls_msg INTO TABLE lr_item_status->messages.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_log~get_log_level.

    FIELD-SYMBOLS <ls_log> LIKE LINE OF mt_log.

    rv_level = zif_abapgit_log=>c_log_level-empty.

    LOOP AT mt_log ASSIGNING <ls_log>.
      IF <ls_log>-msg-level = zif_abapgit_log=>c_log_level-error.
        rv_level = zif_abapgit_log=>c_log_level-error.
        EXIT.
      ELSEIF <ls_log>-msg-level > rv_level.
        rv_level = <ls_log>-msg-level.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_log~get_messages.
    DATA ls_msg TYPE zif_abapgit_log~ty_log_out.
    FIELD-SYMBOLS <ls_log> TYPE ty_log.
    LOOP AT mt_log ASSIGNING <ls_log>.
      ls_msg-type      = <ls_log>-msg-type.
      ls_msg-id        = <ls_log>-msg-id.
      ls_msg-number    = <ls_log>-msg-number.
      ls_msg-text      = <ls_log>-msg-text.
      ls_msg-obj_type  = <ls_log>-item-obj_type.
      ls_msg-obj_name  = <ls_log>-item-obj_name.
      ls_msg-exception = <ls_log>-exception.
      APPEND ls_msg TO rt_msg.
    ENDLOOP.
    DELETE ADJACENT DUPLICATES FROM rt_msg.
  ENDMETHOD.

  METHOD zif_abapgit_log~get_status.

    DATA lr_log TYPE REF TO ty_log.
    rv_status = zif_abapgit_log=>c_status-ok.
    LOOP AT mt_log REFERENCE INTO lr_log.
      CASE lr_log->msg-type.
        WHEN 'E' OR 'A' OR 'X'.
          rv_status = zif_abapgit_log=>c_status-error.
          EXIT.
        WHEN 'W'.
          rv_status = zif_abapgit_log=>c_status-warning.
          CONTINUE.
        WHEN 'S' OR 'I'.
          IF rv_status <> zif_abapgit_log=>c_status-warning.
            rv_status = zif_abapgit_log=>c_status-ok.
          ENDIF.
          CONTINUE.
        WHEN OTHERS. "unknown
          ASSERT 0 = 1.
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_log~get_title.
    rv_title = mv_title.
    IF rv_title IS INITIAL.
      rv_title = 'Log'.
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_log~merge_with.

    DATA lo_log TYPE REF TO zcl_abapgit_log.
    DATA lt_log_temp LIKE lo_log->mt_log.

    IF ii_log IS BOUND.
      lo_log ?= ii_log.
      IF iv_min_level > 0.
        lt_log_temp = lo_log->mt_log.
        DELETE lt_log_temp WHERE msg-level < iv_min_level.
        APPEND LINES OF lt_log_temp TO mt_log.
      ELSE.
        APPEND LINES OF lo_log->mt_log TO mt_log.
      ENDIF.
    ENDIF.

    ri_log = me.

  ENDMETHOD.

  METHOD zif_abapgit_log~set_title.
    mv_title = iv_title.
    ri_log = me.
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_longtexts IMPLEMENTATION.

  METHOD escape_name.
    " Prepare name for SQL LIKE condition
    rv_object = iv_object_name.

    IF 'CA,CE,CO,CT,IA,IE,IO,WC,FU,FX,DI,IS,PS' CS iv_longtext_id.
      " Document types of objects with sub-objects
      rv_object+30 = '%'.
    ELSEIF 'OD' CS iv_longtext_id.
      rv_object+10 = '%'.
    ENDIF.

    rv_object = replace(
      val  = rv_object
      sub  = '_'
      with = '#_'
      occ  = 0 ).
  ENDMETHOD.

  METHOD read.

    DATA: ls_longtext TYPE zif_abapgit_longtexts=>ty_longtext,
          lv_object   TYPE dokil-object,
          lt_dokil    TYPE zif_abapgit_definitions=>ty_dokil_tt.

    FIELD-SYMBOLS: <ls_dokil> LIKE LINE OF lt_dokil.

    IF iv_object_name CA '#'.
      zcx_abapgit_exception=>raise( |Invalid name for longtext: { iv_longtext_id } { iv_object_name }| ).
    ENDIF.

    lv_object = escape_name(
      iv_longtext_id = iv_longtext_id
      iv_object_name = iv_object_name ).

    IF lines( it_dokil ) > 0.

      lt_dokil = it_dokil.

      IF iv_main_lang_only = abap_true.
        DELETE lt_dokil WHERE masterlang <> abap_true.
      ENDIF.

    ELSEIF iv_longtext_id IS NOT INITIAL.
      IF iv_main_lang_only = abap_true.
        SELECT * FROM dokil
                 INTO TABLE lt_dokil
                 WHERE id     = iv_longtext_id
                 AND object LIKE lv_object ESCAPE '#'
                 AND masterlang = abap_true
                 ORDER BY PRIMARY KEY.
      ELSE.
        SELECT * FROM dokil
                 INTO TABLE lt_dokil
                 WHERE id     = iv_longtext_id
                 AND object LIKE lv_object ESCAPE '#'
                 ORDER BY PRIMARY KEY.
      ENDIF.
    ELSE.

      zcx_abapgit_exception=>raise( |serialize_longtexts parameter error| ).

    ENDIF.

    LOOP AT lt_dokil ASSIGNING <ls_dokil>
                     WHERE txtlines > 0.

      CLEAR: ls_longtext.

      ls_longtext-dokil = <ls_dokil>.

      CALL FUNCTION 'DOCU_READ'
        EXPORTING
          id      = <ls_dokil>-id
          langu   = <ls_dokil>-langu
          object  = <ls_dokil>-object
          typ     = <ls_dokil>-typ
          version = <ls_dokil>-version
        IMPORTING
          head    = ls_longtext-head
        TABLES
          line    = ls_longtext-lines.

      IF iv_clear_fields = abap_true.
        CLEAR: ls_longtext-head-tdfuser,
               ls_longtext-head-tdfreles,
               ls_longtext-head-tdfdate,
               ls_longtext-head-tdftime,
               ls_longtext-head-tdluser,
               ls_longtext-head-tdlreles,
               ls_longtext-head-tdldate,
               ls_longtext-head-tdltime.
      ENDIF.

      INSERT ls_longtext INTO TABLE rt_longtexts.

    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_longtexts~changed_by.

    DATA: lt_longtexts TYPE zif_abapgit_longtexts=>ty_longtexts.
    FIELD-SYMBOLS: <ls_longtext> TYPE zif_abapgit_longtexts=>ty_longtext.

    lt_longtexts = read( iv_object_name  = iv_object_name
                         iv_longtext_id  = iv_longtext_id
                         it_dokil        = it_dokil
                         iv_clear_fields = abap_false ).

    READ TABLE lt_longtexts INDEX 1 ASSIGNING <ls_longtext>.
    IF sy-subrc = 0.
      rv_user = <ls_longtext>-head-tdluser.
      IF rv_user IS INITIAL.
        rv_user = <ls_longtext>-head-tdfuser.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_longtexts~delete.

    DATA: lt_dokil  TYPE zif_abapgit_definitions=>ty_dokil_tt,
          lv_object TYPE dokil-object.

    FIELD-SYMBOLS: <ls_dokil> TYPE dokil.

    lv_object = escape_name(
      iv_longtext_id = iv_longtext_id
      iv_object_name = iv_object_name ).

    SELECT * FROM dokil
      INTO TABLE lt_dokil
      WHERE id = iv_longtext_id AND object LIKE lv_object ESCAPE '#'
      ORDER BY PRIMARY KEY.

    LOOP AT lt_dokil ASSIGNING <ls_dokil>.

      CALL FUNCTION 'DOCU_DEL'
        EXPORTING
          id       = <ls_dokil>-id
          langu    = <ls_dokil>-langu
          object   = <ls_dokil>-object
          typ      = <ls_dokil>-typ
        EXCEPTIONS
          ret_code = 1
          OTHERS   = 2.

      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_longtexts~deserialize.

    DATA: lt_longtexts    TYPE zif_abapgit_longtexts=>ty_longtexts,
          lv_object       TYPE dokil-object,
          lt_dokil        TYPE zif_abapgit_definitions=>ty_dokil_tt,
          lv_no_main_lang TYPE dokil-masterlang.

    FIELD-SYMBOLS: <ls_longtext> TYPE zif_abapgit_longtexts=>ty_longtext,
                   <ls_dokil>    TYPE dokil.

    lv_object = escape_name(
      iv_longtext_id = iv_longtext_id
      iv_object_name = iv_object_name ).

    ii_xml->read(
      EXPORTING
        iv_name = iv_longtext_name
      CHANGING
        cg_data = lt_longtexts ).

    LOOP AT lt_longtexts ASSIGNING <ls_longtext>.

      lv_no_main_lang = boolc( iv_main_language <> <ls_longtext>-dokil-langu ).

      CALL FUNCTION 'DOCU_UPDATE'
        EXPORTING
          head          = <ls_longtext>-head
          state         = c_docu_state_active
          typ           = <ls_longtext>-dokil-typ
          version       = <ls_longtext>-dokil-version
          no_masterlang = lv_no_main_lang
        TABLES
          line          = <ls_longtext>-lines.

    ENDLOOP.

    " Read existing texts and check if they were deserialized above
    " If not, delete the texts
    SELECT * FROM dokil
      INTO TABLE lt_dokil
      WHERE id = iv_longtext_id AND object LIKE lv_object ESCAPE '#'
      ORDER BY PRIMARY KEY.

    LOOP AT lt_dokil ASSIGNING <ls_dokil>.

      READ TABLE lt_longtexts TRANSPORTING NO FIELDS WITH KEY
        dokil-id     = <ls_dokil>-id
        dokil-langu  = <ls_dokil>-langu
        dokil-object = <ls_dokil>-object
        dokil-typ    = <ls_dokil>-typ.
      IF sy-subrc <> 0.
        CALL FUNCTION 'DOCU_DEL'
          EXPORTING
            id       = <ls_dokil>-id
            langu    = <ls_dokil>-langu
            object   = <ls_dokil>-object
            typ      = <ls_dokil>-typ
          EXCEPTIONS
            ret_code = 1
            OTHERS   = 2.

        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise_t100( ).
        ENDIF.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_longtexts~serialize.

    rt_longtexts = read( iv_object_name    = iv_object_name
                         iv_longtext_id    = iv_longtext_id
                         it_dokil          = it_dokil
                         iv_main_lang_only = io_i18n_params->ms_params-main_language_only ).

    IF rt_longtexts IS SUPPLIED.
      RETURN.
    ENDIF.

    ii_xml->add( iv_name = iv_longtext_name
                 ig_data = rt_longtexts ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_lxe_texts IMPLEMENTATION.

  METHOD check_langs_versus_installed.

    DATA lt_installed_hash TYPE HASHED TABLE OF laiso WITH UNIQUE KEY table_line.
    FIELD-SYMBOLS <lv_lang> LIKE LINE OF it_languages.

    CLEAR: et_intersection, et_missfits.
    lt_installed_hash = it_installed.

    LOOP AT it_languages ASSIGNING <lv_lang>.
      READ TABLE lt_installed_hash WITH KEY table_line = <lv_lang> TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        APPEND <lv_lang> TO et_intersection.
      ELSE.
        APPEND <lv_lang> TO et_missfits.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD class_constructor.

    APPEND 'CLAS' TO gt_supported_obj_types.
    APPEND 'DOMA' TO gt_supported_obj_types.
    APPEND 'DTEL' TO gt_supported_obj_types.
    APPEND 'FUGR' TO gt_supported_obj_types.
    APPEND 'MSAG' TO gt_supported_obj_types.
    APPEND 'PARA' TO gt_supported_obj_types.
    APPEND 'PROG' TO gt_supported_obj_types.
    APPEND 'SHI3' TO gt_supported_obj_types.
    APPEND 'TABL' TO gt_supported_obj_types.
    APPEND 'TRAN' TO gt_supported_obj_types.
    APPEND 'VIEW' TO gt_supported_obj_types.

  ENDMETHOD.

  METHOD convert_lang_string_to_table.

    DATA:
      lt_langs_str          TYPE string_table,
      lv_laiso              TYPE laiso,
      lv_skip_main_lang_iso TYPE laiso.

    FIELD-SYMBOLS:
      <lv_str>  LIKE LINE OF lt_langs_str.

    " Keep * as indicator for 'all installed languages'
    IF iv_langs = '*'.
      APPEND iv_langs TO rt_languages.
      RETURN.
    ENDIF.

    " Convert string of 2-letter ISO languages into table of sy-langu codes
    SPLIT iv_langs AT ',' INTO TABLE lt_langs_str.

    LOOP AT lt_langs_str ASSIGNING <lv_str>.
      lv_laiso = condense( to_upper( <lv_str> ) ).
      APPEND lv_laiso TO rt_languages.
    ENDLOOP.

    IF iv_skip_main_language IS NOT INITIAL.
      lv_skip_main_lang_iso = langu_to_laiso_safe( iv_skip_main_language ).
      DELETE rt_languages WHERE table_line = lv_skip_main_lang_iso.
    ENDIF.

    SORT rt_languages.
    DELETE ADJACENT DUPLICATES FROM rt_languages.

  ENDMETHOD.

  METHOD convert_table_to_lang_string.

    DATA:
      lt_langs_str TYPE string_table.

    FIELD-SYMBOLS:
      <lv_lang> LIKE LINE OF it_languages,
      <lv_str>  TYPE string.

    " Convert table of sy-langu codes into string of 2-letter ISO languages
    LOOP AT it_languages ASSIGNING <lv_lang>.
      " Keep * as indicator for 'all installed languages'
      IF <lv_lang> = '*'.
        CLEAR lt_langs_str.
        APPEND '*' TO lt_langs_str.
        EXIT.
      ENDIF.

      APPEND INITIAL LINE TO lt_langs_str ASSIGNING <lv_str>.
      <lv_str> = <lv_lang>.
    ENDLOOP.

    CONCATENATE LINES OF lt_langs_str INTO rv_langs SEPARATED BY ','.

  ENDMETHOD.

  METHOD deserialize_from_po.

    DATA lv_lang LIKE LINE OF mo_i18n_params->ms_params-translation_languages.
    DATA lt_po_files TYPE zif_abapgit_i18n_file=>ty_table_of.
    DATA li_po LIKE LINE OF lt_po_files.
    DATA lt_text_pairs_tmp TYPE ty_lxe_translation-text_pairs.
    DATA lt_obj_list TYPE lxe_tt_colob.
    DATA lv_main_lang TYPE lxeisolang.
    DATA lv_target_lang TYPE lxeisolang.

    FIELD-SYMBOLS <lv_lxe_object> LIKE LINE OF lt_obj_list.

    lt_obj_list = get_lxe_object_list(
      iv_object_name = iv_object_name
      iv_object_type = iv_object_type ).

    IF lt_obj_list IS INITIAL.
      RETURN.
    ENDIF.

    lt_po_files  = mo_files->read_i18n_files( ).
    lv_main_lang = get_lang_iso4( langu_to_laiso_safe( mo_i18n_params->ms_params-main_language ) ).

    LOOP AT mo_i18n_params->ms_params-translation_languages INTO lv_lang.
      lv_target_lang = get_lang_iso4( lv_lang ).

      LOOP AT lt_po_files INTO li_po.
        IF li_po->lang( ) = to_lower( lv_lang ). " Not quite efficient but the list is presumably very short
          EXIT.
        ELSE.
          CLEAR li_po.
        ENDIF.
      ENDLOOP.

      CHECK li_po IS BOUND. " Ignore missing files, missing translation is not a crime

      LOOP AT lt_obj_list ASSIGNING <lv_lxe_object>.

        lt_text_pairs_tmp = read_lxe_object_text_pair(
          iv_s_lang    = lv_main_lang
          iv_t_lang    = lv_target_lang
          iv_custmnr   = <lv_lxe_object>-custmnr
          iv_objtype   = <lv_lxe_object>-objtype
          iv_objname   = <lv_lxe_object>-objname
          iv_read_only = abap_false ).

        li_po->translate( CHANGING ct_text_pairs = lt_text_pairs_tmp ).
        " TODO maybe optimize, check if values have changed

        write_lxe_object_text_pair(
          iv_s_lang  = lv_main_lang
          iv_t_lang  = lv_target_lang
          iv_custmnr = <lv_lxe_object>-custmnr
          iv_objtype = <lv_lxe_object>-objtype
          iv_objname = <lv_lxe_object>-objname
          it_pcx_s1  = lt_text_pairs_tmp ).

      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.

  METHOD deserialize_xml.

    DATA:
      lt_lxe_texts      TYPE ty_lxe_translations,
      ls_lxe_item       LIKE LINE OF lt_lxe_texts,
      lt_text_pairs_tmp LIKE ls_lxe_item-text_pairs.

    mi_xml_in->read(
      EXPORTING iv_name = iv_lxe_text_name
      CHANGING  cg_data = lt_lxe_texts ).

    LOOP AT lt_lxe_texts INTO ls_lxe_item.
      " Call Read first for buffer prefill

      lt_text_pairs_tmp = read_lxe_object_text_pair(
        iv_s_lang    = ls_lxe_item-source_lang
        iv_t_lang    = ls_lxe_item-target_lang
        iv_custmnr   = ls_lxe_item-custmnr
        iv_objtype   = ls_lxe_item-objtype
        iv_objname   = ls_lxe_item-objname
        iv_read_only = abap_false ).

      "Call actual Write FM
      write_lxe_object_text_pair(
        iv_s_lang  = ls_lxe_item-source_lang
        iv_t_lang  = ls_lxe_item-target_lang
        iv_custmnr = ls_lxe_item-custmnr
        iv_objtype = ls_lxe_item-objtype
        iv_objname = ls_lxe_item-objname
        it_pcx_s1  = ls_lxe_item-text_pairs ).

    ENDLOOP.

  ENDMETHOD.

  METHOD detect_unsupported_languages.

    check_langs_versus_installed(
      EXPORTING
        it_languages = it_languages
        it_installed = get_installed_languages( )
      IMPORTING
        et_missfits = rt_unsupported_languages ).

  ENDMETHOD.

  METHOD get_installed_languages.

    DATA:
      lv_index               TYPE i,
      lv_langu               TYPE sy-langu,
      lv_laiso               TYPE laiso,
      lv_installed_languages TYPE string,
      lt_language_filter     TYPE zif_abapgit_environment=>ty_system_language_filter.

    IF gt_installed_languages_cache IS INITIAL.
      CALL FUNCTION 'SYSTEM_INSTALLED_LANGUAGES'
        IMPORTING
          languages       = lv_installed_languages
        EXCEPTIONS
          sapgparam_error = 1                " Error requesting profile parameter
          OTHERS          = 2.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( 'Fail to get system SYSTEM_INSTALLED_LANGUAGES' ).
      ENDIF.

      lt_language_filter = zcl_abapinst_factory=>get_environment( )->get_system_language_filter( ).

      DO strlen( lv_installed_languages ) TIMES.
        lv_index = sy-index - 1.
        lv_langu = lv_installed_languages+lv_index(1).

        IF lv_langu NOT IN lt_language_filter.
          CONTINUE.
        ENDIF.

        lv_laiso = langu_to_laiso_safe( lv_langu ).
        APPEND lv_laiso TO gt_installed_languages_cache.
      ENDDO.
    ENDIF.

    rt_languages = gt_installed_languages_cache.

  ENDMETHOD.

  METHOD get_lang_iso4.

    DATA lv_lang_iso639 TYPE laiso.
    DATA lv_country     TYPE land1.
    DATA lv_class       TYPE string.

    lv_class = 'CL_I18N_LANGUAGES'.

" cannot find a way to do this in Steampunk, so dynamic for now,
    CALL METHOD (lv_class)=>sap2_to_iso639_1
      EXPORTING
        im_lang_sap2   = iv_src
      IMPORTING
        ex_lang_iso639 = lv_lang_iso639
        ex_country     = lv_country
      EXCEPTIONS
        no_assignment  = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Failed to convert [{ iv_src }] lang to iso639| ).
    ENDIF.

    CONCATENATE lv_lang_iso639 lv_country INTO rv_iso4.

  ENDMETHOD.

  METHOD get_lxe_object_list.

    DATA lv_object_name TYPE trobj_name.

    lv_object_name = iv_object_name.

    CALL FUNCTION 'LXE_OBJ_EXPAND_TRANSPORT_OBJ'
      EXPORTING
        pgmid           = 'R3TR'
        object          = iv_object_type
        obj_name        = lv_object_name
      TABLES
        ex_colob        = rt_obj_list
      EXCEPTIONS
        unknown_object  = 1
        unknown_ta_type = 2
        OTHERS          = 3.
    IF sy-subrc <> 0.
      RETURN. " Ignore error and return empty list
    ENDIF.

  ENDMETHOD.

  METHOD get_translation_languages.

    " Returns a list of translation languages for serialization
    " If the setting is initial, no translations shall be serialized
    " If the setting is `*`, all installed system languages shall be serialized
    " Else, the setting shall contain all languages to be serialized

    DATA lv_main_lang_laiso TYPE laiso.

    IF it_i18n_languages IS NOT INITIAL.
      READ TABLE it_i18n_languages TRANSPORTING NO FIELDS WITH KEY table_line = '*'.
      IF sy-subrc = 0.
        rt_languages = get_installed_languages( ).
      ELSE.
        check_langs_versus_installed(
          EXPORTING
            it_languages = it_i18n_languages
            it_installed = get_installed_languages( )
          IMPORTING
            et_intersection = rt_languages ).
      ENDIF.
    ENDIF.

    " Remove main language from translation languages
    lv_main_lang_laiso = langu_to_laiso_safe( iv_main_language ).
    DELETE rt_languages WHERE table_line = lv_main_lang_laiso.

  ENDMETHOD.

  METHOD iso4_to_iso2.
    rv_laiso = iv_lxe_lang+0(2).
  ENDMETHOD.

  METHOD is_object_supported.
    READ TABLE gt_supported_obj_types TRANSPORTING NO FIELDS WITH KEY table_line = iv_object_type.
    rv_yes = boolc( sy-subrc = 0 ).
  ENDMETHOD.

  METHOD langu_to_laiso_safe.

    zcl_abapgit_convert=>language_sap1_to_sap2(
      EXPORTING
        im_lang_sap1  = iv_langu
      RECEIVING
        re_lang_sap2  = rv_laiso
      EXCEPTIONS
        no_assignment = 1
        OTHERS        = 2 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Could not convert lang [{ iv_langu }] to ISO| ).
    ENDIF.

  ENDMETHOD.

  METHOD read_lxe_object_text_pair.

    DATA:
      lv_error TYPE lxestring.

    TRY.
        CALL FUNCTION 'LXE_OBJ_TEXT_PAIR_READ'
          EXPORTING
            s_lang    = iv_s_lang
            t_lang    = iv_t_lang
            custmnr   = iv_custmnr
            objtype   = iv_objtype
            objname   = iv_objname
            read_only = iv_read_only
          IMPORTING
            err_msg   = lv_error  " doesn't exist in NW <= 750
          TABLES
            lt_pcx_s1 = rt_text_pairs_tmp.
        IF lv_error IS NOT INITIAL.
          zcx_abapgit_exception=>raise( lv_error ).
        ENDIF.

      CATCH cx_sy_dyn_call_param_not_found.

        CALL FUNCTION 'LXE_OBJ_TEXT_PAIR_READ'
          EXPORTING
            s_lang    = iv_s_lang
            t_lang    = iv_t_lang
            custmnr   = iv_custmnr
            objtype   = iv_objtype
            objname   = iv_objname
            read_only = iv_read_only
          TABLES
            lt_pcx_s1 = rt_text_pairs_tmp.

    ENDTRY.

  ENDMETHOD.

  METHOD read_text_items.

    DATA:
      lt_obj_list      TYPE lxe_tt_colob,
      lv_main_lang     TYPE lxeisolang,
      ls_lxe_text_item LIKE LINE OF rt_text_items.

    FIELD-SYMBOLS:
      <lv_language>   LIKE LINE OF mo_i18n_params->ms_params-translation_languages,
      <lv_lxe_object> LIKE LINE OF lt_obj_list.

    lt_obj_list = get_lxe_object_list(
      iv_object_name = iv_object_name
      iv_object_type = iv_object_type ).

    IF lt_obj_list IS INITIAL.
      RETURN.
    ENDIF.

    " Get list of languages that need to be serialized (already resolves * and installed languages)
    lv_main_lang = get_lang_iso4( langu_to_laiso_safe( mo_i18n_params->ms_params-main_language ) ).

    LOOP AT lt_obj_list ASSIGNING <lv_lxe_object>.
      CLEAR ls_lxe_text_item.
      ls_lxe_text_item-custmnr = <lv_lxe_object>-custmnr.
      ls_lxe_text_item-objtype = <lv_lxe_object>-objtype.
      ls_lxe_text_item-objname = <lv_lxe_object>-objname.

      LOOP AT mo_i18n_params->ms_params-translation_languages ASSIGNING <lv_language>.
        ls_lxe_text_item-source_lang = lv_main_lang.
        ls_lxe_text_item-target_lang = get_lang_iso4( <lv_language> ).
        IF ls_lxe_text_item-source_lang = ls_lxe_text_item-target_lang.
          CONTINUE. " if source = target -> skip
        ENDIF.

        ls_lxe_text_item-text_pairs = read_lxe_object_text_pair(
          iv_s_lang    = ls_lxe_text_item-source_lang
          iv_t_lang    = ls_lxe_text_item-target_lang
          iv_custmnr   = ls_lxe_text_item-custmnr
          iv_objtype   = ls_lxe_text_item-objtype
          iv_objname   = ls_lxe_text_item-objname ).

        IF ls_lxe_text_item-text_pairs IS NOT INITIAL.
          APPEND ls_lxe_text_item TO rt_text_items.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_as_po.

    DATA lt_lxe_texts TYPE ty_lxe_translations.
    DATA lo_po_file TYPE REF TO zcl_abapgit_po_file.
    DATA lv_lang LIKE LINE OF mo_i18n_params->ms_params-translation_languages.
    FIELD-SYMBOLS <ls_translation> LIKE LINE OF lt_lxe_texts.

    lt_lxe_texts = read_text_items(
      iv_object_name   = iv_object_name
      iv_object_type   = iv_object_type ).

    LOOP AT mo_i18n_params->ms_params-translation_languages INTO lv_lang.
      lv_lang = to_lower( lv_lang ).
      CREATE OBJECT lo_po_file
        EXPORTING
          iv_lang = lv_lang.
      LOOP AT lt_lxe_texts ASSIGNING <ls_translation>.
        IF iso4_to_iso2( <ls_translation>-target_lang ) = lv_lang.
          lo_po_file->push_text_pairs(
            iv_objtype    = <ls_translation>-objtype
            iv_objname    = <ls_translation>-objname
            it_text_pairs = <ls_translation>-text_pairs ).
        ENDIF.
      ENDLOOP.
      mo_files->add_i18n_file( lo_po_file ).
    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_xml.

    DATA lt_lxe_texts TYPE ty_lxe_translations.

    lt_lxe_texts = read_text_items(
      iv_object_name   = iv_object_name
      iv_object_type   = iv_object_type ).

    IF lines( lt_lxe_texts ) > 0.
      mi_xml_out->add(
        iv_name = iv_lxe_text_name
        ig_data = lt_lxe_texts ).
    ENDIF.

  ENDMETHOD.

  METHOD write_lxe_object_text_pair.

    DATA:
      lv_error TYPE lxestring.

    TRY.
        CALL FUNCTION 'LXE_OBJ_TEXT_PAIR_WRITE'
          EXPORTING
            s_lang    = iv_s_lang
            t_lang    = iv_t_lang
            custmnr   = iv_custmnr
            objtype   = iv_objtype
            objname   = iv_objname
          IMPORTING
            err_msg   = lv_error  " doesn't exist in NW <= 750
          TABLES
            lt_pcx_s1 = it_pcx_s1.
        IF lv_error IS NOT INITIAL.
          zcx_abapgit_exception=>raise( lv_error ).
        ENDIF.

      CATCH cx_sy_dyn_call_param_not_found.

        CALL FUNCTION 'LXE_OBJ_TEXT_PAIR_WRITE'
          EXPORTING
            s_lang    = iv_s_lang
            t_lang    = iv_t_lang
            custmnr   = iv_custmnr
            objtype   = iv_objtype
            objname   = iv_objname
          TABLES
            lt_pcx_s1 = it_pcx_s1.

    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_lxe_texts~deserialize.

    IF is_object_supported( iv_object_type ) = abap_false.
      RETURN.
    ENDIF.

    mo_i18n_params = io_i18n_params.
    mi_xml_in      = ii_xml.
    mo_files       = io_files.

    " MAYBE TODO: see comment in serialize

    IF 1 = 1.
      deserialize_from_po(
        iv_object_type = iv_object_type
        iv_object_name = iv_object_name ).
    ELSE.
      deserialize_xml(
        iv_object_type = iv_object_type
        iv_object_name = iv_object_name ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_lxe_texts~serialize.

    IF is_object_supported( iv_object_type ) = abap_false.
      RETURN.
    ENDIF.

    mo_i18n_params = io_i18n_params.
    mi_xml_out     = ii_xml.
    mo_files       = io_files.

    " MAYBE TODO
    " if other formats are needed, including the old in-XML approach
    " here is the place to implement it. Supposed architecture:
    " I18N_PARAMS should contain an option which format to use
    " The option should be originally maintained in dot_abapgit structures (e.g. `translation_storage_format`)
    " Consequently it comes here
    " The serialize method can read it and call a corresponding submethod,
    " e.g. serialize_xml or serialize_as_po or ...
    " both ii_xml and io_files are accessible intentionally to enable both XML based or file based formats
    " access to json can be easily added too,
    " or maybe (maybe) some kind of zif_ag_object_ctl with all DAO instead

    IF 1 = 1.
      serialize_as_po(
        iv_object_type = iv_object_type
        iv_object_name = iv_object_name ).
    ELSE.
      serialize_xml(
        iv_object_type = iv_object_type
        iv_object_name = iv_object_name ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_objects_activation IMPLEMENTATION.

  METHOD activate.

    " Make sure that all changes are committed since any activation error will lead to a rollback
    COMMIT WORK AND WAIT.

    IF use_new_activation_logic( ) = abap_true.
      activate_new(
        iv_ddic = iv_ddic
        ii_log  = ii_log ).
    ELSE.
      activate_old(
        iv_ddic = iv_ddic
        ii_log  = ii_log ).
    ENDIF.

    update_where_used( ii_log ).

  ENDMETHOD.

  METHOD activate_ddic.

    DATA: lt_gentab     TYPE STANDARD TABLE OF dcgentb,
          lv_rc         TYPE sy-subrc,
          ls_gentab     LIKE LINE OF lt_gentab,
          lt_deltab     TYPE STANDARD TABLE OF dcdeltb,
          lt_action_tab TYPE STANDARD TABLE OF dctablres,
          lv_logname    TYPE ddmass-logname.

    FIELD-SYMBOLS: <ls_object> LIKE LINE OF gt_objects.

    LOOP AT gt_objects ASSIGNING <ls_object>.
      " Filter types supported by mass activation
      IF is_ddic_type( <ls_object>-object ) = abap_false.
        CONTINUE.
      ENDIF.
      ls_gentab-tabix = sy-tabix.

      get_ddic_type(
        EXPORTING
          iv_obj_type = <ls_object>-object
          iv_obj_name = <ls_object>-obj_name
        IMPORTING
          ev_type     = ls_gentab-type
          ev_name     = ls_gentab-name
          ev_id       = ls_gentab-indx ).

      INSERT ls_gentab INTO TABLE lt_gentab.
    ENDLOOP.

    IF lt_gentab IS NOT INITIAL.

      lv_logname = |ABAPGIT_{ sy-datum }_{ sy-uzeit }|.

      IF lines( lt_gentab ) = 1.
        ii_log->add_info( |> Mass activating 1 DDIC object| ).
      ELSE.
        ii_log->add_info( |> Mass activating { lines( lt_gentab ) } DDIC objects| ).
      ENDIF.
      ii_log->add_info( |Log name: { lv_logname }| ).

      CALL FUNCTION 'DD_MASS_ACT_C3'
        EXPORTING
          ddmode         = 'O'         " activate changes in Original System
          frcact         = abap_true   " force Activation
          medium         = 'T'         " transport order
          device         = 'T'         " saves to table DDRPH?
          version        = 'M'         " activate newest version
          logname        = lv_logname
          write_log      = abap_true
          log_head_tail  = abap_true
          t_on           = space
          prid           = 1
        IMPORTING
          act_rc         = lv_rc
        TABLES
          gentab         = lt_gentab
          deltab         = lt_deltab
          cnvtab         = lt_action_tab
        EXCEPTIONS
          access_failure = 1
          no_objects     = 2
          locked         = 3
          internal_error = 4
          OTHERS         = 5.

      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      IF lv_rc > 0.
        add_errors_and_warnings_to_log(
          iv_logname = lv_logname
          ii_log     = ii_log ).
      ENDIF.

      IF lv_rc > 4.
        zcx_abapgit_exception=>raise( 'Activation cancelled. Check the inactive objects.' ).
      ENDIF.

      " Remove objects from activation queue to avoid double activation in activate_old
      LOOP AT lt_gentab INTO ls_gentab.
        DELETE gt_objects WHERE object = ls_gentab-type AND obj_name = ls_gentab-name.
      ENDLOOP.
      DELETE gt_objects WHERE object = 'INDX' OR object = 'XINX' OR object = 'MCID'.

    ENDIF.

  ENDMETHOD.

  METHOD activate_new.

    IF gt_objects IS INITIAL.
      RETURN.
    ENDIF.

    IF iv_ddic = abap_true.

      activate_ddic( ii_log ).

    ELSE.

      activate_old( ii_log ).

    ENDIF.

  ENDMETHOD.

  METHOD activate_old.

    DATA:
      lv_popup     TYPE abap_bool,
      lv_no_ui     TYPE abap_bool,
      lv_try_again TYPE abap_bool,
      lv_msg       TYPE string,
      lo_checklist TYPE REF TO cl_wb_checklist.

    IF gt_objects IS NOT INITIAL.

      lv_no_ui = boolc( lv_popup = abap_false ).

      IF iv_ddic = abap_true.
        lv_msg = |(with DDIC)|.
      ENDIF.
      IF lines( gt_objects ) = 1.
        ii_log->add_info( |> Activating 1 object { lv_msg }| ).
      ELSE.
        ii_log->add_info( |> Activating { lines( gt_objects ) } objects { lv_msg }| ).
      ENDIF.

      TRY.
          CALL FUNCTION 'RS_WORKING_OBJECTS_ACTIVATE'
            EXPORTING
              activate_ddic_objects  = iv_ddic
              with_popup             = lv_popup
              ui_decoupled           = lv_no_ui
            IMPORTING
              p_checklist            = lo_checklist
            TABLES
              objects                = gt_objects
            EXCEPTIONS
              excecution_error       = 1
              cancelled              = 2
              insert_into_corr_error = 3
              OTHERS                 = 4 ##FM_SUBRC_OK.
        CATCH cx_sy_dyn_call_param_not_found.
          CALL FUNCTION 'RS_WORKING_OBJECTS_ACTIVATE'
            EXPORTING
              activate_ddic_objects  = iv_ddic
              with_popup             = lv_popup
            IMPORTING
              p_checklist            = lo_checklist
            TABLES
              objects                = gt_objects
            EXCEPTIONS
              excecution_error       = 1
              cancelled              = 2
              insert_into_corr_error = 3
              OTHERS                 = 4 ##FM_SUBRC_OK.
      ENDTRY.
      CASE sy-subrc.
        WHEN 1 OR 3 OR 4.
          zcx_abapgit_exception=>raise_t100( ).
        WHEN 2.
          lv_msg = 'Check the log and inactive objects.'.
          IF lv_popup = abap_false.
            lv_try_again = add_activation_errors_to_log(
              ii_log       = ii_log
              io_checklist = lo_checklist ).
            IF lv_try_again = abap_true.
              lv_msg = 'Turn on "Activation Popup" in "Personal Settings" and try again'.
            ENDIF.
          ENDIF.
          zcx_abapgit_exception=>raise( |Activation cancelled. { lv_msg }| ).
      ENDCASE.

    ENDIF.

  ENDMETHOD.

  METHOD add.

* function group SEWORKINGAREA
* function module RS_INSERT_INTO_WORKING_AREA
* class CL_WB_ACTIVATION_WORK_AREA

    FIELD-SYMBOLS: <ls_object>  TYPE dwinactiv,
                   <ls_classes> LIKE LINE OF gt_classes.

    IF iv_type = 'CLAS' OR iv_type = 'INTF'.
      APPEND INITIAL LINE TO gt_classes ASSIGNING <ls_classes>.
      <ls_classes>-object  = iv_type.
      <ls_classes>-clsname = iv_name.
    ELSE.
      APPEND INITIAL LINE TO gt_objects ASSIGNING <ls_object>.
      <ls_object>-object     = iv_type.
      <ls_object>-obj_name   = iv_name.
      <ls_object>-delet_flag = iv_delete.
    ENDIF.

  ENDMETHOD.

  METHOD add_activation_errors_to_log.

    DATA:
      ls_item    TYPE zif_abapgit_definitions=>ty_item,
      lt_message TYPE swbme_error_tab.

    FIELD-SYMBOLS:
      <lv_msg>     TYPE string,
      <ls_message> LIKE LINE OF lt_message.

    io_checklist->get_error_messages( IMPORTING p_error_tab = lt_message ).

    LOOP AT lt_message ASSIGNING <ls_message> WHERE mtype = 'E'.
      " When activating without popup, includes used in multiple main programs cause error
      " Run again WITH activation popup (see abapGit, Personal Settings)
      IF <ls_message>-message-msgid = 'EU' AND <ls_message>-message-msgno = '404'.
        rv_try_again = abap_true.
      ENDIF.
      CLEAR ls_item.
      IF strlen( <ls_message>-object_text ) > 5.
        ls_item-obj_type = <ls_message>-object_text(4).
        ls_item-obj_name = <ls_message>-object_text+5(*).
      ELSEIF <ls_message>-show_req IS NOT INITIAL.
        ls_item-obj_name = <ls_message>-show_req->object_name.
        SELECT SINGLE tadir FROM euobjedit INTO ls_item-obj_type
          WHERE type = <ls_message>-show_req->object_type.
      ENDIF.
      LOOP AT <ls_message>-mtext ASSIGNING <lv_msg>.
        IF sy-tabix = 1.
          ii_log->add(
            iv_type   = 'E'
            iv_msg    = <lv_msg>
            iv_class  = <ls_message>-message-msgid
            iv_number = <ls_message>-message-msgno
            is_item   = ls_item ).
        ELSE.
          ii_log->add_error(
            iv_msg  = <lv_msg>
            is_item = ls_item ).
        ENDIF.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD.

  METHOD add_errors_and_warnings_to_log.

    DATA: lt_lines      TYPE STANDARD TABLE OF trlog,
          lv_logname_db TYPE ddprh-protname.

    FIELD-SYMBOLS: <ls_line> LIKE LINE OF lt_lines.

    lv_logname_db = iv_logname.

    CALL FUNCTION 'TR_READ_LOG'
      EXPORTING
        iv_log_type   = 'DB'
        iv_logname_db = lv_logname_db
      TABLES
        et_lines      = lt_lines
      EXCEPTIONS
        invalid_input = 1
        access_error  = 2
        OTHERS        = 3.

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    " Only error messages
    DELETE lt_lines WHERE severity <> 'E'
                      AND severity <> 'W'.
    " Remove "Return code..." message
    DELETE lt_lines WHERE class = 'D0' AND number = '319'.

    LOOP AT lt_lines ASSIGNING <ls_line>.
      ii_log->add( iv_msg    = <ls_line>-line
                   iv_type   = <ls_line>-severity
                   iv_class  = <ls_line>-class
                   iv_number = |{ <ls_line>-number }| ).
    ENDLOOP.

    ii_log->add_info( |View complete activation log in program RSPUTPRT (type D, log name { iv_logname })| ).

  ENDMETHOD.

  METHOD add_item.
    add( iv_type = is_item-obj_type
         iv_name = is_item-obj_name ).
  ENDMETHOD.

  METHOD clear.
    CLEAR gt_objects.
    CLEAR gt_classes.
  ENDMETHOD.

  METHOD get_ddic_type.

    DATA lv_obj_name TYPE e071-obj_name.

    ev_type = iv_obj_type.

    IF ev_type = 'INDX' OR ev_type = 'XINX' OR ev_type = 'MCID'.
      lv_obj_name = iv_obj_name. "cast

      CALL FUNCTION 'DD_E071_TO_DD'
        EXPORTING
          object        = ev_type
          obj_name      = lv_obj_name
        IMPORTING
          name          = ev_name
          id            = ev_id
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ELSE.
      ev_name = iv_obj_name.
    ENDIF.

  ENDMETHOD.

  METHOD is_active.

    " Checks if object is active or not
    "
    " Note: If object does not exist, this method returns true
    " is_not_inactive might be a better name but we avoid the double negative

    IF is_ddic_type( is_item-obj_type ) = abap_true
      AND c_para     NS is_item-obj_type
      AND c_switches NS is_item-obj_type.
      rv_active = is_ddic_active( is_item ).
    ELSE.
      rv_active = is_non_ddic_active( is_item ).
    ENDIF.

  ENDMETHOD.

  METHOD is_ddic_active.

    DATA:
      lv_type  TYPE ddobjtyp,
      lv_name  TYPE ddobjname,
      lv_id    TYPE ddobjectid,
      lv_state TYPE ddgotstate.

    get_ddic_type(
      EXPORTING
        iv_obj_type = is_item-obj_type
        iv_obj_name = is_item-obj_name
      IMPORTING
        ev_type     = lv_type
        ev_name     = lv_name
        ev_id       = lv_id ).

    " Check if an inactive version of the DDIC object exists
    " state = 'A' checks if an active version exists but does not detect new or modified objects
    " state = 'M' checks for all possible versions so we can find out if an inactive one exists
    " See documentation of the function module
    CALL FUNCTION 'DDIF_STATE_GET'
      EXPORTING
        type          = lv_type
        name          = lv_name
        id            = lv_id
        state         = 'M'
      IMPORTING
        gotstate      = lv_state
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    rv_active = boolc( sy-subrc = 0 AND ( lv_state = '' OR lv_state = 'A' ) ).

  ENDMETHOD.

  METHOD is_ddic_type.

    " Determine if object can be handled by mass activation (see RADMASUTC form ma_tab_check)

    rv_result = abap_true.

    IF c_domain   NS iv_obj_type AND c_types      NS iv_obj_type AND
       c_technset NS iv_obj_type AND c_f4_objects NS iv_obj_type AND
       c_enqueue  NS iv_obj_type AND c_sqsc       NS iv_obj_type AND
       c_stob     NS iv_obj_type AND c_ntab       NS iv_obj_type AND
       c_ddls     NS iv_obj_type AND c_para       NS iv_obj_type AND
       c_switches NS iv_obj_type AND iv_obj_type <> c_enhd       AND
       c_aspect   NS iv_obj_type AND c_scalarfunc NS iv_obj_type.
      rv_result = abap_false.
    ENDIF.

  ENDMETHOD.

  METHOD is_non_ddic_active.

    DATA:
      lt_messages TYPE STANDARD TABLE OF sprot_u WITH DEFAULT KEY,
      ls_e071     TYPE e071,
      lt_e071     TYPE STANDARD TABLE OF e071 WITH DEFAULT KEY.

    ls_e071-object   = is_item-obj_type.
    ls_e071-obj_name = is_item-obj_name.
    INSERT ls_e071 INTO TABLE lt_e071.

    CALL FUNCTION 'RS_INACTIVE_OBJECTS_WARNING'
      EXPORTING
        suppress_protocol         = abap_false
        with_program_includes     = abap_false
        suppress_dictionary_check = abap_false
      TABLES
        p_e071                    = lt_e071
        p_xmsg                    = lt_messages.

    rv_active = boolc( lt_messages IS INITIAL ).

  ENDMETHOD.

  METHOD update_where_used.

    DATA: ls_class   LIKE LINE OF gt_classes,
          lo_cross   TYPE REF TO cl_wb_crossreference,
          ls_item    TYPE zif_abapgit_definitions=>ty_item,
          lv_msg     TYPE string,
          lv_error   TYPE c LENGTH 1,
          lv_include TYPE syrepid.

    LOOP AT gt_classes INTO ls_class.
      CASE ls_class-object.
        WHEN 'CLAS'.
          lv_include = cl_oo_classname_service=>get_classpool_name( ls_class-clsname ).
        WHEN 'INTF'.
          lv_include = cl_oo_classname_service=>get_interfacepool_name( ls_class-clsname ).
      ENDCASE.

      CREATE OBJECT lo_cross
        EXPORTING
          p_name    = lv_include
          p_include = lv_include.

      lo_cross->index_actualize( IMPORTING p_error = lv_error ).

      IF lv_error = abap_true.
        ls_item-obj_type = ls_class-object.
        ls_item-obj_name = ls_class-clsname.
        lv_msg = |Error updating where-used list for { ls_item-obj_type } { ls_item-obj_name }.|
          && | Check for syntax errors|.
        ii_log->add(
          iv_msg  = lv_msg
          is_item = ls_item ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD use_new_activation_logic.

    IF zcl_abapinst_factory=>get_function_module( )->function_exists( 'DD_MASS_ACT_C3' ) = abap_true.
      rv_use_new_activation_logic = abap_true.
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_objects_super IMPLEMENTATION.

  METHOD clear_abap_language_version.

    " Used during serializing of objects
    IF ms_item-abap_language_version = zcl_abapgit_abap_language_vers=>c_no_abap_language_version.
      " Ignore ABAP language version
      CLEAR cv_abap_language_version.
    ELSEIF ms_item-abap_language_version <> zcl_abapgit_abap_language_vers=>c_any_abap_language_version.
      " Check if ABAP language version matches repository setting
      zcl_abapgit_abap_language_vers=>check_abap_language_version(
        iv_abap_language_version = cv_abap_language_version
        is_item                  = ms_item ).
    ENDIF.

  ENDMETHOD.

  METHOD constructor.
    ms_item = is_item.
    ASSERT NOT ms_item IS INITIAL.
    mv_language = iv_language.
    ASSERT NOT mv_language IS INITIAL.

    IF io_files IS NOT INITIAL.
      mo_files = io_files.
    ELSE.
      mo_files = zcl_abapgit_objects_files=>new( is_item ). " New file collection
    ENDIF.

    IF io_i18n_params IS NOT INITIAL.
      mo_i18n_params = io_i18n_params.
    ELSE.
      mo_i18n_params = zcl_abapgit_i18n_params=>new( ). " All defaults
    ENDIF.

  ENDMETHOD.

  METHOD corr_insert.

    DATA: lv_object       TYPE trobj_name,
          lv_object_class TYPE tadir-object.

    IF ig_object_class IS NOT INITIAL.
      lv_object_class = ig_object_class.
      IF ig_object_class = 'DICT'.
        CONCATENATE ms_item-obj_type ms_item-obj_name INTO lv_object.
      ELSE.
        lv_object = ms_item-obj_name.
      ENDIF.
    ELSE.
      lv_object_class = ms_item-obj_type.
      lv_object       = ms_item-obj_name.
    ENDIF.

    zcl_abapinst_factory=>get_cts_api( )->insert_transport_object(
      iv_object   = lv_object_class
      iv_obj_name = lv_object
      iv_package  = iv_package
      iv_language = mv_language ).

  ENDMETHOD.

  METHOD delete_ddic.

    DATA: lv_objname TYPE rsedd0-ddobjname,
          lv_objtype TYPE rsedd0-ddobjtype.

    lv_objname = ms_item-obj_name.
    lv_objtype = iv_objtype.

    TRY.
        CALL FUNCTION 'RS_DD_DELETE_OBJ'
          EXPORTING
            no_ask               = iv_no_ask
            objname              = lv_objname
            objtype              = lv_objtype
            no_ask_delete_append = iv_no_ask_delete_append
          EXCEPTIONS
            not_executed         = 1
            object_not_found     = 2
            object_not_specified = 3
            permission_failure   = 4
            dialog_needed        = 5
            OTHERS               = 6 ##FM_SUBRC_OK.
      CATCH cx_sy_dyn_call_param_not_found.
        TRY.
            " try to force deletion for APPENDs
            CALL FUNCTION 'RS_DD_DELETE_OBJ'
              EXPORTING
                no_ask               = iv_no_ask
                objname              = lv_objname
                objtype              = lv_objtype
                aie_force_deletion   = iv_no_ask_delete_append
              EXCEPTIONS
                not_executed         = 1
                object_not_found     = 2
                object_not_specified = 3
                permission_failure   = 4
                dialog_needed        = 5
                OTHERS               = 6 ##FM_SUBRC_OK.
          CATCH cx_sy_dyn_call_param_not_found.
            " no_ask_delete_append and aie_force_deletion not available in lower releases
            CALL FUNCTION 'RS_DD_DELETE_OBJ'
              EXPORTING
                no_ask               = iv_no_ask
                objname              = lv_objname
                objtype              = lv_objtype
              EXCEPTIONS
                not_executed         = 1
                object_not_found     = 2
                object_not_specified = 3
                permission_failure   = 4
                dialog_needed        = 5
                OTHERS               = 6 ##FM_SUBRC_OK.
        ENDTRY.
    ENDTRY.

    IF sy-subrc = 5.
      zcx_abapgit_exception=>raise( |Object { ms_item-obj_type } { ms_item-obj_name
                                    } has dependencies and must be deleted manually| ).
    ELSEIF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Error deleting { ms_item-obj_type } { ms_item-obj_name }| ).
    ENDIF.

  ENDMETHOD.

  METHOD delete_longtexts.

    zcl_abapinst_factory=>get_longtexts( )->delete(
      iv_longtext_id = iv_longtext_id
      iv_object_name = ms_item-obj_name ).

  ENDMETHOD.

  METHOD deserialize_longtexts.

    zcl_abapinst_factory=>get_longtexts( )->deserialize(
      ii_xml           = ii_xml
      iv_longtext_name = iv_longtext_name
      iv_object_name   = ms_item-obj_name
      iv_longtext_id   = iv_longtext_id
      iv_main_language = mv_language ).

  ENDMETHOD.

  METHOD exists_a_lock_entry_for.

    DATA: lt_lock_entries TYPE STANDARD TABLE OF seqg3.
    DATA: lv_argument TYPE seqg3-garg.

    IF iv_prefix IS INITIAL.
      lv_argument = iv_argument.
    ELSE.
      lv_argument = |{ iv_prefix  }{ iv_argument }|.
      OVERLAY lv_argument WITH '                                          '.
      lv_argument = lv_argument && '*'.
    ENDIF.

    CALL FUNCTION 'ENQUEUE_READ'
      EXPORTING
        guname                = '*'
        garg                  = lv_argument
      TABLES
        enq                   = lt_lock_entries
      EXCEPTIONS
        communication_failure = 1
        system_failure        = 2
        OTHERS                = 3.

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    READ TABLE lt_lock_entries TRANSPORTING NO FIELDS
                               WITH KEY gobj = iv_lock_object.
    IF sy-subrc = 0.
      rv_exists_a_lock_entry = abap_true.
    ENDIF.

  ENDMETHOD.

  METHOD get_accessed_files.
    rt_files = mo_files->get_accessed_files( ).
  ENDMETHOD.

  METHOD get_metadata.

    DATA: lv_class TYPE string.

    lv_class = cl_abap_classdescr=>describe_by_object_ref( me )->get_relative_name( ).

    REPLACE FIRST OCCURRENCE OF 'ZCL_ABAPGIT' IN lv_class WITH 'LCL'.

    rs_metadata-class = lv_class.
    rs_metadata-version = 'v1.0.0'.

  ENDMETHOD.

  METHOD is_active.

    rv_active = zcl_abapgit_objects_activation=>is_active( ms_item ).

  ENDMETHOD.

  METHOD serialize_longtexts.

    zcl_abapinst_factory=>get_longtexts( )->serialize(
      iv_object_name   = ms_item-obj_name
      iv_longtext_name = iv_longtext_name
      iv_longtext_id   = iv_longtext_id
      it_dokil         = it_dokil
      io_i18n_params   = mo_i18n_params
      ii_xml           = ii_xml ).

  ENDMETHOD.

  METHOD set_abap_language_version.

    " Used during deserializing of objects
    IF ms_item-abap_language_version = zcl_abapgit_abap_language_vers=>c_no_abap_language_version.
      " ABAP language version is derived from object type and target package (see zcl_abapgit_objects->deserialize)
      cv_abap_language_version = ms_item-abap_language_version.
    ELSEIF ms_item-abap_language_version <> zcl_abapgit_abap_language_vers=>c_any_abap_language_version.
      " Check if ABAP language version matches repository setting
      zcl_abapgit_abap_language_vers=>check_abap_language_version(
        iv_abap_language_version = cv_abap_language_version
        is_item                  = ms_item ).
    ENDIF.

  ENDMETHOD.

  METHOD set_default_package.

    " In certain cases we need to set the package via ABAP memory
    " because we can't supply it via the APIs.
    "
    " Set default package, see function module RS_CORR_INSERT FORM get_current_devclass.
    "
    " We use ABAP memory instead the SET parameter because it is
    " more reliable. SET parameter doesn't work when multiple objects
    " are deserialized which uses the ABAP memory mechanism.
    " We don't need to reset the memory as it is done in above mentioned form routine.

    EXPORT current_devclass FROM iv_package TO MEMORY ID 'EUK'.

  ENDMETHOD.

  METHOD set_default_transport.

    " In certain cases we need to set the transport via ABAP memory
    " because we can't supply it via the APIs.
    "
    " See function module RS_CORR_INSERT

    EXPORT tasknr FROM iv_transport TO MEMORY ID 'EUT'.

  ENDMETHOD.

  METHOD tadir_delete.

    CALL FUNCTION 'TR_TADIR_INTERFACE'
      EXPORTING
        wi_delete_tadir_entry          = abap_true
        wi_tadir_pgmid                 = 'R3TR'
        wi_tadir_object                = ms_item-obj_type
        wi_tadir_obj_name              = ms_item-obj_name
        wi_test_modus                  = abap_false
      EXCEPTIONS
        tadir_entry_not_existing       = 1
        tadir_entry_ill_type           = 2
        no_systemname                  = 3
        no_systemtype                  = 4
        original_system_conflict       = 5
        object_reserved_for_devclass   = 6
        object_exists_global           = 7
        object_exists_local            = 8
        object_is_distributed          = 9
        obj_specification_not_unique   = 10
        no_authorization_to_delete     = 11
        devclass_not_existing          = 12
        simultanious_set_remove_repair = 13
        order_missing                  = 14
        no_modification_of_head_syst   = 15
        pgmid_object_not_allowed       = 16
        masterlanguage_not_specified   = 17
        devclass_not_specified         = 18
        specify_owner_unique           = 19
        loc_priv_objs_no_repair        = 20
        gtadir_not_reached             = 21
        object_locked_for_order        = 22
        change_of_class_not_allowed    = 23
        no_change_from_sap_to_tmp      = 24
        OTHERS                         = 25.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD tadir_insert.

    CALL FUNCTION 'TR_TADIR_INTERFACE'
      EXPORTING
        wi_test_modus                  = abap_false
        wi_tadir_pgmid                 = 'R3TR'
        wi_tadir_object                = ms_item-obj_type
        wi_tadir_obj_name              = ms_item-obj_name
        wi_tadir_author                = sy-uname
        wi_tadir_devclass              = iv_package
        wi_tadir_masterlang            = mv_language
        iv_delflag                     = abap_false
      EXCEPTIONS
        tadir_entry_not_existing       = 1
        tadir_entry_ill_type           = 2
        no_systemname                  = 3
        no_systemtype                  = 4
        original_system_conflict       = 5
        object_reserved_for_devclass   = 6
        object_exists_global           = 7
        object_exists_local            = 8
        object_is_distributed          = 9
        obj_specification_not_unique   = 10
        no_authorization_to_delete     = 11
        devclass_not_existing          = 12
        simultanious_set_remove_repair = 13
        order_missing                  = 14
        no_modification_of_head_syst   = 15
        pgmid_object_not_allowed       = 16
        masterlanguage_not_specified   = 17
        devclass_not_specified         = 18
        specify_owner_unique           = 19
        loc_priv_objs_no_repair        = 20
        gtadir_not_reached             = 21
        object_locked_for_order        = 22
        change_of_class_not_allowed    = 23
        no_change_from_sap_to_tmp      = 24
        OTHERS                         = 25.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_objects_bridge IMPLEMENTATION.

  METHOD constructor.

    DATA ls_objtype_map LIKE LINE OF gt_objtype_map.

    super->constructor(
      is_item        = is_item
      iv_language    = zif_abapgit_definitions=>c_english
      io_files       = io_files
      io_i18n_params = io_i18n_params ).

    initialize( ).

*    determine the responsible plugin
    READ TABLE gt_objtype_map INTO ls_objtype_map
      WITH TABLE KEY obj_typ = is_item-obj_type.
    IF sy-subrc = 0.
      CREATE OBJECT mo_plugin TYPE (ls_objtype_map-plugin_class).

      CALL METHOD mo_plugin->('SET_ITEM')
        EXPORTING
          iv_obj_type = is_item-obj_type
          iv_obj_name = is_item-obj_name.
    ELSE.
      RAISE EXCEPTION TYPE cx_sy_create_object_error
        EXPORTING
          classname = 'LCL_OBJECTS_BRIDGE'.
    ENDIF.
  ENDMETHOD.

  METHOD initialize.

    DATA lt_plugin_class    TYPE STANDARD TABLE OF seoclsname WITH DEFAULT KEY.
    DATA lv_plugin_class    LIKE LINE OF lt_plugin_class.
    DATA lo_plugin          TYPE REF TO object.
    DATA lt_plugin_obj_type TYPE STANDARD TABLE OF tadir-object WITH DEFAULT KEY.
    DATA ls_objtype_map     LIKE LINE OF gt_objtype_map.

    IF gv_init = abap_true.
      RETURN.
    ENDIF.
    gv_init = abap_true.

    SELECT clsname
      FROM seometarel
      INTO TABLE lt_plugin_class
      WHERE refclsname LIKE 'ZCL_ABAPGITP_OBJECT%'
      AND version = '1'
      ORDER BY clsname.                                   "#EC CI_SUBRC

    CLEAR gt_objtype_map.
    LOOP AT lt_plugin_class INTO lv_plugin_class
        WHERE table_line <> 'ZCL_ABAPGITP_OBJECT_BY_SOBJ'.
* have the generic plugin only as fallback
      TRY.
          CREATE OBJECT lo_plugin TYPE (lv_plugin_class).
        CATCH cx_sy_create_object_error.
          CONTINUE. ">>>>>>>>>>>>>>
      ENDTRY.

      CALL METHOD lo_plugin->('GET_SUPPORTED_OBJ_TYPES')
        IMPORTING
          rt_obj_type = lt_plugin_obj_type.

      ls_objtype_map-plugin_class = lv_plugin_class.
      LOOP AT lt_plugin_obj_type INTO ls_objtype_map-obj_typ.
        INSERT ls_objtype_map INTO TABLE gt_objtype_map.
        IF sy-subrc <> 0.
* No exception in class-constructor possible.
* Anyway, a shortdump is more appropriate in this case
          ASSERT 'There must not be' =
            |multiple abapGit-Plugins for the same object type {
            ls_objtype_map-obj_typ }|.
        ENDIF.
      ENDLOOP.
    ENDLOOP. "at plugins

* and the same for the generic plugin if exists
* have the generic plugin only as fallback
    LOOP AT lt_plugin_class INTO lv_plugin_class
        WHERE table_line = 'ZCL_ABAPGITP_OBJECT_BY_SOBJ'.
      CREATE OBJECT lo_plugin TYPE (lv_plugin_class).

      CALL METHOD lo_plugin->('GET_SUPPORTED_OBJ_TYPES')
        RECEIVING
          rt_obj_type = lt_plugin_obj_type.

      ls_objtype_map-plugin_class = lv_plugin_class.
      LOOP AT lt_plugin_obj_type INTO ls_objtype_map-obj_typ.
        INSERT ls_objtype_map INTO TABLE gt_objtype_map. "knowingly ignore the subrc
      ENDLOOP.
    ENDLOOP. "at plugins

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    rv_user = c_user_unknown. " todo
  ENDMETHOD.

  METHOD zif_abapgit_object~delete.
    DATA lx_plugin TYPE REF TO cx_static_check.

    TRY.
        CALL METHOD mo_plugin->('ZIF_ABAPGITP_PLUGIN~DELETE').
      CATCH cx_static_check INTO lx_plugin.
        zcx_abapgit_exception=>raise( lx_plugin->get_text( ) ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lx_plugin        TYPE REF TO cx_static_check.

    TRY.
        CALL METHOD mo_plugin->('WRAP_DESERIALIZE')
          EXPORTING
            iv_package = iv_package
            io_xml     = io_xml.
      CATCH cx_static_check INTO lx_plugin.
        zcx_abapgit_exception=>raise( lx_plugin->get_text( ) ).
    ENDTRY.
  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    CALL METHOD mo_plugin->('ZIF_ABAPGITP_PLUGIN~EXISTS')
      RECEIVING
        rv_bool = rv_bool.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.

    DATA ls_meta TYPE ty_metadata.

    CALL METHOD mo_plugin->('ZIF_ABAPGITP_PLUGIN~GET_METADATA')
      RECEIVING
        rs_metadata = ls_meta.

    IF ls_meta-late_deser = abap_true.
      APPEND zif_abapgit_object=>gc_step_id-late TO rt_steps.
    ELSEIF ls_meta-ddic = abap_true.
      APPEND zif_abapgit_object=>gc_step_id-ddic TO rt_steps.
    ELSE.
      APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.

    DATA ls_meta TYPE ty_metadata.

    CALL METHOD mo_plugin->('ZIF_ABAPGITP_PLUGIN~GET_METADATA')
      RECEIVING
        rs_metadata = ls_meta.

    MOVE-CORRESPONDING ls_meta TO rs_metadata.

  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = abap_true.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    CALL METHOD mo_plugin->('ZIF_ABAPGITP_PLUGIN~JUMP').
    rv_exit = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    CALL METHOD mo_plugin->('WRAP_SERIALIZE')
      EXPORTING
        io_xml = io_xml.

  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_OBJECTS_FACTORY IMPLEMENTATION.

  METHOD get_gui_jumper.

    IF gi_gui_jumper IS INITIAL.
      CREATE OBJECT gi_gui_jumper TYPE zcl_abapgit_gui_jumper.
    ENDIF.

    ri_gui_jumper = gi_gui_jumper.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_xml IMPLEMENTATION.

  METHOD constructor.
    mi_ixml     = cl_ixml=>create( ).
    mi_xml_doc  = mi_ixml->create_document( ).
    mv_filename = iv_filename.
  ENDMETHOD.

  METHOD error.

    IF ii_parser->num_errors( ) <> 0.
      raise_exception_for( ii_parser->get_error( 0 ) ).
    ENDIF.

    IF mv_filename IS INITIAL.
      zcx_abapgit_exception=>raise( |Error while parsing XML| ).
    ELSE.
      zcx_abapgit_exception=>raise( |Error while parsing XML file { mv_filename }| ).
    ENDIF.

  ENDMETHOD.

  METHOD parse.

    DATA: li_stream_factory TYPE REF TO if_ixml_stream_factory,
          li_istream        TYPE REF TO if_ixml_istream,
          li_element        TYPE REF TO if_ixml_element,
          li_version        TYPE REF TO if_ixml_node,
          li_parser         TYPE REF TO if_ixml_parser.

    ASSERT NOT iv_xml IS INITIAL.

    li_stream_factory = mi_ixml->create_stream_factory( ).
    li_istream = li_stream_factory->create_istream_string( iv_xml ).
    li_parser = mi_ixml->create_parser( stream_factory = li_stream_factory
                                        istream        = li_istream
                                        document       = mi_xml_doc ).
    li_parser->add_strip_space_element( ).
    IF li_parser->parse( ) <> 0.
      error( li_parser ).
    ENDIF.

    li_istream->close( ).

    li_element = mi_xml_doc->find_from_name_ns( depth = 0
                                                name = c_abapgit_tag ).
    li_version = li_element->if_ixml_node~get_attributes(
      )->get_named_item_ns( c_attr_version ).
    IF li_version->get_value( ) <> zif_abapgit_version=>c_xml_version.
      raise_version_mismatch( li_version->get_value( ) ).
    ENDIF.

* buffer serializer metadata. Git node will be removed lateron
    ms_metadata-class   = li_element->get_attribute_ns( c_attr_serializer ).
    ms_metadata-version = li_element->get_attribute_ns( c_attr_serializer_version ).

  ENDMETHOD.

  METHOD raise_exception_for.
    DATA lv_message TYPE string.

    lv_message = |XML parser error: { ii_error->get_reason( ) }, | &&
                 |Line { ii_error->get_line( ) } | &&
                 |Col. { ii_error->get_column( ) }|.

    IF mv_filename IS NOT INITIAL.
      lv_message = lv_message && | File { mv_filename }|.
    ENDIF.

    zcx_abapgit_exception=>raise( lv_message ).

  ENDMETHOD.

  METHOD raise_version_mismatch.

    DATA lv_text TYPE string.

    lv_text = |The XML versions do not match, expected: { zif_abapgit_version=>c_xml_version }, actual: { iv_vers }|.

    IF mv_filename IS NOT INITIAL.
      lv_text = lv_text && |, file: { mv_filename }|.
    ENDIF.

    lv_text = lv_text && | (see https://docs.abapgit.org/other-xml-mismatch.html)|.

    zcx_abapgit_exception=>raise( lv_text ).

  ENDMETHOD.

  METHOD to_xml.
* will render to codepage UTF-16

    DATA: li_ostream       TYPE REF TO if_ixml_ostream,
          li_renderer      TYPE REF TO if_ixml_renderer,
          li_streamfactory TYPE REF TO if_ixml_stream_factory.

    li_streamfactory = mi_ixml->create_stream_factory( ).

    li_ostream = li_streamfactory->create_ostream_cstring( rv_xml ).

    li_renderer = mi_ixml->create_renderer( ostream  = li_ostream
                                            document = mi_xml_doc ).
    li_renderer->set_normalizing( iv_normalize ).

    li_renderer->render( ).

    " handling of BOM moved to zcl_abapgit_convert=>string_to_xstring_utf8_bom

  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_XML_INPUT IMPLEMENTATION.

  METHOD constructor.

    super->constructor( iv_filename ).
    parse( iv_xml ).
    fix_xml( ).

  ENDMETHOD.

  METHOD fix_xml.

    DATA: li_git  TYPE REF TO if_ixml_element,
          li_abap TYPE REF TO if_ixml_node.

    li_git ?= mi_xml_doc->find_from_name_ns( depth = 0
                                             name = c_abapgit_tag ).
    li_abap = li_git->get_first_child( ).

    mi_xml_doc->get_root( )->remove_child( li_git ).
    mi_xml_doc->get_root( )->append_child( li_abap ).

  ENDMETHOD.

  METHOD zif_abapgit_xml_input~get_metadata.
    rs_metadata = ms_metadata.
  ENDMETHOD.

  METHOD zif_abapgit_xml_input~get_raw.
    ri_raw = mi_xml_doc.
  ENDMETHOD.

  METHOD zif_abapgit_xml_input~read.

    DATA: lx_error TYPE REF TO cx_transformation_error,
          lt_rtab  TYPE abap_trans_resbind_tab.

    FIELD-SYMBOLS: <ls_rtab> LIKE LINE OF lt_rtab.

    ASSERT NOT iv_name IS INITIAL.

    CLEAR cg_data. "Initialize result to avoid problems with empty values

    APPEND INITIAL LINE TO lt_rtab ASSIGNING <ls_rtab>.
    <ls_rtab>-name = iv_name.
    GET REFERENCE OF cg_data INTO <ls_rtab>-value.

    TRY.
        CALL TRANSFORMATION id
          OPTIONS value_handling = 'accept_data_loss'
          SOURCE XML mi_xml_doc
          RESULT (lt_rtab).
      CATCH cx_transformation_error INTO lx_error.
        IF mv_filename IS INITIAL.
          zcx_abapgit_exception=>raise( lx_error->if_message~get_text( ) ).
        ELSE.
          zcx_abapgit_exception=>raise( |File { mv_filename }: { lx_error->if_message~get_text( ) }| ).
        ENDIF.
    ENDTRY.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_objects_files IMPLEMENTATION.

  METHOD add.
    APPEND is_file TO mt_files.
  ENDMETHOD.

  METHOD add_abap.

    DATA: lv_source TYPE string,
          ls_file   TYPE zif_abapgit_git_definitions=>ty_file.

    CONCATENATE LINES OF it_abap INTO lv_source SEPARATED BY cl_abap_char_utilities=>newline.
* when editing files via eg. GitHub web interface it adds a newline at end of file
    lv_source = lv_source && cl_abap_char_utilities=>newline.

    ls_file-path = '/'.
    ls_file-filename = zcl_abapgit_filename_logic=>object_to_file(
      is_item  = ms_item
      iv_extra = iv_extra
      iv_ext   = 'abap' ).
    ls_file-data = zcl_abapgit_convert=>string_to_xstring_utf8( lv_source ).

    APPEND ls_file TO mt_files.

  ENDMETHOD.

  METHOD add_i18n_file.

    DATA ls_file TYPE zif_abapgit_git_definitions=>ty_file.

    ls_file-data = ii_i18n_file->render( ).
    IF ls_file-data IS INITIAL.
      RETURN. " Don't add empty files
    ENDIF.

    ls_file-path     = '/'.
    ls_file-filename = zcl_abapgit_filename_logic=>object_to_i18n_file(
      is_item  = ms_item
      iv_lang  = ii_i18n_file->lang( )
      iv_ext   = ii_i18n_file->ext( ) ).

    APPEND ls_file TO mt_files.

  ENDMETHOD.

  METHOD add_raw.

    DATA: ls_file TYPE zif_abapgit_git_definitions=>ty_file.

    ls_file-path     = '/'.
    ls_file-data     = iv_data.
    ls_file-filename = zcl_abapgit_filename_logic=>object_to_file(
      is_item  = ms_item
      iv_extra = iv_extra
      iv_ext   = iv_ext ).

    APPEND ls_file TO mt_files.

  ENDMETHOD.

  METHOD add_string.

    DATA: ls_file TYPE zif_abapgit_git_definitions=>ty_file.

    ls_file-path = '/'.
    ls_file-filename = zcl_abapgit_filename_logic=>object_to_file(
      is_item  = ms_item
      iv_extra = iv_extra
      iv_ext   = iv_ext ).
    ls_file-data = zcl_abapgit_convert=>string_to_xstring_utf8( iv_string ).

    APPEND ls_file TO mt_files.

  ENDMETHOD.

  METHOD add_xml.

    DATA: lv_xml  TYPE string,
          ls_file TYPE zif_abapgit_git_definitions=>ty_file.

    lv_xml = ii_xml->render( iv_normalize = iv_normalize
                             is_metadata = is_metadata ).
    ls_file-path = '/'.

    ls_file-filename = zcl_abapgit_filename_logic=>object_to_file(
      is_item  = ms_item
      iv_extra = iv_extra
      iv_ext   = 'xml' ).

    REPLACE FIRST OCCURRENCE
      OF REGEX '<\?xml version="1\.0" encoding="[\w-]+"\?>'
      IN lv_xml
      WITH '<?xml version="1.0" encoding="utf-8"?>'.
    ASSERT sy-subrc = 0.

    ls_file-data = zcl_abapgit_convert=>string_to_xstring_utf8_bom( lv_xml ).

    APPEND ls_file TO mt_files.
  ENDMETHOD.

  METHOD constructor.
    ms_item = is_item.
    mv_path = iv_path.
  ENDMETHOD.

  METHOD contains_file.
    DATA: lv_filename TYPE string.

    lv_filename = zcl_abapgit_filename_logic=>object_to_file(
      is_item  = ms_item
      iv_extra = iv_extra
      iv_ext   = iv_ext ).

    IF mv_path IS NOT INITIAL.
      READ TABLE mt_files TRANSPORTING NO FIELDS
          WITH KEY file_path
          COMPONENTS path     = mv_path
                     filename = lv_filename.
    ELSE.
      READ TABLE mt_files TRANSPORTING NO FIELDS
          WITH KEY file
          COMPONENTS filename = lv_filename.
    ENDIF.

    IF sy-subrc = 0.
      rv_present = abap_true.
    ENDIF.
  ENDMETHOD.

  METHOD get_accessed_files.
    rt_files = mt_accessed_files.
  ENDMETHOD.

  METHOD get_files.
    rt_files = mt_files.
  ENDMETHOD.

  METHOD get_file_pattern.
    rv_pattern = zcl_abapgit_filename_logic=>object_to_file(
      is_item  = ms_item
      iv_ext   = '*' ).
    " Escape special characters for use with 'covers pattern' (CP)
    REPLACE ALL OCCURRENCES OF '#' IN rv_pattern WITH '##'.
    REPLACE ALL OCCURRENCES OF '+' IN rv_pattern WITH '#+'.
  ENDMETHOD.

  METHOD is_json_metadata.

    DATA lv_pattern TYPE string.

    FIELD-SYMBOLS <ls_file> LIKE LINE OF mt_files.

    lv_pattern = |*.{ to_lower( ms_item-obj_type ) }.json|.

    LOOP AT mt_files ASSIGNING <ls_file> WHERE filename CP lv_pattern.
      rv_result = abap_true.
      EXIT.
    ENDLOOP.

  ENDMETHOD.

  METHOD mark_accessed.

    FIELD-SYMBOLS <ls_accessed> LIKE LINE OF mt_accessed_files.

    READ TABLE mt_accessed_files TRANSPORTING NO FIELDS
      WITH KEY path = iv_path filename = iv_file.
    IF sy-subrc > 0. " Not found ? -> Add
      APPEND INITIAL LINE TO mt_accessed_files ASSIGNING <ls_accessed>.
      <ls_accessed>-path     = iv_path.
      <ls_accessed>-filename = iv_file.
      <ls_accessed>-sha1     = iv_sha1.
    ENDIF.

  ENDMETHOD.

  METHOD new.
    CREATE OBJECT ro_files
      EXPORTING
        is_item = is_item
        iv_path = iv_path.
  ENDMETHOD.

  METHOD read_abap.

    DATA: lv_filename TYPE string,
          lv_data     TYPE xstring,
          lv_abap     TYPE string.

    lv_filename = zcl_abapgit_filename_logic=>object_to_file(
      is_item  = ms_item
      iv_extra = iv_extra
      iv_ext   = 'abap' ).

    lv_data = read_file( iv_filename = lv_filename
                         iv_error    = iv_error ).

    IF lv_data IS INITIAL. " Post-handling of iv_error = false
      RETURN.
    ENDIF.

    lv_abap = zcl_abapgit_convert=>xstring_to_string_utf8( lv_data ).

    SPLIT lv_abap AT cl_abap_char_utilities=>newline INTO TABLE rt_abap.

  ENDMETHOD.

  METHOD read_file.

    FIELD-SYMBOLS <ls_file>     LIKE LINE OF mt_files.

    IF mv_path IS NOT INITIAL.
      READ TABLE mt_files ASSIGNING <ls_file>
          WITH KEY file_path
          COMPONENTS path     = mv_path
                     filename = iv_filename.
    ELSE.
      READ TABLE mt_files ASSIGNING <ls_file>
          WITH KEY file
          COMPONENTS filename = iv_filename.
    ENDIF.

    IF sy-subrc <> 0.
      IF iv_error = abap_true.
        zcx_abapgit_exception=>raise( |File not found: { iv_filename }| ).
      ELSE.
        RETURN.
      ENDIF.
    ENDIF.

    " Update access table
    mark_accessed(
      iv_path = <ls_file>-path
      iv_file = <ls_file>-filename
      iv_sha1 = <ls_file>-sha1 ).

    rv_data = <ls_file>-data.

  ENDMETHOD.

  METHOD read_i18n_files.

    DATA:
      lv_lang       TYPE laiso,
      lv_ext        TYPE string,
      lo_po         TYPE REF TO zcl_abapgit_po_file,
      lo_properties TYPE REF TO zcl_abapgit_properties_file.

    FIELD-SYMBOLS <ls_file> LIKE LINE OF mt_files.

    LOOP AT mt_files ASSIGNING <ls_file>.

      zcl_abapgit_filename_logic=>i18n_file_to_object(
        EXPORTING
          iv_path     = <ls_file>-path
          iv_filename = <ls_file>-filename
        IMPORTING
          ev_lang     = lv_lang
          ev_ext      = lv_ext ).

      CASE lv_ext.
        WHEN 'po'.
          CREATE OBJECT lo_po EXPORTING iv_lang = lv_lang.
          lo_po->parse( <ls_file>-data ).
          APPEND lo_po TO rt_i18n_files.
        WHEN 'properties'.
          CREATE OBJECT lo_properties EXPORTING iv_lang = lv_lang.
          lo_properties->parse( <ls_file>-data ).
          APPEND lo_properties TO rt_i18n_files.
        WHEN OTHERS.
          CONTINUE. " Unsupported i18n file type
      ENDCASE.

      mark_accessed(
        iv_path = <ls_file>-path
        iv_file = <ls_file>-filename
        iv_sha1 = <ls_file>-sha1 ).

    ENDLOOP.

  ENDMETHOD.

  METHOD read_raw.

    DATA: lv_filename TYPE string.

    lv_filename = zcl_abapgit_filename_logic=>object_to_file(
      is_item  = ms_item
      iv_extra = iv_extra
      iv_ext   = iv_ext ).

    rv_data = read_file( lv_filename ).

  ENDMETHOD.

  METHOD read_string.

    DATA: lv_filename TYPE string,
          lv_data     TYPE xstring.

    lv_filename = zcl_abapgit_filename_logic=>object_to_file(
      is_item  = ms_item
      iv_extra = iv_extra
      iv_ext   = iv_ext ).

    lv_data = read_file( lv_filename ).

    rv_string = zcl_abapgit_convert=>xstring_to_string_utf8( lv_data ).

  ENDMETHOD.

  METHOD read_xml.

    DATA: lv_filename TYPE string,
          lv_data     TYPE xstring,
          lv_xml      TYPE string.

    lv_filename = zcl_abapgit_filename_logic=>object_to_file(
      is_item  = ms_item
      iv_extra = iv_extra
      iv_ext   = 'xml' ).

    lv_data = read_file( lv_filename ).

    lv_xml = zcl_abapgit_convert=>xstring_to_string_utf8( lv_data ).

    CREATE OBJECT ri_xml
      TYPE zcl_abapgit_xml_input
      EXPORTING
        iv_xml      = lv_xml
        iv_filename = lv_filename.

  ENDMETHOD.

  METHOD set_files.

    FIELD-SYMBOLS: <ls_file> LIKE LINE OF it_files.

    CLEAR mt_files.

    " Set only files matching the pattern for this object
    " If a path has been defined in the constructor, then the path has to match, too
    LOOP AT it_files ASSIGNING <ls_file> WHERE filename CP get_file_pattern( ).
      IF mv_path IS INITIAL.
        INSERT <ls_file> INTO TABLE mt_files.
      ELSEIF mv_path = <ls_file>-path.
        INSERT <ls_file> INTO TABLE mt_files.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_objects_injector IMPLEMENTATION.

  METHOD set_gui_jumper.

    zcl_abapgit_objects_factory=>gi_gui_jumper = ii_gui_jumper.

  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_XML_OUTPUT IMPLEMENTATION.

  METHOD build_asx_node.

    DATA: li_attr TYPE REF TO if_ixml_attribute.

    ri_element = mi_xml_doc->create_element_ns(
      name   = 'abap'
      prefix = 'asx' ).

    li_attr = mi_xml_doc->create_attribute_ns( 'version' ).
    li_attr->if_ixml_node~set_value( '1.0' ).
    ri_element->set_attribute_node_ns( li_attr ).

    li_attr = mi_xml_doc->create_attribute_ns(
      name   = 'asx'
      prefix = 'xmlns' ).
    li_attr->if_ixml_node~set_value( 'http://www.sap.com/abapxml' ).
    ri_element->set_attribute_node_ns( li_attr ).

  ENDMETHOD.

  METHOD zif_abapgit_xml_output~add.

    DATA: li_node TYPE REF TO if_ixml_node,
          li_doc  TYPE REF TO if_ixml_document,
          lt_stab TYPE abap_trans_srcbind_tab.

    FIELD-SYMBOLS: <ls_stab> LIKE LINE OF lt_stab.

    ASSERT NOT iv_name IS INITIAL.

    IF ig_data IS INITIAL.
      RETURN.
    ENDIF.

    APPEND INITIAL LINE TO lt_stab ASSIGNING <ls_stab>.
    <ls_stab>-name = iv_name.
    GET REFERENCE OF ig_data INTO <ls_stab>-value.

    li_doc = cl_ixml=>create( )->create_document( ).

    CALL TRANSFORMATION id
      OPTIONS initial_components = 'suppress'
      SOURCE (lt_stab)
      RESULT XML li_doc.

    li_node = mi_xml_doc->get_root( )->get_first_child( ).
    IF li_node IS BOUND.
      mi_xml_doc->get_root( )->get_first_child( )->get_first_child( )->append_child(
        li_doc->get_root( )->get_first_child( )->get_first_child( )->get_first_child( ) ).
    ELSE.
      mi_xml_doc->get_root( )->append_child( li_doc->get_root( )->get_first_child( ) ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_xml_output~add_xml.

    DATA: li_element TYPE REF TO if_ixml_element.

    li_element = mi_xml_doc->create_element( iv_name ).
    li_element->append_child( ii_xml ).

    mi_xml_doc->get_root( )->get_first_child( )->get_first_child( )->append_child( li_element ).

  ENDMETHOD.

  METHOD zif_abapgit_xml_output~render.

    DATA: li_git  TYPE REF TO if_ixml_element,
          li_abap TYPE REF TO if_ixml_element.

    IF mi_raw IS INITIAL.
      li_abap ?= mi_xml_doc->get_root( )->get_first_child( ).
      mi_xml_doc->get_root( )->remove_child( li_abap ).
      IF li_abap IS INITIAL.
        li_abap = build_asx_node( ).
      ENDIF.
    ELSE.
      li_abap = mi_raw.
    ENDIF.

    li_git = mi_xml_doc->create_element( c_abapgit_tag ).
    li_git->set_attribute( name = c_attr_version
                           value = zif_abapgit_version=>c_xml_version ).
    IF NOT is_metadata IS INITIAL.
      li_git->set_attribute( name  = c_attr_serializer
                             value = is_metadata-class ).
      li_git->set_attribute( name  = c_attr_serializer_version
                             value = is_metadata-version ).
    ENDIF.
    li_git->append_child( li_abap ).
    mi_xml_doc->get_root( )->append_child( li_git ).

    rv_xml = to_xml( iv_normalize ).

  ENDMETHOD.

  METHOD zif_abapgit_xml_output~set_raw.
    mi_raw = ii_raw.
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_objects_program IMPLEMENTATION.

  METHOD add_tpool.

    FIELD-SYMBOLS: <ls_tpool_in>  LIKE LINE OF it_tpool,
                   <ls_tpool_out> LIKE LINE OF rt_tpool.

    LOOP AT it_tpool ASSIGNING <ls_tpool_in>.
      APPEND INITIAL LINE TO rt_tpool ASSIGNING <ls_tpool_out>.
      MOVE-CORRESPONDING <ls_tpool_in> TO <ls_tpool_out>.
      IF <ls_tpool_out>-id = 'S'.
        <ls_tpool_out>-split = <ls_tpool_out>-entry.
        <ls_tpool_out>-entry = <ls_tpool_out>-entry+8.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD auto_correct_cua_adm.
    " issue #1807 automatic correction of CUA interfaces saved incorrectly in the past (ADM was not saved in the XML)

    CONSTANTS:
      lc_num_n_space TYPE string VALUE ' 0123456789',
      lc_num_only    TYPE string VALUE '0123456789'.

    FIELD-SYMBOLS:
      <ls_pfk> TYPE rsmpe_pfk,
      <ls_act> TYPE rsmpe_act,
      <ls_men> TYPE rsmpe_men.

    IF cs_adm IS NOT INITIAL
        AND cs_adm-actcode CO lc_num_n_space
        AND cs_adm-mencode CO lc_num_n_space
        AND cs_adm-pfkcode CO lc_num_n_space. "Check performed in form check_adm of include LSMPIF03
      RETURN.
    ENDIF.

    LOOP AT is_cua-act ASSIGNING <ls_act>.
      IF <ls_act>-code+6(14) IS INITIAL AND <ls_act>-code(6) CO lc_num_only.
        cs_adm-actcode = <ls_act>-code.
      ENDIF.
    ENDLOOP.

    LOOP AT is_cua-men ASSIGNING <ls_men>.
      IF <ls_men>-code+6(14) IS INITIAL AND <ls_men>-code(6) CO lc_num_only.
        cs_adm-mencode = <ls_men>-code.
      ENDIF.
    ENDLOOP.

    LOOP AT is_cua-pfk ASSIGNING <ls_pfk>.
      IF <ls_pfk>-code+6(14) IS INITIAL AND <ls_pfk>-code(6) CO lc_num_only.
        cs_adm-pfkcode = <ls_pfk>-code.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD deserialize_cua.

    DATA: ls_tr_key TYPE trkey,
          ls_adm    TYPE rsmpe_adm.

    IF lines( is_cua-sta ) = 0
        AND lines( is_cua-fun ) = 0
        AND lines( is_cua-men ) = 0
        AND lines( is_cua-mtx ) = 0
        AND lines( is_cua-act ) = 0
        AND lines( is_cua-but ) = 0
        AND lines( is_cua-pfk ) = 0
        AND lines( is_cua-set ) = 0
        AND lines( is_cua-doc ) = 0
        AND lines( is_cua-tit ) = 0
        AND lines( is_cua-biv ) = 0.
      RETURN.
    ENDIF.

    SELECT SINGLE devclass INTO ls_tr_key-devclass
      FROM tadir
      WHERE pgmid = 'R3TR'
      AND object = ms_item-obj_type
      AND obj_name = ms_item-obj_name.                  "#EC CI_GENBUFF
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'not found in tadir' ).
    ENDIF.

    ls_tr_key-obj_type = ms_item-obj_type.
    ls_tr_key-obj_name = ms_item-obj_name.
    ls_tr_key-sub_type = 'CUAD'.
    ls_tr_key-sub_name = iv_program_name.

    ls_adm = is_cua-adm.
    auto_correct_cua_adm( EXPORTING is_cua = is_cua CHANGING cs_adm = ls_adm ).

    sy-tcode = 'SE41' ##WRITE_OK. " evil hack, workaround to handle fixes in note 2159455
    CALL FUNCTION 'RS_CUA_INTERNAL_WRITE'
      EXPORTING
        program   = iv_program_name
        language  = mv_language
        tr_key    = ls_tr_key
        adm       = ls_adm
        state     = c_state-inactive
      TABLES
        sta       = is_cua-sta
        fun       = is_cua-fun
        men       = is_cua-men
        mtx       = is_cua-mtx
        act       = is_cua-act
        but       = is_cua-but
        pfk       = is_cua-pfk
        set       = is_cua-set
        doc       = is_cua-doc
        tit       = is_cua-tit
        biv       = is_cua-biv
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc <> 0.
* if moving code from SAPlink, see https://github.com/abapGit/abapGit/issues/562
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    zcl_abapgit_objects_activation=>add(
      iv_type = 'CUAD'
      iv_name = iv_program_name ).

  ENDMETHOD.

  METHOD deserialize_dynpros.

    CONSTANTS lc_rpyty_force_off TYPE c LENGTH 1 VALUE '/'.

    DATA: lv_name            TYPE dwinactiv-obj_name,
          lt_d020s_to_delete TYPE TABLE OF d020s,
          ls_d020s           LIKE LINE OF lt_d020s_to_delete,
          lt_params          TYPE TABLE OF d023s,
          ls_dynpro          LIKE LINE OF it_dynpros.

    FIELD-SYMBOLS: <ls_field> TYPE rpy_dyfatc.

    " Delete DYNPROs which are not in the list
    CALL FUNCTION 'RS_SCREEN_LIST'
      EXPORTING
        dynnr     = ''
        progname  = ms_item-obj_name
      TABLES
        dynpros   = lt_d020s_to_delete
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc = 2.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    SORT lt_d020s_to_delete BY dnum ASCENDING.

* ls_dynpro is changed by the function module, a field-symbol will cause
* the program to dump since it_dynpros cannot be changed
    LOOP AT it_dynpros INTO ls_dynpro.

      READ TABLE lt_d020s_to_delete WITH KEY dnum = ls_dynpro-header-screen
        TRANSPORTING NO FIELDS
        BINARY SEARCH.
      IF sy-subrc = 0.
        DELETE lt_d020s_to_delete INDEX sy-tabix.
      ENDIF.

      " todo: kept for compatibility, remove after grace period #3680
      ls_dynpro-flow_logic = uncondense_flow(
        it_flow = ls_dynpro-flow_logic
        it_spaces = ls_dynpro-spaces ).

      IF ls_dynpro-flow_logic IS INITIAL.
        ls_dynpro-flow_logic = mo_files->read_abap( iv_extra = 'screen_' && ls_dynpro-header-screen ).
      ENDIF.

      LOOP AT ls_dynpro-fields ASSIGNING <ls_field>.
* if the DDIC element has a PARAMETER_ID and the flag "from_dict" is active
* the import will enable the SET-/GET_PARAM flag. In this case: "force off"
        IF <ls_field>-param_id IS NOT INITIAL
            AND <ls_field>-from_dict = abap_true.
          IF <ls_field>-set_param IS INITIAL.
            <ls_field>-set_param = lc_rpyty_force_off.
          ENDIF.
          IF <ls_field>-get_param IS INITIAL.
            <ls_field>-get_param = lc_rpyty_force_off.
          ENDIF.
        ENDIF.

* If the previous conditions are met the value 'F' will be taken over
* during de-serialization potentially overlapping other fields in the screen,
* we set the tag to the correct value 'X'
        IF <ls_field>-type = 'CHECK'
            AND <ls_field>-from_dict = abap_true
            AND <ls_field>-text IS INITIAL
            AND <ls_field>-modific IS INITIAL.
          <ls_field>-modific = 'X'.
        ENDIF.

        "fix for issue #2747:
        IF <ls_field>-foreignkey IS INITIAL.
          <ls_field>-foreignkey = lc_rpyty_force_off.
        ENDIF.

      ENDLOOP.

      IF ls_dynpro-header-type CA c_native_dynpro AND ls_dynpro-nat_header IS NOT INITIAL.
        DELETE FROM d021t WHERE prog = ls_dynpro-header-program AND dynr = ls_dynpro-header-screen ##SUBRC_OK.
        INSERT d021t FROM TABLE ls_dynpro-nat_texts ##SUBRC_OK.

        ls_dynpro-nat_header-dgen = sy-datum.
        ls_dynpro-nat_header-tgen = sy-uzeit.

        CALL FUNCTION 'RPY_DYNPRO_INSERT_NATIVE'
          EXPORTING
            header             = ls_dynpro-nat_header
            dynprotext         = ls_dynpro-header-descript
          TABLES
            fieldlist          = ls_dynpro-nat_fields
            flowlogic          = ls_dynpro-flow_logic
            params             = lt_params
          EXCEPTIONS
            cancelled          = 1
            already_exists     = 2
            program_not_exists = 3
            not_executed       = 4
            OTHERS             = 5.
      ELSE.
        CALL FUNCTION 'RPY_DYNPRO_INSERT'
          EXPORTING
            header                 = ls_dynpro-header
            suppress_exist_checks  = abap_true
            suppress_generate      = ls_dynpro-header-no_execute
          TABLES
            containers             = ls_dynpro-containers
            fields_to_containers   = ls_dynpro-fields
            flow_logic             = ls_dynpro-flow_logic
          EXCEPTIONS
            cancelled              = 1
            already_exists         = 2
            program_not_exists     = 3
            not_executed           = 4
            missing_required_field = 5
            illegal_field_value    = 6
            field_not_allowed      = 7
            not_generated          = 8
            illegal_field_position = 9
            OTHERS                 = 10.
      ENDIF.
      IF sy-subrc <> 2 AND sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      CONCATENATE ls_dynpro-header-program ls_dynpro-header-screen
        INTO lv_name RESPECTING BLANKS.
      ASSERT NOT lv_name IS INITIAL.

      zcl_abapgit_objects_activation=>add(
        iv_type = 'DYNP'
        iv_name = lv_name ).

    ENDLOOP.

    " Delete obsolete screens
    LOOP AT lt_d020s_to_delete INTO ls_d020s.

      CALL FUNCTION 'RS_SCRP_DELETE'
        EXPORTING
          dynnr                  = ls_d020s-dnum
          progname               = ms_item-obj_name
          with_popup             = abap_false
        EXCEPTIONS
          enqueued_by_user       = 1
          enqueue_system_failure = 2
          not_executed           = 3
          not_exists             = 4
          no_modify_permission   = 5
          popup_canceled         = 6.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD deserialize_exit_include.

    DATA:
      lv_progname TYPE reposrc-progname,
      lv_title    TYPE rglif-title.

    " Includes in SAP exit function groups must be processed in active state only
    " (check in RS_INSERT_INTO_WORKING_AREA)
    lv_title = get_program_title( it_tpool ).

    SELECT SINGLE progname FROM reposrc INTO lv_progname
      WHERE progname = is_progdir-name
      AND r3state = c_state-active.

    IF sy-subrc = 0.
      update_program(
        is_progdir = is_progdir
        it_source  = it_source
        iv_title   = lv_title
        iv_state   = '' ).
    ELSE.
      insert_program(
        is_progdir = is_progdir
        it_source  = it_source
        iv_title   = lv_title
        iv_package = iv_package
        iv_state   = '' ).
    ENDIF.

  ENDMETHOD.

  METHOD deserialize_program.

    DATA:
      lv_progname TYPE reposrc-progname,
      lv_title    TYPE rglif-title.

    IF is_exit_include( is_progdir-name ) = abap_true.
      deserialize_exit_include(
        is_progdir = is_progdir
        it_source  = it_source
        it_tpool   = it_tpool
        iv_package = iv_package ).
      RETURN.
    ENDIF.

    zcl_abapinst_factory=>get_cts_api( )->insert_transport_object(
      iv_object   = 'ABAP'
      iv_obj_name = is_progdir-name
      iv_package  = iv_package
      iv_language = mv_language ).

    lv_title = get_program_title( it_tpool ).

    " Check if program already exists
    SELECT SINGLE progname FROM reposrc INTO lv_progname
      WHERE progname = is_progdir-name
      AND r3state = c_state-active.

    IF sy-subrc = 0.
      update_program(
        is_progdir = is_progdir
        it_source  = it_source
        iv_title   = lv_title ).
    ELSE.
      insert_program(
        is_progdir = is_progdir
        it_source  = it_source
        iv_title   = lv_title
        iv_package = iv_package ).
    ENDIF.

    zcl_abapinst_factory=>get_sap_report( )->update_progdir(
      is_progdir = is_progdir
      iv_package = iv_package ).

    zcl_abapgit_objects_activation=>add(
      iv_type = 'REPS'
      iv_name = is_progdir-name ).

  ENDMETHOD.

  METHOD deserialize_textpool.

    DATA lv_language TYPE sy-langu.
    DATA lv_state    TYPE c.
    DATA lv_delete   TYPE abap_bool.

    IF iv_language IS INITIAL.
      lv_language = mv_language.
    ELSE.
      lv_language = iv_language.
    ENDIF.

    IF lv_language = mv_language.
      lv_state = c_state-inactive. "Textpool in main language needs to be activated
    ELSE.
      lv_state = c_state-active. "Translations are always active
    ENDIF.

    IF it_tpool IS INITIAL.
      IF iv_is_include = abap_false OR lv_state = c_state-active.
        DELETE TEXTPOOL iv_program "Remove initial description from textpool if
          LANGUAGE lv_language     "original program does not have a textpool
          STATE lv_state.

        lv_delete = abap_true.
      ELSE.
        INSERT TEXTPOOL iv_program "In case of includes: Deletion of textpool in
          FROM it_tpool            "main language cannot be activated because
          LANGUAGE lv_language     "this would activate the deletion of the textpool
          STATE lv_state.          "of the mail program -> insert empty textpool
      ENDIF.
    ELSE.
      INSERT TEXTPOOL iv_program
        FROM it_tpool
        LANGUAGE lv_language
        STATE lv_state.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( 'error from INSERT TEXTPOOL' ).
      ENDIF.
    ENDIF.

    "Textpool in main language needs to be activated (not for FUGS/FUGX)
    IF lv_state = c_state-inactive AND iv_program NP 'SAPLX*'.
      zcl_abapgit_objects_activation=>add(
        iv_type   = 'REPT'
        iv_name   = iv_program
        iv_delete = lv_delete ).
    ENDIF.
  ENDMETHOD.

  METHOD get_program_title.

    DATA ls_tpool LIKE LINE OF it_tpool.

    FIELD-SYMBOLS <lg_any> TYPE any.

    READ TABLE it_tpool INTO ls_tpool WITH KEY id = 'R'.
    IF sy-subrc = 0.
      " there is a bug in RPY_PROGRAM_UPDATE, the header line of TTAB is not
      " cleared, so the title length might be inherited from a different program.
      ASSIGN ('(SAPLSIFP)TTAB') TO <lg_any>.
      IF sy-subrc = 0.
        CLEAR <lg_any>.
      ENDIF.

      rv_title = ls_tpool-entry.
    ENDIF.

  ENDMETHOD.

  METHOD insert_program.

    TRY.
        CALL FUNCTION 'RPY_PROGRAM_INSERT'
          EXPORTING
            development_class = iv_package
            program_name      = is_progdir-name
            program_type      = is_progdir-subc
            title_string      = iv_title
            save_inactive     = iv_state
            suppress_dialog   = abap_true
            uccheck           = is_progdir-uccheck " does not exist on lower releases
          TABLES
            source_extended   = it_source
          EXCEPTIONS
            already_exists    = 1
            cancelled         = 2
            name_not_allowed  = 3
            permission_error  = 4
            OTHERS            = 5 ##FM_SUBRC_OK.
      CATCH cx_sy_dyn_call_param_not_found.
        CALL FUNCTION 'RPY_PROGRAM_INSERT'
          EXPORTING
            development_class = iv_package
            program_name      = is_progdir-name
            program_type      = is_progdir-subc
            title_string      = iv_title
            save_inactive     = iv_state
            suppress_dialog   = abap_true
          TABLES
            source_extended   = it_source
          EXCEPTIONS
            already_exists    = 1
            cancelled         = 2
            name_not_allowed  = 3
            permission_error  = 4
            OTHERS            = 5 ##FM_SUBRC_OK.
    ENDTRY.
    IF sy-subrc = 3.

      " For cases that standard function does not handle (like FUGR),
      " we save active and inactive version of source with the given PROGRAM TYPE.
      " Without the active version, the code will not be visible in case of activation errors.
      zcl_abapinst_factory=>get_sap_report( )->insert_report(
        iv_name         = is_progdir-name
        iv_package      = iv_package
        it_source       = it_source
        iv_state        = c_state-active
        iv_version      = is_progdir-uccheck
        iv_program_type = is_progdir-subc ).

      zcl_abapinst_factory=>get_sap_report( )->insert_report(
        iv_name         = is_progdir-name
        iv_package      = iv_package
        it_source       = it_source
        iv_state        = c_state-inactive
        iv_version      = is_progdir-uccheck
        iv_program_type = is_progdir-subc ).

    ELSEIF sy-subrc > 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD is_any_dynpro_locked.

    DATA: lt_dynpros TYPE ty_dynpro_tt,
          lv_object  TYPE seqg3-garg.

    FIELD-SYMBOLS: <ls_dynpro> TYPE ty_dynpro.

    lt_dynpros = serialize_dynpros( iv_program ).

    LOOP AT lt_dynpros ASSIGNING <ls_dynpro>.

      lv_object = |{ <ls_dynpro>-header-screen }{ <ls_dynpro>-header-program }|.

      IF exists_a_lock_entry_for( iv_lock_object = 'ESCRP'
                                  iv_argument    = lv_object ) = abap_true.
        rv_is_any_dynpro_locked = abap_true.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD is_cua_locked.

    DATA: lv_object TYPE eqegraarg.

    lv_object = |CU{ iv_program }|.
    OVERLAY lv_object WITH '                                          '.
    lv_object = lv_object && '*'.

    rv_is_cua_locked = exists_a_lock_entry_for( iv_lock_object = 'ESCUAPAINT'
                                                iv_argument    = lv_object ).

  ENDMETHOD.

  METHOD is_exit_include.
    rv_is_exit_include = boolc(
      iv_program CP 'LX*' OR iv_program CP 'SAPLX*' OR
      iv_program+1 CP '/LX*' OR iv_program+1 CP '/SAPLX*' ).
  ENDMETHOD.

  METHOD is_text_locked.

    DATA: lv_object TYPE eqegraarg.

    lv_object = |*{ iv_program }|.

    rv_is_text_locked = exists_a_lock_entry_for( iv_lock_object = 'EABAPTEXTE'
                                                 iv_argument    = lv_object ).

  ENDMETHOD.

  METHOD read_tpool.

    FIELD-SYMBOLS: <ls_tpool_in>  LIKE LINE OF it_tpool,
                   <ls_tpool_out> LIKE LINE OF rt_tpool.

    LOOP AT it_tpool ASSIGNING <ls_tpool_in>.
      APPEND INITIAL LINE TO rt_tpool ASSIGNING <ls_tpool_out>.
      MOVE-CORRESPONDING <ls_tpool_in> TO <ls_tpool_out>.
      IF <ls_tpool_out>-id = 'S'.
        CONCATENATE <ls_tpool_in>-split <ls_tpool_in>-entry
          INTO <ls_tpool_out>-entry
          RESPECTING BLANKS.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_cua.

    CALL FUNCTION 'RS_CUA_INTERNAL_FETCH'
      EXPORTING
        program         = iv_program_name
        language        = mv_language
        state           = c_state-active
      IMPORTING
        adm             = rs_cua-adm
      TABLES
        sta             = rs_cua-sta
        fun             = rs_cua-fun
        men             = rs_cua-men
        mtx             = rs_cua-mtx
        act             = rs_cua-act
        but             = rs_cua-but
        pfk             = rs_cua-pfk
        set             = rs_cua-set
        doc             = rs_cua-doc
        tit             = rs_cua-tit
        biv             = rs_cua-biv
      EXCEPTIONS
        not_found       = 1
        unknown_version = 2
        OTHERS          = 3.
    IF sy-subrc > 1.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD serialize_dynpros.
    DATA: ls_header               TYPE rpy_dyhead,
          lt_containers           TYPE dycatt_tab,
          lt_fields_to_containers TYPE dyfatc_tab,
          lt_flow_logic           TYPE swydyflow,
          lt_d020s                TYPE TABLE OF d020s,
          lt_texts                TYPE TABLE OF d021t,
          lt_fieldlist_int        TYPE TABLE OF d021s. "internal format

    FIELD-SYMBOLS: <ls_d020s>       LIKE LINE OF lt_d020s,
                   <lv_outputstyle> TYPE scrpostyle,
                   <ls_container>   LIKE LINE OF lt_containers,
                   <ls_field>       LIKE LINE OF lt_fields_to_containers,
                   <ls_dynpro>      LIKE LINE OF rt_dynpro,
                   <ls_field_int>   LIKE LINE OF lt_fieldlist_int.

    "#2746: relevant flag values (taken from include MSEUSBIT)
    CONSTANTS: lc_flg1ddf TYPE x VALUE '20',
               lc_flg3fku TYPE x VALUE '08',
               lc_flg3for TYPE x VALUE '04',
               lc_flg3fdu TYPE x VALUE '02'.

    CALL FUNCTION 'RS_SCREEN_LIST'
      EXPORTING
        dynnr     = ''
        progname  = iv_program_name
      TABLES
        dynpros   = lt_d020s
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc = 2.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    SORT lt_d020s BY dnum ASCENDING.

* loop dynpros and skip generated selection screens
    LOOP AT lt_d020s ASSIGNING <ls_d020s>
        WHERE type <> 'S' AND type <> 'W' AND type <> 'J'
        AND NOT dnum IS INITIAL.

      CALL FUNCTION 'RPY_DYNPRO_READ'
        EXPORTING
          progname             = iv_program_name
          dynnr                = <ls_d020s>-dnum
        IMPORTING
          header               = ls_header
        TABLES
          containers           = lt_containers
          fields_to_containers = lt_fields_to_containers
          flow_logic           = lt_flow_logic
        EXCEPTIONS
          cancelled            = 1
          not_found            = 2
          permission_error     = 3
          OTHERS               = 4.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      "#2746: we need the dynpro fields in internal format:
      FREE lt_fieldlist_int.

      CALL FUNCTION 'RPY_DYNPRO_READ_NATIVE'
        EXPORTING
          progname   = iv_program_name
          dynnr      = <ls_d020s>-dnum
        TABLES
          fieldlist  = lt_fieldlist_int
          fieldtexts = lt_texts.

      LOOP AT lt_fields_to_containers ASSIGNING <ls_field>.
* output style is a NUMC field, the XML conversion will fail if it contains invalid value
* field does not exist in all versions
        ASSIGN COMPONENT 'OUTPUTSTYLE' OF STRUCTURE <ls_field> TO <lv_outputstyle>.
        IF sy-subrc = 0 AND <lv_outputstyle> = '  '.
          CLEAR <lv_outputstyle>.
        ENDIF.

        "2746: we apply the same logic as in SAPLWBSCREEN
        "for setting or unsetting the foreignkey field:
        UNASSIGN <ls_field_int>.
        READ TABLE lt_fieldlist_int ASSIGNING <ls_field_int> WITH KEY fnam = <ls_field>-name.
        IF <ls_field_int> IS ASSIGNED.
          IF <ls_field_int>-flg1 O lc_flg1ddf AND
              <ls_field_int>-flg3 O lc_flg3for AND
              <ls_field_int>-flg3 Z lc_flg3fdu AND
              <ls_field_int>-flg3 Z lc_flg3fku.
            <ls_field>-foreignkey = 'X'.
          ELSE.
            CLEAR <ls_field>-foreignkey.
          ENDIF.
        ENDIF.

        IF <ls_field>-from_dict = abap_true AND
           <ls_field>-modific   <> 'F' AND
           <ls_field>-modific   <> 'X'.
          CLEAR <ls_field>-text.
        ENDIF.
      ENDLOOP.

      LOOP AT lt_containers ASSIGNING <ls_container>.
        IF <ls_container>-c_resize_v = abap_false.
          CLEAR <ls_container>-c_line_min.
        ENDIF.
        IF <ls_container>-c_resize_h = abap_false.
          CLEAR <ls_container>-c_coln_min.
        ENDIF.
      ENDLOOP.

      APPEND INITIAL LINE TO rt_dynpro ASSIGNING <ls_dynpro>.
      <ls_dynpro>-header = ls_header.

      " Store flow logic as separate ABAP files instead of XML
      mo_files->add_abap(
        iv_extra = 'screen_' && ls_header-screen
        it_abap  = lt_flow_logic ).

      READ TABLE lt_fieldlist_int TRANSPORTING NO FIELDS WITH KEY fill = 'X'.
      IF ls_header-type CA c_native_dynpro AND sy-subrc = 0.
        " In particular for dynpros with splitter
        <ls_dynpro>-nat_header = <ls_d020s>.
        CLEAR: <ls_dynpro>-nat_header-dgen, <ls_dynpro>-nat_header-tgen.
        <ls_dynpro>-nat_fields = lt_fieldlist_int.
        <ls_dynpro>-nat_texts  = lt_texts.
      ELSE.
        <ls_dynpro>-containers = lt_containers.
        <ls_dynpro>-fields     = lt_fields_to_containers.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_program.

    DATA: ls_progdir      TYPE zif_abapgit_sap_report=>ty_progdir,
          lv_program_name TYPE syrepid,
          lt_dynpros      TYPE ty_dynpro_tt,
          ls_cua          TYPE ty_cua,
          li_report       TYPE REF TO zif_abapgit_sap_report,
          lt_source       TYPE TABLE OF abaptxt255,
          lt_tpool        TYPE textpool_table,
          ls_tpool        LIKE LINE OF lt_tpool,
          li_xml          TYPE REF TO zif_abapgit_xml_output.

    IF iv_program IS INITIAL.
      lv_program_name = is_item-obj_name.
    ELSE.
      lv_program_name = iv_program.
    ENDIF.

    zcl_abapgit_language=>set_current_language( mv_language ).

    CALL FUNCTION 'RPY_PROGRAM_READ'
      EXPORTING
        program_name     = lv_program_name
        with_includelist = abap_false
        with_lowercase   = abap_true
      TABLES
        source_extended  = lt_source
        textelements     = lt_tpool
      EXCEPTIONS
        cancelled        = 1
        not_found        = 2
        permission_error = 3
        OTHERS           = 4.

    IF sy-subrc = 2.
      zcl_abapgit_language=>restore_login_language( ).
      RETURN.
    ELSEIF sy-subrc <> 0.
      zcl_abapgit_language=>restore_login_language( ).
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    zcl_abapgit_language=>restore_login_language( ).

    " If inactive version exists, then RPY_PROGRAM_READ does not return the active code
    li_report = zcl_abapinst_factory=>get_sap_report( ).

    TRY.
        " Raises exception if inactive version does not exist
        ls_progdir = li_report->read_progdir(
          iv_name  = lv_program_name
          iv_state = c_state-inactive ).

        " Explicitly request active source code
        lt_source = li_report->read_report(
          iv_name  = lv_program_name
          iv_state = c_state-active ).
      CATCH zcx_abapgit_exception ##NO_HANDLER.
    ENDTRY.

    ls_progdir = li_report->read_progdir(
      iv_name  = lv_program_name
      iv_state = c_state-active ).

    clear_abap_language_version( CHANGING cv_abap_language_version = ls_progdir-uccheck ).

    IF io_xml IS BOUND.
      li_xml = io_xml.
    ELSE.
      CREATE OBJECT li_xml TYPE zcl_abapgit_xml_output.
    ENDIF.

    li_xml->add( iv_name = 'PROGDIR'
                 ig_data = ls_progdir ).
    IF ls_progdir-subc = '1' OR ls_progdir-subc = 'M'.
      lt_dynpros = serialize_dynpros( lv_program_name ).
      li_xml->add( iv_name = 'DYNPROS'
                   ig_data = lt_dynpros ).

      ls_cua = serialize_cua( lv_program_name ).
      IF NOT ls_cua IS INITIAL.
        li_xml->add( iv_name = 'CUA'
                     ig_data = ls_cua ).
      ENDIF.
    ENDIF.

    READ TABLE lt_tpool WITH KEY id = 'R' INTO ls_tpool.
    IF sy-subrc = 0 AND ls_tpool-key = '' AND ls_tpool-length = 0.
      DELETE lt_tpool INDEX sy-tabix.
    ENDIF.

    li_xml->add( iv_name = 'TPOOL'
                 ig_data = add_tpool( lt_tpool ) ).

    IF NOT io_xml IS BOUND.
      io_files->add_xml( iv_extra = iv_extra
                         ii_xml   = li_xml ).
    ENDIF.

    strip_generation_comments( CHANGING ct_source = lt_source ).

    io_files->add_abap( iv_extra = iv_extra
                        it_abap  = lt_source ).

  ENDMETHOD.

  METHOD strip_generation_comments.

    FIELD-SYMBOLS <lv_line> TYPE any. " Assuming CHAR (e.g. abaptxt255_tab) or string (FUGR)

    IF ms_item-obj_type <> 'FUGR'.
      RETURN.
    ENDIF.

    " Case 1: MV FM main prog and TOPs
    READ TABLE ct_source INDEX 1 ASSIGNING <lv_line>.
    IF sy-subrc = 0 AND <lv_line> CP '#**regenerated at *'.
      DELETE ct_source INDEX 1.
      RETURN.
    ENDIF.

    " Case 2: MV FM includes
    IF lines( ct_source ) < 5. " Generation header length
      RETURN.
    ENDIF.

    READ TABLE ct_source INDEX 1 ASSIGNING <lv_line>.
    ASSERT sy-subrc = 0.
    IF NOT <lv_line> CP '#*---*'.
      RETURN.
    ENDIF.

    READ TABLE ct_source INDEX 2 ASSIGNING <lv_line>.
    ASSERT sy-subrc = 0.
    IF NOT <lv_line> CP '#**'.
      RETURN.
    ENDIF.

    READ TABLE ct_source INDEX 3 ASSIGNING <lv_line>.
    ASSERT sy-subrc = 0.
    IF NOT <lv_line> CP '#**generation date:*'.
      RETURN.
    ENDIF.

    READ TABLE ct_source INDEX 4 ASSIGNING <lv_line>.
    ASSERT sy-subrc = 0.
    IF NOT <lv_line> CP '#**generator version:*'.
      RETURN.
    ENDIF.

    READ TABLE ct_source INDEX 5 ASSIGNING <lv_line>.
    ASSERT sy-subrc = 0.
    IF NOT <lv_line> CP '#*---*'.
      RETURN.
    ENDIF.

    DELETE ct_source INDEX 4.
    DELETE ct_source INDEX 3.

  ENDMETHOD.

  METHOD uncondense_flow.

    DATA: lv_spaces LIKE LINE OF it_spaces.

    FIELD-SYMBOLS: <ls_flow>   LIKE LINE OF it_flow,
                   <ls_output> LIKE LINE OF rt_flow.

    LOOP AT it_flow ASSIGNING <ls_flow>.
      APPEND INITIAL LINE TO rt_flow ASSIGNING <ls_output>.
      <ls_output>-line = <ls_flow>-line.

      READ TABLE it_spaces INDEX sy-tabix INTO lv_spaces.
      IF sy-subrc = 0.
        SHIFT <ls_output>-line RIGHT BY lv_spaces PLACES IN CHARACTER MODE.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD update_program.

    zcl_abapgit_language=>set_current_language( mv_language ).

    CALL FUNCTION 'RPY_PROGRAM_UPDATE'
      EXPORTING
        program_name     = is_progdir-name
        title_string     = iv_title
        save_inactive    = iv_state
      TABLES
        source_extended  = it_source
      EXCEPTIONS
        cancelled        = 1
        permission_error = 2
        not_found        = 3
        OTHERS           = 4.

    IF sy-subrc <> 0.
      zcl_abapgit_language=>restore_login_language( ).

      IF sy-msgid = 'EU' AND sy-msgno = '510'.
        zcx_abapgit_exception=>raise( 'User is currently editing program' ).
      ELSEIF sy-msgid = 'EU' AND sy-msgno = '522'.
        " for generated table maintenance function groups, the author is set to SAP* instead of the user which
        " generates the function group. This hits some standard checks, pulling new code again sets the author
        " to the current user which avoids the check
        IF is_exit_include( is_progdir-name ) = abap_false.
          zcx_abapgit_exception=>raise( |Delete function group and pull again, { is_progdir-name } (EU522)| ).
        ENDIF.
      ELSE.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDIF.

    zcl_abapgit_language=>restore_login_language( ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_acid IMPLEMENTATION.

  METHOD create_object.

    DATA: lv_name TYPE aab_id_name.

    lv_name = ms_item-obj_name.

    CREATE OBJECT ro_aab
      EXPORTING
        im_name          = lv_name
      EXCEPTIONS
        name_not_allowed = 1
        OTHERS           = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
* looks like "changed by user" is not stored in the database
    rv_user = c_user_unknown.
  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lo_aab TYPE REF TO cl_aab_id.

    lo_aab = create_object( ).
    lo_aab->enqueue(
      EXCEPTIONS
        foreign_lock = 1
        system_error = 2
        cts_error    = 3
        OTHERS       = 4 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.
    lo_aab->delete(
      EXCEPTIONS
        prop_error       = 1
        propt_error      = 2
        act_error        = 3
        cts_error        = 4
        cts_devclass     = 5
        id_not_found     = 6
        no_authorization = 7
        id_still_used    = 8
        where_used_error = 9
        OTHERS           = 10 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.
    lo_aab->dequeue( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_description TYPE aab_id_descript,
          lo_aab         TYPE REF TO cl_aab_id.

    io_xml->read( EXPORTING iv_name = 'DESCRIPTION'
                  CHANGING  cg_data = lv_description ).

    lo_aab = create_object( ).

    lo_aab->enqueue(
      EXCEPTIONS
        foreign_lock = 1
        system_error = 2
        cts_error    = 3
        OTHERS       = 4 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    lo_aab->set_descript(
      EXPORTING
        im_descript      = lv_description
      EXCEPTIONS
        no_authorization = 1
        OTHERS           = 2 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    tadir_insert( iv_package ).

    lo_aab->save(
      EXCEPTIONS
        no_descript_specified = 1
        no_changes_found      = 2
        prop_error            = 3
        propt_error           = 4
        act_error             = 5
        cts_error             = 6
        sync_attributes_error = 7
        action_canceled       = 8
        OTHERS                = 9 ).
    IF sy-subrc >= 3.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    lo_aab->dequeue( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_state TYPE abap_bool,
          lo_aab   TYPE REF TO cl_aab_id.

    lo_aab = create_object( ).

    lo_aab->get_state( IMPORTING ex_state = lv_state ).
    rv_bool = boolc( lv_state = abap_true ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by zcl_abapinst_objects=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lo_aab         TYPE REF TO cl_aab_id,
          lv_description TYPE aab_id_descript.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    lo_aab = create_object( ).

    lo_aab->get_descript(
      IMPORTING ex_descript = lv_description
      EXCEPTIONS no_description_found = 1 ).

    io_xml->add( iv_name = 'DESCRIPTION'
                 ig_data = lv_description ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_avar IMPLEMENTATION.

  METHOD create_object.

    DATA: lv_name TYPE aab_var_name.

    lv_name = ms_item-obj_name.

    CREATE OBJECT ro_aab_var
      EXPORTING
        im_name          = lv_name
        im_local         = ''
      EXCEPTIONS
        name_not_allowed = 1
        user_not_valid   = 2
        no_authorization = 3
        OTHERS           = 4.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    DATA: lo_aab TYPE REF TO cl_aab_variant.

    lo_aab = create_object( ).
    lo_aab->get_author( IMPORTING ex_author = rv_user ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lo_aab TYPE REF TO cl_aab_variant.

    lo_aab = create_object( ).
    lo_aab->enqueue( ).
    lo_aab->delete(
      EXCEPTIONS
        var_not_found    = 1
        prop_error       = 2
        propt_error      = 3
        var_id_error     = 4
        no_authorization = 5
        cts_error        = 6
        cts_devclass     = 7
        OTHERS           = 8 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Error deleting AVAR { ms_item-obj_name }| ).
    ENDIF.
    lo_aab->dequeue( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_possible    TYPE abap_bool,
          lv_description TYPE aab_var_descript,
          ls_is          TYPE aab_var_obj_act,
          lt_ids         TYPE aab_var_obj_act_tab,
          lo_aab         TYPE REF TO cl_aab_variant.

    " AVAR can only be created in transportable packages
    lv_possible = zcl_abapinst_factory=>get_sap_package( iv_package )->are_changes_recorded_in_tr_req( ).
    IF lv_possible = abap_false.
      zcx_abapgit_exception=>raise( |Global activation variants require a transportable package| ).
    ENDIF.

    " Create AVAR with description and object (id) list
    io_xml->read( EXPORTING iv_name = 'DESCRIPTION'
                  CHANGING  cg_data = lv_description ).

    io_xml->read( EXPORTING iv_name = 'IDS'
                  CHANGING  cg_data = lt_ids ).

    lo_aab = create_object( ).
    lo_aab->enqueue( ).
    lo_aab->set_descript(
      EXPORTING
        im_descript      = lv_description
      EXCEPTIONS
        no_authorization = 1 ).
    IF sy-subrc <> 0.
      lo_aab->dequeue( ).
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    LOOP AT lt_ids INTO ls_is.
      lo_aab->set_id(
        EXPORTING
          im_name              = ls_is-name
          im_object            = ls_is-object
          im_actmode           = ls_is-actmode
        EXCEPTIONS
          no_authorization     = 1
          id_not_exists        = 2
          id_not_transportable = 3
          OTHERS               = 4 ).
      IF sy-subrc <> 0.
        lo_aab->dequeue( ).
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDLOOP.

    tadir_insert( iv_package ).

    lo_aab->save(
      EXCEPTIONS
        no_descript_specified = 1
        prop_error            = 2
        propt_error           = 3
        var_id_error          = 4
        no_changes_found      = 5
        cts_error             = 6 ).
    IF sy-subrc <> 0.
      lo_aab->dequeue( ).
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.
    lo_aab->dequeue( ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_state TYPE abap_bool,
          lo_aab   TYPE REF TO cl_aab_variant.

    lo_aab = create_object( ).

    lo_aab->get_state( IMPORTING ex_state = lv_state ).
    rv_bool = boolc( lv_state = abap_true ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lo_aab         TYPE REF TO cl_aab_variant,
          lt_ids         TYPE aab_var_obj_act_tab,
          lv_description TYPE aab_var_descript.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    lo_aab = create_object( ).

    lo_aab->get_descript(
      IMPORTING
        ex_descript = lv_description
      EXCEPTIONS
        no_descript_found = 1 ).
    IF sy-subrc = 0.
      io_xml->add( iv_name = 'DESCRIPTION'
                   ig_data = lv_description ).
    ENDIF.

    lo_aab->get_ids( IMPORTING ex_ids = lt_ids ).

    io_xml->add( iv_name = 'IDS'
                 ig_data = lt_ids ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_clas IMPLEMENTATION.

  METHOD constructor.

    super->constructor(
      is_item        = is_item
      iv_language    = iv_language
      io_files       = io_files
      io_i18n_params = io_i18n_params ).

    mi_object_oriented_object_fct = zcl_abapgit_oo_factory=>get_by_type( ms_item-obj_type ).

    mv_classpool_name = cl_oo_classname_service=>get_classpool_name( |{ is_item-obj_name }| ).

  ENDMETHOD.

  METHOD deserialize_abap.

    DATA: ls_vseoclass             TYPE vseoclass,
          lt_source                TYPE seop_source_string,
          lt_local_definitions     TYPE seop_source_string,
          lt_local_implementations TYPE seop_source_string,
          lt_local_macros          TYPE seop_source_string,
          lt_test_classes          TYPE seop_source_string,
          ls_class_key             TYPE seoclskey,
          lt_attributes            TYPE zif_abapgit_oo_object_fnc=>ty_obj_attribute_tt.

    lt_source = mo_files->read_abap( ).

    lt_local_definitions = mo_files->read_abap(
      iv_extra = zif_abapgit_oo_object_fnc=>c_parts-locals_def
      iv_error = abap_false ).

    lt_local_implementations = mo_files->read_abap(
      iv_extra = zif_abapgit_oo_object_fnc=>c_parts-locals_imp
      iv_error = abap_false ).

    lt_local_macros = mo_files->read_abap(
      iv_extra = zif_abapgit_oo_object_fnc=>c_parts-macros
      iv_error = abap_false ).

    lt_test_classes = mo_files->read_abap(
      iv_extra = zif_abapgit_oo_object_fnc=>c_parts-testclasses
      iv_error = abap_false ).

    ls_class_key-clsname = ms_item-obj_name.

    ii_xml->read( EXPORTING iv_name = 'VSEOCLASS'
                  CHANGING  cg_data = ls_vseoclass ).

    set_abap_language_version( CHANGING cv_abap_language_version = ls_vseoclass-unicode ).

    ii_xml->read( EXPORTING iv_name = 'ATTRIBUTES'
                  CHANGING  cg_data = lt_attributes ).

    " Remove code for test classes if they have been deleted
    IF ls_vseoclass-with_unit_tests = abap_false.
      CLEAR lt_test_classes.
    ENDIF.

    mi_object_oriented_object_fct->create(
      EXPORTING
        iv_check      = abap_true
        iv_package    = iv_package
        it_attributes = lt_attributes
      CHANGING
        cg_properties = ls_vseoclass ).

    mi_object_oriented_object_fct->generate_locals(
      is_key                   = ls_class_key
      iv_package               = iv_package
      iv_version               = ls_vseoclass-unicode
      it_local_definitions     = lt_local_definitions
      it_local_implementations = lt_local_implementations
      it_local_macros          = lt_local_macros
      it_local_test_classes    = lt_test_classes ).

    repo_apack_replacement( CHANGING ct_source = lt_source ).

    mi_object_oriented_object_fct->deserialize_source(
      is_key     = ls_class_key
      iv_package = iv_package
      iv_version = ls_vseoclass-unicode
      it_source  = lt_source ).

  ENDMETHOD.

  METHOD deserialize_descr.

    DATA:
      ls_class_key          TYPE seoclskey,
      lt_descriptions_class TYPE zif_abapgit_oo_object_fnc=>ty_seoclasstx_tt,
      lt_descriptions_compo TYPE zif_abapgit_oo_object_fnc=>ty_seocompotx_tt,
      lt_descriptions_subco TYPE zif_abapgit_oo_object_fnc=>ty_seosubcotx_tt.

    ls_class_key-clsname = ms_item-obj_name.

    ii_xml->read( EXPORTING iv_name = 'DESCRIPTIONS_CLASS'
                  CHANGING  cg_data = lt_descriptions_class ).

    mi_object_oriented_object_fct->update_descriptions_class(
      is_key          = ls_class_key
      iv_language     = mv_language
      it_descriptions = lt_descriptions_class ).

    ii_xml->read( EXPORTING iv_name = 'DESCRIPTIONS'
                  CHANGING  cg_data = lt_descriptions_compo ).

    mi_object_oriented_object_fct->update_descriptions_compo(
      is_key          = ls_class_key
      it_descriptions = lt_descriptions_compo ).

    ii_xml->read( EXPORTING iv_name = 'DESCRIPTIONS_SUB'
                  CHANGING  cg_data = lt_descriptions_subco ).

    mi_object_oriented_object_fct->update_descriptions_subco(
      is_key          = ls_class_key
      it_descriptions = lt_descriptions_subco ).

  ENDMETHOD.

  METHOD deserialize_docu.

    DATA: lt_lines      TYPE tlinetab,
          lv_object     TYPE dokhl-object,
          lt_i18n_lines TYPE zif_abapgit_lang_definitions=>ty_i18n_lines,
          ls_i18n_lines TYPE zif_abapgit_lang_definitions=>ty_i18n_line.

    ii_xml->read( EXPORTING iv_name = 'LINES'
                  CHANGING cg_data = lt_lines ).

    lv_object = ms_item-obj_name.

    IF lines( lt_lines ) = 0.
      mi_object_oriented_object_fct->delete_documentation(
        iv_id          = c_longtext_id-class
        iv_object_name = lv_object
        iv_language    = mv_language ).
      RETURN.
    ENDIF.

    mi_object_oriented_object_fct->create_documentation(
      it_lines       = lt_lines
      iv_id          = c_longtext_id-class
      iv_object_name = lv_object
      iv_language    = mv_language ).

    ii_xml->read( EXPORTING iv_name = 'I18N_LINES'
                  CHANGING cg_data = lt_i18n_lines ).

    LOOP AT lt_i18n_lines INTO ls_i18n_lines.
      mi_object_oriented_object_fct->create_documentation(
        it_lines         = ls_i18n_lines-lines
        iv_id            = c_longtext_id-class
        iv_object_name   = lv_object
        iv_language      = ls_i18n_lines-language
        iv_no_masterlang = abap_true ).
    ENDLOOP.

    deserialize_longtexts(
      ii_xml           = ii_xml
      iv_longtext_name = c_longtext_name-attributes
      iv_longtext_id   = c_longtext_id-attributes ).

    deserialize_longtexts(
      ii_xml           = ii_xml
      iv_longtext_name = c_longtext_name-methods
      iv_longtext_id   = c_longtext_id-methods ).

    deserialize_longtexts(
      ii_xml           = ii_xml
      iv_longtext_name = c_longtext_name-events
      iv_longtext_id   = c_longtext_id-events ).

    deserialize_longtexts(
      ii_xml           = ii_xml
      iv_longtext_name = c_longtext_name-types
      iv_longtext_id   = c_longtext_id-types ).

  ENDMETHOD.

  METHOD deserialize_exceptions.

    DATA: ls_vseoclass TYPE vseoclass.

    ii_xml->read( EXPORTING iv_name = 'VSEOCLASS'
                  CHANGING  cg_data = ls_vseoclass ).

    " For exceptions that are sub-class of another exception, we need to set the category explicitly (#6490)
    IF ls_vseoclass-category = '40'.
      UPDATE seoclassdf SET category = '40' WHERE clsname = ls_vseoclass-clsname.
    ENDIF.

  ENDMETHOD.

  METHOD deserialize_pre_ddic.

    DATA: ls_vseoclass TYPE vseoclass.

    ii_xml->read( EXPORTING iv_name = 'VSEOCLASS'
                  CHANGING  cg_data = ls_vseoclass ).

    set_abap_language_version( CHANGING cv_abap_language_version = ls_vseoclass-unicode ).

    IF ls_vseoclass-category = '40'.
      " In lower releases, creating exception classes raise a popup asking for package
      " To avoid this, we set the default package here
      set_default_package( iv_package ).
    ENDIF.

    mi_object_oriented_object_fct->create(
      EXPORTING
        iv_check      = abap_false
        iv_package    = iv_package
      CHANGING
        cg_properties = ls_vseoclass ).

  ENDMETHOD.

  METHOD deserialize_sotr.
    "OTR stands for Online Text Repository
    mi_object_oriented_object_fct->create_sotr(
      iv_object_name = ms_item-obj_name
      iv_package     = iv_package
      ii_xml         = ii_xml ).
  ENDMETHOD.

  METHOD deserialize_tpool.

    DATA: lv_clsname   TYPE seoclsname,
          lt_tpool_ext TYPE zif_abapgit_definitions=>ty_tpool_tt,
          lt_tpool     TYPE textpool_table.

    ii_xml->read( EXPORTING iv_name = 'TPOOL'
                  CHANGING cg_data = lt_tpool_ext ).
    lt_tpool = read_tpool( lt_tpool_ext ).

    IF lines( lt_tpool ) = 0.
      RETURN.
    ENDIF.

    lv_clsname = ms_item-obj_name.

    mi_object_oriented_object_fct->insert_text_pool(
      iv_class_name = lv_clsname
      it_text_pool  = lt_tpool
      iv_language   = mv_language ).

  ENDMETHOD.

  METHOD deserialize_tpool_i18n.

    DATA: lv_clsname    TYPE seoclsname,
          lt_tpool      TYPE textpool_table,
          lt_i18n_tpool TYPE zif_abapgit_lang_definitions=>ty_i18n_tpools,
          ls_i18n_tpool TYPE zif_abapgit_lang_definitions=>ty_i18n_tpool.

    lv_clsname = ms_item-obj_name.

    ii_xml->read( EXPORTING iv_name = 'I18N_TPOOL'
                  CHANGING  cg_data = lt_i18n_tpool ).

    mo_i18n_params->trim_saplang_keyed_table(
      EXPORTING
        iv_lang_field_name = 'LANGUAGE'
      CHANGING
        ct_tab = lt_i18n_tpool ).

    LOOP AT lt_i18n_tpool INTO ls_i18n_tpool.
      lt_tpool = read_tpool( ls_i18n_tpool-textpool ).
      mi_object_oriented_object_fct->insert_text_pool(
        iv_class_name = lv_clsname
        it_text_pool  = lt_tpool
        iv_language   = ls_i18n_tpool-language
        iv_state      = 'A' ).
    ENDLOOP.

  ENDMETHOD.

  METHOD interface_replacement.

    DATA lv_tabix TYPE sy-tabix.

    FIELD-SYMBOLS <lv_source> LIKE LINE OF ct_source.

    FIND REGEX '^\s*INTERFACES(:| )\s*' && iv_from_interface && '\s*.' IN TABLE ct_source MATCH LINE lv_tabix.
    IF sy-subrc = 0.
      READ TABLE ct_source ASSIGNING <lv_source> INDEX lv_tabix.
      ASSERT sy-subrc = 0.

      REPLACE FIRST OCCURRENCE OF iv_from_interface IN <lv_source>
                             WITH iv_to_interface IGNORING CASE.

      REPLACE ALL OCCURRENCES OF iv_from_interface && '~descriptor' IN TABLE ct_source
                            WITH iv_to_interface && '~descriptor' IGNORING CASE.
      REPLACE ALL OCCURRENCES OF iv_from_interface && '=>' IN TABLE ct_source
                            WITH iv_to_interface && '=>' IGNORING CASE.
      REPLACE ALL OCCURRENCES OF iv_from_interface && '->' IN TABLE ct_source
                            WITH iv_to_interface && '->' IGNORING CASE.
    ENDIF.

  ENDMETHOD.

  METHOD is_class_locked.

    DATA: lv_argument TYPE seqg3-garg.

    lv_argument = ms_item-obj_name.
    OVERLAY lv_argument WITH '=============================='.
    lv_argument = lv_argument && '*'.

    rv_is_class_locked = exists_a_lock_entry_for( iv_lock_object = 'ESEOCLASS'
                                                  iv_argument    = lv_argument ).

  ENDMETHOD.

  METHOD repo_apack_replacement.

    DATA lv_apack TYPE seoclsname.

    " Check if SAP-version of APACK manifest exists
    SELECT SINGLE clsname INTO lv_apack
      FROM seoclass
      WHERE clsname = zif_abapgit_apack_definitions=>c_apack_interface_sap.
    IF sy-subrc = 0.
      RETURN.
    ENDIF.

    " If not, replace with abapGit version
    interface_replacement(
      EXPORTING
        iv_from_interface = to_lower( zif_abapgit_apack_definitions=>c_apack_interface_sap )
        iv_to_interface   = to_lower( zif_abapgit_apack_definitions=>c_apack_interface_cust )
      CHANGING
        ct_source         = ct_source ).

  ENDMETHOD.

  METHOD serialize_attr.

    DATA: lt_attributes TYPE zif_abapgit_oo_object_fnc=>ty_obj_attribute_tt.

    lt_attributes = mi_object_oriented_object_fct->read_attributes( iv_clsname ).
    IF lines( lt_attributes ) = 0.
      RETURN.
    ENDIF.

    ii_xml->add( iv_name = 'ATTRIBUTES'
                 ig_data = lt_attributes ).

  ENDMETHOD.

  METHOD serialize_descr_class.

    DATA: lt_descriptions    TYPE zif_abapgit_oo_object_fnc=>ty_seoclasstx_tt,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    " Main language is already in VSEOCLASS so we serialize only translations
    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN.
    ENDIF.

    lt_descriptions = mi_object_oriented_object_fct->read_descriptions_class(
      iv_object_name = iv_clsname
      iv_language    = mv_language ).

    IF lines( lt_descriptions ) = 0.
      RETURN.
    ENDIF.
    " Remove technical languages
    lt_language_filter = mo_i18n_params->build_language_filter( ).
    DELETE lt_descriptions WHERE NOT langu IN lt_language_filter AND langu <> mv_language.

    ii_xml->add( iv_name = 'DESCRIPTIONS_CLASS'
                 ig_data = lt_descriptions ).

  ENDMETHOD.

  METHOD serialize_descr_compo.

    DATA: lt_descriptions    TYPE zif_abapgit_oo_object_fnc=>ty_seocompotx_tt,
          lv_language        TYPE spras,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      lv_language = mv_language.
    ENDIF.

    lt_descriptions = mi_object_oriented_object_fct->read_descriptions_compo(
      iv_object_name = iv_clsname
      iv_language    = lv_language ).

    IF lines( lt_descriptions ) = 0.
      RETURN.
    ENDIF.
    " Remove technical languages
    lt_language_filter = mo_i18n_params->build_language_filter( ).
    DELETE lt_descriptions WHERE NOT langu IN lt_language_filter AND langu <> mv_language.

    ii_xml->add( iv_name = 'DESCRIPTIONS'
                 ig_data = lt_descriptions ).

  ENDMETHOD.

  METHOD serialize_descr_subco.

    DATA: lt_descriptions    TYPE zif_abapgit_oo_object_fnc=>ty_seosubcotx_tt,
          lv_language        TYPE spras,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      lv_language = mv_language.
    ENDIF.

    lt_descriptions = mi_object_oriented_object_fct->read_descriptions_subco(
      iv_object_name = iv_clsname
      iv_language    = lv_language ).

    IF lines( lt_descriptions ) = 0.
      RETURN.
    ENDIF.
    " Remove technical languages
    lt_language_filter = mo_i18n_params->build_language_filter( ).
    DELETE lt_descriptions WHERE NOT langu IN lt_language_filter AND langu <> mv_language.

    ii_xml->add( iv_name = 'DESCRIPTIONS_SUB'
                 ig_data = lt_descriptions ).

  ENDMETHOD.

  METHOD serialize_docu.

    DATA: lt_lines      TYPE tlinetab,
          lv_object     TYPE dokhl-object,
          lv_langu      TYPE sy-langu,
          lt_i18n_lines TYPE zif_abapgit_lang_definitions=>ty_i18n_lines,
          ls_i18n_lines TYPE zif_abapgit_lang_definitions=>ty_i18n_line.

    lv_object = iv_clsname.

    lt_lines = mi_object_oriented_object_fct->read_documentation(
      iv_id          = c_longtext_id-class
      iv_object_name = lv_object
      iv_language    = mv_language ).
    IF lines( lt_lines ) > 0.
      ii_xml->add( iv_name = 'LINES'
                   ig_data = lt_lines ).
    ENDIF.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN.
    ENDIF.

    LOOP AT it_langu_additional INTO lv_langu.

      lt_lines = mi_object_oriented_object_fct->read_documentation(
        iv_id          = c_longtext_id-class
        iv_object_name = lv_object
        iv_language    = lv_langu ).

      IF lines( lt_lines ) > 0.
        CLEAR ls_i18n_lines.
        ls_i18n_lines-language = lv_langu.
        ls_i18n_lines-lines    = lt_lines.
        INSERT ls_i18n_lines INTO TABLE lt_i18n_lines.
      ENDIF.

    ENDLOOP.

    IF lines( lt_i18n_lines ) > 0.
      ii_xml->add( iv_name = 'I18N_LINES'
                   ig_data = lt_i18n_lines ).
    ENDIF.

    serialize_longtexts(
      ii_xml           = ii_xml
      iv_longtext_name = c_longtext_name-attributes
      iv_longtext_id   = c_longtext_id-attributes ).

    serialize_longtexts(
      ii_xml           = ii_xml
      iv_longtext_name = c_longtext_name-methods
      iv_longtext_id   = c_longtext_id-methods ).

    serialize_longtexts(
      ii_xml           = ii_xml
      iv_longtext_name = c_longtext_name-events
      iv_longtext_id   = c_longtext_id-events ).

    serialize_longtexts(
      ii_xml           = ii_xml
      iv_longtext_name = c_longtext_name-types
      iv_longtext_id   = c_longtext_id-types ).

  ENDMETHOD.

  METHOD serialize_sotr.
    mi_object_oriented_object_fct->read_sotr(
      iv_object_name = ms_item-obj_name
      io_i18n_params = mo_i18n_params
      ii_xml         = ii_xml ).
  ENDMETHOD.

  METHOD serialize_tpool.

    DATA lt_tpool TYPE textpool_table.

    lt_tpool = mi_object_oriented_object_fct->read_text_pool(
      iv_class_name = iv_clsname
      iv_language   = mv_language ).
    ii_xml->add( iv_name = 'TPOOL'
                 ig_data = add_tpool( lt_tpool ) ).

    rt_tpool = lt_tpool.

  ENDMETHOD.

  METHOD serialize_tpool_i18n.

    DATA: lt_tpool      TYPE textpool_table,
          lv_index      TYPE i,
          lv_langu      TYPE sy-langu,
          lt_i18n_tpool TYPE zif_abapgit_lang_definitions=>ty_i18n_tpools,
          ls_i18n_tpool TYPE zif_abapgit_lang_definitions=>ty_i18n_tpool.

    FIELD-SYMBOLS <ls_tpool> LIKE LINE OF it_tpool_main.

    DATA lt_tpool_main LIKE SORTED TABLE OF <ls_tpool> WITH UNIQUE KEY id key.

    IF mo_i18n_params->ms_params-main_language_only = abap_true OR lines( it_tpool_main ) = 0.
      RETURN.
    ENDIF.

    " Copy single records to be able to catch duplicate key error
    LOOP AT it_tpool_main ASSIGNING <ls_tpool>.
      INSERT <ls_tpool> INTO TABLE lt_tpool_main.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( |Inconsistent textpool in { ms_item-obj_type } { ms_item-obj_name }| ).
      ENDIF.
    ENDLOOP.

    LOOP AT it_langu_additional INTO lv_langu.

      lt_tpool = mi_object_oriented_object_fct->read_text_pool(
        iv_class_name = iv_clsname
        iv_language   = lv_langu ).

      LOOP AT lt_tpool ASSIGNING <ls_tpool>.
        lv_index = sy-tabix.
        READ TABLE lt_tpool_main WITH KEY id = <ls_tpool>-id key = <ls_tpool>-key
          TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          DELETE lt_tpool INDEX lv_index.
        ENDIF.
      ENDLOOP.

      IF lines( lt_tpool ) > 0.
        CLEAR ls_i18n_tpool.
        ls_i18n_tpool-language = lv_langu.
        ls_i18n_tpool-textpool = add_tpool( lt_tpool ).
        INSERT ls_i18n_tpool INTO TABLE lt_i18n_tpool.
      ENDIF.

    ENDLOOP.

    IF lines( lt_i18n_tpool ) > 0.
      ii_xml->add( iv_name = 'I18N_TPOOL'
                   ig_data = lt_i18n_tpool ).
    ENDIF.

  ENDMETHOD.

  METHOD serialize_xml.

    DATA: ls_vseoclass        TYPE vseoclass,
          lt_tpool            TYPE textpool_table,
          ls_clskey           TYPE seoclskey,
          lt_langu_additional TYPE zif_abapgit_lang_definitions=>ty_langus,
          lt_language_filter  TYPE zif_abapgit_environment=>ty_system_language_filter.

    ls_clskey-clsname = ms_item-obj_name.

    "If class was deserialized with a previous version of abapGit and current language was different
    "from main language at this time, this call would return SY-LANGU as main language. To fix
    "these objects, set SY-LANGU to main language temporarily.
    zcl_abapgit_language=>set_current_language( mv_language ).

    TRY.
        ls_vseoclass = mi_object_oriented_object_fct->get_class_properties( ls_clskey ).

        clear_abap_language_version( CHANGING cv_abap_language_version = ls_vseoclass-unicode ).

      CLEANUP.
        zcl_abapgit_language=>restore_login_language( ).

    ENDTRY.

    zcl_abapgit_language=>restore_login_language( ).

    IF mv_skip_testclass = abap_true.
      CLEAR ls_vseoclass-with_unit_tests.
    ENDIF.

    " Table d010tinf stores info. on languages in which program is maintained
    " Select all active translations of program texts
    " Skip main language - it was already serialized
    lt_language_filter = mo_i18n_params->build_language_filter( ).

    SELECT DISTINCT language
      INTO TABLE lt_langu_additional
      FROM d010tinf
      WHERE r3state  = 'A'
        AND prog     = mv_classpool_name
        AND language IN lt_language_filter
        AND language <> mv_language
      ORDER BY language.

    ii_xml->add( iv_name = 'VSEOCLASS'
                 ig_data = ls_vseoclass ).

    lt_tpool = serialize_tpool(
      ii_xml     = ii_xml
      iv_clsname = ls_clskey-clsname ).

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      serialize_tpool_i18n(
        ii_xml              = ii_xml
        it_langu_additional = lt_langu_additional
        it_tpool_main       = lt_tpool
        iv_clsname          = ls_clskey-clsname ).
    ENDIF.

    IF ls_vseoclass-category = seoc_category_exception.
      serialize_sotr( ii_xml ).
    ENDIF.

    SELECT DISTINCT langu
      INTO TABLE lt_langu_additional
      FROM dokhl
      WHERE id     = 'CL'
        AND object = ls_clskey-clsname
        AND langu IN lt_language_filter
        AND langu <> mv_language
      ORDER BY langu.

    serialize_docu( ii_xml              = ii_xml
                    iv_clsname          = ls_clskey-clsname
                    it_langu_additional = lt_langu_additional ).

    serialize_descr_class( ii_xml     = ii_xml
                           iv_clsname = ls_clskey-clsname ).

    serialize_descr_compo( ii_xml     = ii_xml
                           iv_clsname = ls_clskey-clsname ).

    serialize_descr_subco( ii_xml     = ii_xml
                           iv_clsname = ls_clskey-clsname ).

    serialize_attr( ii_xml     = ii_xml
                    iv_clsname = ls_clskey-clsname ).

  ENDMETHOD.

  METHOD source_apack_replacement.

    DATA lv_clsname TYPE seoclsname.

    " Check if abapGit version of APACK manifest is used
    SELECT SINGLE clsname INTO lv_clsname
      FROM seometarel
      WHERE clsname    = ms_item-obj_name
        AND refclsname = zif_abapgit_apack_definitions=>c_apack_interface_cust
        AND version    = '1'.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    " If yes, replace with SAP-version
    interface_replacement(
      EXPORTING
        iv_from_interface = to_lower( zif_abapgit_apack_definitions=>c_apack_interface_cust )
        iv_to_interface   = to_lower( zif_abapgit_apack_definitions=>c_apack_interface_sap )
      CHANGING
        ct_source         = ct_source ).

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    TYPES: BEGIN OF ty_reposrc,
             unam  TYPE reposrc-unam,
             udat  TYPE reposrc-udat,
             utime TYPE reposrc-utime,
           END OF ty_reposrc.

    DATA: lt_reposrc  TYPE STANDARD TABLE OF ty_reposrc,
          ls_reposrc  LIKE LINE OF lt_reposrc,
          lv_include  TYPE syrepid,
          lt_includes TYPE STANDARD TABLE OF syrepid.

    CASE iv_extra.
      WHEN zif_abapgit_oo_object_fnc=>c_parts-locals_def.
        lv_include = cl_oo_classname_service=>get_ccdef_name( |{ ms_item-obj_name }| ).
        INSERT lv_include INTO TABLE lt_includes.
      WHEN zif_abapgit_oo_object_fnc=>c_parts-locals_imp.
        lv_include = cl_oo_classname_service=>get_ccimp_name( |{ ms_item-obj_name }| ).
        INSERT lv_include INTO TABLE lt_includes.
      WHEN zif_abapgit_oo_object_fnc=>c_parts-macros.
        lv_include = cl_oo_classname_service=>get_ccmac_name( |{ ms_item-obj_name }| ).
        INSERT lv_include INTO TABLE lt_includes.
      WHEN zif_abapgit_oo_object_fnc=>c_parts-testclasses.
        lv_include = cl_oo_classname_service=>get_ccau_name( |{ ms_item-obj_name }| ).
        INSERT lv_include INTO TABLE lt_includes.
      WHEN OTHERS.
        lt_includes = mi_object_oriented_object_fct->get_includes( ms_item-obj_name ).
    ENDCASE.

    ASSERT lines( lt_includes ) > 0.

    SELECT unam udat utime FROM reposrc
      INTO TABLE lt_reposrc
      FOR ALL ENTRIES IN lt_includes
      WHERE progname = lt_includes-table_line
      AND r3state = 'A'.
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ELSE.
      SORT lt_reposrc BY udat DESCENDING utime DESCENDING.
      READ TABLE lt_reposrc INDEX 1 INTO ls_reposrc.
      ASSERT sy-subrc = 0.
      rv_user = ls_reposrc-unam.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.
    DATA: ls_clskey TYPE seoclskey.
    ls_clskey-clsname = ms_item-obj_name.

    corr_insert( iv_package ).

    mi_object_oriented_object_fct->delete( ls_clskey ).
  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    IF iv_step = zif_abapgit_object=>gc_step_id-abap.

      deserialize_abap( ii_xml     = io_xml
                        iv_package = iv_package ).

      deserialize_descr( io_xml ).

      deserialize_tpool( io_xml ).

      IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
        deserialize_tpool_i18n( io_xml ).
      ENDIF.

      deserialize_sotr( ii_xml     = io_xml
                        iv_package = iv_package ).

      deserialize_docu( io_xml ).

      mi_object_oriented_object_fct->add_to_activation_list( ms_item ).

    ELSEIF iv_step = zif_abapgit_object=>gc_step_id-early.

      " If class does not exist, create it
      " so DDIC that depends on it does not fail activation
      IF zif_abapgit_object~exists( ) = abap_false.
        deserialize_pre_ddic(
          ii_xml     = io_xml
          iv_package = iv_package ).
      ELSE.
        corr_insert( iv_package ).
      ENDIF.

    ELSEIF iv_step = zif_abapgit_object=>gc_step_id-late.

      deserialize_exceptions( io_xml ).

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA ls_class_key TYPE seoclskey.

    ls_class_key-clsname = ms_item-obj_name.

    rv_bool = mi_object_oriented_object_fct->exists( ls_class_key-clsname ).

    " Skip classes generated by DDLS (SADL)
    IF rv_bool = abap_true AND
      mi_object_oriented_object_fct->read_superclass( ls_class_key-clsname ) = 'CL_SADL_GTK_EXPOSURE_MPC'.
      rv_bool = abap_false.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-early TO rt_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
    APPEND zif_abapgit_object=>gc_step_id-late TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    IF is_class_locked( ) = abap_true OR is_text_locked( mv_classpool_name ) = abap_true.
      rv_is_locked = abap_true.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA ls_item TYPE zif_abapgit_definitions=>ty_item.

    ls_item-obj_type = 'PROG'.

    CASE iv_extra.
      WHEN zif_abapgit_oo_object_fnc=>c_parts-locals_def.
        ls_item-obj_name = cl_oo_classname_service=>get_ccdef_name( |{ ms_item-obj_name }| ).
      WHEN zif_abapgit_oo_object_fnc=>c_parts-locals_imp.
        ls_item-obj_name = cl_oo_classname_service=>get_ccimp_name( |{ ms_item-obj_name }| ).
      WHEN zif_abapgit_oo_object_fnc=>c_parts-macros.
        ls_item-obj_name = cl_oo_classname_service=>get_ccmac_name( |{ ms_item-obj_name }| ).
      WHEN zif_abapgit_oo_object_fnc=>c_parts-testclasses.
        ls_item-obj_name = cl_oo_classname_service=>get_ccau_name( |{ ms_item-obj_name }| ).
    ENDCASE.

    IF ls_item-obj_name IS NOT INITIAL.
      rv_exit = zcl_abapgit_objects_factory=>get_gui_jumper( )->jump( ls_item ).
    ENDIF.

    " Otherwise covered by zcl_abapinst_objects=>JUMP

  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lt_source    TYPE seop_source_string,
          ls_class_key TYPE seoclskey.

    ls_class_key-clsname = ms_item-obj_name.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    CALL FUNCTION 'SEO_BUFFER_REFRESH'
      EXPORTING
        version = seoc_version_active
        force   = abap_true.
    CALL FUNCTION 'SEO_BUFFER_REFRESH'
      EXPORTING
        version = seoc_version_inactive
        force   = abap_true.

    lt_source = mi_object_oriented_object_fct->serialize_abap( ls_class_key ).

    source_apack_replacement( CHANGING ct_source = lt_source ).

    mo_files->add_abap( lt_source ).

    lt_source = mi_object_oriented_object_fct->serialize_abap(
      is_class_key = ls_class_key
      iv_type      = seop_ext_class_locals_def ).
    IF lines( lt_source ) > 0.
      mo_files->add_abap(
        iv_extra = zif_abapgit_oo_object_fnc=>c_parts-locals_def
        it_abap  = lt_source ).
    ENDIF.

    lt_source = mi_object_oriented_object_fct->serialize_abap(
      is_class_key = ls_class_key
      iv_type      = seop_ext_class_locals_imp ).
    IF lines( lt_source ) > 0.
      mo_files->add_abap(
        iv_extra = zif_abapgit_oo_object_fnc=>c_parts-locals_imp
        it_abap  = lt_source ).
    ENDIF.

    lt_source = mi_object_oriented_object_fct->serialize_abap(
      is_class_key            = ls_class_key
      iv_type                 = seop_ext_class_testclasses ).

    mv_skip_testclass = mi_object_oriented_object_fct->get_skip_test_classes( ).
    IF lines( lt_source ) > 0 AND mv_skip_testclass = abap_false.
      mo_files->add_abap(
        iv_extra = zif_abapgit_oo_object_fnc=>c_parts-testclasses
        it_abap  = lt_source ).
    ENDIF.

    lt_source = mi_object_oriented_object_fct->serialize_abap(
      is_class_key = ls_class_key
      iv_type      = seop_ext_class_macros ).
    IF lines( lt_source ) > 0.
      mo_files->add_abap(
        iv_extra = zif_abapgit_oo_object_fnc=>c_parts-macros
        it_abap  = lt_source ).
    ENDIF.

    serialize_xml( io_xml ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_persist_packages IMPLEMENTATION.

  METHOD from_xml.

    DATA lo_input TYPE REF TO zif_abapgit_xml_input.

    CREATE OBJECT lo_input TYPE zcl_abapgit_xml_input EXPORTING iv_xml = iv_xml.

    lo_input->read(
      EXPORTING
        iv_name = zcl_abapgit_persistence_db=>c_type_packages
      CHANGING
        cg_data = rt_packages ).

  ENDMETHOD.

  METHOD get_instance.

    IF go_persist IS NOT BOUND.
      CREATE OBJECT go_persist.
    ENDIF.
    ro_persist = go_persist.

  ENDMETHOD.

  METHOD init.

    TRY.
        " Might have changed in another session so always get latest
        mt_packages = from_xml( zcl_abapgit_persistence_db=>get_instance( )->read(
          iv_type  = zcl_abapgit_persistence_db=>c_type_packages
          iv_value = '' ) ).
      CATCH zcx_abapgit_exception zcx_abapgit_not_found ##NO_HANDLER.
    ENDTRY.

  ENDMETHOD.

  METHOD modify.

    DATA ls_package LIKE LINE OF mt_packages.

    FIELD-SYMBOLS <ls_package> LIKE LINE OF mt_packages.

    init( ).

    IF iv_component IS INITIAL AND iv_comp_posid IS INITIAL.
      DELETE mt_packages WHERE devclass = iv_package.
    ELSE.
      READ TABLE mt_packages ASSIGNING <ls_package> WITH TABLE KEY devclass = iv_package.
      IF sy-subrc = 0.
        <ls_package>-component  = iv_component.
        <ls_package>-comp_posid = iv_comp_posid.
      ELSE.
        ls_package-devclass   = iv_package.
        ls_package-component  = iv_component.
        ls_package-comp_posid = iv_comp_posid.
        INSERT ls_package INTO TABLE mt_packages.
      ENDIF.
    ENDIF.

    zcl_abapgit_persistence_db=>get_instance( )->modify(
      iv_type       = zcl_abapgit_persistence_db=>c_type_packages
      iv_value      = ''
      iv_data       = to_xml( mt_packages ) ).

    COMMIT WORK AND WAIT.

  ENDMETHOD.

  METHOD read.

    init( ).

    READ TABLE mt_packages INTO rs_package WITH TABLE KEY devclass = iv_package.
    IF sy-subrc <> 0.
      rs_package-devclass = iv_package. " no component
    ENDIF.

  ENDMETHOD.

  METHOD to_xml.

    DATA li_output TYPE REF TO zif_abapgit_xml_output.

    CREATE OBJECT li_output TYPE zcl_abapgit_xml_output.

    li_output->add(
      iv_name = zcl_abapgit_persistence_db=>c_type_packages
      ig_data = it_packages ).

    rv_xml = li_output->render( ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_devc IMPLEMENTATION.

  METHOD adjust_sw_component.

    DATA:
      lv_namespace TYPE namespace,
      lv_comp_type TYPE c LENGTH 1.

    " Keep software component of a package for ABAP add-ons (customer and partner developments)...
    SELECT SINGLE comp_type FROM cvers INTO lv_comp_type WHERE component = cv_dlvunit.
    IF sy-subrc = 0 AND lv_comp_type = 'A'.
      " ... with a matching namespace (typical Add-on Assembly Kit scenario)
      lv_namespace = |/{ cv_dlvunit }/|.
      SELECT SINGLE namespace FROM trnspace INTO lv_namespace WHERE namespace = lv_namespace.
      IF sy-subrc <> 0.
        CLEAR cv_dlvunit.
      ENDIF.
    ELSE.
      CLEAR cv_dlvunit.
    ENDIF.

  ENDMETHOD.

  METHOD constructor.

    super->constructor(
      is_item        = is_item
      iv_language    = iv_language
      io_files       = io_files
      io_i18n_params = io_i18n_params ).

    IF is_item-devclass IS NOT INITIAL.
      mv_local_devclass = is_item-devclass.
    ELSE.
      mv_local_devclass = is_item-obj_name.
    ENDIF.

  ENDMETHOD.

  METHOD get_package.
    IF zif_abapgit_object~exists( ) = abap_true.
      ri_package = load_package( mv_local_devclass ).
    ENDIF.
  ENDMETHOD.

  METHOD is_empty.

    DATA: lv_object_name TYPE tadir-obj_name,
          lt_subpackages TYPE zif_abapgit_sap_package=>ty_devclass_tt.

    lt_subpackages = zcl_abapinst_factory=>get_sap_package( iv_package_name )->list_subpackages( ).

    IF lines( lt_subpackages ) > 0.
      rv_is_empty = abap_false.
      RETURN.
    ENDIF.

    " Ignore the SOTR if is linked to the current SAP package (DEVC)
    SELECT SINGLE obj_name
           FROM tadir
           INTO lv_object_name
           WHERE pgmid = 'R3TR'
           AND NOT ( ( object = 'DEVC' OR object = 'SOTR' ) AND obj_name = iv_package_name )
           AND devclass = iv_package_name.
    rv_is_empty = boolc( sy-subrc <> 0 ).

  ENDMETHOD.

  METHOD is_local.

    DATA lv_dlvunit TYPE tdevc-dlvunit.

    SELECT SINGLE dlvunit FROM tdevc INTO lv_dlvunit
        WHERE devclass = iv_package_name AND intsys <> 'SAP'.
    IF sy-subrc = 0 AND lv_dlvunit = 'LOCAL'.
      rv_is_local = abap_true.
    ENDIF.

  ENDMETHOD.

  METHOD load_package.

    cl_package_factory=>load_package(
      EXPORTING
        i_package_name             = iv_package_name
        i_force_reload             = abap_true
      IMPORTING
        e_package                  = ri_package
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        no_access                  = 4
        object_locked_and_modified = 5
        OTHERS                     = 6 ).
    IF sy-subrc = 1.
      RETURN.
    ELSEIF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD remove_obsolete_tadir.

    DATA:
      lv_pack  TYPE devclass,
      lt_pack  TYPE STANDARD TABLE OF devclass,
      ls_tadir TYPE zif_abapgit_definitions=>ty_tadir,
      lt_tadir TYPE zif_abapgit_definitions=>ty_tadir_tt,
      ls_item  TYPE zif_abapgit_definitions=>ty_item.

    " TADIR entries must remain for transportable packages
    IF is_local( iv_package_name ) = abap_false.
      RETURN.
    ENDIF.

    " Clean-up sub packages first
    SELECT devclass FROM tdevc INTO TABLE lt_pack
      WHERE parentcl = iv_package_name
      ORDER BY PRIMARY KEY.

    LOOP AT lt_pack INTO lv_pack.
      remove_obsolete_tadir( lv_pack ).
    ENDLOOP.

    " Remove TADIR entries for objects that do not exist anymore
    SELECT * FROM tadir INTO CORRESPONDING FIELDS OF TABLE lt_tadir
      WHERE devclass = iv_package_name
      ORDER BY PRIMARY KEY ##TOO_MANY_ITAB_FIELDS.

    LOOP AT lt_tadir INTO ls_tadir.
      ls_item-obj_type = ls_tadir-object.
      ls_item-obj_name = ls_tadir-obj_name.

      IF zcl_abapinst_objects=>exists( ls_item ) = abap_false.
        CALL FUNCTION 'TR_TADIR_INTERFACE'
          EXPORTING
            wi_delete_tadir_entry = abap_true
            wi_tadir_pgmid        = 'R3TR'
            wi_tadir_object       = ls_tadir-object
            wi_tadir_obj_name     = ls_tadir-obj_name
            wi_test_modus         = abap_false
          EXCEPTIONS
            OTHERS                = 1 ##FM_SUBRC_OK.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD set_lock.

    DATA: lv_changeable TYPE abap_bool.

    ii_package->get_changeable( IMPORTING e_changeable = lv_changeable ).
    IF lv_changeable <> iv_lock.
      TRY.
          CALL METHOD ii_package->('SET_CHANGEABLE')
            EXPORTING
              i_changeable                = iv_lock
              i_suppress_dialog           = abap_true " Parameter missing in 702
            EXCEPTIONS
              object_locked_by_other_user = 1
              permission_failure          = 2
              object_already_changeable   = 3
              object_already_unlocked     = 4
              object_just_created         = 5
              object_deleted              = 6
              object_modified             = 7
              object_not_existing         = 8
              object_invalid              = 9
              unexpected_error            = 10
              OTHERS                      = 11.
        CATCH cx_sy_dyn_call_param_not_found.
          ii_package->set_changeable(
            EXPORTING
              i_changeable                = iv_lock
            EXCEPTIONS
              object_locked_by_other_user = 1
              permission_failure          = 2
              object_already_changeable   = 3
              object_already_unlocked     = 4
              object_just_created         = 5
              object_deleted              = 6
              object_modified             = 7
              object_not_existing         = 8
              object_invalid              = 9
              unexpected_error            = 10
              OTHERS                      = 11 ).
      ENDTRY.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDIF.

    TRY.
        CALL METHOD ii_package->('SET_PERMISSIONS_CHANGEABLE')
          EXPORTING
            i_changeable                = iv_lock
            i_suppress_dialog           = abap_true " Parameter missing in 702
          EXCEPTIONS
            object_already_changeable   = 1
            object_already_unlocked     = 2
            object_locked_by_other_user = 3
            object_modified             = 4
            object_just_created         = 5
            object_deleted              = 6
            permission_failure          = 7
            object_invalid              = 8
            unexpected_error            = 9
            OTHERS                      = 10.
      CATCH cx_sy_dyn_call_param_not_found.
        ii_package->set_permissions_changeable(
          EXPORTING
            i_changeable                = iv_lock
          EXCEPTIONS
            object_already_changeable   = 1
            object_already_unlocked     = 2
            object_locked_by_other_user = 3
            object_modified             = 4
            object_just_created         = 5
            object_deleted              = 6
            permission_failure          = 7
            object_invalid              = 8
            unexpected_error            = 9
            OTHERS                      = 10 ).
    ENDTRY.
    IF ( sy-subrc = 1 AND iv_lock = abap_true ) OR ( sy-subrc = 2 AND iv_lock = abap_false ).
      " There's no getter to find out beforehand...
    ELSEIF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD unlock_and_raise_error.

    DATA ls_msg TYPE bal_s_msg.

    " Remember message since unlock overwrites it (for example with XT465)
    MOVE-CORRESPONDING sy TO ls_msg.

    set_lock( ii_package = ii_package
              iv_lock    = abap_false ).

    zcx_abapgit_exception=>raise_t100(
      iv_msgid = ls_msg-msgid
      iv_msgno = ls_msg-msgno
      iv_msgv1 = ls_msg-msgv1
      iv_msgv2 = ls_msg-msgv2
      iv_msgv3 = ls_msg-msgv3
      iv_msgv4 = ls_msg-msgv4 ).

  ENDMETHOD.

  METHOD update_pinf_usages.
    DATA: lt_current_permissions TYPE tpak_permission_to_use_list,
          li_usage               TYPE REF TO if_package_permission_to_use,
          ls_data_sign           TYPE scomppsign,
          ls_add_permission_data TYPE pkgpermdat,
          lt_handled             TYPE SORTED TABLE OF i WITH UNIQUE KEY table_line.
    FIELD-SYMBOLS: <ls_usage_data> LIKE LINE OF it_usage_data.

    " Get the current permissions
    ii_package->get_permissions_to_use(
      IMPORTING
        e_permissions    = lt_current_permissions
      EXCEPTIONS
        object_invalid   = 1
        unexpected_error = 2
        OTHERS           = 3 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    ls_data_sign-err_sever = abap_true.

    " New permissions
    LOOP AT it_usage_data ASSIGNING <ls_usage_data>.
      READ TABLE lt_current_permissions
           WITH KEY table_line->package_interface_name = <ls_usage_data>-intf_name
           INTO li_usage.

      IF sy-subrc = 0 AND li_usage IS BOUND.
        INSERT sy-tabix INTO TABLE lt_handled.

        " Permission already exists, update attributes
        li_usage->set_all_attributes(
          EXPORTING
            i_permission_data     = <ls_usage_data>
            i_data_sign           = ls_data_sign
          EXCEPTIONS
            object_not_changeable = 1
            object_invalid        = 2
            intern_err            = 3
            OTHERS                = 4 ).
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise_t100( ).
        ENDIF.

      ELSE.
        " Permission does not exist yet, add it
        MOVE-CORRESPONDING <ls_usage_data> TO ls_add_permission_data.
        ii_package->add_permission_to_use(
          EXPORTING
            i_pkg_permission_data   = ls_add_permission_data
          EXCEPTIONS
            object_not_changeable   = 1
            object_access_error     = 2
            object_already_existing = 3
            object_invalid          = 4
            unexpected_error        = 5
            OTHERS                  = 6 ).
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise_t100( ).
        ENDIF.

      ENDIF.

      FREE li_usage.
    ENDLOOP.

    " Delete missing usages
    LOOP AT lt_current_permissions INTO li_usage.
      READ TABLE lt_handled WITH TABLE KEY table_line = sy-tabix TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        CONTINUE.
      ENDIF.

      li_usage->delete(
        EXCEPTIONS
          object_not_changeable = 1
          object_invalid        = 2
*          deletion_not_allowed  = 3 downport, does not exist in 7.30
          intern_err            = 4
          OTHERS                = 5 ).
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    DATA li_package TYPE REF TO if_package.

    li_package = get_package( ).
    IF li_package IS BOUND.
      rv_user = li_package->changed_by.
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: li_package TYPE REF TO if_package,
          lv_package TYPE devclass.

    " Package deletion is a bit tricky. A package can only be deleted if there are no objects
    " contained in it. This includes subpackages, so first the leaf packages need to be deleted.
    " Unfortunately deleted objects that are still contained in an unreleased transport request
    " also count towards the contained objects counter.
    " -> Currently we delete only empty packages
    "
    " If objects are deleted, the TADIR entry is deleted when the transport request is released.
    " So before we can delete the package, the transport which deletes the objects
    " in the package has to be released.

    lv_package = ms_item-obj_name.

    " Remove remaining OTR entries
    zcl_abapgit_sotr_handler=>delete_sotr_package( iv_package ).

    remove_obsolete_tadir( lv_package ).

    IF is_empty( lv_package ) = abap_true.

      li_package = load_package( lv_package ).

      IF li_package IS NOT BOUND.
        RETURN.
      ENDIF.

      IF lv_package(1) = '$'.
        zcl_abapgit_persist_packages=>get_instance( )->modify( lv_package ).
      ENDIF.

      set_lock( ii_package = li_package
                iv_lock    = abap_true ).

      TRY.
          CALL METHOD li_package->('DELETE')
            EXPORTING
              i_suppress_dialog     = abap_true  " Parameter missing in 702
            EXCEPTIONS
              object_not_empty      = 1
              object_not_changeable = 2
              object_invalid        = 3
              intern_err            = 4
              OTHERS                = 5.

        CATCH cx_sy_dyn_call_param_not_found.

          li_package->delete(
            EXCEPTIONS
              object_not_empty      = 1
              object_not_changeable = 2
              object_invalid        = 3
              intern_err            = 4
              OTHERS                = 5 ).

      ENDTRY.

      IF sy-subrc <> 0.
        unlock_and_raise_error( li_package ).
      ENDIF.

      TRY.
          CALL METHOD li_package->('SAVE')
            EXPORTING
              i_suppress_dialog     = abap_true
            EXCEPTIONS
              object_invalid        = 1
              object_not_changeable = 2
              cancelled_in_corr     = 3
              permission_failure    = 4
              unexpected_error      = 5
              intern_err            = 6
              OTHERS                = 7.

        CATCH cx_sy_dyn_call_param_not_found.

          li_package->save(
            EXCEPTIONS
              object_invalid        = 1
              object_not_changeable = 2
              cancelled_in_corr     = 3
              permission_failure    = 4
              unexpected_error      = 5
              intern_err            = 6
              OTHERS                = 7 ).

      ENDTRY.

      IF sy-subrc <> 0.
        unlock_and_raise_error( li_package ).
      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: li_package      TYPE REF TO if_package,
          ls_package_data TYPE scompkdtln,
          ls_data_sign    TYPE scompksign,
          lt_usage_data   TYPE scomppdata,
          ls_save_sign    TYPE paksavsign.

    FIELD-SYMBOLS: <ls_usage_data> TYPE scomppdtln.
    FIELD-SYMBOLS: <lg_field> TYPE any.

    mv_local_devclass = iv_package.

    io_xml->read(
      EXPORTING
        iv_name = 'DEVC'
      CHANGING
        cg_data = ls_package_data ).

    IF mv_local_devclass(1) = '$'.
      IF ls_package_data-mainpack = 'X'.
        zcx_abapgit_exception=>raise( |Main package { iv_package } cannot be used in local package| ).
      ELSEIF ls_package_data-mainpack = 'S'.
        zcx_abapgit_exception=>raise( |Structure package { iv_package } cannot be used in local package| ).
      ENDIF.
    ENDIF.

    li_package = get_package( ).

    " Swap out repository package name with the local installation package name
    ls_package_data-devclass = mv_local_devclass.
    IF li_package IS BOUND.
      ls_package_data-pdevclass = li_package->transport_layer.
    ENDIF.

    " For local packages store application component
    IF ls_package_data-devclass(1) = '$'.
      zcl_abapgit_persist_packages=>get_instance( )->modify(
        iv_package    = ls_package_data-devclass
        iv_component  = ls_package_data-component
        iv_comp_posid = ls_package_data-comp_posid ).
    ENDIF.

    " Parent package is not changed. Assume the folder logic already created the package and set
    " the hierarchy before.
    CLEAR ls_package_data-parentcl.

    ASSIGN COMPONENT 'PACKKIND' OF STRUCTURE ls_package_data TO <lg_field>.
    IF sy-subrc = 0.
      set_abap_language_version( CHANGING cv_abap_language_version = <lg_field> ).
    ENDIF.
    ASSIGN COMPONENT 'PACKKIND' OF STRUCTURE ls_data_sign TO <lg_field>.
    IF sy-subrc = 0.
      <lg_field> = abap_true.
    ENDIF.

* Fields not set:
* korrflag
* parentcl
* cli_check
* intprefx
    IF ls_package_data-dlvunit IS NOT INITIAL.
      ls_data_sign-dlvunit = abap_true.
    ENDIF.
    ls_data_sign-ctext            = abap_true.
    ls_data_sign-as4user          = abap_true.
    ls_data_sign-pdevclass        = abap_true.
    ls_data_sign-comp_posid       = abap_true.
    ls_data_sign-component        = abap_true.
    ls_data_sign-perminher        = abap_true.
    ls_data_sign-packtype         = abap_true.
    ls_data_sign-restricted       = abap_true.
    ls_data_sign-mainpack         = abap_true.
    ls_data_sign-srv_check        = abap_true.
    ls_data_sign-ext_alias        = abap_true.
    ls_data_sign-project_guid     = abap_true.
    ls_data_sign-project_id       = abap_true.
    ls_data_sign-project_passdown = abap_true.

    IF ls_package_data-ctext IS INITIAL.
      ls_package_data-ctext = mv_local_devclass.
    ENDIF.
    IF ls_package_data-dlvunit IS INITIAL.
      ls_package_data-dlvunit = 'HOME'.
    ENDIF.

    ls_package_data-as4user = sy-uname.

    IF li_package IS BOUND.
      " Package already exists, change it
      set_lock( ii_package = li_package
                iv_lock    = abap_true ).

      li_package->set_all_attributes(
        EXPORTING
          i_package_data             = ls_package_data
          i_data_sign                = ls_data_sign
        EXCEPTIONS
          object_not_changeable      = 1
          object_deleted             = 2
          object_invalid             = 3
          short_text_missing         = 4
          author_not_existing        = 5
          local_package              = 6
          software_component_invalid = 7
          layer_invalid              = 8
          korrflag_invalid           = 9
          component_not_existing     = 10
          component_missing          = 11
          authorize_failure          = 12
          prefix_in_use              = 13
          unexpected_error           = 14
          intern_err                 = 15
*          wrong_mainpack_value       = 16  downport, does not exist in 7.30
*          superpackage_invalid       = 17  downport, does not exist in 7.30
          OTHERS                     = 18 ).
      IF sy-subrc <> 0.
        unlock_and_raise_error( li_package ).
      ENDIF.

    ELSE.
      " Package does not exist yet, create it
      " This shouldn't really happen, because the folder logic initially creates the packages.
      cl_package_factory=>create_new_package(
        IMPORTING
          e_package                  = li_package
        CHANGING
          c_package_data             = ls_package_data
        EXCEPTIONS
          object_already_existing    = 1
          object_just_created        = 2
          not_authorized             = 3
          wrong_name_prefix          = 4
          undefined_name             = 5
          reserved_local_name        = 6
          invalid_package_name       = 7
          short_text_missing         = 8
          software_component_invalid = 9
          layer_invalid              = 10
          author_not_existing        = 11
          component_not_existing     = 12
          component_missing          = 13
          prefix_in_use              = 14
          unexpected_error           = 15
          intern_err                 = 16
          no_access                  = 17
*          invalid_translation_depth  = 18 downport, does not exist in 7.30
*          wrong_mainpack_value       = 19 downport, does not exist in 7.30
*          superpackage_invalid       = 20 downport, does not exist in 7.30
*          error_in_cts_checks        = 21 downport, does not exist in 7.31
          OTHERS                     = 22 ).
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDIF.

    " Load package interface usages
    TRY.
        io_xml->read(
          EXPORTING
            iv_name = 'PERMISSION'
          CHANGING
            cg_data = lt_usage_data ).
      CATCH zcx_abapgit_exception ##NO_HANDLER.
        " No permissions saved
    ENDTRY.

    LOOP AT lt_usage_data ASSIGNING <ls_usage_data>.
      <ls_usage_data>-client_pak = mv_local_devclass.
    ENDLOOP.

    update_pinf_usages( ii_package    = li_package
                        it_usage_data = lt_usage_data ).

    ls_save_sign-pack   = abap_true.
    ls_save_sign-permis = abap_true.
    ls_save_sign-elems  = abap_true.
    ls_save_sign-interf = abap_true.

    li_package->save_generic(
      EXPORTING
        i_save_sign           = ls_save_sign
        i_transport_request   = iv_transport
        i_suppress_dialog     = abap_true
      EXCEPTIONS
        cancelled_in_corr     = 1
        permission_failure    = 2
        object_not_changeable = 3
        object_invalid        = 4
        OTHERS                = 5 ).
    IF sy-subrc <> 0.
      unlock_and_raise_error( li_package ).
    ENDIF.

    set_lock( ii_package = li_package
              iv_lock    = abap_false ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.
    " Check remote package if deserialize has not been called before this
    IF mv_local_devclass IS INITIAL.
      rv_bool = abap_false.
    ELSE.
      cl_package_helper=>check_package_existence(
        EXPORTING
          i_package_name          = mv_local_devclass
        IMPORTING
          e_package_exists        = rv_bool
        EXCEPTIONS
          intern_err              = 1
          OTHERS                  = 2 ).
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = 'EEUDB'
                                            iv_argument    = ms_item-obj_name
                                            iv_prefix      = 'DV' ).
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by zcl_abapinst_objects=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.

    IF iv_filename <> zcl_abapgit_filename_logic=>c_package_file.
      zcx_abapgit_exception=>raise( |Unexpected filename for package { cs_item-obj_name }| ).
    ENDIF.

    " Try to get a unique package name for DEVC by using the path
    cs_item-obj_name = zcl_abapgit_folder_logic=>get_instance( )->path_to_package(
      iv_top                  = iv_package
      io_dot                  = io_dot
      iv_create_if_not_exists = abap_false
      iv_path                 = iv_path ).

  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.

    " Packages have a fixed filename so that the repository can be installed to a different
    " package(-hierarchy) on the client and not show up as a different package in the repo.
    cv_filename = zcl_abapgit_filename_logic=>c_package_file.

  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.
    DATA: ls_package_data TYPE scompkdtln,
          ls_package_comp TYPE zcl_abapgit_persist_packages=>ty_package,
          li_package      TYPE REF TO if_package,
          lt_intf_usages  TYPE tpak_permission_to_use_list,
          lt_usage_data   TYPE scomppdata,
          ls_usage_data   TYPE scomppdtln,
          li_usage        TYPE REF TO if_package_permission_to_use.

    FIELD-SYMBOLS: <lg_field> TYPE any.

    li_package = get_package( ).
    IF li_package IS NOT BOUND.
      zcx_abapgit_exception=>raise( |Could not find package to serialize.| ).
    ENDIF.

    li_package->get_all_attributes(
      IMPORTING
        e_package_data  = ls_package_data
      EXCEPTIONS
        object_invalid  = 1
        package_deleted = 2
        intern_err      = 3
        OTHERS          = 4 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    " For local packages get application component
    IF is_local( ls_package_data-devclass ) = abap_true.
      ls_package_comp = zcl_abapgit_persist_packages=>get_instance( )->read( ls_package_data-devclass ).
      ls_package_data-component  = ls_package_comp-component.
      ls_package_data-comp_posid = ls_package_comp-comp_posid.
    ENDIF.

    CLEAR: ls_package_data-devclass,
           ls_package_data-parentcl.

    " Clear administrative data to prevent diffs
    CLEAR: ls_package_data-created_by,
           ls_package_data-created_on,
           ls_package_data-changed_by,
           ls_package_data-changed_on,
           ls_package_data-as4user.

    " Clear text descriptions that might be localized
    CLEAR: ls_package_data-comp_text,
           ls_package_data-dlvu_text,
           ls_package_data-layer_text.

    " Clear obsolete fields
    CLEAR: ls_package_data-intfprefx,
           ls_package_data-cli_check.

    " If software component is related to add-on and a valid namespace, then keep it
    adjust_sw_component( CHANGING cv_dlvunit = ls_package_data-dlvunit ).

    ASSIGN COMPONENT 'TRANSLATION_DEPTH_TEXT'
           OF STRUCTURE ls_package_data
           TO <lg_field>.
    IF sy-subrc = 0.
      CLEAR: <lg_field>.
    ENDIF.

    ASSIGN COMPONENT 'TRANSLATION_GRAPH_DEPTH_TEXT'
           OF STRUCTURE ls_package_data
           TO <lg_field>.
    IF sy-subrc = 0.
      CLEAR: <lg_field>.
    ENDIF.

    " Clear things related to local installation package
    CLEAR: ls_package_data-namespace,
           ls_package_data-dlvunit,
           ls_package_data-tpclass,
           ls_package_data-pdevclass.

    " Not usable on customer systems
    ASSIGN COMPONENT 'TRANSLATION_DEPTH'
           OF STRUCTURE ls_package_data
           TO <lg_field>.
    IF sy-subrc = 0.
      CLEAR: <lg_field>.
    ENDIF.

    ASSIGN COMPONENT 'TRANSLATION_GRAPH_DEPTH'
           OF STRUCTURE ls_package_data
           TO <lg_field>.
    IF sy-subrc = 0.
      CLEAR: <lg_field>.
    ENDIF.

    CLEAR: ls_package_data-korrflag.

    ASSIGN COMPONENT 'PACKKIND' OF STRUCTURE ls_package_data TO <lg_field>.
    IF sy-subrc = 0.
      clear_abap_language_version( CHANGING cv_abap_language_version = <lg_field> ).
    ENDIF.

    io_xml->add( iv_name = 'DEVC'
                 ig_data = ls_package_data ).

    " Save package interface usages
    li_package->get_permissions_to_use(
      IMPORTING
        e_permissions    = lt_intf_usages
      EXCEPTIONS
        object_invalid   = 1
        unexpected_error = 2
        OTHERS           = 3 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    LOOP AT lt_intf_usages INTO li_usage.
      li_usage->get_all_attributes(
        IMPORTING
          e_permission_data = ls_usage_data
        EXCEPTIONS
          object_invalid    = 1
          intern_err        = 2
          OTHERS            = 3 ).
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      CLEAR: ls_usage_data-pack_name, ls_usage_data-client_pak.

      APPEND ls_usage_data TO lt_usage_data.
    ENDLOOP.

    IF lt_usage_data IS NOT INITIAL.
      io_xml->add( iv_name = 'PERMISSION'
                   ig_data = lt_usage_data ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_doma IMPLEMENTATION.

  METHOD adjust_exit.

    DATA lv_function TYPE funcname.

    IF cv_exit IS NOT INITIAL.
      lv_function = |CONVERSION_EXIT_{ cv_exit }_INPUT|.

      " If exit function does not exist, remove it
      IF zcl_abapinst_factory=>get_function_module( )->function_exists( lv_function ) = abap_false.
        cv_exit = ''.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD check_exit.

    DATA lv_exit TYPE dd01v-convexit.

    rv_done = abap_true.

    IF iv_exit IS NOT INITIAL.
      " Check if exit function is set correctly
      SELECT SINGLE convexit FROM dd01v INTO lv_exit WHERE domname = ms_item-obj_name.
      IF sy-subrc = 0 AND lv_exit <> iv_exit.
        rv_done = abap_false.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD deserialize_texts.

    DATA: lv_name       TYPE ddobjname,
          lv_valpos     TYPE valpos,
          ls_dd01v_tmp  TYPE dd01v,
          lt_dd07v_tmp  TYPE TABLE OF dd07v,
          lt_i18n_langs TYPE TABLE OF langu,
          lt_dd01_texts TYPE ty_dd01_texts,
          lt_dd07_texts TYPE ty_dd07_texts.

    FIELD-SYMBOLS: <lv_lang>      LIKE LINE OF lt_i18n_langs,
                   <ls_dd07v>     LIKE LINE OF it_dd07v,
                   <ls_dd01_text> LIKE LINE OF lt_dd01_texts,
                   <ls_dd07_text> LIKE LINE OF lt_dd07_texts.

    lv_name = ms_item-obj_name.

    ii_xml->read( EXPORTING iv_name = 'I18N_LANGS'
                  CHANGING  cg_data = lt_i18n_langs ).

    ii_xml->read( EXPORTING iv_name = 'DD01_TEXTS'
                  CHANGING  cg_data = lt_dd01_texts ).

    ii_xml->read( EXPORTING iv_name = 'DD07_TEXTS'
                  CHANGING  cg_data = lt_dd07_texts ).

    mo_i18n_params->trim_saplang_list( CHANGING ct_sap_langs = lt_i18n_langs ).

    SORT lt_i18n_langs.
    SORT lt_dd07_texts BY ddlanguage. " Optimization

    LOOP AT lt_i18n_langs ASSIGNING <lv_lang>.

      " Domain description
      ls_dd01v_tmp = is_dd01v.
      READ TABLE lt_dd01_texts ASSIGNING <ls_dd01_text> WITH KEY ddlanguage = <lv_lang>.
      IF sy-subrc > 0.
        zcx_abapgit_exception=>raise( |DD01_TEXTS cannot find lang { <lv_lang> } in XML| ).
      ENDIF.
      MOVE-CORRESPONDING <ls_dd01_text> TO ls_dd01v_tmp.

      " Domain values
      lt_dd07v_tmp = it_dd07v.
      LOOP AT lt_dd07v_tmp ASSIGNING <ls_dd07v>.
        lv_valpos = <ls_dd07v>-valpos.
        " it_dd07v was potentially renumbered so lookup by value
        READ TABLE lt_dd07_texts ASSIGNING <ls_dd07_text>
          WITH KEY ddlanguage = <lv_lang> domvalue_l = <ls_dd07v>-domvalue_l domvalue_h = <ls_dd07v>-domvalue_h.
        IF sy-subrc = 0.
          MOVE-CORRESPONDING <ls_dd07_text> TO <ls_dd07v>.
          <ls_dd07v>-valpos = lv_valpos.
          DELETE lt_dd07_texts INDEX sy-tabix. " Optimization
        ELSE.
          " no translation -> keep entry but clear texts
          <ls_dd07v>-ddlanguage = <lv_lang>.
          CLEAR: <ls_dd07v>-ddtext, <ls_dd07v>-domval_ld, <ls_dd07v>-domval_hd.
        ENDIF.
      ENDLOOP.

      CALL FUNCTION 'DDIF_DOMA_PUT'
        EXPORTING
          name              = lv_name
          dd01v_wa          = ls_dd01v_tmp
        TABLES
          dd07v_tab         = lt_dd07v_tmp
        EXCEPTIONS
          doma_not_found    = 1
          name_inconsistent = 2
          doma_inconsistent = 3
          put_failure       = 4
          put_refused       = 5
          OTHERS            = 6.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD handle_dependencies.

    " For domains with dependency on conversion exit function, we use two phases:
    " 1) DDIC phase:
    "    - If function does not exit, remove the exit function
    " 2) LATE phase
    "    - If function was removed, change it to the correct exit function
    CASE iv_step.
      WHEN zif_abapgit_object=>gc_step_id-ddic.
        adjust_exit( CHANGING cv_exit = cv_exit ).

      WHEN zif_abapgit_object=>gc_step_id-late.
        cv_done = check_exit( cv_exit ).

      WHEN OTHERS.
        ASSERT 0 = 1.
    ENDCASE.

  ENDMETHOD.

  METHOD serialize_texts.

    DATA: lv_name            TYPE ddobjname,
          lv_index           TYPE i,
          ls_dd01v           TYPE dd01v,
          lt_dd07v           TYPE TABLE OF dd07v,
          lt_i18n_langs      TYPE TABLE OF langu,
          lt_dd01_texts      TYPE ty_dd01_texts,
          lt_dd07_texts      TYPE ty_dd07_texts,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    FIELD-SYMBOLS: <lv_lang>      LIKE LINE OF lt_i18n_langs,
                   <ls_dd07v>     LIKE LINE OF lt_dd07v,
                   <ls_dd07v_tmp> LIKE LINE OF lt_dd07v,
                   <ls_dd01_text> LIKE LINE OF lt_dd01_texts,
                   <ls_dd07_text> LIKE LINE OF lt_dd07_texts.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN.
    ENDIF.

    lv_name = ms_item-obj_name.

    " Collect additional languages, skip main lang - it was serialized already
    lt_language_filter = mo_i18n_params->build_language_filter( ).

    SELECT DISTINCT ddlanguage AS langu INTO TABLE lt_i18n_langs
      FROM dd01v
      WHERE domname = lv_name
      AND ddlanguage IN lt_language_filter
      AND ddlanguage <> mv_language
      ORDER BY langu.                                     "#EC CI_SUBRC

    SELECT DISTINCT ddlanguage AS langu APPENDING TABLE lt_i18n_langs
      FROM dd07v
      WHERE domname = lv_name
      AND ddlanguage IN lt_language_filter
      AND ddlanguage <> mv_language
      ORDER BY langu.                                     "#EC CI_SUBRC

    SORT lt_i18n_langs.
    DELETE ADJACENT DUPLICATES FROM lt_i18n_langs.

    LOOP AT lt_i18n_langs ASSIGNING <lv_lang>.
      lv_index = sy-tabix.

      CALL FUNCTION 'DDIF_DOMA_GET'
        EXPORTING
          name          = lv_name
          langu         = <lv_lang>
        IMPORTING
          dd01v_wa      = ls_dd01v
        TABLES
          dd07v_tab     = lt_dd07v
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.
      IF sy-subrc <> 0.
        DELETE lt_i18n_langs INDEX lv_index. " Don't save this lang
        CONTINUE.
      ENDIF.

      IF ls_dd01v-ddlanguage IS INITIAL.
        ls_dd01v-ddlanguage = <lv_lang>.
      ENDIF.

      APPEND INITIAL LINE TO lt_dd01_texts ASSIGNING <ls_dd01_text>.
      MOVE-CORRESPONDING ls_dd01v TO <ls_dd01_text>.

      " Process main language entries and find corresponding translation
      LOOP AT it_dd07v ASSIGNING <ls_dd07v> WHERE NOT ddlanguage IS INITIAL.
        APPEND INITIAL LINE TO lt_dd07_texts ASSIGNING <ls_dd07_text>.
        READ TABLE lt_dd07v ASSIGNING <ls_dd07v_tmp>
          WITH KEY ddlanguage = <lv_lang> domvalue_l = <ls_dd07v>-domvalue_l domvalue_h = <ls_dd07v>-domvalue_h.
        IF sy-subrc = 0.
          MOVE-CORRESPONDING <ls_dd07v_tmp> TO <ls_dd07_text>.
        ELSE.
          " no translation -> keep entry but clear texts
          MOVE-CORRESPONDING <ls_dd07v> TO <ls_dd07_text>.
          <ls_dd07_text>-ddlanguage = <lv_lang>.
          CLEAR: <ls_dd07_text>-ddtext, <ls_dd07_text>-domval_ld, <ls_dd07_text>-domval_hd.
        ENDIF.
      ENDLOOP.

    ENDLOOP.

    SORT lt_i18n_langs ASCENDING.
    SORT lt_dd01_texts BY ddlanguage ASCENDING.
    SORT lt_dd07_texts BY valpos ASCENDING ddlanguage ASCENDING.

    IF lines( lt_i18n_langs ) > 0.
      ii_xml->add( iv_name = 'I18N_LANGS'
                   ig_data = lt_i18n_langs ).

      ii_xml->add( iv_name = 'DD01_TEXTS'
                   ig_data = lt_dd01_texts ).

      ii_xml->add( iv_name = 'DD07_TEXTS'
                   ig_data = lt_dd07_texts ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE as4user FROM dd01l INTO rv_user
      WHERE domname = ms_item-obj_name
      AND as4local = 'A'
      AND as4vers = '0000'.
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    delete_ddic( iv_objtype              = 'D'
                 iv_no_ask_delete_append = abap_true ).

    delete_longtexts( c_longtext_id_doma ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

* package SEDD
* package SDIC

    DATA: lv_name  TYPE ddobjname,
          lv_done  TYPE abap_bool,
          ls_dd01v TYPE dd01v,
          lt_dd07v TYPE TABLE OF dd07v.

    FIELD-SYMBOLS <ls_dd07v> TYPE dd07v.

    io_xml->read( EXPORTING iv_name = 'DD01V'
                  CHANGING  cg_data = ls_dd01v ).
    io_xml->read( EXPORTING iv_name = 'DD07V_TAB'
                  CHANGING  cg_data = lt_dd07v ).

    handle_dependencies(
      EXPORTING
        iv_step = iv_step
      CHANGING
        cv_exit = ls_dd01v-convexit
        cv_done = lv_done ).

    IF lv_done = abap_true.
      RETURN.
    ENDIF.

    corr_insert( iv_package      = iv_package
                 ig_object_class = 'DICT' ).

    lv_name = ms_item-obj_name. " type conversion

    LOOP AT lt_dd07v ASSIGNING <ls_dd07v>.
      <ls_dd07v>-domname = lv_name.
      <ls_dd07v>-valpos = sy-tabix.
    ENDLOOP.

    CALL FUNCTION 'DDIF_DOMA_PUT'
      EXPORTING
        name              = lv_name
        dd01v_wa          = ls_dd01v
      TABLES
        dd07v_tab         = lt_dd07v
      EXCEPTIONS
        doma_not_found    = 1
        name_inconsistent = 2
        doma_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      deserialize_texts(
        ii_xml   = io_xml
        is_dd01v = ls_dd01v
        it_dd07v = lt_dd07v ).
    ENDIF.

    deserialize_longtexts( ii_xml         = io_xml
                           iv_longtext_id = c_longtext_id_doma ).

    zcl_abapgit_objects_activation=>add_item( ms_item ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA lv_domname TYPE dd01l-domname.

    SELECT SINGLE domname FROM dd01l INTO lv_domname
      WHERE domname = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-ddic TO rt_steps.
    APPEND zif_abapgit_object=>gc_step_id-late TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = 'ESDICT'
                                            iv_argument    = |{ ms_item-obj_type }{ ms_item-obj_name }| ).
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by ZCL_ABAPGIT_OBJECT=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_name    TYPE ddobjname,
          lv_state   TYPE ddgotstate,
          ls_dd01v   TYPE dd01v,
          lv_masklen TYPE c LENGTH 4,
          lt_dd07v   TYPE TABLE OF dd07v.

    FIELD-SYMBOLS <ls_dd07v> TYPE dd07v.

    lv_name = ms_item-obj_name.

    CALL FUNCTION 'DDIF_DOMA_GET'
      EXPORTING
        name          = lv_name
        state         = 'A'
        langu         = mv_language
      IMPORTING
        gotstate      = lv_state
        dd01v_wa      = ls_dd01v
      TABLES
        dd07v_tab     = lt_dd07v
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    IF ls_dd01v IS INITIAL OR lv_state <> 'A'.
      RETURN.
    ENDIF.

    CLEAR: ls_dd01v-as4user,
           ls_dd01v-as4date,
           ls_dd01v-as4time,
           ls_dd01v-appexist.

* make sure XML serialization does not dump if the field contains invalid data
* note that this is a N field, so '' is not valid
    IF ls_dd01v-authclass = ''.
      CLEAR ls_dd01v-authclass.
    ENDIF.
    lv_masklen = ls_dd01v-masklen.
    IF lv_masklen = '' OR NOT lv_masklen CO '0123456789'.
      CLEAR ls_dd01v-masklen.
    ENDIF.

    DELETE lt_dd07v WHERE appval = abap_true.

    SORT lt_dd07v BY
      valpos ASCENDING
      ddlanguage ASCENDING.

    LOOP AT lt_dd07v ASSIGNING <ls_dd07v>.
      CLEAR <ls_dd07v>-domname.
    ENDLOOP.

    io_xml->add( iv_name = 'DD01V'
                 ig_data = ls_dd01v ).
    io_xml->add( iv_name = 'DD07V_TAB'
                 ig_data = lt_dd07v ).

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      serialize_texts(
        ii_xml   = io_xml
        it_dd07v = lt_dd07v ).
    ENDIF.

    serialize_longtexts( ii_xml         = io_xml
                         iv_longtext_id = c_longtext_id_doma ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_dsys IMPLEMENTATION.

  METHOD constructor.

    DATA: lv_prefix    TYPE namespace,
          lv_bare_name TYPE progname.

    super->constructor(
      is_item        = is_item
      iv_language    = iv_language
      io_files       = io_files
      io_i18n_params = io_i18n_params ).

    IF ms_item-obj_name(1) = '/'.

      CALL FUNCTION 'RS_NAME_SPLIT_NAMESPACE'
        EXPORTING
          name_with_namespace    = ms_item-obj_name
        IMPORTING
          namespace              = lv_prefix
          name_without_namespace = lv_bare_name.

      mv_doc_object = |{ lv_bare_name+0(4) }{ lv_prefix }{ lv_bare_name+4(*) }|.
    ELSE.

      mv_doc_object = ms_item-obj_name.
    ENDIF.

  ENDMETHOD.

  METHOD deserialize_dsys.

    DATA: ls_data      TYPE ty_data,
          ls_docu_info TYPE dokil,
          lv_version   TYPE dokvers,
          lv_doku_obj  TYPE doku_obj.

    lv_doku_obj = mv_doc_object.
    ii_xml->read( EXPORTING iv_name = 'DSYS'
                  CHANGING cg_data = ls_data ).

    CALL FUNCTION 'DOCU_INIT'
      EXPORTING
        id     = c_id
        langu  = mv_language
        object = lv_doku_obj
        typ    = c_typ
      IMPORTING
        xdokil = ls_docu_info.

    lv_version = ls_docu_info-version.

    CALL FUNCTION 'DOCU_UPDATE'
      EXPORTING
        head    = ls_data-head
        state   = 'A'
        typ     = c_typ
        version = lv_version
      TABLES
        line    = ls_data-lines.

  ENDMETHOD.

  METHOD get_main_lang.

    SELECT SINGLE langu FROM dokil INTO rv_language
      WHERE id = c_id
      AND object = mv_doc_object
      AND masterlang = abap_true.                       "#EC CI_NOORDER

    IF sy-subrc <> 0.
      rv_language = mv_language.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    rv_user = zcl_abapinst_factory=>get_longtexts( )->changed_by(
      iv_object_name = mv_doc_object
      iv_longtext_id = c_id ).

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    zcl_abapinst_factory=>get_longtexts( )->delete(
      iv_object_name = mv_doc_object
      iv_longtext_id = c_id ).

    corr_insert( iv_package ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_metadata TYPE zif_abapgit_definitions=>ty_metadata.

    ls_metadata = io_xml->get_metadata( ).

    CASE ls_metadata-version.

      WHEN 'v1.0.0'.
        deserialize_dsys( io_xml ).

      WHEN 'v2.0.0'.
        zcl_abapinst_factory=>get_longtexts( )->deserialize(
          ii_xml           = io_xml
          iv_object_name   = mv_doc_object
          iv_longtext_id   = c_id
          iv_main_language = mv_language ).

      WHEN OTHERS.
        zcx_abapgit_exception=>raise( 'unsupported DSYS version' ).

    ENDCASE.

    tadir_insert( iv_package ).

    corr_insert( iv_package ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_count TYPE i.

    SELECT SINGLE COUNT( * ) FROM dokil INTO lv_count
           WHERE id   = c_id
           AND object = mv_doc_object.  "#EC CI_GENBUFF "#EC CI_NOORDER

    rv_bool = boolc( lv_count > 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
    rs_metadata-version = 'v2.0.0'.
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA lv_lang TYPE sy-langu.

    lv_lang = get_main_lang( ).

    CALL FUNCTION 'DSYS_EDIT'
      EXPORTING
        dokclass            = mv_doc_object+0(4)
        dokname             = mv_doc_object+4(*)
        doklangu            = lv_lang
      EXCEPTIONS
        not_hypertext_class = 1
        no_editor           = 2
        OTHERS              = 3.

    rv_exit = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    zcl_abapinst_factory=>get_longtexts( )->serialize(
      iv_object_name = mv_doc_object
      iv_longtext_id = c_id
      io_i18n_params = mo_i18n_params
      ii_xml         = io_xml ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_dtel IMPLEMENTATION.

  METHOD deserialize_texts.

    DATA: lv_name       TYPE ddobjname,
          ls_dd04v_tmp  TYPE dd04v,
          lt_i18n_langs TYPE TABLE OF langu,
          lt_dd04_texts TYPE ty_dd04_texts.

    FIELD-SYMBOLS: <lv_lang>      LIKE LINE OF lt_i18n_langs,
                   <ls_dd04_text> LIKE LINE OF lt_dd04_texts.

    lv_name = ms_item-obj_name.

    ii_xml->read( EXPORTING iv_name = 'I18N_LANGS'
                  CHANGING  cg_data = lt_i18n_langs ).

    ii_xml->read( EXPORTING iv_name = 'DD04_TEXTS'
                  CHANGING  cg_data = lt_dd04_texts ).

    mo_i18n_params->trim_saplang_list( CHANGING ct_sap_langs = lt_i18n_langs ).

    SORT lt_i18n_langs.
    SORT lt_dd04_texts BY ddlanguage. " Optimization

    LOOP AT lt_i18n_langs ASSIGNING <lv_lang>.

      " Data element description
      ls_dd04v_tmp = is_dd04v.
      READ TABLE lt_dd04_texts ASSIGNING <ls_dd04_text> WITH KEY ddlanguage = <lv_lang>.
      IF sy-subrc > 0.
        zcx_abapgit_exception=>raise( |DD04_TEXTS cannot find lang { <lv_lang> } in XML| ).
      ENDIF.
      MOVE-CORRESPONDING <ls_dd04_text> TO ls_dd04v_tmp.
      CALL FUNCTION 'DDIF_DTEL_PUT'
        EXPORTING
          name              = lv_name
          dd04v_wa          = ls_dd04v_tmp
        EXCEPTIONS
          dtel_not_found    = 1
          name_inconsistent = 2
          dtel_inconsistent = 3
          put_failure       = 4
          put_refused       = 5
          OTHERS            = 6.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_texts.

    DATA: lv_name            TYPE ddobjname,
          lv_index           TYPE i,
          ls_dd04v           TYPE dd04v,
          lt_dd04_texts      TYPE ty_dd04_texts,
          lt_i18n_langs      TYPE TABLE OF langu,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    FIELD-SYMBOLS: <lv_lang>      LIKE LINE OF lt_i18n_langs,
                   <ls_dd04_text> LIKE LINE OF lt_dd04_texts.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN.
    ENDIF.

    lv_name = ms_item-obj_name.

    " Collect additional languages, skip main lang - it was serialized already
    lt_language_filter = mo_i18n_params->build_language_filter( ).

    SELECT DISTINCT ddlanguage AS langu INTO TABLE lt_i18n_langs
      FROM dd04v
      WHERE rollname = lv_name
      AND ddlanguage IN lt_language_filter
      AND ddlanguage <> mv_language
      ORDER BY langu.                                     "#EC CI_SUBRC

    LOOP AT lt_i18n_langs ASSIGNING <lv_lang>.
      lv_index = sy-tabix.
      CALL FUNCTION 'DDIF_DTEL_GET'
        EXPORTING
          name          = lv_name
          langu         = <lv_lang>
        IMPORTING
          dd04v_wa      = ls_dd04v
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.
      IF sy-subrc <> 0 OR ls_dd04v-ddlanguage IS INITIAL.
        DELETE lt_i18n_langs INDEX lv_index. " Don't save this lang
        CONTINUE.
      ENDIF.

      APPEND INITIAL LINE TO lt_dd04_texts ASSIGNING <ls_dd04_text>.
      MOVE-CORRESPONDING ls_dd04v TO <ls_dd04_text>.

    ENDLOOP.

    SORT lt_i18n_langs ASCENDING.
    SORT lt_dd04_texts BY ddlanguage ASCENDING.

    IF lines( lt_i18n_langs ) > 0.
      ii_xml->add( iv_name = 'I18N_LANGS'
                   ig_data = lt_i18n_langs ).

      ii_xml->add( iv_name = 'DD04_TEXTS'
                   ig_data = lt_dd04_texts ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE as4user FROM dd04l INTO rv_user
      WHERE rollname = ms_item-obj_name
      AND as4local = 'A'
      AND as4vers = '0000'.
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    delete_ddic( 'E' ).

    delete_longtexts( c_longtext_id_dtel ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_dd04v TYPE dd04v,
          lv_name  TYPE ddobjname.

    io_xml->read( EXPORTING iv_name = 'DD04V'
                  CHANGING cg_data = ls_dd04v ).

    corr_insert( iv_package = iv_package
                 ig_object_class = 'DICT' ).

    lv_name = ms_item-obj_name. " type conversion

    CALL FUNCTION 'DDIF_DTEL_PUT'
      EXPORTING
        name              = lv_name
        dd04v_wa          = ls_dd04v
      EXCEPTIONS
        dtel_not_found    = 1
        name_inconsistent = 2
        dtel_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      deserialize_texts(
        ii_xml   = io_xml
        is_dd04v = ls_dd04v ).
    ENDIF.

    deserialize_longtexts( ii_xml         = io_xml
                           iv_longtext_id = c_longtext_id_dtel ).

    deserialize_longtexts( ii_xml           = io_xml
                           iv_longtext_name = 'LONGTEXTS_' && c_longtext_id_dtel_suppl
                           iv_longtext_id   = c_longtext_id_dtel_suppl ).

    zcl_abapgit_objects_activation=>add_item( ms_item ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_rollname TYPE dd04l-rollname.

    lv_rollname = ms_item-obj_name.

    " Check nametab because it's fast
    CALL FUNCTION 'DD_GET_NAMETAB_HEADER'
      EXPORTING
        tabname   = lv_rollname
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc <> 0.
      " Check for inactive or modified versions
      SELECT SINGLE rollname FROM dd04l INTO lv_rollname
        WHERE rollname = lv_rollname.
    ENDIF.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-ddic TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = 'ESDICT'
                                            iv_argument    = |{ ms_item-obj_type }{ ms_item-obj_name }| ).
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by ZCL_ABAPGIT_OBJECT=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.
* fm DDIF_DTEL_GET bypasses buffer, so SELECTs are
* done directly from here

    DATA: lv_name  TYPE ddobjname,
          ls_dd04v TYPE dd04v.

    lv_name = ms_item-obj_name.

    SELECT SINGLE * FROM dd04l
      INTO CORRESPONDING FIELDS OF ls_dd04v
      WHERE rollname = lv_name
      AND as4local = 'A'
      AND as4vers = '0000'.
    IF sy-subrc <> 0 OR ls_dd04v IS INITIAL.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM dd04t
      INTO CORRESPONDING FIELDS OF ls_dd04v
      WHERE rollname = lv_name
      AND ddlanguage = mv_language
      AND as4local = 'A'
      AND as4vers = '0000'.

    CLEAR: ls_dd04v-as4user,
           ls_dd04v-as4date,
           ls_dd04v-as4time.

    IF ls_dd04v-refkind = 'D'.
* clear values inherited from domain
      CLEAR: ls_dd04v-datatype,
             ls_dd04v-leng,
             ls_dd04v-decimals,
             ls_dd04v-outputlen,
             ls_dd04v-valexi,
             ls_dd04v-lowercase,
             ls_dd04v-signflag,
             ls_dd04v-convexit,
             ls_dd04v-entitytab.
    ENDIF.

    IF ls_dd04v-routputlen = ''.
* numeric field, make sure it is initial or XML serialization will dump
      CLEAR ls_dd04v-routputlen.
    ENDIF.
    IF ls_dd04v-authclass = ''.
      CLEAR ls_dd04v-authclass.
    ENDIF.

    io_xml->add( iv_name = 'DD04V'
                 ig_data = ls_dd04v ).

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      serialize_texts( io_xml ).
    ENDIF.

    serialize_longtexts( ii_xml         = io_xml
                         iv_longtext_id = c_longtext_id_dtel ).

    serialize_longtexts( ii_xml           = io_xml
                         iv_longtext_name = 'LONGTEXTS_' && c_longtext_id_dtel_suppl
                         iv_longtext_id   = c_longtext_id_dtel_suppl ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enhc IMPLEMENTATION.

  METHOD constructor.

    super->constructor(
      is_item        = is_item
      iv_language    = iv_language
      io_files       = io_files
      io_i18n_params = io_i18n_params ).

    mv_composite_id = ms_item-obj_name.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE changedby INTO rv_user FROM enhcompheader
      WHERE enhcomposite = ms_item-obj_name AND version = 'A'.
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lx_enh_root   TYPE REF TO cx_enh_root,
          li_enh_object TYPE REF TO if_enh_object.

    TRY.
        li_enh_object = cl_enh_factory=>load_enhancement_composite(
          name = mv_composite_id
          lock = abap_true ).

        li_enh_object->delete( nevertheless_delete = abap_true
                               run_dark            = abap_true ).
        li_enh_object->unlock( ).

      CATCH cx_enh_root INTO lx_enh_root.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lx_enh_root         TYPE REF TO cx_enh_root,
          li_enh_composite    TYPE REF TO if_enh_composite,
          lv_package          TYPE devclass,
          lt_composite_childs TYPE enhcompositename_it,
          lt_enh_childs       TYPE enhname_it,
          lv_longtext_id      TYPE enhdocuobject,
          lv_vers             TYPE enhcompheader-version,
          lv_shorttext        TYPE string.

    FIELD-SYMBOLS: <lv_composite_child> TYPE enhcompositename,
                   <lv_enh_child>       LIKE LINE OF lt_enh_childs.

    lv_package = iv_package.

    io_xml->read( EXPORTING iv_name = 'SHORTTEXT'
                  CHANGING  cg_data = lv_shorttext ).
    io_xml->read( EXPORTING iv_name = 'COMPOSITE_CHILDS'
                  CHANGING  cg_data = lt_composite_childs ).
    io_xml->read( EXPORTING iv_name = 'ENH_CHILDS'
                  CHANGING  cg_data = lt_enh_childs ).
    io_xml->read( EXPORTING iv_name = 'LONGTEXT_ID'
                  CHANGING  cg_data = lv_longtext_id ).

    SELECT SINGLE version FROM enhcompheader INTO lv_vers WHERE enhcomposite = ms_item-obj_name.
    IF sy-subrc = 0.
      " If object exists already, then set TADIR entry to deleted
      " otherwise create_enhancement_composite will fail
      tadir_delete( ).
    ENDIF.

    TRY.
        cl_enh_factory=>create_enhancement_composite(
          EXPORTING
            name      = mv_composite_id
            run_dark  = abap_true
          IMPORTING
            composite = li_enh_composite
          CHANGING
            devclass  = lv_package ).

        li_enh_composite->if_enh_object_docu~set_shorttext( lv_shorttext ).

        LOOP AT lt_composite_childs ASSIGNING <lv_composite_child>.
          li_enh_composite->add_composite_child( <lv_composite_child> ).
        ENDLOOP.

        LOOP AT lt_enh_childs ASSIGNING <lv_enh_child>.
          li_enh_composite->add_enh_child( <lv_enh_child> ).
        ENDLOOP.

        li_enh_composite->set_longtext_id( lv_longtext_id ).

        li_enh_composite->if_enh_object~save( ).
        li_enh_composite->if_enh_object~activate( ).
        li_enh_composite->if_enh_object~unlock( ).

      CATCH cx_enh_root INTO lx_enh_root.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    TRY.
        cl_enh_factory=>load_enhancement_composite(
          name = mv_composite_id
          lock = abap_false ).
        rv_bool = abap_true.
      CATCH cx_enh_root.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_argument TYPE seqg3-garg.

    lv_argument = |{ mv_composite_id }|.
    OVERLAY lv_argument WITH '                                  '.
    lv_argument = |{ lv_argument }*|.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = |E_ENHANCE|
                                            iv_argument    = lv_argument ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by zcl_abapinst_objects=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lx_enh_root         TYPE REF TO cx_enh_root,
          li_enh_composite    TYPE REF TO if_enh_composite,
          lt_composite_childs TYPE enhcompositename_it,
          lt_enh_childs       TYPE enhname_it,
          lv_longtext_id      TYPE enhdocuobject,
          lv_shorttext        TYPE string.

    TRY.
        li_enh_composite = cl_enh_factory=>load_enhancement_composite(
          name = mv_composite_id
          lock = abap_false ).

        lv_shorttext = li_enh_composite->if_enh_object_docu~get_shorttext( ).

        lt_composite_childs = li_enh_composite->get_composite_childs( ).
        lt_enh_childs       = li_enh_composite->get_enh_childs( ).
        lv_longtext_id      = li_enh_composite->get_longtext_id( ).

        io_xml->add( iv_name = 'SHORTTEXT'
                     ig_data = lv_shorttext ).
        io_xml->add( iv_name = 'COMPOSITE_CHILDS'
                     ig_data = lt_composite_childs ).
        io_xml->add( iv_name = 'ENH_CHILDS'
                     ig_data = lt_enh_childs ).
        io_xml->add( iv_name = 'LONGTEXT_ID'
                     ig_data = lv_longtext_id ).

      CATCH cx_enh_root INTO lx_enh_root.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enho_badi IMPLEMENTATION.

  METHOD constructor.
    ms_item = is_item.
  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lv_spot_name TYPE enhspotname,
          lv_shorttext TYPE string,
          lv_enhname   TYPE enhname,
          lo_badi      TYPE REF TO cl_enh_tool_badi_impl,
          li_tool      TYPE REF TO if_enh_tool,
          lv_package   TYPE devclass,
          lt_impl      TYPE enh_badi_impl_data_it,
          lx_enh_root  TYPE REF TO cx_enh_root.

    FIELD-SYMBOLS: <ls_impl> LIKE LINE OF lt_impl.

    ii_xml->read( EXPORTING iv_name = 'SHORTTEXT'
                  CHANGING cg_data  = lv_shorttext ).
    ii_xml->read( EXPORTING iv_name = 'SPOT_NAME'
                  CHANGING cg_data  = lv_spot_name ).
    ii_xml->read( EXPORTING iv_name = 'IMPL'
                  CHANGING cg_data  = lt_impl ).

    lv_enhname = ms_item-obj_name.
    lv_package = iv_package.
    TRY.
        cl_enh_factory=>create_enhancement(
          EXPORTING
            enhname     = lv_enhname
            enhtype     = cl_abstract_enh_tool_redef=>credefinition
            enhtooltype = cl_enh_tool_badi_impl=>tooltype
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).
        lo_badi ?= li_tool.

        lo_badi->set_spot_name( lv_spot_name ).
        lo_badi->if_enh_object_docu~set_shorttext( lv_shorttext ).
        LOOP AT lt_impl ASSIGNING <ls_impl>.
          lo_badi->add_implementation( <ls_impl> ).
        ENDLOOP.
        lo_badi->if_enh_object~save( run_dark = abap_true ).
        lo_badi->if_enh_object~unlock( ).
      CATCH cx_enh_root INTO lx_enh_root.
        TRY.
            lo_badi->if_enh_object~unlock( ).
          CATCH cx_sy_ref_is_initial cx_enh_mod_not_allowed ##NO_HANDLER.
        ENDTRY.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_badi_impl TYPE REF TO cl_enh_tool_badi_impl,
          lv_spot_name TYPE enhspotname,
          lv_shorttext TYPE string,
          lt_impl      TYPE enh_badi_impl_data_it.

    FIELD-SYMBOLS: <ls_impl>   LIKE LINE OF lt_impl,
                   <ls_values> LIKE LINE OF <ls_impl>-filter_values,
                   <ls_filter> LIKE LINE OF <ls_impl>-filters.

    lo_badi_impl ?= ii_enh_tool.

    lv_shorttext = lo_badi_impl->if_enh_object_docu~get_shorttext( ).
    lv_spot_name = lo_badi_impl->get_spot_name( ).
    lt_impl      = lo_badi_impl->get_implementations( ).

    LOOP AT lt_impl ASSIGNING <ls_impl>.
* make sure the XML serialization does not dump, field type = N
      LOOP AT <ls_impl>-filter_values ASSIGNING <ls_values>.
        IF <ls_values>-filter_numeric_value1 CA space.
          CLEAR <ls_values>-filter_numeric_value1.
        ENDIF.
      ENDLOOP.
      LOOP AT <ls_impl>-filters ASSIGNING <ls_filter>.
        IF <ls_filter>-filter_numeric_value1 CA space.
          CLEAR <ls_filter>-filter_numeric_value1.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

    ii_xml->add( iv_name = 'TOOL'
                 ig_data = ii_enh_tool->get_tool( ) ).
    ii_xml->add( ig_data = lv_shorttext
                 iv_name = 'SHORTTEXT' ).
    ii_xml->add( iv_name = 'SPOT_NAME'
                 ig_data = lv_spot_name ).
    ii_xml->add( iv_name = 'IMPL'
                 ig_data = lt_impl ).

  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_OBJECT_ENHO_HOOK IMPLEMENTATION.

  METHOD add_sources.

    DATA lv_source TYPE string.
    DATA ls_file LIKE LINE OF ct_files.

    FIELD-SYMBOLS <ls_enhancement> LIKE LINE OF ct_enhancements.

    LOOP AT ct_enhancements ASSIGNING <ls_enhancement>.
      " Use hash as filename since full_name is very long
      CLEAR ls_file.
      ls_file-name = <ls_enhancement>-full_name.
      ls_file-file = substring(
        val = zcl_abapgit_hash=>sha1_string( <ls_enhancement>-full_name )
        len = 8 ).
      INSERT ls_file INTO TABLE ct_files.

      " Add full name as comment and put code between enhancement statements
      lv_source = c_enhancement.
      REPLACE '*' IN lv_source WITH ms_item-obj_name.
      INSERT lv_source INTO <ls_enhancement>-source INDEX 1.

      lv_source = |"Name: { <ls_enhancement>-full_name }|.
      INSERT lv_source INTO <ls_enhancement>-source INDEX 1.

      APPEND c_endenhancement TO <ls_enhancement>-source.

      mo_files->add_abap( iv_extra = ls_file-file
                          it_abap  = <ls_enhancement>-source ).

      CLEAR <ls_enhancement>-source.
    ENDLOOP.

  ENDMETHOD.

  METHOD constructor.
    ms_item = is_item.
    mo_files = io_files.
  ENDMETHOD.

  METHOD hook_impl_deserialize.

    FIELD-SYMBOLS: <ls_impl>   LIKE LINE OF ct_impl,
                   <lv_line>   TYPE string,
                   <lv_space>  TYPE i,
                   <ls_spaces> LIKE LINE OF it_spaces.

    LOOP AT ct_impl ASSIGNING <ls_impl>.
      READ TABLE it_spaces ASSIGNING <ls_spaces> WITH KEY full_name = <ls_impl>-full_name.
      IF sy-subrc = 0.
        LOOP AT <ls_impl>-source ASSIGNING <lv_line>.
          READ TABLE <ls_spaces>-spaces ASSIGNING <lv_space> INDEX sy-tabix.
          IF sy-subrc = 0 AND <lv_space> > 0.
            DO <lv_space> TIMES.
              CONCATENATE space <lv_line> INTO <lv_line> RESPECTING BLANKS.
            ENDDO.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD read_sources.

    DATA lv_source TYPE string.
    DATA ls_file LIKE LINE OF ct_files.
    DATA lv_from TYPE i.
    DATA lv_to TYPE i.

    FIELD-SYMBOLS <ls_enhancement> LIKE LINE OF ct_enhancements.

    LOOP AT ct_enhancements ASSIGNING <ls_enhancement>.
      READ TABLE ct_files INTO ls_file WITH TABLE KEY name = <ls_enhancement>-full_name.
      IF sy-subrc = 0.
        <ls_enhancement>-source = mo_files->read_abap( iv_extra = ls_file-file ).
        " Get code between enhancement statements
        LOOP AT <ls_enhancement>-source INTO lv_source.
          IF lv_source CP c_enhancement.
            lv_from = sy-tabix.
          ENDIF.
          IF lv_source CP c_endenhancement.
            lv_to = sy-tabix.
          ENDIF.
        ENDLOOP.
        DELETE <ls_enhancement>-source FROM lv_to.
        DELETE <ls_enhancement>-source TO lv_from.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lv_shorttext       TYPE string,
          lo_hook_impl       TYPE REF TO cl_enh_tool_hook_impl,
          li_tool            TYPE REF TO if_enh_tool,
          lv_enhname         TYPE enhname,
          lv_package         TYPE devclass,
          ls_original_object TYPE enh_hook_admin,
          lt_spaces          TYPE ty_spaces_tt,
          lt_files           TYPE ty_files,
          lt_enhancements    TYPE enh_hook_impl_it,
          lx_enh_root        TYPE REF TO cx_enh_root.

    FIELD-SYMBOLS: <ls_enhancement> LIKE LINE OF lt_enhancements.

    ii_xml->read( EXPORTING iv_name = 'SHORTTEXT'
                  CHANGING cg_data  = lv_shorttext ).
    ii_xml->read( EXPORTING iv_name = 'ORIGINAL_OBJECT'
                  CHANGING cg_data  = ls_original_object ).
    ii_xml->read( EXPORTING iv_name = 'ENHANCEMENTS'
                  CHANGING cg_data  = lt_enhancements ).
    ii_xml->read( EXPORTING iv_name = 'FILES'
                  CHANGING cg_data  = lt_files ).
    ii_xml->read( EXPORTING iv_name = 'SPACES'
                  CHANGING cg_data  = lt_spaces ).

    " todo: kept for compatibility, remove after grace period #3680
    hook_impl_deserialize( EXPORTING it_spaces = lt_spaces
                           CHANGING ct_impl    = lt_enhancements ).

    read_sources( CHANGING ct_enhancements = lt_enhancements
                           ct_files        = lt_files ).

    lv_enhname = ms_item-obj_name.
    lv_package = iv_package.
    TRY.
        cl_enh_factory=>create_enhancement(
          EXPORTING
            enhname     = lv_enhname
            enhtype     = cl_abstract_enh_tool_redef=>credefinition
            enhtooltype = cl_enh_tool_hook_impl=>tooltype
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).
        lo_hook_impl ?= li_tool.

        lo_hook_impl->if_enh_object_docu~set_shorttext( lv_shorttext ).
        lo_hook_impl->set_original_object(
            pgmid       = ls_original_object-pgmid
            obj_name    = ls_original_object-org_obj_name
            obj_type    = ls_original_object-org_obj_type
            program     = ls_original_object-programname
            main_type   = ls_original_object-org_main_type
            main_name   = ls_original_object-org_main_name ).
        lo_hook_impl->set_include_bound( ls_original_object-include_bound ).

        LOOP AT lt_enhancements ASSIGNING <ls_enhancement>.
          lo_hook_impl->add_hook_impl(
              overwrite        = <ls_enhancement>-overwrite
              method           = <ls_enhancement>-method
              enhmode          = <ls_enhancement>-enhmode
              full_name        = <ls_enhancement>-full_name
              source           = <ls_enhancement>-source
              spot             = <ls_enhancement>-spotname
              parent_full_name = <ls_enhancement>-parent_full_name ).
        ENDLOOP.
        lo_hook_impl->if_enh_object~save( run_dark = abap_true ).
        lo_hook_impl->if_enh_object~unlock( ).
      CATCH cx_enh_root INTO lx_enh_root.
        TRY.
            lo_hook_impl->if_enh_object~unlock( ).
          CATCH cx_sy_ref_is_initial cx_enh_mod_not_allowed ##NO_HANDLER.
        ENDTRY.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lv_shorttext       TYPE string,
          lo_hook_impl       TYPE REF TO cl_enh_tool_hook_impl,
          ls_original_object TYPE enh_hook_admin,
          lt_spaces          TYPE ty_spaces_tt,
          lt_files           TYPE ty_files,
          ls_progdir         TYPE zif_abapgit_sap_report=>ty_progdir,
          lt_enhancements    TYPE enh_hook_impl_it.

    FIELD-SYMBOLS: <ls_enhancement> LIKE LINE OF lt_enhancements.

    lo_hook_impl ?= ii_enh_tool.

    lv_shorttext = lo_hook_impl->if_enh_object_docu~get_shorttext( ).
    lo_hook_impl->get_original_object(
      IMPORTING
        pgmid     = ls_original_object-pgmid
        obj_name  = ls_original_object-org_obj_name
        obj_type  = ls_original_object-org_obj_type
        main_type = ls_original_object-org_main_type
        main_name = ls_original_object-org_main_name
        program   = ls_original_object-programname ).

* dont call method lo_hook_impl->get_include_bound( ), it might dump
* if the PROG does not exists
    IF ls_original_object-org_main_type = 'PROG' OR ls_original_object-org_main_type = 'REPS'.
      TRY.
          ls_progdir = zcl_abapinst_factory=>get_sap_report( )->read_progdir( ls_original_object-org_main_name ).
          ls_original_object-include_bound = boolc( ls_progdir-subc = 'I' ).
        CATCH zcx_abapgit_exception.
          ls_original_object-include_bound = abap_false.
      ENDTRY.
    ENDIF.

    lt_enhancements = lo_hook_impl->get_hook_impls( ).

    LOOP AT lt_enhancements ASSIGNING <ls_enhancement>.
      CLEAR: <ls_enhancement>-extid,
             <ls_enhancement>-id.
    ENDLOOP.

    add_sources( CHANGING ct_enhancements = lt_enhancements
                          ct_files        = lt_files ).

    ii_xml->add( iv_name = 'TOOL'
                 ig_data = ii_enh_tool->get_tool( ) ).
    ii_xml->add( iv_name = 'SHORTTEXT'
                 ig_data = lv_shorttext ).
    ii_xml->add( iv_name = 'ORIGINAL_OBJECT'
                 ig_data = ls_original_object ).
    ii_xml->add( iv_name = 'ENHANCEMENTS'
                 ig_data = lt_enhancements ).
    ii_xml->add( iv_name = 'FILES'
                 ig_data = lt_files ).
    ii_xml->add( iv_name = 'SPACES'
                 ig_data = lt_spaces ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enho_class IMPLEMENTATION.

  METHOD adjust_generated_comments.

    FIELD-SYMBOLS <lv_source> LIKE LINE OF ct_source.

    " Enhancements contain comments that end in '.' or ' .' depending on release
    " This routine replaces the space-dot with just dot
    LOOP AT ct_source ASSIGNING <lv_source>.
      IF strlen( <lv_source> ) > 2.
        <lv_source> = replace(
          val   = <lv_source>
          regex = '^(\*".*) \.$'
          with  = '$1.' ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD constructor.
    ms_item = is_item.
    mo_files = io_files.
  ENDMETHOD.

  METHOD deserialize_includes.

    DATA: lt_tab_methods TYPE enhnewmeth_tab,
          lv_editorder   TYPE n LENGTH 3,
          lv_methname    TYPE seocpdname,
          lt_abap        TYPE rswsourcet,
          lx_enh_root    TYPE REF TO cx_enh_root,
          lv_new_em      TYPE abap_bool,
          lt_files       TYPE zif_abapgit_git_definitions=>ty_files_tt.

    FIELD-SYMBOLS: <ls_method> LIKE LINE OF lt_tab_methods,
                   <ls_file>   TYPE zif_abapgit_git_definitions=>ty_file.

    ii_xml->read( EXPORTING iv_name = 'TAB_METHODS'
                  CHANGING cg_data = lt_tab_methods ).

    lv_new_em = abap_false.
    lt_files = mo_files->get_files( ).
    LOOP AT lt_files ASSIGNING <ls_file>
        WHERE filename CS 'enho.em_'.
      lv_new_em = abap_true.
      EXIT.
    ENDLOOP.

    SORT lt_tab_methods BY meth_header-editorder.
    LOOP AT lt_tab_methods ASSIGNING <ls_method>.

      lv_methname = <ls_method>-methkey-cmpname.
      IF lv_new_em = abap_true.
        lt_abap = mo_files->read_abap( iv_extra = 'em_' && lv_methname ).
      ELSE.
        " old way
        lv_editorder = <ls_method>-meth_header-editorder.
        lt_abap = mo_files->read_abap( iv_extra = 'em' && lv_editorder ).
      ENDIF.

      TRY.
          io_class->add_change_new_method_source(
              clsname    = <ls_method>-methkey-clsname
              methname   = lv_methname
              methsource = lt_abap ).
        CATCH cx_enh_root INTO lx_enh_root.
          zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
      ENDTRY.

    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_includes.

    DATA: lt_includes TYPE enhnewmeth_tabincl_plus_enha,
          lt_source   TYPE TABLE OF abaptxt255,
          lv_include  TYPE syrepid.

    FIELD-SYMBOLS: <ls_include> LIKE LINE OF lt_includes.

    lt_includes = io_class->get_enh_method_includes( ).
    LOOP AT lt_includes ASSIGNING <ls_include>.
      lv_include = io_class->if_enh_tool~get_name( ).
      TRANSLATE lv_include USING ' ='.
      lv_include+30 = 'EM'.
      lv_include+32(8) = <ls_include>-includenr.

      CALL FUNCTION 'RPY_PROGRAM_READ'
        EXPORTING
          program_name     = lv_include
          with_includelist = abap_false
          with_lowercase   = abap_true
        TABLES
          source_extended  = lt_source
        EXCEPTIONS
          cancelled        = 1
          not_found        = 2
          permission_error = 3
          OTHERS           = 4.
      IF sy-subrc = 0.
        mo_files->add_abap( iv_extra = |EM_{ <ls_include>-cpdname }|
                            it_abap  = lt_source ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lo_enh_class TYPE REF TO cl_enh_tool_class,
          lt_owr       TYPE enhmeth_tabkeys,
          lt_pre       TYPE enhmeth_tabkeys,
          lt_post      TYPE enhmeth_tabkeys,
          lt_source    TYPE rswsourcet,
          li_tool      TYPE REF TO if_enh_tool,
          lv_shorttext TYPE string,
          lv_class     TYPE seoclsname,
          lv_enhname   TYPE enhname,
          lv_package   TYPE devclass,
          lx_enh_root  TYPE REF TO cx_enh_root.

    ii_xml->read( EXPORTING iv_name = 'SHORTTEXT'
                  CHANGING cg_data  = lv_shorttext ).
    ii_xml->read( EXPORTING iv_name = 'OWR_METHODS'
                  CHANGING cg_data  = lt_owr ).
    ii_xml->read( EXPORTING iv_name = 'PRE_METHODS'
                  CHANGING cg_data  = lt_pre ).
    ii_xml->read( EXPORTING iv_name = 'POST_METHODS'
                  CHANGING cg_data  = lt_post ).
    ii_xml->read( EXPORTING iv_name = 'CLASS'
                  CHANGING cg_data  = lv_class ).
    lt_source = mo_files->read_abap( ).

    lv_enhname = ms_item-obj_name.
    lv_package = iv_package.
    TRY.
        cl_enh_factory=>create_enhancement(
          EXPORTING
            enhname     = lv_enhname
            enhtype     = ''
            enhtooltype = cl_enh_tool_class=>tooltype
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).
        lo_enh_class ?= li_tool.

        lo_enh_class->if_enh_object_docu~set_shorttext( lv_shorttext ).
        lo_enh_class->set_class( lv_class ).
        lo_enh_class->set_owr_methods( version     = 'I'
                                       owr_methods = lt_owr ).
        lo_enh_class->set_pre_methods( version     = 'I'
                                       pre_methods = lt_pre ).
        lo_enh_class->set_post_methods( version      = 'I'
                                        post_methods = lt_post ).
        lo_enh_class->set_eimp_include( version     = 'I'
                                        eimp_source = lt_source ).

        zcl_abapgit_object_enho_clif=>deserialize(
          io_xml  = ii_xml
          io_clif = lo_enh_class ).

        deserialize_includes(
          ii_xml   = ii_xml
          io_class = lo_enh_class ).

        lo_enh_class->if_enh_object~save( run_dark = abap_true ).
        lo_enh_class->if_enh_object~unlock( ).
      CATCH cx_enh_root INTO lx_enh_root.
        TRY.
            lo_enh_class->if_enh_object~unlock( ).
          CATCH cx_sy_ref_is_initial cx_enh_mod_not_allowed ##NO_HANDLER.
        ENDTRY.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_enh_class TYPE REF TO cl_enh_tool_class,
          lt_owr       TYPE enhmeth_tabkeys,
          lt_pre       TYPE enhmeth_tabkeys,
          lt_post      TYPE enhmeth_tabkeys,
          lt_source    TYPE rswsourcet,
          lv_class     TYPE seoclsname,
          lv_shorttext TYPE string.

    lo_enh_class ?= ii_enh_tool.

    lv_shorttext = lo_enh_class->if_enh_object_docu~get_shorttext( ).
    lt_owr = lo_enh_class->get_owr_methods( ).
    lt_pre = lo_enh_class->get_pre_methods( ).
    lt_post = lo_enh_class->get_post_methods( ).
    lt_source = lo_enh_class->get_eimp_include( ).
    lo_enh_class->get_class( IMPORTING class_name = lv_class ).

    ii_xml->add( iv_name = 'TOOL'
                 ig_data = ii_enh_tool->get_tool( ) ).
    ii_xml->add( ig_data = lv_shorttext
                 iv_name = 'SHORTTEXT' ).
    ii_xml->add( iv_name = 'CLASS'
                 ig_data = lv_class ).
    ii_xml->add( iv_name = 'OWR_METHODS'
                 ig_data = lt_owr ).
    ii_xml->add( iv_name = 'PRE_METHODS'
                 ig_data = lt_pre ).
    ii_xml->add( iv_name = 'POST_METHODS'
                 ig_data = lt_post ).

    adjust_generated_comments( CHANGING ct_source = lt_source ).

    mo_files->add_abap( lt_source ).

    zcl_abapgit_object_enho_clif=>serialize(
      io_xml  = ii_xml
      io_clif = lo_enh_class ).

    serialize_includes( lo_enh_class ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enho_intf IMPLEMENTATION.

  METHOD constructor.
    ms_item  = is_item.
    mo_files = io_files.
  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lo_enh_intf  TYPE REF TO cl_enh_tool_intf,
          li_tool      TYPE REF TO if_enh_tool,
          lv_shorttext TYPE string,
          lv_class     TYPE seoclsname,
          lv_enhname   TYPE enhname,
          lv_package   TYPE devclass,
          lx_enh_root  TYPE REF TO cx_enh_root.

    ii_xml->read( EXPORTING iv_name = 'SHORTTEXT'
                  CHANGING cg_data  = lv_shorttext ).
    ii_xml->read( EXPORTING iv_name = 'CLASS'
                  CHANGING cg_data  = lv_class ).

    lv_enhname = ms_item-obj_name.
    lv_package = iv_package.
    TRY.
        cl_enh_factory=>create_enhancement(
          EXPORTING
            enhname     = lv_enhname
            enhtype     = ''
            enhtooltype = cl_enh_tool_intf=>tooltype
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).
        lo_enh_intf ?= li_tool.

        lo_enh_intf->if_enh_object_docu~set_shorttext( lv_shorttext ).
        lo_enh_intf->set_class( lv_class ).

        zcl_abapgit_object_enho_clif=>deserialize(
          io_xml  = ii_xml
          io_clif = lo_enh_intf ).

        lo_enh_intf->if_enh_object~save( run_dark = abap_true ).
        lo_enh_intf->if_enh_object~unlock( ).
      CATCH cx_enh_root INTO lx_enh_root.
        TRY.
            lo_enh_intf->if_enh_object~unlock( ).
          CATCH cx_sy_ref_is_initial cx_enh_mod_not_allowed ##NO_HANDLER.
        ENDTRY.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_enh_intf  TYPE REF TO cl_enh_tool_intf,
          lv_class     TYPE seoclsname,
          lv_shorttext TYPE string.

    lo_enh_intf ?= ii_enh_tool.

    lv_shorttext = lo_enh_intf->if_enh_object_docu~get_shorttext( ).
    lo_enh_intf->get_class( IMPORTING class_name = lv_class ).

    ii_xml->add( iv_name = 'TOOL'
                 ig_data = ii_enh_tool->get_tool( ) ).
    ii_xml->add( ig_data = lv_shorttext
                 iv_name = 'SHORTTEXT' ).
    ii_xml->add( iv_name = 'CLASS'
                 ig_data = lv_class ).

    zcl_abapgit_object_enho_clif=>serialize(
      io_xml  = ii_xml
      io_clif = lo_enh_intf ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enho_wdyc IMPLEMENTATION.

  METHOD constructor.
    ms_item = is_item.
  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lv_enhname TYPE enhname,
          lo_wdyconf TYPE REF TO cl_wdr_cfg_enhancement,
          li_tool    TYPE REF TO if_enh_tool,
          ls_obj     TYPE wdy_config_key,
          lv_xml     TYPE string,
          lt_data    TYPE wdy_cfg_expl_data_tab,
          lv_package TYPE devclass.

    ii_xml->read( EXPORTING iv_name = 'ORIGINAL_OBJECT'
                  CHANGING  cg_data = ls_obj ).

    ii_xml->read( EXPORTING iv_name = 'ENHANCEMENT_DATA'
                  CHANGING  cg_data = lv_xml ).

    lv_enhname = ms_item-obj_name.
    lv_package = iv_package.
    TRY.
        cl_enh_factory=>create_enhancement(
          EXPORTING
            enhname     = lv_enhname
            enhtype     = ''
            enhtooltype = cl_wdr_cfg_enhancement=>tooltype
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).

        lo_wdyconf ?= li_tool.

        CALL METHOD cl_wdr_cfg_persistence_utils=>('COMP_XML_TO_TABLES')
          EXPORTING
            xml_content   = lv_xml
          IMPORTING
            expl_data_tab = lt_data.

* only works on new ABAP versions, parameters differ between versions
        CALL METHOD lo_wdyconf->('SET_ENHANCEMENT_DATA')
          EXPORTING
            p_enh_data = lt_data.

        lo_wdyconf->if_enh_object~save( run_dark = abap_true ).
        lo_wdyconf->if_enh_object~unlock( ).
      CATCH cx_enh_root cx_static_check.
        TRY.
            lo_wdyconf->if_enh_object~unlock( ).
          CATCH cx_sy_ref_is_initial cx_enh_mod_not_allowed ##NO_HANDLER.
        ENDTRY.
        zcx_abapgit_exception=>raise( 'error deserializing ENHO wdyconf' ).
    ENDTRY.
  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_wdyconf  TYPE REF TO cl_wdr_cfg_enhancement,
          lt_data     TYPE wdy_cfg_expl_data_tab,
          ls_outline  TYPE wdy_cfg_outline_data,
          ls_obj      TYPE wdy_config_key,
          li_document TYPE REF TO if_ixml_document,
          li_element  TYPE REF TO if_ixml_element.

    lo_wdyconf ?= ii_enh_tool.

    ls_obj = lo_wdyconf->get_original_object( ).
    ii_xml->add( iv_name = 'TOOL'
                 ig_data = ii_enh_tool->get_tool( ) ).
    ii_xml->add( iv_name = 'ORIGINAL_OBJECT'
                 ig_data = ls_obj ).

* only works on new ABAP versions, parameters differ between versions
    CALL METHOD lo_wdyconf->('GET_ENHANCEMENT_DATA')
      EXPORTING
        p_scope    = 1
      IMPORTING
        p_enh_data = lt_data.

    CALL METHOD cl_wdr_cfg_persistence_utils=>('COMP_TABLES_TO_XML')
      EXPORTING
        outline_data  = ls_outline
        expl_data_tab = lt_data
      IMPORTING
        element       = li_element
      CHANGING
        document      = li_document.

    ii_xml->add_xml( iv_name = 'ENHANCEMENT_DATA'
                     ii_xml = li_element ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enho_fugr IMPLEMENTATION.

  METHOD constructor.
    ms_item = is_item.
    mo_files = io_files.
  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: lo_fugrdata  TYPE REF TO cl_enh_tool_fugr,
          ls_enha_data TYPE enhfugrdata,
          li_tool      TYPE REF TO if_enh_tool,
          lv_tool      TYPE enhtooltype,
          lv_package   TYPE devclass,
          lx_enh_root  TYPE REF TO cx_enh_root.

    FIELD-SYMBOLS: <ls_fuba> TYPE enhfugrfuncdata.

    ii_xml->read(
      EXPORTING
        iv_name = 'TOOL'
      CHANGING
        cg_data = lv_tool ).

    ii_xml->read(
      EXPORTING
        iv_name = 'FUGRDATA'
      CHANGING
        cg_data = ls_enha_data ).

    lv_package = iv_package.

    TRY.
        cl_enh_factory=>create_enhancement(
          EXPORTING
            enhname     = |{ ms_item-obj_name }|
            enhtype     = ''
            enhtooltype = lv_tool
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).

        lo_fugrdata ?= li_tool.

        lo_fugrdata->set_fugr( ls_enha_data-fugr ).

        LOOP AT ls_enha_data-enh_fubas ASSIGNING <ls_fuba>.

          lo_fugrdata->set_func_data( func_name     = <ls_fuba>-fuba
                                      func_enhadata = <ls_fuba> ).

        ENDLOOP.

        lo_fugrdata->if_enh_object~save( run_dark = abap_true ).
        lo_fugrdata->if_enh_object~unlock( ).
      CATCH cx_enh_root INTO lx_enh_root.
        TRY.
            lo_fugrdata->if_enh_object~unlock( ).
          CATCH cx_sy_ref_is_initial cx_enh_mod_not_allowed ##NO_HANDLER.
        ENDTRY.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_fugrdata  TYPE REF TO cl_enh_tool_fugr,
          lv_fugr_name TYPE rs38l-area,
          ls_enha_data TYPE enhfugrdata.

    FIELD-SYMBOLS: <ls_docuobj> TYPE enhfugrparamdocu.

    lo_fugrdata ?= ii_enh_tool.

    lo_fugrdata->get_fugr( IMPORTING fugr_name = lv_fugr_name ).

    TRY.
        lo_fugrdata->get_all_data_for_fugr(
          EXPORTING
            fugr_name = lv_fugr_name
          IMPORTING
            enha_data = ls_enha_data ).

        LOOP AT ls_enha_data-docuobjs ASSIGNING <ls_docuobj>.
          CLEAR: <ls_docuobj>-shorttext,
                 <ls_docuobj>-longtext.
        ENDLOOP.

      CATCH cx_enh_not_found.
        zcx_abapgit_exception=>raise( |error deserializing ENHO fugrdata { ms_item-obj_name }| ).
    ENDTRY.

    ii_xml->add( iv_name = 'TOOL'
                 ig_data = lo_fugrdata->if_enh_tool~get_tool( ) ).

    ii_xml->add( iv_name = 'FUGRDATA'
                 ig_data = ls_enha_data ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enho_wdyn IMPLEMENTATION.

  METHOD constructor.
    ms_item = is_item.
  ENDMETHOD.

  METHOD zif_abapgit_object_enho~deserialize.

    DATA: ls_enh_data  TYPE enhwdyn,
          li_tool      TYPE REF TO if_enh_tool,
          lo_wdyn      TYPE REF TO cl_enh_tool_wdy,
          lv_tool_type TYPE enhtooltype,
          lv_package   TYPE devclass.

    FIELD-SYMBOLS: <ls_controller_data> TYPE enhwdyc,
                   <ls_view_data>       TYPE enhwdyv.

    ii_xml->read(
      EXPORTING
        iv_name = 'TOOL'
      CHANGING
        cg_data = lv_tool_type ).

    ii_xml->read(
      EXPORTING
        iv_name = 'COMPONENT_DATA'
      CHANGING
        cg_data = ls_enh_data ).

    lv_package = iv_package.

    TRY.
        cl_enh_factory=>create_enhancement(
          EXPORTING
            enhname     = |{ ms_item-obj_name }|
            enhtype     = ''
            enhtooltype = lv_tool_type
          IMPORTING
            enhancement = li_tool
          CHANGING
            devclass    = lv_package ).

        lo_wdyn ?= li_tool.

        lo_wdyn->initialize( ls_enh_data-component_name ).

        lo_wdyn->set_component_data( ls_enh_data-component_data ).

        LOOP AT ls_enh_data-controller_data ASSIGNING <ls_controller_data>.

          lo_wdyn->set_controller_data( p_controller_name = <ls_controller_data>-controller_name
                                        p_enh_data        = <ls_controller_data> ).

        ENDLOOP.

        LOOP AT ls_enh_data-view_data ASSIGNING <ls_view_data>.

          lo_wdyn->set_view_data( p_view_name = <ls_view_data>-view_name
                                  p_enh_data  = <ls_view_data> ).

        ENDLOOP.

        lo_wdyn->if_enh_object~save( run_dark = abap_true ).
        lo_wdyn->if_enh_object~unlock( ).

      CATCH cx_root.
        TRY.
            lo_wdyn->if_enh_object~unlock( ).
          CATCH cx_sy_ref_is_initial cx_enh_mod_not_allowed ##NO_HANDLER.
        ENDTRY.
        zcx_abapgit_exception=>raise( |error deserializing ENHO wdyn { ms_item-obj_name }| ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object_enho~serialize.

    DATA: lo_wdyn           TYPE REF TO cl_enh_tool_wdy,
          lv_component_name TYPE wdy_component_name,
          ls_enh_data       TYPE enhwdyn.

    lo_wdyn ?= ii_enh_tool.
    lv_component_name = lo_wdyn->get_component_name( ).

    TRY.
        lo_wdyn->get_all_data_for_comp(
          EXPORTING
            p_component_name = lv_component_name
          IMPORTING
            p_enh_data       = ls_enh_data ).

        ii_xml->add( iv_name = 'TOOL'
                     ig_data = ii_enh_tool->get_tool( ) ).

        ii_xml->add( iv_name = 'COMPONENT_DATA'
                     ig_data = ls_enh_data ).

      CATCH cx_enh_not_found.
        zcx_abapgit_exception=>raise( |error serializing ENHO wdyn { ms_item-obj_name }| ).
    ENDTRY.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enho IMPLEMENTATION.

  METHOD factory.

    CASE iv_tool.
      WHEN cl_enh_tool_badi_impl=>tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_badi
          EXPORTING
            is_item = ms_item.
      WHEN cl_enh_tool_hook_impl=>tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_hook
          EXPORTING
            is_item  = ms_item
            io_files = mo_files.
      WHEN cl_enh_tool_class=>tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_class
          EXPORTING
            is_item  = ms_item
            io_files = mo_files.
      WHEN cl_enh_tool_intf=>tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_intf
          EXPORTING
            is_item  = ms_item
            io_files = mo_files.
      WHEN cl_wdr_cfg_enhancement=>tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_wdyc
          EXPORTING
            is_item = ms_item.
      WHEN 'FUGRENH'.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_fugr
          EXPORTING
            is_item  = ms_item
            io_files = mo_files.
      WHEN 'WDYENH'.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enho_wdyn
          EXPORTING
            is_item = ms_item.
      WHEN OTHERS.
        zcx_abapgit_exception=>raise( |Unsupported ENHO type { iv_tool }| ).
    ENDCASE.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    DATA: lv_enh_id   TYPE enhname,
          lt_log      TYPE enh_log_it,
          li_log_obj  TYPE REF TO if_enh_log,
          ls_enhlog   TYPE enhlog,
          lv_lines    TYPE i,
          lt_enhlog   TYPE STANDARD TABLE OF enhlog WITH DEFAULT KEY,
          li_enh_tool TYPE REF TO if_enh_tool.

    lv_enh_id = ms_item-obj_name.
    TRY.
        li_enh_tool = cl_enh_factory=>get_enhancement(
          enhancement_id   = lv_enh_id
          run_dark         = abap_true
          bypassing_buffer = abap_true ).
      CATCH cx_enh_root.
        rv_user = c_user_unknown.
        RETURN.
    ENDTRY.

    lt_log = li_enh_tool->get_log( ).

    LOOP AT lt_log INTO li_log_obj.
      ls_enhlog = li_log_obj->get_enhlog( ).
      APPEND ls_enhlog TO lt_enhlog.
    ENDLOOP.

    lv_lines = lines( lt_enhlog ).
    READ TABLE lt_enhlog INTO ls_enhlog INDEX lv_lines.
    IF sy-subrc = 0.
      rv_user = ls_enhlog-loguser.
    ELSE.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_enh_id     TYPE enhname,
          li_enh_object TYPE REF TO if_enh_object,
          lx_enh_root   TYPE REF TO cx_enh_root,
          lv_corrnum    TYPE trkorr.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    zcl_abapgit_sotr_handler=>delete_sotr(
      iv_pgmid    = 'R3TR'
      iv_object   = ms_item-obj_type
      iv_obj_name = ms_item-obj_name ).

    zcl_abapgit_sots_handler=>delete_sots(
      iv_pgmid    = 'R3TR'
      iv_object   = ms_item-obj_type
      iv_obj_name = ms_item-obj_name ).

    lv_corrnum = iv_transport.

    lv_enh_id = ms_item-obj_name.
    TRY.
        li_enh_object = cl_enh_factory=>get_enhancement(
          enhancement_id = lv_enh_id
          run_dark       = abap_true
          lock           = abap_true ).
        li_enh_object->delete(
          EXPORTING
            nevertheless_delete = abap_true
            run_dark            = abap_true
          CHANGING
            trkorr              = lv_corrnum ).
        li_enh_object->unlock( ).
      CATCH cx_enh_root INTO lx_enh_root.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_tool TYPE enhtooltype,
          li_enho TYPE REF TO zif_abapgit_object_enho.

    IF zif_abapgit_object~exists( ) = abap_true.
      zif_abapgit_object~delete( iv_package   = iv_package
                                 iv_transport = iv_transport ).
    ENDIF.

    io_xml->read( EXPORTING iv_name = 'TOOL'
                  CHANGING cg_data = lv_tool ).

    li_enho = factory( lv_tool ).

    li_enho->deserialize( ii_xml     = io_xml
                          iv_package = iv_package ).

    zcl_abapgit_sotr_handler=>create_sotr(
      iv_package = iv_package
      io_xml     = io_xml ).

    zcl_abapgit_sots_handler=>create_sots(
      iv_package = iv_package
      io_xml     = io_xml ).

    zcl_abapgit_objects_activation=>add_item( ms_item ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_enh_id TYPE enhname.

    lv_enh_id = ms_item-obj_name.
    TRY.
        cl_enh_factory=>get_enhancement(
          enhancement_id   = lv_enh_id
          run_dark         = abap_true
          bypassing_buffer = abap_true ).
        rv_bool = abap_true.
      CATCH cx_enh_root.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE seqg3-garg.

    lv_object = |{ ms_item-obj_type }{ ms_item-obj_name }|.
    OVERLAY lv_object WITH '                                          '.
    lv_object = lv_object && '*'.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = 'E_ENHANCE'
                                            iv_argument    = lv_object ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by zcl_abapinst_objects=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_enh_id   TYPE enhname,
          li_enho     TYPE REF TO zif_abapgit_object_enho,
          li_enh_tool TYPE REF TO if_enh_tool,
          lx_enh_root TYPE REF TO cx_enh_root.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    lv_enh_id = ms_item-obj_name.
    TRY.
        li_enh_tool = cl_enh_factory=>get_enhancement(
          enhancement_id   = lv_enh_id
          run_dark         = abap_true
          bypassing_buffer = abap_true ).
      CATCH cx_enh_root INTO lx_enh_root.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

    li_enho = factory( li_enh_tool->get_tool( ) ).

    li_enho->serialize( ii_xml      = io_xml
                        ii_enh_tool = li_enh_tool ).

    zcl_abapgit_sotr_handler=>read_sotr(
      iv_pgmid       = 'R3TR'
      iv_object      = ms_item-obj_type
      iv_obj_name    = ms_item-obj_name
      io_i18n_params = mo_i18n_params
      io_xml         = io_xml ).

    zcl_abapgit_sots_handler=>read_sots(
      iv_pgmid       = 'R3TR'
      iv_object      = ms_item-obj_type
      iv_obj_name    = ms_item-obj_name
      io_i18n_params = mo_i18n_params
      io_xml         = io_xml ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enho_clif IMPLEMENTATION.

  METHOD deserialize.

    DATA: lt_tab_attributes TYPE enhclasstabattrib,
          lt_tab_types      TYPE enhtype_tab,
          lt_tab_methods    TYPE enhnewmeth_tab,
          ls_type_line      TYPE vseotype,
          ls_header         TYPE vseomethod,
          ls_param          TYPE vseomepara,
          ls_exc            TYPE vseoexcep,
          lt_tab_eventdata  TYPE enhevent_tab,
          ls_event_line     TYPE vseoevent,
          ls_event_param    TYPE vseoeparam.

    FIELD-SYMBOLS: <ls_type>        LIKE LINE OF lt_tab_types,
                   <ls_method>      LIKE LINE OF lt_tab_methods,
                   <ls_param>       LIKE LINE OF <ls_method>-meth_param,
                   <ls_event>       LIKE LINE OF lt_tab_eventdata,
                   <ls_exc>         LIKE LINE OF <ls_method>-meth_exc,
                   <ls_event_param> LIKE LINE OF <ls_event>-event_param.

    io_xml->read( EXPORTING iv_name = 'TAB_ATTRIBUTES'
                  CHANGING cg_data = lt_tab_attributes ).
    io_xml->read( EXPORTING iv_name = 'TAB_TYPES'
                  CHANGING cg_data = lt_tab_types ).
    io_xml->read( EXPORTING iv_name = 'TAB_METHODS'
                  CHANGING cg_data = lt_tab_methods ).
    io_xml->read( EXPORTING iv_name = 'TAB_EVENTDATA'
                  CHANGING cg_data = lt_tab_eventdata ).

    LOOP AT lt_tab_types ASSIGNING <ls_type>.
      MOVE-CORRESPONDING <ls_type> TO ls_type_line.
      TRY.
          io_clif->add_change_enha_type( type_line = ls_type_line ).
        CATCH cx_enh_mod_not_allowed
        cx_enh_is_not_enhanceable ##NO_HANDLER.
          " TODO
      ENDTRY.
    ENDLOOP.

    io_clif->set_enhattributes( lt_tab_attributes ).

* SAP standard SET_ENH_NEW_METHOS does not work

    LOOP AT lt_tab_methods ASSIGNING <ls_method>.

      MOVE-CORRESPONDING <ls_method>-meth_header TO ls_header.

      io_clif->add_change_new_enh_method(
        methkey       = <ls_method>-methkey
        method_header = ls_header ).

* parameters
      LOOP AT <ls_method>-meth_param ASSIGNING <ls_param>.
        MOVE-CORRESPONDING <ls_param> TO ls_param.
        io_clif->add_change_enh_methparam(
          methname   = <ls_method>-methkey-cmpname
          param_line = ls_param ).
      ENDLOOP.

* exceptions
      LOOP AT <ls_method>-meth_exc ASSIGNING <ls_exc>.
        MOVE-CORRESPONDING <ls_exc> TO ls_exc.
        io_clif->add_change_enh_methexc(
          methname    = <ls_method>-methkey-cmpname
          except_line = ls_exc ).
      ENDLOOP.

    ENDLOOP.

    " events are renumbered based on
    LOOP AT lt_tab_eventdata ASSIGNING <ls_event>.

      MOVE-CORRESPONDING <ls_event>-event_header TO ls_event_line.

      io_clif->add_change_enha_event(
        event_key  = <ls_event>-eventkey
        event_line = ls_event_line ).

* parameters
      LOOP AT <ls_event>-event_param ASSIGNING <ls_event_param>.
        MOVE-CORRESPONDING <ls_event_param> TO ls_event_param.
        io_clif->add_change_enh_eventparam(
          eventname   = <ls_event>-eventkey-cmpname
          event_param = ls_event_param ).
      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.

  METHOD serialize.

    DATA: lt_tab_attributes TYPE enhclasstabattrib,
          lt_tab_types      TYPE enhtype_tab,
          lt_tab_methods    TYPE enhnewmeth_tab,
          lt_tab_eventdata  TYPE enhevent_tab,
          lv_editorder      TYPE i.

    FIELD-SYMBOLS: <ls_attr>        LIKE LINE OF lt_tab_attributes,
                   <ls_type>        LIKE LINE OF lt_tab_types,
                   <ls_meth>        LIKE LINE OF lt_tab_methods,
                   <ls_param>       LIKE LINE OF <ls_meth>-meth_param,
                   <ls_exc>         LIKE LINE OF <ls_meth>-meth_exc,
                   <ls_event>       LIKE LINE OF lt_tab_eventdata,
                   <ls_event_param> LIKE LINE OF <ls_event>-event_param.

    io_clif->get_enhattributes( IMPORTING tab_attributes = lt_tab_attributes ).

    io_clif->get_enhatypes( IMPORTING tab_types = lt_tab_types ).

    io_clif->get_enh_new_methodes( IMPORTING tab_methodes = lt_tab_methods ).

    io_clif->get_enhevents( IMPORTING tab_eventdata = lt_tab_eventdata ).

    LOOP AT lt_tab_attributes ASSIGNING <ls_attr>.
      CLEAR: <ls_attr>-author,
             <ls_attr>-createdon,
             <ls_attr>-changedby,
             <ls_attr>-changedon,
             <ls_attr>-descript_id.
    ENDLOOP.

    LOOP AT lt_tab_types ASSIGNING <ls_type>.
      CLEAR: <ls_type>-author,
             <ls_type>-createdon,
             <ls_type>-changedby,
             <ls_type>-changedon,
             <ls_type>-descript_id.
    ENDLOOP.

    lv_editorder = 0.
    SORT lt_tab_methods BY meth_header-editorder.
    LOOP AT lt_tab_methods ASSIGNING <ls_meth>.
      CLEAR: <ls_meth>-meth_header-author,
             <ls_meth>-meth_header-createdon,
             <ls_meth>-meth_header-changedby,
             <ls_meth>-meth_header-changedon,
             <ls_meth>-meth_header-descript_id.
      lv_editorder = lv_editorder + 1.
      <ls_meth>-meth_header-editorder = lv_editorder.
      LOOP AT <ls_meth>-meth_param ASSIGNING <ls_param>.
        CLEAR: <ls_param>-author,
               <ls_param>-createdon,
               <ls_param>-changedby,
               <ls_param>-changedon,
               <ls_param>-descript_id.
      ENDLOOP.
      LOOP AT <ls_meth>-meth_exc ASSIGNING <ls_exc>.
        CLEAR: <ls_exc>-author,
               <ls_exc>-createdon,
               <ls_exc>-changedby,
               <ls_exc>-changedon,
               <ls_exc>-descript_id.
      ENDLOOP.
    ENDLOOP.

    LOOP AT lt_tab_eventdata ASSIGNING <ls_event>.
      CLEAR: <ls_event>-event_header-author,
             <ls_event>-event_header-createdon,
             <ls_event>-event_header-changedby,
             <ls_event>-event_header-changedon,
             <ls_event>-event_header-descript_id.
      LOOP AT <ls_event>-event_param ASSIGNING <ls_event_param>.
        CLEAR: <ls_event_param>-author,
               <ls_event_param>-createdon,
               <ls_event_param>-changedby,
               <ls_event_param>-changedon,
               <ls_event_param>-descript_id.
      ENDLOOP.
    ENDLOOP.

    io_xml->add( iv_name = 'TAB_ATTRIBUTES'
                 ig_data = lt_tab_attributes ).
    io_xml->add( iv_name = 'TAB_TYPES'
                 ig_data = lt_tab_types ).
    io_xml->add( iv_name = 'TAB_METHODS'
                 ig_data = lt_tab_methods ).
    io_xml->add( iv_name = 'TAB_EVENTDATA'
                 ig_data = lt_tab_eventdata ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enhs_badi_d IMPLEMENTATION.

  METHOD zif_abapgit_object_enhs~deserialize.

    DATA: lv_parent          TYPE enhspotcompositename,
          lt_enh_badi        TYPE enh_badi_data_it,
          lo_badidef_tool    TYPE REF TO cl_enh_tool_badi_def,
          lv_enh_shorttext   TYPE string,
          li_enh_object      TYPE REF TO if_enh_object,
          li_enh_object_docu TYPE REF TO if_enh_object_docu,
          lx_enh_root        TYPE REF TO cx_enh_root.

    FIELD-SYMBOLS: <ls_enh_badi> LIKE LINE OF lt_enh_badi.

    ii_xml->read( EXPORTING iv_name = 'PARENT_COMP'
                  CHANGING  cg_data = lv_parent ).

    ii_xml->read( EXPORTING iv_name = 'BADI_DATA'
                  CHANGING  cg_data = lt_enh_badi ).

    ii_xml->read( EXPORTING iv_name = 'SHORTTEXT'
                  CHANGING  cg_data = lv_enh_shorttext ).

    li_enh_object ?= ii_enh_spot_tool.
    li_enh_object_docu ?= ii_enh_spot_tool.

    TRY.
        li_enh_object_docu->set_shorttext( lv_enh_shorttext ).

        lo_badidef_tool ?= ii_enh_spot_tool.

        LOOP AT lt_enh_badi ASSIGNING <ls_enh_badi>.
          lo_badidef_tool->add_badi_def( <ls_enh_badi> ).
        ENDLOOP.

        li_enh_object->save( ).
        li_enh_object->activate( ).
        li_enh_object->unlock( ).

      CATCH cx_enh_root INTO lx_enh_root.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object_enhs~serialize.

    DATA: lv_spot_name       TYPE enhspotname,
          lv_parent          TYPE enhspotcompositename,
          lt_enh_badi        TYPE enh_badi_data_it,
          lo_badidef_tool    TYPE REF TO cl_enh_tool_badi_def,
          lv_enh_shorttext   TYPE string,
          li_enh_object_docu TYPE REF TO if_enh_object_docu.

    lo_badidef_tool ?= ii_enh_spot_tool.

    li_enh_object_docu ?= ii_enh_spot_tool.
    lv_enh_shorttext = li_enh_object_docu->get_shorttext( ).

    "get parent = composite enhs (ENHC)
    lv_parent = cl_r3standard_persistence=>enh_find_parent_composite( lv_spot_name ).
    "get subsequent BADI definitions
    lt_enh_badi = lo_badidef_tool->get_badi_defs( ).

    ii_xml->add( ig_data = ii_enh_spot_tool->get_tool( )
                 iv_name = 'TOOL' ).

    ii_xml->add( ig_data = lv_enh_shorttext
                 iv_name = 'SHORTTEXT' ).

    ii_xml->add( ig_data = lv_parent
                 iv_name = 'PARENT_COMP' ).

    ii_xml->add( ig_data = lt_enh_badi
                 iv_name = 'BADI_DATA' ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enhs_hook_d IMPLEMENTATION.

  METHOD zif_abapgit_object_enhs~deserialize.

    DATA: lv_enh_shorttext       TYPE string,
          ls_enh_hook_definition TYPE enh_hook_def,
          ls_hook_definition     TYPE ty_hook_defifnition,
          li_enh_object          TYPE REF TO if_enh_object,
          li_enh_object_docu     TYPE REF TO if_enh_object_docu,
          lo_hookdef_tool        TYPE REF TO cl_enh_tool_hook_def,
          lx_enh_root            TYPE REF TO cx_enh_root.

    FIELD-SYMBOLS: <ls_hook_definition> TYPE enh_hook_def_ext.

    ii_xml->read( EXPORTING iv_name = 'SHORTTEXT'
                  CHANGING  cg_data = lv_enh_shorttext ).

    ii_xml->read( EXPORTING iv_name = 'BADI_DATA'
                  CHANGING  cg_data = ls_hook_definition ).

    li_enh_object ?= ii_enh_spot_tool.
    li_enh_object_docu ?= ii_enh_spot_tool.

    TRY.
        li_enh_object_docu->set_shorttext( lv_enh_shorttext ).

        lo_hookdef_tool ?= ii_enh_spot_tool.

        lo_hookdef_tool->set_original_object( pgmid     = ls_hook_definition-pgmid
                                              obj_name  = ls_hook_definition-obj_name
                                              obj_type  = ls_hook_definition-obj_type
                                              program   = ls_hook_definition-program
                                              main_type = ls_hook_definition-main_type
                                              main_name = ls_hook_definition-main_name ).

        LOOP AT ls_hook_definition-def_hooks ASSIGNING <ls_hook_definition>.
          MOVE-CORRESPONDING <ls_hook_definition> TO ls_enh_hook_definition.
          lo_hookdef_tool->add_hook_def( ls_enh_hook_definition ).
        ENDLOOP.

        li_enh_object->save( ).
        li_enh_object->activate( ).
        li_enh_object->unlock( ).

      CATCH cx_enh_root INTO lx_enh_root.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object_enhs~serialize.

    DATA: lo_hookdef_tool    TYPE REF TO cl_enh_tool_hook_def,
          lv_enh_shorttext   TYPE string,
          li_enh_object_docu TYPE REF TO if_enh_object_docu,
          ls_hook_definition TYPE ty_hook_defifnition.

    lo_hookdef_tool ?= ii_enh_spot_tool.

    li_enh_object_docu ?= ii_enh_spot_tool.
    lv_enh_shorttext = li_enh_object_docu->get_shorttext( ).

    ls_hook_definition-def_hooks = lo_hookdef_tool->get_hook_defs( ).

    lo_hookdef_tool->get_original_object(
      IMPORTING
        pgmid     = ls_hook_definition-pgmid
        obj_name  = ls_hook_definition-obj_name
        obj_type  = ls_hook_definition-obj_type
        main_type = ls_hook_definition-main_type
        main_name = ls_hook_definition-main_name
        program   = ls_hook_definition-program ).

    ii_xml->add( ig_data = ii_enh_spot_tool->get_tool( )
                 iv_name = 'TOOL' ).

    ii_xml->add( ig_data = lv_enh_shorttext
                 iv_name = 'SHORTTEXT' ).

    ii_xml->add( ig_data = ls_hook_definition
                 iv_name = 'BADI_DATA' ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enhs IMPLEMENTATION.

  METHOD factory.

    CASE iv_tool.
      WHEN cl_enh_tool_badi_def=>tooltype.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enhs_badi_d.
      WHEN cl_enh_tool_hook_def=>tool_type.
        CREATE OBJECT ri_enho TYPE zcl_abapgit_object_enhs_hook_d.
      WHEN OTHERS.
        zcx_abapgit_exception=>raise( |ENHS: Unsupported tool { iv_tool }| ).
    ENDCASE.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    DATA: lv_spot_name TYPE enhspotname,
          li_spot_ref  TYPE REF TO if_enh_spot_tool.

    lv_spot_name = ms_item-obj_name.

    TRY.
        li_spot_ref = cl_enh_factory=>get_enhancement_spot( spot_name = lv_spot_name
                                                            run_dark  = abap_true ).
        li_spot_ref->get_attributes( IMPORTING changedby = rv_user ).

      CATCH cx_enh_root.
        rv_user = c_user_unknown.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_spot_name  TYPE enhspotname,
          lx_enh_root   TYPE REF TO cx_enh_root,
          li_enh_object TYPE REF TO if_enh_object.

    zcl_abapgit_sotr_handler=>delete_sotr(
      iv_pgmid    = 'R3TR'
      iv_object   = ms_item-obj_type
      iv_obj_name = ms_item-obj_name ).

    zcl_abapgit_sots_handler=>delete_sots(
      iv_pgmid    = 'R3TR'
      iv_object   = ms_item-obj_type
      iv_obj_name = ms_item-obj_name ).

    lv_spot_name  = ms_item-obj_name.

    TRY.
        li_enh_object ?= cl_enh_factory=>get_enhancement_spot( spot_name = lv_spot_name
                                                               run_dark  = abap_true
                                                               lock      = abap_true ).

        li_enh_object->delete( nevertheless_delete = abap_true
                               run_dark            = abap_true ).

        li_enh_object->unlock( ).

      CATCH cx_enh_root INTO lx_enh_root.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_parent    TYPE enhspotcompositename,
          lv_spot_name TYPE enhspotname,
          lv_tool      TYPE enhspottooltype,
          lv_package   LIKE iv_package,
          lx_enh_root  TYPE REF TO cx_enh_root,
          li_spot_ref  TYPE REF TO if_enh_spot_tool,
          li_enhs      TYPE REF TO zif_abapgit_object_enhs.

    IF zif_abapgit_object~exists( ) = abap_true.
      zif_abapgit_object~delete( iv_package   = iv_package
                                 iv_transport = iv_transport ).
    ENDIF.

    io_xml->read( EXPORTING iv_name = 'TOOL'
                  CHANGING  cg_data = lv_tool ).

    lv_spot_name = ms_item-obj_name.
    lv_package   = iv_package.

    TRY.
        cl_enh_factory=>create_enhancement_spot(
          EXPORTING
            spot_name      = lv_spot_name
            tooltype       = lv_tool
            dark           = abap_false
            compositename  = lv_parent
          IMPORTING
            spot           = li_spot_ref
          CHANGING
            devclass       = lv_package ).

      CATCH cx_enh_root INTO lx_enh_root.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

    li_enhs = factory( lv_tool ).

    li_enhs->deserialize( ii_xml           = io_xml
                          iv_package       = iv_package
                          ii_enh_spot_tool = li_spot_ref ).

    zcl_abapgit_sotr_handler=>create_sotr(
      iv_package = iv_package
      io_xml     = io_xml ).

    zcl_abapgit_sots_handler=>create_sots(
      iv_package = iv_package
      io_xml     = io_xml ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_spot_name TYPE enhspotname,
          li_spot_ref  TYPE REF TO if_enh_spot_tool.

    lv_spot_name = ms_item-obj_name.

    TRY.
        li_spot_ref = cl_enh_factory=>get_enhancement_spot( spot_name = lv_spot_name
                                                            run_dark  = abap_true ).

        rv_bool = abap_true.

      CATCH cx_enh_root.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by zcl_abapinst_objects=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_spot_name TYPE enhspotname,
          li_spot_ref  TYPE REF TO if_enh_spot_tool,
          li_enhs      TYPE REF TO zif_abapgit_object_enhs,
          lx_enh_root  TYPE REF TO cx_enh_root.

    lv_spot_name = ms_item-obj_name.

    TRY.
        li_spot_ref = cl_enh_factory=>get_enhancement_spot( spot_name = lv_spot_name
                                                            run_dark  = abap_true ).

      CATCH cx_enh_root INTO lx_enh_root.
        zcx_abapgit_exception=>raise_with_text( lx_enh_root ).
    ENDTRY.

    li_enhs = factory( li_spot_ref->get_tool( ) ).

    li_enhs->serialize( ii_xml           = io_xml
                        ii_enh_spot_tool = li_spot_ref ).

    zcl_abapgit_sotr_handler=>read_sotr(
      iv_pgmid       = 'R3TR'
      iv_object      = ms_item-obj_type
      iv_obj_name    = ms_item-obj_name
      io_i18n_params = mo_i18n_params
      io_xml         = io_xml ).

    zcl_abapgit_sots_handler=>read_sots(
      iv_pgmid       = 'R3TR'
      iv_object      = ms_item-obj_type
      iv_obj_name    = ms_item-obj_name
      io_i18n_params = mo_i18n_params
      io_xml         = io_xml ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_enqu IMPLEMENTATION.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE as4user FROM dd25l
      INTO rv_user
      WHERE viewname = ms_item-obj_name
      AND as4local = 'A'
      AND as4vers  = '0000'.
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    delete_ddic( 'L' ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_name  TYPE ddobjname,
          ls_dd25v TYPE dd25v,
          lt_dd26e TYPE TABLE OF dd26e,
          lt_dd27p TYPE ty_dd27p.

    io_xml->read( EXPORTING iv_name = 'DD25V'
                  CHANGING cg_data = ls_dd25v ).
    io_xml->read( EXPORTING iv_name = 'DD26E_TABLE'
                  CHANGING cg_data = lt_dd26e ).
    io_xml->read( EXPORTING iv_name = 'DD27P_TABLE'
                  CHANGING cg_data = lt_dd27p ).

    corr_insert( iv_package = iv_package
                 ig_object_class = 'DICT' ).

    lv_name = ms_item-obj_name.

    CALL FUNCTION 'DDIF_ENQU_PUT'
      EXPORTING
        name              = lv_name
        dd25v_wa          = ls_dd25v
      TABLES
        dd26e_tab         = lt_dd26e
        dd27p_tab         = lt_dd27p
      EXCEPTIONS
        enqu_not_found    = 1
        name_inconsistent = 2
        enqu_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    zcl_abapgit_objects_activation=>add_item( ms_item ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_viewname TYPE dd25l-viewname.

    SELECT SINGLE viewname FROM dd25l INTO lv_viewname
      WHERE viewname = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-ddic TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = abap_false.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by ZCL_ABAPGIT_OBJECT=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_name  TYPE ddobjname,
          lv_state TYPE ddgotstate,
          ls_dd25v TYPE dd25v,
          lt_dd26e TYPE TABLE OF dd26e,
          lt_dd27p TYPE ty_dd27p.

    lv_name = ms_item-obj_name.

    CALL FUNCTION 'DDIF_ENQU_GET'
      EXPORTING
        name          = lv_name
        state         = 'A'
        langu         = mv_language
      IMPORTING
        gotstate      = lv_state
        dd25v_wa      = ls_dd25v
      TABLES
        dd26e_tab     = lt_dd26e
        dd27p_tab     = lt_dd27p
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    IF ls_dd25v IS INITIAL OR lv_state <> 'A'.
      RETURN.
    ENDIF.

    CLEAR: ls_dd25v-as4user,
           ls_dd25v-as4date,
           ls_dd25v-as4time,
           ls_dd25v-as4local,
           ls_dd25v-as4vers.

    _clear_dd27p_fields( CHANGING ct_dd27p = lt_dd27p ).

    io_xml->add( iv_name = 'DD25V'
                 ig_data = ls_dd25v ).
    io_xml->add( ig_data = lt_dd26e
                 iv_name = 'DD26E_TABLE' ).
    io_xml->add( ig_data = lt_dd27p
                 iv_name = 'DD27P_TABLE' ).

  ENDMETHOD.

  METHOD _clear_dd27p_fields.

    FIELD-SYMBOLS <ls_dd27p> TYPE dd27p.

    LOOP AT ct_dd27p ASSIGNING <ls_dd27p>.
      "taken from table
      CLEAR <ls_dd27p>-headlen.
      CLEAR <ls_dd27p>-scrlen1.
      CLEAR <ls_dd27p>-scrlen2.
      CLEAR <ls_dd27p>-scrlen3.
      CLEAR <ls_dd27p>-intlen.
      CLEAR <ls_dd27p>-outputlen.
      CLEAR <ls_dd27p>-flength.
      CLEAR <ls_dd27p>-ddtext.
      CLEAR <ls_dd27p>-reptext.
      CLEAR <ls_dd27p>-scrtext_s.
      CLEAR <ls_dd27p>-scrtext_m.
      CLEAR <ls_dd27p>-scrtext_l.
      CLEAR <ls_dd27p>-rollname.
      CLEAR <ls_dd27p>-rollnamevi.
      CLEAR <ls_dd27p>-entitytab.
      CLEAR <ls_dd27p>-datatype.
      CLEAR <ls_dd27p>-inttype.
      CLEAR <ls_dd27p>-ddlanguage.
      CLEAR <ls_dd27p>-domname.
      CLEAR <ls_dd27p>-signflag.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_fugr IMPLEMENTATION.

  METHOD check_rfc_parameters.

* function module RS_FUNCTIONMODULE_INSERT does the same deep down, but the right error
* message is not returned to the user, this is a workaround to give a proper error
* message to the user

    DATA: ls_parameter TYPE rsfbpara,
          lt_fupa      TYPE rsfb_param,
          ls_fupa      LIKE LINE OF lt_fupa.

    IF is_function-remote_call = 'R'.
      cl_fb_parameter_conversion=>convert_parameter_old_to_fupa(
        EXPORTING
          functionname = is_function-funcname
          import       = is_function-import
          export       = is_function-export
          change       = is_function-changing
          tables       = is_function-tables
          except       = is_function-exception
        IMPORTING
          fupararef    = lt_fupa ).

      LOOP AT lt_fupa INTO ls_fupa WHERE paramtype = 'I' OR paramtype = 'E' OR paramtype = 'C' OR paramtype = 'T'.
        cl_fb_parameter_conversion=>convert_intern_to_extern(
          EXPORTING
            parameter_db  = ls_fupa
          IMPORTING
            parameter_vis = ls_parameter ).

        CALL FUNCTION 'RS_FB_CHECK_PARAMETER_REMOTE'
          EXPORTING
            parameter             = ls_parameter
            basxml_enabled        = is_function-remote_basxml
          EXCEPTIONS
            not_remote_compatible = 1
            OTHERS                = 2.
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise_t100( ).
        ENDIF.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.

  METHOD deserialize_functions.

    DATA: lv_include   TYPE rs38l-include,
          lv_area      TYPE rs38l-area,
          lv_group     TYPE rs38l-area,
          lv_namespace TYPE rs38l-namespace,
          lt_source    TYPE TABLE OF abaptxt255,
          lv_msg       TYPE string,
          lx_error     TYPE REF TO zcx_abapgit_exception.

    FIELD-SYMBOLS: <ls_func> LIKE LINE OF it_functions.

    LOOP AT it_functions ASSIGNING <ls_func>.

      lt_source = mo_files->read_abap( iv_extra = <ls_func>-funcname ).

      lv_area = ms_item-obj_name.

      CALL FUNCTION 'FUNCTION_INCLUDE_SPLIT'
        EXPORTING
          complete_area = lv_area
        IMPORTING
          namespace     = lv_namespace
          group         = lv_group
        EXCEPTIONS
          OTHERS        = 12.

      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_msg.
        ii_log->add_error( iv_msg  = |Function module { <ls_func>-funcname }: { lv_msg }|
                           is_item = ms_item ).
        CONTINUE. "with next function module
      ENDIF.

      IF zcl_abapinst_factory=>get_function_module( )->function_exists( <ls_func>-funcname ) = abap_true.
* delete the function module to make sure the parameters are updated
* haven't found a nice way to update the parameters
        CALL FUNCTION 'FUNCTION_DELETE'
          EXPORTING
            funcname                 = <ls_func>-funcname
            suppress_success_message = abap_true
          EXCEPTIONS
            error_message            = 1
            OTHERS                   = 2.
        IF sy-subrc <> 0.
          MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_msg.
          ii_log->add_error( iv_msg = |Function module { <ls_func>-funcname }: { lv_msg }|
                             is_item = ms_item ).
          CONTINUE. "with next function module
        ENDIF.
      ENDIF.

      TRY.
          check_rfc_parameters( <ls_func> ).
        CATCH zcx_abapgit_exception INTO lx_error.
          ii_log->add_error(
            iv_msg  = |Function module { <ls_func>-funcname }: { lx_error->get_text( ) }|
            is_item = ms_item ).
          CONTINUE. "with next function module
      ENDTRY.

      CALL FUNCTION 'RS_FUNCTIONMODULE_INSERT'
        EXPORTING
          funcname                = <ls_func>-funcname
          function_pool           = lv_group
          interface_global        = <ls_func>-global_flag
          remote_call             = <ls_func>-remote_call
          short_text              = <ls_func>-short_text
          update_task             = <ls_func>-update_task
          exception_class         = <ls_func>-exception_classes
          namespace               = lv_namespace
          remote_basxml_supported = <ls_func>-remote_basxml
          corrnum                 = iv_transport
        IMPORTING
          function_include        = lv_include
        TABLES
          import_parameter        = <ls_func>-import
          export_parameter        = <ls_func>-export
          tables_parameter        = <ls_func>-tables
          changing_parameter      = <ls_func>-changing
          exception_list          = <ls_func>-exception
          parameter_docu          = <ls_func>-documentation
        EXCEPTIONS
          double_task             = 1
          error_message           = 2
          function_already_exists = 3
          invalid_function_pool   = 4
          invalid_name            = 5
          too_many_functions      = 6
          no_modify_permission    = 7
          no_show_permission      = 8
          enqueue_system_failure  = 9
          canceled_in_corr        = 10
          OTHERS                  = 11.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_msg.
        ii_log->add_error( iv_msg = |Function module { <ls_func>-funcname }: { lv_msg }|
                           is_item = ms_item ).
        CONTINUE.  "with next function module
      ENDIF.

      zcl_abapinst_factory=>get_sap_report( )->insert_report(
        iv_name    = lv_include
        iv_package = iv_package
        iv_version = iv_version
        it_source  = lt_source ).

      ii_log->add_success( iv_msg = |Function module { <ls_func>-funcname } imported|
                           is_item = ms_item ).
    ENDLOOP.

  ENDMETHOD.

  METHOD deserialize_function_docs.

    FIELD-SYMBOLS <ls_func> LIKE LINE OF it_functions.

    zcl_abapinst_factory=>get_longtexts( )->deserialize(
      iv_longtext_id   = c_longtext_id_prog
      iv_object_name   = iv_prog_name
      ii_xml           = ii_xml
      iv_main_language = mv_language ).

    LOOP AT it_functions ASSIGNING <ls_func>.
      zcl_abapinst_factory=>get_longtexts( )->deserialize(
        iv_longtext_name = |LONGTEXTS_{ <ls_func>-funcname }|
        iv_longtext_id   = c_longtext_id_func
        iv_object_name   = <ls_func>-funcname
        ii_xml           = ii_xml
        iv_main_language = mv_language ).
      zcl_abapinst_factory=>get_longtexts( )->deserialize(
        iv_longtext_name = |LONGTEXTS_{ <ls_func>-funcname }___EXC|
        iv_longtext_id   = c_longtext_id_func_exc
        iv_object_name   = <ls_func>-funcname
        ii_xml           = ii_xml
        iv_main_language = mv_language ).
    ENDLOOP.

  ENDMETHOD.

  METHOD deserialize_includes.

    DATA: lo_xml       TYPE REF TO zif_abapgit_xml_input,
          ls_progdir   TYPE zif_abapgit_sap_report=>ty_progdir,
          lt_includes  TYPE ty_sobj_name_tt,
          lt_tpool     TYPE textpool_table,
          lt_tpool_ext TYPE zif_abapgit_definitions=>ty_tpool_tt,
          lt_source    TYPE TABLE OF abaptxt255,
          lx_exc       TYPE REF TO zcx_abapgit_exception.

    FIELD-SYMBOLS: <lv_include> LIKE LINE OF lt_includes.

    tadir_insert( iv_package ).

    ii_xml->read( EXPORTING iv_name = 'INCLUDES'
                  CHANGING cg_data = lt_includes ).

    LOOP AT lt_includes ASSIGNING <lv_include>.

      "ignore simple transformation includes (as long as they remain in existing repositories)
      IF strlen( <lv_include> ) = 33 AND <lv_include>+30(3) = 'XTI'.
        ii_log->add_warning( iv_msg = |Simple Transformation include { <lv_include> } ignored|
                             is_item = ms_item ).
        CONTINUE.
      ENDIF.

      TRY.
          lt_source = mo_files->read_abap( iv_extra = <lv_include> ).

          lo_xml = mo_files->read_xml( <lv_include> ).

          lo_xml->read( EXPORTING iv_name = 'PROGDIR'
                        CHANGING cg_data = ls_progdir ).

          set_abap_language_version( CHANGING cv_abap_language_version = ls_progdir-uccheck ).

          lo_xml->read( EXPORTING iv_name = 'TPOOL'
                        CHANGING cg_data = lt_tpool_ext ).
          lt_tpool = read_tpool( lt_tpool_ext ).

          deserialize_program( is_progdir = ls_progdir
                               it_source  = lt_source
                               it_tpool   = lt_tpool
                               iv_package = iv_package ).

          deserialize_textpool( iv_program    = <lv_include>
                                it_tpool      = lt_tpool
                                iv_is_include = abap_true ).

          ii_log->add_success( iv_msg = |Include { ls_progdir-name } imported|
                               is_item = ms_item ).

        CATCH zcx_abapgit_exception INTO lx_exc.
          ii_log->add_exception( ix_exc = lx_exc
                                 is_item = ms_item ).
          CONTINUE.
      ENDTRY.

    ENDLOOP.

  ENDMETHOD.

  METHOD deserialize_texts.
    DATA: lt_tpool_i18n TYPE ty_tpools_i18n,
          lt_tpool      TYPE textpool_table.

    FIELD-SYMBOLS <ls_tpool> LIKE LINE OF lt_tpool_i18n.
    ii_xml->read( EXPORTING iv_name = 'I18N_TPOOL'
                  CHANGING  cg_data = lt_tpool_i18n ).

    LOOP AT lt_tpool_i18n ASSIGNING <ls_tpool>.
      lt_tpool = read_tpool( <ls_tpool>-textpool ).
      deserialize_textpool( iv_program  = iv_prog_name
                            iv_language = <ls_tpool>-language
                            it_tpool    = lt_tpool ).
    ENDLOOP.
  ENDMETHOD.

  METHOD deserialize_xml.

    DATA: lv_complete  TYPE rs38l-area,
          lv_namespace TYPE rs38l-namespace,
          lv_areat     TYPE tlibt-areat,
          lv_stext     TYPE tftit-stext,
          lv_group     TYPE rs38l-area.

    lv_complete = ms_item-obj_name.

    CALL FUNCTION 'FUNCTION_INCLUDE_SPLIT'
      EXPORTING
        complete_area                = lv_complete
      IMPORTING
        namespace                    = lv_namespace
        group                        = lv_group
      EXCEPTIONS
        include_not_exists           = 1
        group_not_exists             = 2
        no_selections                = 3
        no_function_include          = 4
        no_function_pool             = 5
        delimiter_wrong_position     = 6
        no_customer_function_group   = 7
        no_customer_function_include = 8
        reserved_name_customer       = 9
        namespace_too_long           = 10
        area_length_error            = 11
        OTHERS                       = 12.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    ii_xml->read( EXPORTING iv_name = 'AREAT'
                  CHANGING cg_data = lv_areat ).
    lv_stext = lv_areat.

    CALL FUNCTION 'RS_FUNCTION_POOL_INSERT'
      EXPORTING
        function_pool           = lv_group
        short_text              = lv_stext
        namespace               = lv_namespace
        devclass                = iv_package
        unicode_checks          = iv_version
        corrnum                 = iv_transport
        suppress_corr_check     = abap_false
      EXCEPTIONS
        name_already_exists     = 1
        name_not_correct        = 2
        function_already_exists = 3
        invalid_function_pool   = 4
        invalid_name            = 5
        too_many_functions      = 6
        no_modify_permission    = 7
        no_show_permission      = 8
        enqueue_system_failure  = 9
        canceled_in_corr        = 10
        undefined_error         = 11
        OTHERS                  = 12.

    CASE sy-subrc.
      WHEN 0.
        " Everything is ok
      WHEN 1 OR 3.
        " If the function group exists we need to manually update the short text
        update_func_group_short_text( iv_group      = lv_group
                                      iv_short_text = lv_stext ).
      WHEN OTHERS.
        zcx_abapgit_exception=>raise_t100( ).
    ENDCASE.

  ENDMETHOD.

  METHOD functions.

    DATA: lv_area    TYPE rs38l-area,
          lt_enlfdir TYPE STANDARD TABLE OF enlfdir.
    DATA lv_index TYPE i.

    FIELD-SYMBOLS: <ls_functab> TYPE LINE OF ty_rs38l_incl_tt,
                   <ls_enlfdir> TYPE enlfdir.

    lv_area = ms_item-obj_name.

    CALL FUNCTION 'RS_FUNCTION_POOL_CONTENTS'
      EXPORTING
        function_pool           = lv_area
      TABLES
        functab                 = rt_functab
      EXCEPTIONS
        function_pool_not_found = 1
        OTHERS                  = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    "FM is not reliable if Function Group is inconsistent, so cross-check results (#7147)
    SELECT * FROM enlfdir
      INTO TABLE lt_enlfdir
      WHERE area = ms_item-obj_name
        AND active = abap_true
      ORDER BY funcname.                                  "#EC CI_SUBRC

    LOOP AT lt_enlfdir ASSIGNING <ls_enlfdir>.
      TRANSLATE <ls_enlfdir>-funcname TO UPPER CASE.
    ENDLOOP.

    SORT lt_enlfdir BY funcname ASCENDING.

    "Remove anything not in FM attributes table
    LOOP AT rt_functab ASSIGNING <ls_functab>.
      TRANSLATE <ls_functab> TO UPPER CASE.
      lv_index = sy-tabix.
      READ TABLE lt_enlfdir WITH KEY funcname = <ls_functab>-funcname TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        DELETE rt_functab INDEX lv_index.
      ENDIF.
    ENDLOOP.

    SORT rt_functab BY funcname ASCENDING.
    DELETE ADJACENT DUPLICATES FROM rt_functab COMPARING funcname.

  ENDMETHOD.

  METHOD get_abap_version.

    DATA: lt_includes TYPE ty_sobj_name_tt,
          ls_progdir  TYPE zif_abapgit_sap_report=>ty_progdir,
          lo_xml      TYPE REF TO zif_abapgit_xml_input.

    FIELD-SYMBOLS: <lv_include> LIKE LINE OF lt_includes.

    ii_xml->read( EXPORTING iv_name = 'INCLUDES'
                  CHANGING cg_data = lt_includes ).

    LOOP AT lt_includes ASSIGNING <lv_include>.

      lo_xml = mo_files->read_xml( <lv_include> ).

      lo_xml->read( EXPORTING iv_name = 'PROGDIR'
                    CHANGING cg_data = ls_progdir ).

      IF ls_progdir-uccheck IS INITIAL.
        CONTINUE.
      ELSEIF rv_abap_version IS INITIAL.
        rv_abap_version = ls_progdir-uccheck.
        CONTINUE.
      ELSEIF rv_abap_version <> ls_progdir-uccheck.
*** All includes need to have the same ABAP language version
        zcx_abapgit_exception=>raise( 'different ABAP Language Versions' ).
      ENDIF.
    ENDLOOP.

    IF rv_abap_version IS INITIAL.
      set_abap_language_version( CHANGING cv_abap_language_version = rv_abap_version ).
    ENDIF.

  ENDMETHOD.

  METHOD includes.

    TYPES: BEGIN OF ty_reposrc,
             progname TYPE reposrc-progname,
           END OF ty_reposrc.

    DATA: lt_reposrc        TYPE STANDARD TABLE OF ty_reposrc WITH DEFAULT KEY,
          ls_reposrc        LIKE LINE OF lt_reposrc,
          lv_program        TYPE program,
          lv_maintviewname  LIKE LINE OF rt_includes,
          lv_offset_ns      TYPE i,
          lv_tabix          LIKE sy-tabix,
          lt_functab        TYPE ty_rs38l_incl_tt,
          lt_tadir_includes TYPE HASHED TABLE OF objname WITH UNIQUE KEY table_line.

    FIELD-SYMBOLS: <lv_include> LIKE LINE OF rt_includes,
                   <ls_func>    LIKE LINE OF lt_functab.

    IF lines( mt_includes_cache ) > 0.
      rt_includes = mt_includes_cache.
      RETURN.
    ENDIF.

    lv_program = main_name( ).
    lt_functab = functions( ).

    CALL FUNCTION 'RS_GET_ALL_INCLUDES'
      EXPORTING
        program      = lv_program
      TABLES
        includetab   = rt_includes
      EXCEPTIONS
        not_existent = 1
        no_program   = 2
        OTHERS       = 3.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'Error from RS_GET_ALL_INCLUDES' ).
    ENDIF.

    LOOP AT lt_functab ASSIGNING <ls_func>.
      DELETE TABLE rt_includes FROM <ls_func>-include.
    ENDLOOP.

* handle generated maintenance views
    IF ms_item-obj_name(1) <> '/'.
      "FGroup name does not contain a namespace
      lv_maintviewname = |L{ ms_item-obj_name }T00|.
    ELSE.
      "FGroup name contains a namespace
      lv_offset_ns = find( val = ms_item-obj_name+1
                           sub = '/' ).
      lv_offset_ns = lv_offset_ns + 2.
      lv_maintviewname = |{ ms_item-obj_name(lv_offset_ns) }L{ ms_item-obj_name+lv_offset_ns }T00|.
    ENDIF.

    READ TABLE rt_includes WITH KEY table_line = lv_maintviewname TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND lv_maintviewname TO rt_includes.
    ENDIF.

    SORT rt_includes.
    IF lines( rt_includes ) > 0.
      " check which includes have their own tadir entry
      " these includes might reside in a different package or might be shared between multiple function groups
      " or other programs and are hence no part of the to serialized FUGR object
      " they will be handled as individual objects when serializing their package
      " in addition, referenced XTI includes referencing (simple) transformations must be ignored
      SELECT obj_name
        INTO TABLE lt_tadir_includes
        FROM tadir
        FOR ALL ENTRIES IN rt_includes
        WHERE pgmid      = 'R3TR'
              AND object = 'PROG'
              AND obj_name = rt_includes-table_line.
      LOOP AT rt_includes ASSIGNING <lv_include>.
        " skip autogenerated includes from Table Maintenance Generator
        IF <lv_include> CP 'LSVIM*'.
          DELETE rt_includes INDEX sy-tabix.
          CONTINUE.
        ENDIF.
        READ TABLE lt_tadir_includes WITH KEY table_line = <lv_include> TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          DELETE rt_includes.
          CONTINUE.
        ENDIF.
        IF strlen( <lv_include> ) = 33 AND <lv_include>+30(3) = 'XTI'.
          "ignore referenced (simple) transformation includes
          DELETE rt_includes.
          CONTINUE.
        ENDIF.
      ENDLOOP.

      IF lines( rt_includes ) > 0.
        SELECT progname FROM reposrc
          INTO TABLE lt_reposrc
          FOR ALL ENTRIES IN rt_includes
          WHERE progname = rt_includes-table_line
          AND r3state = 'A'.
      ENDIF.
      SORT lt_reposrc BY progname ASCENDING.
    ENDIF.

    LOOP AT rt_includes ASSIGNING <lv_include>.
      lv_tabix = sy-tabix.

* make sure the include exists
      READ TABLE lt_reposrc INTO ls_reposrc
        WITH KEY progname = <lv_include> BINARY SEARCH.
      IF sy-subrc <> 0.
        DELETE rt_includes INDEX lv_tabix.
        CONTINUE.
      ENDIF.

      "Make sure that the include does not belong to another function group
      IF is_part_of_other_fugr( <lv_include> ) = abap_true.
        DELETE rt_includes.
      ENDIF.
    ENDLOOP.

    APPEND lv_program TO rt_includes.
    SORT rt_includes.

    mt_includes_cache = rt_includes.

  ENDMETHOD.

  METHOD is_any_function_module_locked.

    DATA: lt_functions TYPE ty_rs38l_incl_tt.

    FIELD-SYMBOLS: <ls_function> TYPE rs38l_incl.

    TRY.
        lt_functions = functions( ).
      CATCH zcx_abapgit_exception.
        RETURN.
    ENDTRY.

    LOOP AT lt_functions ASSIGNING <ls_function>.

      IF exists_a_lock_entry_for( iv_lock_object = 'ESFUNCTION'
                                  iv_argument    = |{ <ls_function>-funcname }| ) = abap_true.
        rv_any_function_module_locked = abap_true.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD is_any_include_locked.

    DATA: lt_includes TYPE ty_sobj_name_tt.
    FIELD-SYMBOLS: <lv_include> TYPE sobj_name.

    TRY.
        lt_includes = includes( ).
      CATCH zcx_abapgit_exception.
        RETURN.
    ENDTRY.

    LOOP AT lt_includes ASSIGNING <lv_include>.

      IF exists_a_lock_entry_for( iv_lock_object = 'ESRDIRE'
                                  iv_argument    = |{ <lv_include> }| ) = abap_true.
        rv_is_any_include_locked = abap_true.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD is_function_group_locked.
    rv_is_functions_group_locked = exists_a_lock_entry_for( iv_lock_object = 'EEUDB'
                                                            iv_argument    = ms_item-obj_name
                                                            iv_prefix      = 'FG' ).
  ENDMETHOD.

  METHOD is_part_of_other_fugr.
    " make sure that the include belongs to the function group
    " like in LSEAPFAP Form TADIR_MAINTENANCE
    DATA ls_tadir TYPE tadir.
    DATA lv_namespace TYPE rs38l-namespace.
    DATA lv_function_group TYPE rs38l-area.
    DATA lv_include TYPE rs38l-include.
    DATA ls_item_key TYPE zif_abapgit_definitions=>ty_item.

    rv_belongs_to_other_fugr = abap_false.
    IF iv_include(1) = 'L' OR iv_include+1 CS '/L'.
      lv_include = iv_include.
      ls_tadir-object = 'FUGR'.

      CALL FUNCTION 'FUNCTION_INCLUDE_SPLIT'
        IMPORTING
          namespace = lv_namespace
          group     = lv_function_group
        CHANGING
          include   = lv_include
        EXCEPTIONS
          OTHERS    = 1 ##FM_SUBRC_OK.

      IF lv_function_group(1) = 'X'.    " "EXIT"-function-module
        ls_tadir-object = 'FUGS'.
      ENDIF.

      IF sy-subrc = 0.

        CONCATENATE lv_namespace lv_function_group INTO ls_tadir-obj_name.
        ls_item_key-obj_type = ls_tadir-object.
        ls_item_key-obj_name = ls_tadir-obj_name.

        " compare complete tadir key to distinguish between regular and exit function groups
        IF ( ls_tadir-obj_name <> ms_item-obj_name OR ls_tadir-object <> ms_item-obj_type ) AND
           zcl_abapinst_objects=>exists( ls_item_key ) = abap_true.
          rv_belongs_to_other_fugr = abap_true.
        ENDIF.
      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD main_name.

    DATA: lv_area      TYPE rs38l-area,
          lv_namespace TYPE rs38l-namespace,
          lv_group     TYPE rs38l-area.

    lv_area = ms_item-obj_name.

    CALL FUNCTION 'FUNCTION_INCLUDE_SPLIT'
      EXPORTING
        complete_area                = lv_area
      IMPORTING
        namespace                    = lv_namespace
        group                        = lv_group
      EXCEPTIONS
        include_not_exists           = 1
        group_not_exists             = 2
        no_selections                = 3
        no_function_include          = 4
        no_function_pool             = 5
        delimiter_wrong_position     = 6
        no_customer_function_group   = 7
        no_customer_function_include = 8
        reserved_name_customer       = 9
        namespace_too_long           = 10
        area_length_error            = 11
        OTHERS                       = 12.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    CONCATENATE lv_namespace 'SAPL' lv_group INTO rv_program.

  ENDMETHOD.

  METHOD serialize_functions.

    DATA:
      lt_source     TYPE TABLE OF rssource,
      lt_functab    TYPE ty_rs38l_incl_tt,
      lt_new_source TYPE rsfb_source,
      ls_function   LIKE LINE OF rt_functions.

    FIELD-SYMBOLS: <ls_func>          LIKE LINE OF lt_functab,
                   <ls_documentation> TYPE LINE OF ty_function-documentation.

    lt_functab = functions( ).

    LOOP AT lt_functab ASSIGNING <ls_func>.
* fm RPY_FUNCTIONMODULE_READ does not support source code
* lines longer than 72 characters
      CLEAR ls_function.
      MOVE-CORRESPONDING <ls_func> TO ls_function.

      CLEAR lt_new_source.
      CLEAR lt_source.

      CALL FUNCTION 'RPY_FUNCTIONMODULE_READ_NEW'
        EXPORTING
          functionname            = <ls_func>-funcname
        IMPORTING
          global_flag             = ls_function-global_flag
          remote_call             = ls_function-remote_call
          update_task             = ls_function-update_task
          short_text              = ls_function-short_text
          remote_basxml_supported = ls_function-remote_basxml
        TABLES
          import_parameter        = ls_function-import
          changing_parameter      = ls_function-changing
          export_parameter        = ls_function-export
          tables_parameter        = ls_function-tables
          exception_list          = ls_function-exception
          documentation           = ls_function-documentation
          source                  = lt_source
        CHANGING
          new_source              = lt_new_source
        EXCEPTIONS
          error_message           = 1
          function_not_found      = 2
          invalid_name            = 3
          OTHERS                  = 4.
      IF sy-subrc = 2.
        CONTINUE.
      ELSEIF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( 'Error from RPY_FUNCTIONMODULE_READ_NEW' ).
      ENDIF.

      LOOP AT ls_function-documentation ASSIGNING <ls_documentation>.
        CLEAR <ls_documentation>-index.
      ENDLOOP.

      SELECT SINGLE exten3 INTO ls_function-exception_classes FROM enlfdir
        WHERE funcname = <ls_func>-funcname.              "#EC CI_SUBRC

      APPEND ls_function TO rt_functions.

      IF NOT lt_new_source IS INITIAL.
        strip_generation_comments( CHANGING ct_source = lt_new_source ).
        mo_files->add_abap(
          iv_extra = <ls_func>-funcname
          it_abap  = lt_new_source ).
      ELSE.
        strip_generation_comments( CHANGING ct_source = lt_source ).
        mo_files->add_abap(
          iv_extra = <ls_func>-funcname
          it_abap  = lt_source ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_function_docs.

    FIELD-SYMBOLS <ls_func> LIKE LINE OF it_functions.

    zcl_abapinst_factory=>get_longtexts( )->serialize(
      iv_longtext_id = c_longtext_id_prog
      iv_object_name = iv_prog_name
      io_i18n_params = mo_i18n_params
      ii_xml         = ii_xml ).

    LOOP AT it_functions ASSIGNING <ls_func>.
      zcl_abapinst_factory=>get_longtexts( )->serialize(
        iv_longtext_name = |LONGTEXTS_{ <ls_func>-funcname }|
        iv_longtext_id   = c_longtext_id_func
        iv_object_name   = <ls_func>-funcname
        io_i18n_params   = mo_i18n_params
        ii_xml           = ii_xml ).
      zcl_abapinst_factory=>get_longtexts( )->serialize(
        iv_longtext_name = |LONGTEXTS_{ <ls_func>-funcname }___EXC|
        iv_longtext_id   = c_longtext_id_func_exc
        iv_object_name   = <ls_func>-funcname
        io_i18n_params   = mo_i18n_params
        ii_xml           = ii_xml ).
    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_includes.

    DATA: lt_includes TYPE ty_sobj_name_tt.

    FIELD-SYMBOLS: <lv_include> LIKE LINE OF lt_includes.

    lt_includes = includes( ).

    LOOP AT lt_includes ASSIGNING <lv_include>.

* todo, filename is not correct, a include can be used in several programs
      serialize_program( is_item    = ms_item
                         io_files   = mo_files
                         iv_program = <lv_include>
                         iv_extra   = <lv_include> ).

    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_texts.
    DATA: lt_tpool_i18n TYPE ty_tpools_i18n,
          lt_tpool      TYPE textpool_table.

    FIELD-SYMBOLS <ls_tpool> LIKE LINE OF lt_tpool_i18n.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN.
    ENDIF.

    " Table d010tinf stores info. on languages in which program is maintained
    " Select all active translations of program texts
    " Skip main language - it was already serialized
    SELECT DISTINCT language
      INTO CORRESPONDING FIELDS OF TABLE lt_tpool_i18n
      FROM d010tinf
      WHERE r3state = 'A'
      AND prog = iv_prog_name
      AND language <> mv_language
      ORDER BY language ##TOO_MANY_ITAB_FIELDS.

    mo_i18n_params->trim_saplang_keyed_table(
      EXPORTING
        iv_lang_field_name = 'LANGUAGE'
      CHANGING
        ct_tab = lt_tpool_i18n ).

    SORT lt_tpool_i18n BY language ASCENDING.
    LOOP AT lt_tpool_i18n ASSIGNING <ls_tpool>.
      READ TEXTPOOL iv_prog_name
        LANGUAGE <ls_tpool>-language
        INTO lt_tpool.
      <ls_tpool>-textpool = add_tpool( lt_tpool ).
    ENDLOOP.

    IF lines( lt_tpool_i18n ) > 0.
      ii_xml->add( iv_name = 'I18N_TPOOL'
                   ig_data = lt_tpool_i18n ).
    ENDIF.
  ENDMETHOD.

  METHOD serialize_xml.

    DATA: lt_includes TYPE ty_sobj_name_tt,
          lv_areat    TYPE tlibt-areat.

    SELECT SINGLE areat INTO lv_areat
      FROM tlibt
      WHERE spras = mv_language
      AND area = ms_item-obj_name.        "#EC CI_GENBUFF "#EC CI_SUBRC

    lt_includes = includes( ).

    ii_xml->add( iv_name = 'AREAT'
                 ig_data = lv_areat ).
    ii_xml->add( iv_name = 'INCLUDES'
                 ig_data = lt_includes ).

  ENDMETHOD.

  METHOD update_func_group_short_text.

    " We update the short text directly.
    " SE80 does the same in
    "   Program SAPLSEUF / LSEUFF07
    "   FORM GROUP_CHANGE

    UPDATE tlibt SET areat = iv_short_text
      WHERE spras = mv_language AND area = iv_group.

  ENDMETHOD.

  METHOD update_where_used.
* make extra sure the where-used list is updated after deletion
* Experienced some problems with the T00 include
* this method just tries to update everything

    DATA: lv_include LIKE LINE OF it_includes,
          lo_cross   TYPE REF TO cl_wb_crossreference.

    LOOP AT it_includes INTO lv_include.

      CREATE OBJECT lo_cross
        EXPORTING
          p_name    = lv_include
          p_include = lv_include.

      lo_cross->index_actualize( ).

    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    TYPES: BEGIN OF ty_stamps,
             user TYPE syuname,
             date TYPE d,
             time TYPE t,
           END OF ty_stamps.

    DATA:
      lt_stamps    TYPE STANDARD TABLE OF ty_stamps WITH DEFAULT KEY,
      lv_program   TYPE program,
      lv_found     TYPE abap_bool,
      lt_functions TYPE ty_rs38l_incl_tt.

    FIELD-SYMBOLS:
      <ls_function> LIKE LINE OF lt_functions,
      <lv_include>  LIKE LINE OF mt_includes_all,
      <ls_stamp>    LIKE LINE OF lt_stamps.

    lv_program = main_name( ).

    IF mt_includes_all IS INITIAL.
      CALL FUNCTION 'RS_GET_ALL_INCLUDES'
        EXPORTING
          program      = lv_program
        TABLES
          includetab   = mt_includes_all
        EXCEPTIONS
          not_existent = 1
          no_program   = 2
          OTHERS       = 3.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( 'Error from RS_GET_ALL_INCLUDES' ).
      ENDIF.
    ENDIF.

    " Check if changed_by for include object was requested
    LOOP AT mt_includes_all ASSIGNING <lv_include> WHERE table_line = to_upper( iv_extra ).
      lv_program = <lv_include>.
      lv_found   = abap_true.
      EXIT.
    ENDLOOP.

    " Check if changed_by for function module was requested
    lt_functions = functions( ).

    LOOP AT lt_functions ASSIGNING <ls_function> WHERE funcname = to_upper( iv_extra ).
      lv_program = <ls_function>-include.
      lv_found   = abap_true.
      EXIT.
    ENDLOOP.

    SELECT unam AS user udat AS date utime AS time FROM reposrc
      APPENDING CORRESPONDING FIELDS OF TABLE lt_stamps
      WHERE progname = lv_program
      AND r3state = 'A'
      ORDER BY PRIMARY KEY.                               "#EC CI_SUBRC

    IF mt_includes_all IS NOT INITIAL AND lv_found = abap_false.
      SELECT unam AS user udat AS date utime AS time FROM reposrc
        APPENDING CORRESPONDING FIELDS OF TABLE lt_stamps
        FOR ALL ENTRIES IN mt_includes_all
        WHERE progname = mt_includes_all-table_line
        AND r3state = 'A'.                                "#EC CI_SUBRC
    ENDIF.

    SELECT unam AS user udat AS date utime AS time FROM repotext " Program text pool
      APPENDING CORRESPONDING FIELDS OF TABLE lt_stamps
      WHERE progname = lv_program
      AND r3state = 'A'
      ORDER BY PRIMARY KEY.                               "#EC CI_SUBRC

    SELECT vautor AS user vdatum AS date vzeit AS time FROM eudb         " GUI
      APPENDING CORRESPONDING FIELDS OF TABLE lt_stamps
      WHERE relid = 'CU'
      AND name = lv_program
      AND srtf2 = 0
      ORDER BY PRIMARY KEY ##TOO_MANY_ITAB_FIELDS.

* Screens: username not stored in D020S database table

    SORT lt_stamps BY date DESCENDING time DESCENDING.

    READ TABLE lt_stamps INDEX 1 ASSIGNING <ls_stamp>.
    IF sy-subrc = 0.
      rv_user = <ls_stamp>-user.
    ELSE.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_area     TYPE rs38l-area,
          lt_includes TYPE ty_sobj_name_tt.

    " FUGR related to change documents will be deleted by CHDO
    SELECT SINGLE fgrp FROM tcdrps INTO lv_area WHERE fgrp = ms_item-obj_name.
    IF sy-subrc = 0.
      RETURN.
    ENDIF.

    lt_includes = includes( ).

    lv_area = ms_item-obj_name.

    CALL FUNCTION 'RS_FUNCTION_POOL_DELETE'
      EXPORTING
        area                   = lv_area
        suppress_popups        = abap_true
        skip_progress_ind      = abap_true
        corrnum                = iv_transport
      EXCEPTIONS
        canceled_in_corr       = 1
        enqueue_system_failure = 2
        function_exist         = 3
        not_executed           = 4
        no_modify_permission   = 5
        no_show_permission     = 6
        permission_failure     = 7
        pool_not_exist         = 8
        cancelled              = 9
        OTHERS                 = 10.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    update_where_used( lt_includes ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_program_name TYPE syrepid,
          lv_abap_version TYPE trdir-uccheck,
          lt_functions    TYPE ty_function_tt,
          lt_dynpros      TYPE ty_dynpro_tt,
          ls_cua          TYPE ty_cua.

    lv_abap_version = get_abap_version( io_xml ).

    deserialize_xml(
      ii_xml       = io_xml
      iv_version   = lv_abap_version
      iv_package   = iv_package
      iv_transport = iv_transport ).

    io_xml->read( EXPORTING iv_name = 'FUNCTIONS'
                  CHANGING cg_data = lt_functions ).

    deserialize_functions(
      it_functions = lt_functions
      ii_log       = ii_log
      iv_version   = lv_abap_version
      iv_package   = iv_package
      iv_transport = iv_transport ).

    deserialize_includes(
      ii_xml     = io_xml
      iv_package = iv_package
      ii_log     = ii_log ).

    lv_program_name = main_name( ).

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      deserialize_texts( iv_prog_name = lv_program_name
                         ii_xml       = io_xml ).
    ENDIF.

    io_xml->read( EXPORTING iv_name = 'DYNPROS'
                  CHANGING cg_data = lt_dynpros ).

    deserialize_dynpros( lt_dynpros ).

    io_xml->read( EXPORTING iv_name = 'CUA'
                  CHANGING cg_data = ls_cua ).

    deserialize_cua( iv_program_name = lv_program_name
                     is_cua = ls_cua ).

    deserialize_function_docs(
      iv_prog_name = lv_program_name
      it_functions = lt_functions
      ii_xml       = io_xml ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_pool  TYPE tlibg-area.

    lv_pool = ms_item-obj_name.
    CALL FUNCTION 'RS_FUNCTION_POOL_EXISTS'
      EXPORTING
        function_pool   = lv_pool
      EXCEPTIONS
        pool_not_exists = 1.
    rv_bool = boolc( sy-subrc <> 1 ).

    " Skip FUGR generated by CHDO
    IF rv_bool = abap_true.
      SELECT SINGLE fgrp FROM tcdrp INTO lv_pool WHERE fgrp = lv_pool.
      IF sy-subrc = 0.
        rv_bool = abap_false.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_program TYPE program.

    lv_program = main_name( ).

    IF is_function_group_locked( )        = abap_true
    OR is_any_include_locked( )           = abap_true
    OR is_any_function_module_locked( )   = abap_true
    OR is_any_dynpro_locked( lv_program ) = abap_true
    OR is_cua_locked( lv_program )        = abap_true
    OR is_text_locked( lv_program )       = abap_true.

      rv_is_locked = abap_true.

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA:
      ls_item      TYPE zif_abapgit_definitions=>ty_item,
      lt_functions TYPE ty_rs38l_incl_tt,
      lt_includes  TYPE ty_sobj_name_tt.

    FIELD-SYMBOLS:
      <ls_function> LIKE LINE OF lt_functions,
      <lv_include>  LIKE LINE OF lt_includes.

    ls_item-obj_type = 'PROG'.
    ls_item-obj_name = to_upper( iv_extra ).

    lt_functions = functions( ).

    LOOP AT lt_functions ASSIGNING <ls_function> WHERE funcname = ls_item-obj_name.
      ls_item-obj_name = <ls_function>-include.
      rv_exit = zcl_abapgit_objects_factory=>get_gui_jumper( )->jump( ls_item ).
      IF rv_exit = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.

    lt_includes = includes( ).

    LOOP AT lt_includes ASSIGNING <lv_include> WHERE table_line = ls_item-obj_name.
      rv_exit = zcl_abapgit_objects_factory=>get_gui_jumper( )->jump( ls_item ).
      IF rv_exit = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.

    " Otherwise covered by zcl_abapinst_objects=>JUMP

  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

* function group SEUF
* function group SIFP
* function group SUNI

    DATA: lt_functions    TYPE ty_function_tt,
          ls_progdir      TYPE zif_abapgit_sap_report=>ty_progdir,
          lv_program_name TYPE syrepid,
          lt_dynpros      TYPE ty_dynpro_tt,
          ls_cua          TYPE ty_cua.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    serialize_xml( io_xml ).

    lt_functions = serialize_functions( ).

    io_xml->add( iv_name = 'FUNCTIONS'
                 ig_data = lt_functions ).

    serialize_includes( ).

    lv_program_name = main_name( ).

    ls_progdir = zcl_abapinst_factory=>get_sap_report( )->read_progdir( lv_program_name ).

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      serialize_texts(
        iv_prog_name = lv_program_name
        ii_xml       = io_xml ).
    ENDIF.

    IF ls_progdir-subc = 'F'.
      lt_dynpros = serialize_dynpros( lv_program_name ).
      io_xml->add( iv_name = 'DYNPROS'
                   ig_data = lt_dynpros ).

      ls_cua = serialize_cua( lv_program_name ).
      io_xml->add( iv_name = 'CUA'
                   ig_data = ls_cua ).
    ENDIF.

    serialize_function_docs( iv_prog_name = lv_program_name
                             it_functions = lt_functions
                             ii_xml       = io_xml ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_idoc IMPLEMENTATION.

  METHOD clear_idoc_segement_field.

    FIELD-SYMBOLS <lg_any_field> TYPE any.

    ASSIGN COMPONENT iv_fieldname OF STRUCTURE cg_structure TO <lg_any_field>.
    IF sy-subrc = 0.
      CLEAR <lg_any_field>.
    ENDIF.

  ENDMETHOD.

  METHOD clear_idoc_segement_fields.

    clear_idoc_segement_field( EXPORTING iv_fieldname = 'DEVC'
                               CHANGING  cg_structure = cg_structure ).
    clear_idoc_segement_field( EXPORTING iv_fieldname = 'PLAST'
                               CHANGING  cg_structure = cg_structure ).
    clear_idoc_segement_field( EXPORTING iv_fieldname = 'PWORK'
                               CHANGING  cg_structure = cg_structure ).
    clear_idoc_segement_field( EXPORTING iv_fieldname = 'PRESP'
                               CHANGING  cg_structure = cg_structure ).
    clear_idoc_segement_field( EXPORTING iv_fieldname = 'CREDATE'
                               CHANGING  cg_structure = cg_structure ).
    clear_idoc_segement_field( EXPORTING iv_fieldname = 'CRETIME'
                               CHANGING  cg_structure = cg_structure ).
    clear_idoc_segement_field( EXPORTING iv_fieldname = 'LDATE'
                               CHANGING  cg_structure = cg_structure ).
    clear_idoc_segement_field( EXPORTING iv_fieldname = 'LTIME'
                               CHANGING  cg_structure = cg_structure ).
  ENDMETHOD.

  METHOD constructor.

    super->constructor(
      is_item        = is_item
      iv_language    = iv_language
      io_files       = io_files
      io_i18n_params = io_i18n_params ).

    mv_idoctyp = ms_item-obj_name.

  ENDMETHOD.

  METHOD is_closed.

    DATA ls_idoc TYPE ty_idoc.

    CALL FUNCTION 'IDOCTYPE_READ'
      EXPORTING
        pi_idoctyp       = mv_idoctyp
      IMPORTING
        pe_attributes    = ls_idoc-attributes
      EXCEPTIONS
        object_not_found = 1
        db_error         = 2
        no_authority     = 3
        OTHERS           = 4.
    rv_closed = boolc( sy-subrc = 0 AND ls_idoc-attributes-closed = abap_true ).

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    DATA: ls_attributes TYPE edi_iapi01.

    CALL FUNCTION 'IDOCTYPE_READ'
      EXPORTING
        pi_idoctyp       = mv_idoctyp
      IMPORTING
        pe_attributes    = ls_attributes
      EXCEPTIONS
        object_not_found = 1
        db_error         = 2
        no_authority     = 3
        OTHERS           = 4.

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    rv_user = ls_attributes-plast.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    CALL FUNCTION 'IDOCTYPE_DELETE'
      EXPORTING
        pi_idoctyp          = mv_idoctyp
      EXCEPTIONS
        object_not_found    = 1
        lock_error          = 2
        action_not_possible = 3
        transport_error     = 4
        db_error            = 5
        no_authority        = 6
        OTHERS              = 7.

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_idoc       TYPE ty_idoc,
          lv_transport  TYPE trkorr,
          ls_edbas      TYPE edbas,
          ls_attributes TYPE edi_iapi05.

    io_xml->read(
      EXPORTING
        iv_name = 'IDOC'
      CHANGING
        cg_data = ls_idoc ).

    MOVE-CORRESPONDING ls_idoc-attributes TO ls_attributes.

    IF zif_abapgit_object~exists( ) = abap_false.
      " Avoid popup asking for package
      tadir_insert( iv_package ).

      CALL FUNCTION 'IDOCTYPE_CREATE'
        EXPORTING
          pi_idoctyp       = mv_idoctyp
          pi_devclass      = iv_package
          pi_attributes    = ls_attributes
        TABLES
          pt_syntax        = ls_idoc-t_syntax
        EXCEPTIONS
          object_not_found = 1
          object_exists    = 2
          syntax_error     = 3
          segment_error    = 4
          transport_error  = 5
          db_error         = 6
          no_authority     = 7
          OTHERS           = 8.
    ELSE.
      IF is_closed( ) = abap_true.
        CALL FUNCTION 'IDOCTYPE_UNCLOSE'
          EXPORTING
            pi_idoctyp          = mv_idoctyp
          EXCEPTIONS
            object_not_found    = 1
            action_not_possible = 2
            db_error            = 3
            no_authority        = 4
            OTHERS              = 5.
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise_t100( ).
        ENDIF.
      ENDIF.

      CALL FUNCTION 'IDOCTYPE_UPDATE'
        EXPORTING
          pi_idoctyp       = mv_idoctyp
          pi_attributes    = ls_attributes
        TABLES
          pt_syntax        = ls_idoc-t_syntax
        EXCEPTIONS
          object_not_found = 1
          object_exists    = 2
          syntax_error     = 3
          segment_error    = 4
          transport_error  = 5
          db_error         = 6
          no_authority     = 7
          OTHERS           = 8.
    ENDIF.

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    IF ls_idoc-attributes-closed = abap_true.
      IF iv_transport IS NOT INITIAL.
        lv_transport = iv_transport.

        CALL FUNCTION 'IDOCTYPE_CLOSE'
          EXPORTING
            pi_idoctyp          = mv_idoctyp
          CHANGING
            pc_order            = lv_transport
          EXCEPTIONS
            object_not_found    = 1
            action_not_possible = 2
            db_error            = 3
            no_authority        = 4
            OTHERS              = 5.
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise_t100( ).
        ENDIF.
      ENDIF.

      " IDOCTYPE_CLOSE saves current release but it should be same as in repo
      SELECT SINGLE * FROM edbas INTO ls_edbas WHERE idoctyp = mv_idoctyp.
      ls_edbas-released = ls_idoc-attributes-released.
      ls_edbas-applrel  = ls_idoc-attributes-applrel.
      ls_edbas-closed   = ls_idoc-attributes-closed.
      UPDATE edbas FROM ls_edbas.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( |Error updating IDOC { mv_idoctyp }| ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    CALL FUNCTION 'IDOCTYPE_EXISTENCE_CHECK'
      EXPORTING
        pi_idoctyp       = mv_idoctyp
      EXCEPTIONS
        object_not_found = 1
        db_error         = 2
        OTHERS           = 3.

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA: lt_bdcdata TYPE TABLE OF bdcdata.

    FIELD-SYMBOLS: <ls_bdcdata> LIKE LINE OF lt_bdcdata.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING <ls_bdcdata>.
    <ls_bdcdata>-program  = 'SAPMSED5'.
    <ls_bdcdata>-dynpro   = '0010'.
    <ls_bdcdata>-dynbegin = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING <ls_bdcdata>.
    <ls_bdcdata>-fnam = 'SED5STRUC-OBJECT'.
    <ls_bdcdata>-fval = ms_item-obj_name.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING <ls_bdcdata>.
    <ls_bdcdata>-fnam = 'SED5STRUC-SELECT_ORG'.
    <ls_bdcdata>-fval = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING <ls_bdcdata>.
    <ls_bdcdata>-fnam = 'BDC_OKCODE'.
    <ls_bdcdata>-fval = '=DISP'.

    zcl_abapgit_objects_factory=>get_gui_jumper( )->jump_batch_input(
      iv_tcode   = 'WE30'
      it_bdcdata = lt_bdcdata ).

    rv_exit = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_idoc TYPE ty_idoc.

    CALL FUNCTION 'IDOCTYPE_READ'
      EXPORTING
        pi_idoctyp       = mv_idoctyp
      IMPORTING
        pe_attributes    = ls_idoc-attributes
      TABLES
        pt_syntax        = ls_idoc-t_syntax
      EXCEPTIONS
        object_not_found = 1
        db_error         = 2
        no_authority     = 3
        OTHERS           = 4.

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    clear_idoc_segement_fields( CHANGING cg_structure = ls_idoc-attributes ).

    io_xml->add( iv_name = 'IDOC'
                 ig_data = ls_idoc ).

  ENDMETHOD.
ENDCLASS.

CLASS lcl_aff_helper DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      get_descriptions_compo_subco
        IMPORTING iv_language          TYPE sy-langu
                  iv_clif_name         TYPE seoclsname
        RETURNING VALUE(rs_properties) TYPE zif_abapgit_aff_oo_types_v1=>ty_descriptions ,
      get_descr_comp_subc_w_exposure
        IMPORTING iv_language          TYPE sy-langu
                  iv_clif_name         TYPE seoclsname
                  iv_exposure          TYPE seoexpose DEFAULT seoc_exposure_public
        RETURNING VALUE(rs_properties) TYPE zif_abapgit_aff_oo_types_v1=>ty_descriptions ,
      set_descriptions_compo_subco
        IMPORTING iv_clif_name  TYPE seoclsname
                  iv_language   TYPE langu
                  is_properties TYPE zif_abapgit_aff_oo_types_v1=>ty_descriptions .
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_component,
        visibility TYPE seoexpose,
        cmpname    TYPE seocmpname,
        descript   TYPE seodescr,
        cmptype    TYPE seocmptype,
      END OF ty_component,
      BEGIN OF ty_sub_component,
        cmpname  TYPE seocmpname,
        sconame  TYPE seosconame,
        descript TYPE seodescr,
        scotype  TYPE seoscotype,
      END OF ty_sub_component,
      ty_compontents     TYPE SORTED TABLE OF ty_component WITH UNIQUE DEFAULT KEY,
      ty_sub_compontents TYPE SORTED TABLE OF ty_sub_component WITH UNIQUE DEFAULT KEY.

    CLASS-METHODS:
      get_attributes
        IMPORTING is_components    TYPE ty_compontents
        RETURNING VALUE(rs_result) TYPE zif_abapgit_aff_oo_types_v1=>ty_component_descriptions,
      get_methods
        IMPORTING is_components     TYPE ty_compontents
                  is_sub_components TYPE ty_sub_compontents
        RETURNING VALUE(rs_result)  TYPE zif_abapgit_aff_oo_types_v1=>ty_methods,
      get_types
        IMPORTING is_components    TYPE ty_compontents
        RETURNING VALUE(rs_result) TYPE zif_abapgit_aff_oo_types_v1=>ty_component_descriptions,
      get_events
        IMPORTING is_components     TYPE ty_compontents
                  is_sub_components TYPE ty_sub_compontents
        RETURNING VALUE(rs_result)  TYPE zif_abapgit_aff_oo_types_v1=>ty_events,
      set_methods
        IMPORTING iv_clif_name  TYPE seoclsname
                  iv_language   TYPE langu
                  is_properties TYPE zif_abapgit_aff_oo_types_v1=>ty_descriptions,
      set_attributes
        IMPORTING iv_clif_name  TYPE seoclsname
                  iv_language   TYPE langu
                  is_properties TYPE zif_abapgit_aff_oo_types_v1=>ty_descriptions,
      set_events
        IMPORTING iv_clif_name  TYPE seoclsname
                  iv_language   TYPE langu
                  is_properties TYPE zif_abapgit_aff_oo_types_v1=>ty_descriptions,
      set_types
        IMPORTING iv_clif_name  TYPE seoclsname
                  iv_language   TYPE langu
                  is_properties TYPE zif_abapgit_aff_oo_types_v1=>ty_descriptions .
ENDCLASS.

CLASS lcl_aff_helper IMPLEMENTATION.

  METHOD get_descr_comp_subc_w_exposure.
    DATA:
      lt_components     TYPE ty_compontents,
      lt_sub_components TYPE ty_sub_compontents.

    SELECT df~exposure AS visibility component~cmpname component_text~descript component~cmptype
      INTO TABLE lt_components
      FROM seocompo AS component
      LEFT OUTER JOIN seocompotx AS component_text
      ON component~cmpname = component_text~cmpname AND component~clsname = component_text~clsname AND
         component_text~langu = iv_language
      INNER JOIN seocompodf AS df
      ON component~clsname = df~clsname AND
         component~cmpname = df~cmpname
      WHERE component~clsname = iv_clif_name AND
            df~exposure       = iv_exposure.           "#EC CI_BUFFJOIN

    SELECT sub_component~cmpname sub_component~sconame sub_component_text~descript sub_component~scotype
      INTO TABLE lt_sub_components
      FROM seosubco AS sub_component JOIN seosubcotx AS sub_component_text
      ON sub_component~clsname = sub_component_text~clsname AND
         sub_component~cmpname = sub_component_text~cmpname AND
         sub_component~sconame = sub_component_text~sconame
      INNER JOIN seocompodf AS df
      ON sub_component~clsname = df~clsname AND
         sub_component~cmpname = df~cmpname
      WHERE sub_component~clsname    = iv_clif_name
        AND df~exposure              = iv_exposure
        AND sub_component_text~langu = iv_language
        AND sub_component_text~descript <> space.      "#EC CI_BUFFJOIN

    rs_properties-attributes = get_attributes( lt_components ).
    rs_properties-methods = get_methods( is_components     = lt_components
                                         is_sub_components = lt_sub_components ).
    rs_properties-events = get_events( is_components     = lt_components
                                       is_sub_components = lt_sub_components ).
    rs_properties-types = get_types( lt_components ).
  ENDMETHOD.

  METHOD get_descriptions_compo_subco.
    TYPES:
      BEGIN OF ty_helper_type,
        cmpname  TYPE seocmpname,
        descript TYPE seodescr,
        cmptype  TYPE seocmptype,
      END OF ty_helper_type.
    DATA:
      lt_components     TYPE STANDARD TABLE OF ty_helper_type,
      lt_sub_components TYPE ty_sub_compontents,
      lt_components_exp TYPE ty_compontents,
      ls_component_exp  LIKE LINE OF lt_components_exp.
    FIELD-SYMBOLS:
      <ls_component> LIKE LINE OF lt_components.

    SELECT component~cmpname component_text~descript component~cmptype
      INTO TABLE lt_components
      FROM seocompo AS component
      LEFT OUTER JOIN seocompotx AS component_text
      ON component~cmpname = component_text~cmpname AND component~clsname    = component_text~clsname
                                                    AND component_text~langu = iv_language
      WHERE component~clsname = iv_clif_name
      ORDER BY component~cmpname.                      "#EC CI_BUFFJOIN

    SELECT sub_component~cmpname sub_component~sconame sub_component_text~descript sub_component~scotype
      INTO TABLE lt_sub_components
      FROM seosubco AS sub_component JOIN seosubcotx AS sub_component_text
      ON sub_component~clsname      = sub_component_text~clsname
          AND sub_component~cmpname = sub_component_text~cmpname
          AND sub_component~sconame = sub_component_text~sconame
      WHERE sub_component~clsname    = iv_clif_name
        AND sub_component_text~langu = iv_language
        AND sub_component_text~descript <> space.      "#EC CI_BUFFJOIN

    LOOP AT lt_components ASSIGNING <ls_component>.
      CLEAR ls_component_exp.
      MOVE-CORRESPONDING <ls_component> TO ls_component_exp.
      INSERT ls_component_exp INTO TABLE lt_components_exp.
    ENDLOOP.

    rs_properties-attributes = get_attributes( lt_components_exp ).
    rs_properties-methods = get_methods( is_components     = lt_components_exp
                                         is_sub_components = lt_sub_components ).
    rs_properties-events = get_events( is_components     = lt_components_exp
                                       is_sub_components = lt_sub_components ).
    rs_properties-types = get_types( lt_components_exp ).

  ENDMETHOD.

  METHOD get_attributes.
    DATA:
      lo_component TYPE zif_abapgit_aff_oo_types_v1=>ty_component_description.
    FIELD-SYMBOLS <lo_attribute> TYPE ty_component.

    LOOP AT is_components ASSIGNING <lo_attribute> WHERE cmptype = seoo_cmptype_attribute AND descript IS NOT INITIAL.
      lo_component-name = <lo_attribute>-cmpname.
      lo_component-description = <lo_attribute>-descript.
      INSERT lo_component INTO TABLE rs_result.
    ENDLOOP.
  ENDMETHOD.

  METHOD get_methods.
    DATA:
      lo_method    TYPE zif_abapgit_aff_oo_types_v1=>ty_method,
      lo_exception TYPE zif_abapgit_aff_oo_types_v1=>ty_component_description,
      lo_parameter TYPE zif_abapgit_aff_oo_types_v1=>ty_component_description.

    FIELD-SYMBOLS <ls_sub_component> TYPE ty_sub_component.
    FIELD-SYMBOLS <ls_component> TYPE ty_component.

    LOOP AT is_components ASSIGNING <ls_component> WHERE cmptype = seoo_cmptype_method.
      lo_method-name = <ls_component>-cmpname.
      lo_method-description = <ls_component>-descript.

      LOOP AT is_sub_components ASSIGNING <ls_sub_component> WHERE cmpname = <ls_component>-cmpname.
        CASE <ls_sub_component>-scotype.
          WHEN seos_scotype_parameter.
            lo_parameter-name = <ls_sub_component>-sconame.
            lo_parameter-description = <ls_sub_component>-descript.
            INSERT lo_parameter INTO TABLE lo_method-parameters.
          WHEN seos_scotype_exception.
            lo_exception-name = <ls_sub_component>-sconame.
            lo_exception-description = <ls_sub_component>-descript.
            INSERT lo_exception INTO TABLE lo_method-exceptions.
        ENDCASE.
      ENDLOOP.

      IF lo_method-description IS NOT INITIAL
          OR lo_method-exceptions IS NOT INITIAL
          OR lo_method-parameters IS NOT INITIAL.
        INSERT lo_method INTO TABLE rs_result.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD get_types.
    DATA:
        lo_type TYPE zif_abapgit_aff_oo_types_v1=>ty_component_description.
    FIELD-SYMBOLS: <ls_types> TYPE ty_component.

    LOOP AT is_components ASSIGNING <ls_types>
        WHERE cmptype = seoo_cmptype_type AND descript IS NOT INITIAL.
      lo_type-name = <ls_types>-cmpname.
      lo_type-description = <ls_types>-descript.
      INSERT lo_type INTO TABLE rs_result.
    ENDLOOP.
  ENDMETHOD.

  METHOD get_events.
    DATA:
      lo_parameter TYPE zif_abapgit_aff_oo_types_v1=>ty_component_description,
      lo_event     TYPE zif_abapgit_aff_oo_types_v1=>ty_event.
    FIELD-SYMBOLS <ls_event> TYPE ty_component.
    FIELD-SYMBOLS <ls_sub_component> TYPE ty_sub_component.

    LOOP AT is_components ASSIGNING <ls_event> WHERE cmptype = seoo_cmptype_event.
      lo_event-name = <ls_event>-cmpname.
      lo_event-description = <ls_event>-descript.

      LOOP AT is_sub_components ASSIGNING <ls_sub_component> WHERE cmpname = <ls_event>-cmpname.
        lo_parameter-name = <ls_sub_component>-sconame.
        lo_parameter-description = <ls_sub_component>-descript.
        INSERT lo_parameter INTO TABLE lo_event-parameters.
      ENDLOOP.

      IF lo_event-description IS NOT INITIAL OR lo_event-parameters IS NOT INITIAL.
        INSERT lo_event INTO TABLE rs_result.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD set_attributes.
    DATA:
      lo_attribute TYPE seocompotx.
    FIELD-SYMBOLS: <ls_attribute> TYPE zif_abapgit_aff_oo_types_v1=>ty_component_description.

    LOOP AT is_properties-attributes ASSIGNING <ls_attribute>.
      lo_attribute-clsname  = iv_clif_name.
      lo_attribute-cmpname  = <ls_attribute>-name.
      lo_attribute-langu    = iv_language.
      lo_attribute-descript = <ls_attribute>-description.
      MODIFY seocompotx FROM lo_attribute.
    ENDLOOP.
  ENDMETHOD.

  METHOD set_methods.
    DATA:
      lo_method           TYPE seocompotx,
      lo_method_exception TYPE seosubcotx,
      lo_method_parameter TYPE seosubcotx.
    FIELD-SYMBOLS: <ls_method>    TYPE zif_abapgit_aff_oo_types_v1=>ty_method,
                   <ls_parameter> TYPE zif_abapgit_aff_oo_types_v1=>ty_component_description,
                   <ls_exception> TYPE zif_abapgit_aff_oo_types_v1=>ty_component_description.

    LOOP AT is_properties-methods ASSIGNING <ls_method>.
      lo_method-clsname  = iv_clif_name.
      lo_method-cmpname  = <ls_method>-name.
      lo_method-langu    = iv_language.
      lo_method-descript = <ls_method>-description.
      MODIFY seocompotx FROM lo_method.

      LOOP AT <ls_method>-parameters ASSIGNING <ls_parameter>.
        lo_method_parameter-clsname  = iv_clif_name.
        lo_method_parameter-cmpname  = <ls_method>-name.
        lo_method_parameter-sconame  = <ls_parameter>-name.
        lo_method_parameter-langu    = iv_language.
        lo_method_parameter-descript = <ls_parameter>-description.
        MODIFY seosubcotx FROM lo_method_parameter.
      ENDLOOP.

      LOOP AT <ls_method>-exceptions ASSIGNING <ls_exception>.
        lo_method_exception-clsname  = iv_clif_name.
        lo_method_exception-cmpname  = <ls_method>-name.
        lo_method_exception-sconame  = <ls_exception>-name.
        lo_method_exception-langu    = iv_language.
        lo_method_exception-descript = <ls_exception>-description.
        MODIFY seosubcotx FROM lo_method_exception.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.

  METHOD set_events.
    DATA:
      lo_event_parameter TYPE seosubcotx,
      lo_event           TYPE seocompotx.
    FIELD-SYMBOLS: <ls_event>     TYPE zif_abapgit_aff_oo_types_v1=>ty_event,
                   <ls_parameter> TYPE zif_abapgit_aff_oo_types_v1=>ty_component_description.

    LOOP AT is_properties-events ASSIGNING <ls_event>.
      lo_event-clsname  = iv_clif_name.
      lo_event-cmpname  = <ls_event>-name.
      lo_event-langu    = iv_language.
      lo_event-descript = <ls_event>-description.
      MODIFY seocompotx FROM lo_event.

      LOOP AT <ls_event>-parameters ASSIGNING <ls_parameter>.
        lo_event_parameter-clsname  = iv_clif_name.
        lo_event_parameter-cmpname  = <ls_event>-name.
        lo_event_parameter-sconame  = <ls_parameter>-name.
        lo_event_parameter-langu    = iv_language.
        lo_event_parameter-descript = <ls_parameter>-description.
        MODIFY seosubcotx FROM lo_event_parameter.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.

  METHOD set_types.
    DATA:
      lo_type TYPE seocompotx.
    FIELD-SYMBOLS: <ls_type> TYPE zif_abapgit_aff_oo_types_v1=>ty_component_description.

    LOOP AT is_properties-types ASSIGNING <ls_type>.
      lo_type-clsname  = iv_clif_name.
      lo_type-cmpname  = <ls_type>-name.
      lo_type-langu    = iv_language.
      lo_type-descript = <ls_type>-description.
      MODIFY seocompotx FROM lo_type.
    ENDLOOP.
  ENDMETHOD.

  METHOD set_descriptions_compo_subco.
    set_attributes( is_properties = is_properties
                    iv_clif_name  = iv_clif_name
                    iv_language   = iv_language ).
    set_methods( is_properties = is_properties
                 iv_clif_name  = iv_clif_name
                 iv_language   = iv_language ).
    set_events( is_properties = is_properties
                iv_clif_name  = iv_clif_name
                iv_language   = iv_language ).
    set_types( is_properties = is_properties
               iv_clif_name  = iv_clif_name
               iv_language   = iv_language ).
  ENDMETHOD.

ENDCLASS.

CLASS lcl_aff_type_mapping DEFINITION.
  PUBLIC SECTION.
    INTERFACES zif_abapgit_aff_type_mapping.
  PRIVATE SECTION.
    METHODS set_abapgit_descriptions
      IMPORTING is_clsname          TYPE seoclsname
                is_intf_aff         TYPE zif_abapgit_aff_intf_v1=>ty_main
      EXPORTING et_descriptions     TYPE zif_abapgit_oo_object_fnc=>ty_seocompotx_tt
                et_descriptions_sub TYPE zif_abapgit_oo_object_fnc=>ty_seosubcotx_tt.
ENDCLASS.

CLASS lcl_aff_type_mapping IMPLEMENTATION.

  METHOD zif_abapgit_aff_type_mapping~to_aff.
    DATA:
      ls_data_abapgit TYPE zcl_abapgit_object_intf=>ty_intf,
      ls_data_aff     TYPE zif_abapgit_aff_intf_v1=>ty_main.

    ls_data_abapgit = iv_data.

    ls_data_aff-format_version = '1'.

    " get header
    ls_data_aff-header-description = ls_data_abapgit-vseointerf-descript.
    ls_data_aff-header-abap_language_version = ls_data_abapgit-vseointerf-unicode.
    ls_data_aff-header-original_language = ls_data_abapgit-vseointerf-langu.

    " get category and proxy
    ls_data_aff-category = ls_data_abapgit-vseointerf-category.
    ls_data_aff-proxy = ls_data_abapgit-vseointerf-clsproxy.

    " get descriptions
    ls_data_aff-descriptions = lcl_aff_helper=>get_descriptions_compo_subco(
      iv_language  = ls_data_aff-header-original_language
      iv_clif_name = ls_data_abapgit-vseointerf-clsname ).

    es_data = ls_data_aff.
  ENDMETHOD.

  METHOD zif_abapgit_aff_type_mapping~to_abapgit.
    DATA:
      ls_data_abapgit TYPE zcl_abapgit_object_intf=>ty_intf,
      ls_data_aff     TYPE zif_abapgit_aff_intf_v1=>ty_main,
      lv_classname    TYPE seoclsname.

    ls_data_aff = iv_data.

    lv_classname = to_upper( iv_object_name ).

    set_abapgit_descriptions( EXPORTING is_clsname          = lv_classname
                                        is_intf_aff         = ls_data_aff
                              IMPORTING et_descriptions     = ls_data_abapgit-description
                                        et_descriptions_sub = ls_data_abapgit-description_sub ).

    ls_data_abapgit-vseointerf-clsname  = lv_classname.
    ls_data_abapgit-vseointerf-descript = ls_data_aff-header-description.
    ls_data_abapgit-vseointerf-category = ls_data_aff-category.
    ls_data_abapgit-vseointerf-unicode  = ls_data_aff-header-abap_language_version.
    ls_data_abapgit-vseointerf-langu    = ls_data_aff-header-original_language.
    ls_data_abapgit-vseointerf-clsproxy = ls_data_aff-proxy.
    ls_data_abapgit-vseointerf-exposure = seoc_exposure_public.
    ls_data_abapgit-vseointerf-state    = seoc_state_implemented.

    es_data = ls_data_abapgit.

  ENDMETHOD.

  METHOD set_abapgit_descriptions.

    DATA ls_description       TYPE seocompotx.
    DATA ls_description_subco TYPE seosubcotx.
    FIELD-SYMBOLS <ls_description>      TYPE zif_abapgit_aff_oo_types_v1=>ty_component_description.
    FIELD-SYMBOLS <ls_meth_description> TYPE zif_abapgit_aff_oo_types_v1=>ty_method.
    FIELD-SYMBOLS <ls_evt_description>  TYPE zif_abapgit_aff_oo_types_v1=>ty_event.

    LOOP AT is_intf_aff-descriptions-types ASSIGNING <ls_description>.
      ls_description-clsname  = is_clsname.
      ls_description-cmpname  = <ls_description>-name.
      ls_description-langu    = is_intf_aff-header-original_language.
      ls_description-descript = <ls_description>-description.
      APPEND ls_description TO et_descriptions.
    ENDLOOP.

    LOOP AT is_intf_aff-descriptions-attributes ASSIGNING <ls_description>.
      ls_description-clsname  = is_clsname.
      ls_description-cmpname  = <ls_description>-name.
      ls_description-langu    = is_intf_aff-header-original_language.
      ls_description-descript = <ls_description>-description.
      APPEND ls_description TO et_descriptions.
    ENDLOOP.

    LOOP AT is_intf_aff-descriptions-methods ASSIGNING <ls_meth_description>.
      ls_description-clsname  = is_clsname.
      ls_description-cmpname  = <ls_meth_description>-name.
      ls_description-langu    = is_intf_aff-header-original_language.
      ls_description-descript = <ls_meth_description>-description.
      APPEND ls_description TO et_descriptions.

      LOOP AT <ls_meth_description>-parameters ASSIGNING <ls_description>.
        ls_description_subco-clsname  = ls_description-clsname.
        ls_description_subco-cmpname  = ls_description-cmpname.
        ls_description_subco-langu    = ls_description-langu.
        ls_description_subco-sconame  = <ls_description>-name.
        ls_description_subco-descript = <ls_description>-description.
        APPEND ls_description_subco TO et_descriptions_sub.
      ENDLOOP.

      LOOP AT <ls_meth_description>-exceptions ASSIGNING <ls_description>.
        ls_description_subco-clsname  = ls_description-clsname.
        ls_description_subco-cmpname  = ls_description-cmpname.
        ls_description_subco-langu    = ls_description-langu.
        ls_description_subco-sconame  = <ls_description>-name.
        ls_description_subco-descript = <ls_description>-description.
        APPEND ls_description_subco TO et_descriptions_sub.
      ENDLOOP.
    ENDLOOP.

    LOOP AT is_intf_aff-descriptions-events ASSIGNING <ls_evt_description>.
      ls_description-clsname  = is_clsname.
      ls_description-cmpname  = <ls_evt_description>-name.
      ls_description-langu    = is_intf_aff-header-original_language.
      ls_description-descript = <ls_evt_description>-description.
      APPEND ls_description TO et_descriptions.

      LOOP AT <ls_evt_description>-parameters ASSIGNING <ls_description>.
        ls_description_subco-clsname  = ls_description-clsname.
        ls_description_subco-cmpname  = ls_description-cmpname.
        ls_description_subco-langu    = ls_description-langu.
        ls_description_subco-sconame  = <ls_description>-name.
        ls_description_subco-descript = <ls_description>-description.
        APPEND ls_description_subco TO et_descriptions_sub.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_aff_metadata_handler DEFINITION.
  PUBLIC SECTION.

    CLASS-METHODS serialize
      IMPORTING is_intf          TYPE zcl_abapgit_object_intf=>ty_intf
      RETURNING VALUE(rv_result) TYPE xstring
      RAISING   zcx_abapgit_exception.
    CLASS-METHODS serialize_translations
      IMPORTING is_intf          TYPE zcl_abapgit_object_intf=>ty_intf
                it_language      TYPE zif_abapgit_definitions=>ty_languages
      RETURNING VALUE(rt_result) TYPE zif_abapgit_i18n_file=>ty_table_of
      RAISING   zcx_abapgit_exception.
    CLASS-METHODS deserialize
      IMPORTING iv_data          TYPE string
      RETURNING VALUE(rv_result) TYPE zif_abapgit_aff_intf_v1=>ty_main
      RAISING   zcx_abapgit_exception.
    CLASS-METHODS deserialize_translation
      IMPORTING io_files           TYPE REF TO zcl_abapgit_objects_files
                is_item            TYPE zif_abapgit_definitions=>ty_item
      EXPORTING et_description_int TYPE zcl_abapgit_object_intf=>ty_intf-description_int
                et_description     TYPE zcl_abapgit_object_intf=>ty_intf-description
                et_description_sub TYPE zcl_abapgit_object_intf=>ty_intf-description_sub
      RAISING   zcx_abapgit_exception.
  PRIVATE SECTION.
    CLASS-METHODS:
      "! For serialization
      "! @parameter rt_result | Map/table that associates ABAP values to JSON values (enums)
      get_mappings
        RETURNING VALUE(rt_result) TYPE zcl_abapgit_json_handler=>ty_enum_mappings,
      "! For serialization
      "! @parameter rt_result | Paths that will not be serialized (depending on value)
      get_paths_to_skip
        RETURNING VALUE(rt_result) TYPE zcl_abapgit_json_handler=>ty_skip_paths,
      fill_translation
        IMPORTING iv_name          TYPE seoclsname
                  iv_language      TYPE laiso
        RETURNING VALUE(rt_result) TYPE zif_abapgit_aff_intf_v1=>ty_main.
ENDCLASS.

CLASS lcl_aff_metadata_handler IMPLEMENTATION.

  METHOD serialize.
    DATA:
      ls_data_aff      TYPE zif_abapgit_aff_intf_v1=>ty_main,
      lx_exception     TYPE REF TO cx_root,
      lo_aff_handler   TYPE REF TO zcl_abapgit_json_handler,
      lo_aff_mapper    TYPE REF TO zif_abapgit_aff_type_mapping,
      lt_enum_mappings TYPE zcl_abapgit_json_handler=>ty_enum_mappings,
      lt_paths_to_skip TYPE zcl_abapgit_json_handler=>ty_skip_paths.

    CREATE OBJECT lo_aff_mapper TYPE lcl_aff_type_mapping.
    lo_aff_mapper->to_aff( EXPORTING iv_data = is_intf
                           IMPORTING es_data = ls_data_aff ).

    lt_enum_mappings = get_mappings( ).
    lt_paths_to_skip = get_paths_to_skip( ).

    CREATE OBJECT lo_aff_handler.
    TRY.
        rv_result = lo_aff_handler->serialize( iv_data          = ls_data_aff
                                               iv_enum_mappings = lt_enum_mappings
                                               iv_skip_paths    = lt_paths_to_skip ).
      CATCH cx_root INTO lx_exception.
        zcx_abapgit_exception=>raise_with_text( lx_exception ).
    ENDTRY.

  ENDMETHOD.

  METHOD get_mappings.
    DATA:
      ls_category_mapping   TYPE zcl_abapgit_json_handler=>ty_enum_mapping,
      ls_json_abap_mapping  TYPE zcl_abapgit_json_handler=>ty_json_abap_mapping,
      lt_json_abap_mappings TYPE zcl_abapgit_json_handler=>ty_json_abap_mappings.

    ls_json_abap_mapping-abap = zif_abapgit_aff_intf_v1=>co_category-general.
    ls_json_abap_mapping-json = 'standard'.
    APPEND ls_json_abap_mapping TO lt_json_abap_mappings.
    ls_json_abap_mapping-abap = zif_abapgit_aff_intf_v1=>co_category-classic_badi.
    ls_json_abap_mapping-json = 'classicBadi'.
    APPEND ls_json_abap_mapping TO lt_json_abap_mappings.
    ls_json_abap_mapping-abap = zif_abapgit_aff_intf_v1=>co_category-business_static_components.
    ls_json_abap_mapping-json = 'businessStaticComponents'.
    APPEND ls_json_abap_mapping TO lt_json_abap_mappings.
    ls_json_abap_mapping-abap = zif_abapgit_aff_intf_v1=>co_category-db_procedure_proxy.
    ls_json_abap_mapping-json = 'dbProcedureProxy'.
    APPEND ls_json_abap_mapping TO lt_json_abap_mappings.
    ls_json_abap_mapping-abap = zif_abapgit_aff_intf_v1=>co_category-web_dynpro_runtime.
    ls_json_abap_mapping-json = 'webDynproRuntime'.
    APPEND ls_json_abap_mapping TO lt_json_abap_mappings.
    ls_json_abap_mapping-abap = zif_abapgit_aff_intf_v1=>co_category-enterprise_service.
    ls_json_abap_mapping-json = 'enterpriseService'.
    APPEND ls_json_abap_mapping TO lt_json_abap_mappings.

    ls_category_mapping-path = '/category'.
    ls_category_mapping-mappings = lt_json_abap_mappings.

    APPEND ls_category_mapping TO rt_result.
  ENDMETHOD.

  METHOD get_paths_to_skip.
    DATA:
      ls_path_to_skipp TYPE zcl_abapgit_json_handler=>ty_path_value_pair.

    ls_path_to_skipp-path  = '/category'.
    ls_path_to_skipp-value = 'standard'.

    APPEND ls_path_to_skipp TO rt_result.
  ENDMETHOD.

  METHOD deserialize.
    DATA:
      lo_ajson                      TYPE REF TO zcl_abapgit_json_handler,
      lx_exception                  TYPE REF TO cx_static_check,
      lt_enum_mappings              TYPE zcl_abapgit_json_handler=>ty_enum_mappings,
      lt_default_abap_langu_version TYPE zcl_abapgit_json_handler=>ty_path_value_pair,
      lt_values_for_initial         TYPE zcl_abapgit_json_handler=>ty_skip_paths.

    lt_values_for_initial = get_paths_to_skip( ).

    lt_default_abap_langu_version-path  = '/header/abap_language_version'.
    lt_default_abap_langu_version-value = zif_abapgit_dot_abapgit=>c_abap_language_version-standard.
    APPEND lt_default_abap_langu_version TO lt_values_for_initial.

    lt_enum_mappings = get_mappings( ).

    CREATE OBJECT lo_ajson.
    TRY.
        lo_ajson->deserialize(
          EXPORTING
            iv_content       = iv_data
            iv_defaults      = lt_values_for_initial
            iv_enum_mappings = lt_enum_mappings
          IMPORTING
            ev_data          = rv_result ).
      CATCH cx_static_check INTO lx_exception.
        zcx_abapgit_exception=>raise_with_text( lx_exception ).
    ENDTRY.

  ENDMETHOD.

  METHOD serialize_translations.
    DATA: ls_data        TYPE zif_abapgit_aff_intf_v1=>ty_main,
          lv_langu       TYPE laiso,
          lv_json        TYPE string,
          lo_ajson       TYPE REF TO zif_abapgit_ajson,
          lo_json_path   TYPE REF TO zcl_abapgit_json_path,
          lt_translation TYPE string_table,
          lx_exception   TYPE REF TO zcx_abapgit_ajson_error,
          lo_trans_file  TYPE REF TO zcl_abapgit_properties_file.

    LOOP AT it_language INTO lv_langu.

      ls_data = fill_translation( iv_name  = is_intf-vseointerf-clsname
                                  iv_language = lv_langu ).

      " convert AFF type to JSON
      TRY.
          lo_ajson = zcl_abapgit_ajson=>new( iv_keep_item_order = abap_true
            )->set( iv_path = '/'
                    iv_val  = ls_data
            )->map( zcl_abapgit_ajson_mapping=>create_to_camel_case( )
            )->filter( zcl_abapgit_ajson_filter_lib=>create_empty_filter( ) ).
          " remove manually the non-primitive types that are initial or not relevant for translation
          lo_ajson->delete( '/category/' ).
          lo_ajson->delete( '/proxy/' ).
          lv_json = lo_ajson->stringify( ).
        CATCH zcx_abapgit_ajson_error INTO lx_exception.
          zcx_abapgit_exception=>raise_with_text( lx_exception ).
      ENDTRY.

      CREATE OBJECT lo_json_path.
      lt_translation = lo_json_path->serialize( lv_json ).

      CREATE OBJECT lo_trans_file
        EXPORTING iv_lang = lv_langu.

      lo_trans_file->push_text_pairs( lt_translation ).

      APPEND lo_trans_file TO rt_result.
    ENDLOOP.

  ENDMETHOD.

  METHOD fill_translation.
    DATA: lv_langu_sap1 TYPE sy-langu.

    lv_langu_sap1 = zcl_abapgit_convert=>language_sap2_to_sap1( iv_language ).

    rt_result-descriptions = lcl_aff_helper=>get_descriptions_compo_subco(
      iv_clif_name = iv_name
      iv_language  = lv_langu_sap1 ).

    SELECT SINGLE descript FROM seoclasstx INTO rt_result-header-description
    WHERE clsname = iv_name AND
          langu   = lv_langu_sap1.

  ENDMETHOD.

  METHOD deserialize_translation.
    DATA: lo_properties_file  TYPE REF TO zcl_abapgit_properties_file,
          lt_description_int  LIKE LINE OF et_description_int,
          lt_translation_file TYPE zif_abapgit_i18n_file=>ty_table_of,
          li_translation_file LIKE LINE OF lt_translation_file,
          ls_aff_data         TYPE zif_abapgit_aff_intf_v1=>ty_main,
          lo_type_mapper      TYPE REF TO zif_abapgit_aff_type_mapping,
          ls_ag_data          TYPE zcl_abapgit_object_intf=>ty_intf,
          lv_sap1             TYPE sy-langu.

    lt_translation_file = io_files->read_i18n_files( ).

    LOOP AT lt_translation_file INTO li_translation_file.

      CLEAR ls_ag_data.

      lo_properties_file ?= li_translation_file.
      lo_properties_file->get_translations( IMPORTING ev_data = ls_aff_data ).

      lv_sap1 = zcl_abapgit_convert=>language_sap2_to_sap1( li_translation_file->lang( ) ).
      ls_aff_data-header-original_language = lv_sap1.

      CREATE OBJECT lo_type_mapper TYPE lcl_aff_type_mapping.
      lo_type_mapper->to_abapgit(
        EXPORTING
          iv_data        = ls_aff_data
          iv_object_name = is_item-obj_name
        IMPORTING
          es_data        = ls_ag_data ).

      lt_description_int-clsname  = ls_ag_data-vseointerf-clsname.
      lt_description_int-langu    = ls_ag_data-vseointerf-langu.
      lt_description_int-descript = ls_ag_data-vseointerf-descript.

      APPEND lt_description_int TO et_description_int.
      APPEND LINES OF ls_ag_data-description     TO et_description.
      APPEND LINES OF ls_ag_data-description_sub TO et_description_sub.

    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_intf IMPLEMENTATION.

  METHOD constructor.

    DATA li_aff_registry TYPE REF TO zif_abapgit_aff_registry.

    super->constructor(
      is_item        = is_item
      iv_language    = iv_language
      io_files       = io_files
      io_i18n_params = io_i18n_params ).

    mi_object_oriented_object_fct = zcl_abapgit_oo_factory=>get_by_type( ms_item-obj_type ).

    CREATE OBJECT li_aff_registry TYPE zcl_abapgit_aff_registry.

    mv_aff_enabled = li_aff_registry->is_supported_object_type( 'INTF' ).

  ENDMETHOD.

  METHOD deserialize_descr_class.
    DATA ls_clskey TYPE seoclskey.
    ls_clskey-clsname = ms_item-obj_name.

    mi_object_oriented_object_fct->update_descriptions_class(
      is_key          = ls_clskey
      iv_language     = mv_language
      it_descriptions = it_description ).
  ENDMETHOD.

  METHOD deserialize_descr_compo.
    DATA ls_clskey TYPE seoclskey.
    ls_clskey-clsname = ms_item-obj_name.

    mi_object_oriented_object_fct->update_descriptions_compo(
      is_key          = ls_clskey
      it_descriptions = it_description ).
  ENDMETHOD.

  METHOD deserialize_descr_subco.
    DATA ls_clskey TYPE seoclskey.
    ls_clskey-clsname = ms_item-obj_name.

    mi_object_oriented_object_fct->update_descriptions_subco(
      is_key          = ls_clskey
      it_descriptions = it_description ).
  ENDMETHOD.

  METHOD deserialize_docu.
    DATA: lv_object     TYPE dokhl-object,
          ls_i18n_lines TYPE zif_abapgit_lang_definitions=>ty_i18n_line.

    lv_object = ms_item-obj_name.

    IF lines( is_docu-lines ) = 0.
      mi_object_oriented_object_fct->delete_documentation(
        iv_id          = c_longtext_id-interface
        iv_object_name = lv_object
        iv_language    = mv_language ).
      RETURN.
    ENDIF.

    mi_object_oriented_object_fct->create_documentation(
      it_lines       = is_docu-lines
      iv_id          = c_longtext_id-interface
      iv_object_name = lv_object
      iv_language    = mv_language ).

    LOOP AT is_docu-i18n_lines INTO ls_i18n_lines.
      mi_object_oriented_object_fct->create_documentation(
        it_lines         = ls_i18n_lines-lines
        iv_id            = c_longtext_id-interface
        iv_object_name   = lv_object
        iv_language      = ls_i18n_lines-language
        iv_no_masterlang = abap_true ).
    ENDLOOP.

    deserialize_longtexts(
      ii_xml           = ii_xml
      iv_longtext_name = c_longtext_name-attributes
      iv_longtext_id   = c_longtext_id-attributes ).

    deserialize_longtexts(
      ii_xml           = ii_xml
      iv_longtext_name = c_longtext_name-methods
      iv_longtext_id   = c_longtext_id-methods ).

    deserialize_longtexts(
      ii_xml           = ii_xml
      iv_longtext_name = c_longtext_name-events
      iv_longtext_id   = c_longtext_id-events ).

  ENDMETHOD.

  METHOD deserialize_pre_ddic.

    DATA ls_intf TYPE ty_intf.

    IF mv_aff_enabled = abap_true.
      ls_intf = read_json( ).
    ELSE.
      ii_xml->read( EXPORTING iv_name = 'VSEOINTERF'
                    CHANGING  cg_data = ls_intf-vseointerf ).
    ENDIF.

    set_abap_language_version( CHANGING cv_abap_language_version = ls_intf-vseointerf-unicode ).

    mi_object_oriented_object_fct->create(
      EXPORTING
        iv_check      = abap_false
        iv_package    = iv_package
      CHANGING
        cg_properties = ls_intf-vseointerf ).

  ENDMETHOD.

  METHOD deserialize_proxy.

    DATA: lv_transport    TYPE trkorr,
          li_proxy_object TYPE REF TO if_px_main,
          lv_name         TYPE prx_r3name,
          lx_proxy_fault  TYPE REF TO cx_proxy_fault.

    lv_name = ms_item-obj_name.

    lv_transport = iv_transport.

    TRY.
        li_proxy_object = cl_pxn_factory=>create(
                              application  = 'PROXY_UI'
                              display_only = abap_false
                              saveable     = abap_true
                          )->if_pxn_factory~load_by_abap_name(
                              object   = ms_item-obj_type
                              obj_name = lv_name ).

        li_proxy_object->activate(
          EXPORTING
            activate_all     = abap_true
          CHANGING
            transport_number = lv_transport ).

        li_proxy_object->dequeue( ).

      CATCH cx_proxy_fault INTO lx_proxy_fault.
        IF li_proxy_object IS BOUND.
          TRY.
              li_proxy_object->dequeue( ).
            CATCH cx_proxy_fault ##NO_HANDLER.
          ENDTRY.
        ENDIF.
        zcx_abapgit_exception=>raise_with_text( lx_proxy_fault ).
    ENDTRY.

  ENDMETHOD.

  METHOD read_json.
    DATA lv_json_data TYPE string.
    DATA ls_intf_aff TYPE zif_abapgit_aff_intf_v1=>ty_main.
    DATA lo_aff_mapper TYPE REF TO zif_abapgit_aff_type_mapping.

    lv_json_data = mo_files->read_string( 'json' ).
    ls_intf_aff = lcl_aff_metadata_handler=>deserialize( lv_json_data ).

    CREATE OBJECT lo_aff_mapper TYPE lcl_aff_type_mapping.
    lo_aff_mapper->to_abapgit( EXPORTING iv_data        = ls_intf_aff
                                         iv_object_name = ms_item-obj_name
                               IMPORTING es_data        = rs_intf ).
  ENDMETHOD.

  METHOD read_xml.
    ii_xml->read( EXPORTING iv_name = 'VSEOINTERF'
                  CHANGING  cg_data = rs_intf-vseointerf ).
    ii_xml->read( EXPORTING iv_name = 'DESCRIPTIONS_INTERFACE'
                  CHANGING  cg_data = rs_intf-description_int ).
    ii_xml->read( EXPORTING iv_name = 'DESCRIPTIONS'
                  CHANGING  cg_data = rs_intf-description ).
    ii_xml->read( EXPORTING iv_name = 'DESCRIPTIONS_SUB'
                  CHANGING  cg_data = rs_intf-description_sub ).
    ii_xml->read( EXPORTING iv_name = 'LINES'
                  CHANGING  cg_data = rs_intf-docu-lines ).
    ii_xml->read( EXPORTING iv_name = 'I18N_LINES'
                  CHANGING  cg_data = rs_intf-docu-i18n_lines ).
  ENDMETHOD.

  METHOD serialize_descr_class.

    DATA: lt_descriptions    TYPE zif_abapgit_oo_object_fnc=>ty_seoclasstx_tt,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    " Main language is already in VSEOCLASS so we serialize only translations
    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN.
    ENDIF.

    lt_descriptions = mi_object_oriented_object_fct->read_descriptions_class(
      iv_object_name = iv_clsname
      iv_language    = mv_language ).

    " Remove technical languages
    lt_language_filter = mo_i18n_params->build_language_filter( ).
    DELETE lt_descriptions WHERE NOT langu IN lt_language_filter AND langu <> mv_language.

    IF lines( lt_descriptions ) = 0.
      RETURN.
    ENDIF.

    rs_description = lt_descriptions.

  ENDMETHOD.

  METHOD serialize_descr_compo.

    DATA: lt_descriptions    TYPE zif_abapgit_oo_object_fnc=>ty_seocompotx_tt,
          lv_language        TYPE spras,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      lv_language = mv_language.
    ENDIF.

    lt_descriptions = mi_object_oriented_object_fct->read_descriptions_compo(
      iv_object_name = iv_clsname
      iv_language    = lv_language ).

    " Remove technical languages
    lt_language_filter = mo_i18n_params->build_language_filter( ).
    DELETE lt_descriptions WHERE NOT langu IN lt_language_filter AND langu <> mv_language.

    IF lines( lt_descriptions ) = 0.
      RETURN.
    ENDIF.

    rs_description = lt_descriptions.

  ENDMETHOD.

  METHOD serialize_descr_subco.

    DATA: lt_descriptions    TYPE zif_abapgit_oo_object_fnc=>ty_seosubcotx_tt,
          lv_language        TYPE spras,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      lv_language = mv_language.
    ENDIF.

    lt_descriptions = mi_object_oriented_object_fct->read_descriptions_subco(
      iv_object_name = iv_clsname
      iv_language    = lv_language ).

    " Remove technical languages
    lt_language_filter = mo_i18n_params->build_language_filter( ).
    DELETE lt_descriptions WHERE NOT langu IN lt_language_filter AND langu <> mv_language.

    IF lines( lt_descriptions ) = 0.
      RETURN.
    ENDIF.

    rs_description = lt_descriptions.

  ENDMETHOD.

  METHOD serialize_docu.

    DATA: lt_lines      TYPE tlinetab,
          lv_object     TYPE dokhl-object,
          lv_langu      TYPE sy-langu,
          lt_i18n_lines TYPE zif_abapgit_lang_definitions=>ty_i18n_lines,
          ls_i18n_lines TYPE zif_abapgit_lang_definitions=>ty_i18n_line.

    lv_object = iv_clsname.

    lt_lines = mi_object_oriented_object_fct->read_documentation(
      iv_id          = c_longtext_id-interface
      iv_object_name = lv_object
      iv_language    = mv_language ).

    rs_docu-lines = lt_lines.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN.
    ENDIF.

    LOOP AT it_langu_additional INTO lv_langu.

      lt_lines = mi_object_oriented_object_fct->read_documentation(
        iv_id          = c_longtext_id-interface
        iv_object_name = lv_object
        iv_language    = lv_langu ).

      IF lines( lt_lines ) > 0.
        CLEAR ls_i18n_lines.
        ls_i18n_lines-language = lv_langu.
        ls_i18n_lines-lines    = lt_lines.
        INSERT ls_i18n_lines INTO TABLE lt_i18n_lines.
      ENDIF.

    ENDLOOP.

    rs_docu-i18n_lines = lt_i18n_lines.

  ENDMETHOD.

  METHOD serialize_xml.

    DATA:
      ls_intf                      TYPE ty_intf,
      ls_clskey                    TYPE seoclskey,
      lv_serialized_data           TYPE xstring,
      lt_langu_additional          TYPE zif_abapgit_lang_definitions=>ty_langus,
      lt_i18n_file                 TYPE zif_abapgit_i18n_file=>ty_table_of,
      lo_i18n_file                 TYPE REF TO zif_abapgit_i18n_file,
      lt_languages_for_translation TYPE zif_abapgit_definitions=>ty_languages.

    ls_clskey-clsname = ms_item-obj_name.

    ls_intf-vseointerf = mi_object_oriented_object_fct->get_interface_properties( ls_clskey ).

    clear_abap_language_version( CHANGING cv_abap_language_version = ls_intf-vseointerf-unicode ).

    " Select all active translations of documentation
    " Skip main language - it was already serialized
    SELECT DISTINCT langu
      INTO TABLE lt_langu_additional
      FROM dokhl
      WHERE id     = c_longtext_id-interface
        AND object = ls_clskey-clsname
        AND langu  <> mv_language
      ORDER BY langu.

    ls_intf-docu = serialize_docu(
      iv_clsname          = ls_clskey-clsname
      it_langu_additional = lt_langu_additional ).

    ls_intf-description_int = serialize_descr_class( ls_clskey-clsname ).
    ls_intf-description     = serialize_descr_compo( ls_clskey-clsname ).
    ls_intf-description_sub = serialize_descr_subco( ls_clskey-clsname ).

    " HERE: switch with feature flag for XML or JSON file format
    IF mv_aff_enabled = abap_true.
      lv_serialized_data = lcl_aff_metadata_handler=>serialize( ls_intf ).
      mo_files->add_raw( iv_ext  = 'json'
                         iv_data = lv_serialized_data ).

      lt_languages_for_translation = extract_languages_for_transl( ls_intf ).

      lt_i18n_file = lcl_aff_metadata_handler=>serialize_translations(
        is_intf     = ls_intf
        it_language = lt_languages_for_translation ).

      LOOP AT lt_i18n_file INTO lo_i18n_file.
        mo_files->add_i18n_file( lo_i18n_file ).
      ENDLOOP.
    ELSE.
      io_xml->add( iv_name = 'VSEOINTERF'
                   ig_data = ls_intf-vseointerf ).
      io_xml->add( iv_name = 'DESCRIPTIONS_INTERFACE'
                   ig_data = ls_intf-description_int ).
      io_xml->add( iv_name = 'DESCRIPTIONS'
                   ig_data = ls_intf-description ).
      io_xml->add( iv_name = 'DESCRIPTIONS_SUB'
                   ig_data = ls_intf-description_sub ).
      io_xml->add( iv_name = 'LINES'
                   ig_data = ls_intf-docu-lines ).
      io_xml->add( iv_name = 'I18N_LINES'
                   ig_data = ls_intf-docu-i18n_lines ).

      serialize_longtexts(
        ii_xml           = io_xml
        iv_longtext_name = c_longtext_name-attributes
        iv_longtext_id   = c_longtext_id-attributes ).

      serialize_longtexts(
        ii_xml           = io_xml
        iv_longtext_name = c_longtext_name-methods
        iv_longtext_id   = c_longtext_id-methods ).

      serialize_longtexts(
        ii_xml           = io_xml
        iv_longtext_name = c_longtext_name-events
        iv_longtext_id   = c_longtext_id-events ).

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    TYPES: BEGIN OF ty_includes,
             programm TYPE syrepid,
           END OF ty_includes.

    TYPES: BEGIN OF ty_reposrc,
             unam  TYPE reposrc-unam,
             udat  TYPE reposrc-udat,
             utime TYPE reposrc-utime,
           END OF ty_reposrc.

    DATA: lt_reposrc  TYPE STANDARD TABLE OF ty_reposrc,
          ls_reposrc  LIKE LINE OF lt_reposrc,
          lt_includes TYPE STANDARD TABLE OF ty_includes.

    lt_includes = mi_object_oriented_object_fct->get_includes( ms_item-obj_name ).
    ASSERT lines( lt_includes ) > 0.

    SELECT unam udat utime FROM reposrc
      INTO TABLE lt_reposrc
      FOR ALL ENTRIES IN lt_includes
      WHERE progname = lt_includes-programm
      AND r3state = 'A'.
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ELSE.
      SORT lt_reposrc BY udat DESCENDING utime DESCENDING.
      READ TABLE lt_reposrc INDEX 1 INTO ls_reposrc.
      ASSERT sy-subrc = 0.
      rv_user = ls_reposrc-unam.
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_object~delete.
    DATA: ls_clskey     TYPE seoclskey,
          ls_vseointerf TYPE vseointerf.

    ls_clskey-clsname = ms_item-obj_name.
    ls_vseointerf = mi_object_oriented_object_fct->get_interface_properties( ls_clskey ).

    IF ls_vseointerf-clsproxy = abap_true.
      " Proxy interfaces are managed via SPRX
      RETURN.
    ENDIF.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    corr_insert( iv_package ).

    mi_object_oriented_object_fct->delete( ls_clskey ).
  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.
    DATA:
      lt_source          TYPE rswsourcet,
      ls_clskey          TYPE seoclskey,
      ls_intf            TYPE ty_intf,
      lt_description     TYPE zif_abapgit_oo_object_fnc=>ty_seocompotx_tt,
      lt_description_int TYPE zif_abapgit_oo_object_fnc=>ty_seoclasstx_tt,
      lt_description_sub TYPE zif_abapgit_oo_object_fnc=>ty_seosubcotx_tt.

    IF iv_step = zif_abapgit_object=>gc_step_id-abap.
      " HERE: switch with feature flag between XML and JSON file format
      IF mv_aff_enabled = abap_true.
        ls_intf = read_json( ).

        lcl_aff_metadata_handler=>deserialize_translation(
          EXPORTING
            io_files           = mo_files
            is_item            = ms_item
          IMPORTING
            et_description     = lt_description
            et_description_int = lt_description_int
            et_description_sub = lt_description_sub ).

        APPEND LINES OF lt_description TO ls_intf-description.
        APPEND LINES OF lt_description_int TO ls_intf-description_int.
        APPEND LINES OF lt_description_sub TO ls_intf-description_sub.

      ELSE.
        ls_intf = read_xml( io_xml ).
      ENDIF.

      set_abap_language_version( CHANGING cv_abap_language_version = ls_intf-vseointerf-unicode ).

      IF ls_intf-vseointerf-clsproxy = abap_true.
        " Proxy interfaces are managed via SPRX
        deserialize_proxy( iv_transport ).

      ELSE.
        mi_object_oriented_object_fct->create(
          EXPORTING
            iv_check      = abap_true
            iv_package    = iv_package
          CHANGING
            cg_properties = ls_intf-vseointerf ).

        ls_clskey-clsname = ms_item-obj_name.
        lt_source = mo_files->read_abap( ).

        mi_object_oriented_object_fct->deserialize_source(
          is_key     = ls_clskey
          iv_package = iv_package
          iv_version = ls_intf-vseointerf-unicode
          it_source  = lt_source ).

        deserialize_descr_class( ls_intf-description_int ).

        deserialize_descr_compo( ls_intf-description ).

        deserialize_descr_subco( ls_intf-description_sub ).

        deserialize_docu(
          is_docu = ls_intf-docu
          ii_xml  = io_xml ).

        mi_object_oriented_object_fct->add_to_activation_list( ms_item ).
      ENDIF.

    ELSEIF iv_step = zif_abapgit_object=>gc_step_id-early.

      " If interface does not exist, create it
      " so DDIC that depends on it does not fail activation
      IF zif_abapgit_object~exists( ) = abap_false.
        deserialize_pre_ddic(
          ii_xml     = io_xml
          iv_package = iv_package ).
      ELSE.
        corr_insert( iv_package ).
      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: ls_class_key TYPE seoclskey,
          lv_category  TYPE seoclassdf-category.

    ls_class_key-clsname = ms_item-obj_name.

    rv_bool = mi_object_oriented_object_fct->exists( ls_class_key-clsname ).

    IF rv_bool = abap_true.
      SELECT SINGLE category FROM seoclassdf INTO lv_category
        WHERE clsname = ls_class_key-clsname
        AND ( version = '1'
        OR version = '0' ) ##WARN_OK.                   "#EC CI_GENBUFF
      IF sy-subrc = 0 AND lv_category = seoc_category_webdynpro_class.
        rv_bool = abap_false.
      ELSE.
        SELECT SINGLE obj_name FROM sproxhdr INTO ls_class_key-clsname
          WHERE object = 'INTF' AND obj_name = ls_class_key-clsname.
        IF sy-subrc = 0.
          " generated by proxy
          rv_bool = abap_false.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-early TO rt_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE eqegraarg.

    lv_object = |{ ms_item-obj_name }|.
    OVERLAY lv_object WITH '==============================P'.
    lv_object = lv_object && '*'.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = 'ESEOCLASS'
                                            iv_argument    = lv_object ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by zcl_abapinst_objects=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lt_source        TYPE seop_source_string,
          ls_interface_key TYPE seoclskey.

    ls_interface_key-clsname = ms_item-obj_name.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    CALL FUNCTION 'SEO_BUFFER_REFRESH'
      EXPORTING
        version = seoc_version_active
        force   = abap_true.
    CALL FUNCTION 'SEO_BUFFER_REFRESH'
      EXPORTING
        version = seoc_version_inactive
        force   = abap_true.

    lt_source = mi_object_oriented_object_fct->serialize_abap( ls_interface_key ).

    mo_files->add_abap( lt_source ).

    serialize_xml( io_xml ).

  ENDMETHOD.

  METHOD extract_languages_for_transl.
    DATA: lv_desc              TYPE seocompotx,
          lv_desc_int          TYPE seoclasstx,
          lv_desc_sub          TYPE seosubcotx,
          lv_unique            TYPE sy-langu,
          lv_sap2              TYPE string,
          lt_unique_language   TYPE STANDARD TABLE OF sy-langu,
          lv_original_language TYPE sy-langu.

    lv_original_language = mo_i18n_params->ms_params-main_language.

    LOOP AT is_intf-description INTO lv_desc WHERE langu <> lv_original_language.
      APPEND lv_desc-langu TO lt_unique_language.
    ENDLOOP.

    LOOP AT is_intf-description_int INTO lv_desc_int WHERE langu <> lv_original_language.
      APPEND lv_desc_int-langu TO lt_unique_language.
    ENDLOOP.

    LOOP AT is_intf-description_sub INTO lv_desc_sub WHERE langu <> lv_original_language.
      APPEND lv_desc_sub-langu TO lt_unique_language.
    ENDLOOP.

    SORT lt_unique_language ASCENDING.
    DELETE ADJACENT DUPLICATES FROM lt_unique_language.

    LOOP AT lt_unique_language INTO lv_unique.
      lv_sap2 = zcl_abapgit_convert=>language_sap1_to_sap2( lv_unique ).
      APPEND lv_sap2 TO rs_result.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_msag IMPLEMENTATION.

  METHOD delete_documentation.
    DATA: lv_key_s TYPE dokhl-object.

    CLEAR lv_key_s.
    CALL FUNCTION 'DOCU_OBJECT_NAME_CONCATENATE'
      EXPORTING
        docu_id  = c_longtext_id_msag
        element  = iv_message_id
        addition = '   '
      IMPORTING
        object   = lv_key_s.

    CALL FUNCTION 'DOKU_DELETE_ALL'
      EXPORTING
        doku_id                        = c_longtext_id_msag
        doku_object                    = lv_key_s
        generic_use                    = 'X'
        suppress_authority             = space
        suppress_enqueue               = space
        suppress_transport             = space
      EXCEPTIONS
        header_without_text            = 1
        index_without_header           = 2
        no_authority_for_devclass_xxxx = 3
        no_docu_found                  = 4
        object_is_already_enqueued     = 5
        object_is_enqueued_by_corr     = 6
        user_break                     = 7
        OTHERS                         = 8.
    IF sy-subrc <> 0 AND sy-subrc <> 4.
      zcx_abapgit_exception=>raise( 'Error deleting longtext for message' ).
    ENDIF.

  ENDMETHOD.

  METHOD delete_msgid.

    delete_documentation( iv_message_id ).

    DELETE FROM t100a WHERE arbgb = iv_message_id.
    IF sy-subrc = 0 OR sy-subrc = 4.
      CALL FUNCTION 'RS_TREE_OBJECT_PLACEMENT'
        EXPORTING
          object    = iv_message_id
          operation = 'DELETE'
          program   = space
          type      = 'CN'.
      DELETE FROM t100o WHERE arbgb = iv_message_id.
      DELETE FROM t100t WHERE arbgb = iv_message_id.    "#EC CI_NOFIRST
      DELETE FROM t100u WHERE arbgb = iv_message_id.
      DELETE FROM t100x WHERE arbgb = iv_message_id.
      DELETE FROM t100 WHERE arbgb = iv_message_id.
    ENDIF.

  ENDMETHOD.

  METHOD deserialize_texts.

    DATA: lv_msg_id     TYPE rglif-message_id,
          ls_t100       TYPE t100,
          lt_t100t      TYPE TABLE OF t100t,
          lt_t100_texts TYPE ty_t100_texts,
          lt_t100u      TYPE TABLE OF t100u.

    FIELD-SYMBOLS: <ls_t100_text> TYPE ty_t100_text.

    lv_msg_id = ms_item-obj_name.

    SELECT * FROM t100u INTO TABLE lt_t100u
      WHERE arbgb = lv_msg_id ORDER BY PRIMARY KEY.     "#EC CI_GENBUFF

    ii_xml->read( EXPORTING iv_name = 'T100_TEXTS'
                  CHANGING  cg_data = lt_t100_texts ).

    ii_xml->read( EXPORTING iv_name = 'T100T'
                  CHANGING  cg_data = lt_t100t ).

    mo_i18n_params->trim_saplang_keyed_table(
      EXPORTING
        iv_lang_field_name = 'SPRSL'
      CHANGING
        ct_tab = lt_t100_texts ).
    mo_i18n_params->trim_saplang_keyed_table(
      EXPORTING
        iv_lang_field_name = 'SPRSL'
      CHANGING
        ct_tab = lt_t100t ).

    MODIFY t100t FROM TABLE lt_t100t.                     "#EC CI_SUBRC

    LOOP AT lt_t100_texts ASSIGNING <ls_t100_text>.
      "check if message exists
      READ TABLE lt_t100u TRANSPORTING NO FIELDS
        WITH KEY arbgb = lv_msg_id msgnr = <ls_t100_text>-msgnr BINARY SEARCH.
      CHECK sy-subrc = 0. "if original message doesn't exist no translations added

      MOVE-CORRESPONDING <ls_t100_text> TO ls_t100.
      ls_t100-arbgb = lv_msg_id.
      MODIFY t100 FROM ls_t100.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( 'MSAG: Table T100 modify failed' ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD free_access_permission.
    CALL FUNCTION 'RS_ACCESS_PERMISSION'
      EXPORTING
        mode         = 'FREE'
        object       = iv_message_id
        object_class = 'T100'.
  ENDMETHOD.

  METHOD serialize_longtexts_msag.

    DATA: lv_doku_object_name  TYPE dokhl-object,
          lt_doku_object_names TYPE STANDARD TABLE OF dokhl-object
                          WITH NON-UNIQUE DEFAULT KEY,
          lt_dokil             TYPE zif_abapgit_definitions=>ty_dokil_tt,
          ls_dokil             LIKE LINE OF lt_dokil,
          lt_language_filter   TYPE zif_abapgit_environment=>ty_system_language_filter.

    FIELD-SYMBOLS: <ls_t100>  TYPE t100.

    IF lines( it_t100 ) = 0.
      RETURN.
    ENDIF.

    LOOP AT it_t100 ASSIGNING <ls_t100>.

      lv_doku_object_name = <ls_t100>-arbgb && <ls_t100>-msgnr.
      INSERT lv_doku_object_name INTO TABLE lt_doku_object_names.

    ENDLOOP.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      SELECT * FROM dokil
        INTO TABLE lt_dokil
        FOR ALL ENTRIES IN lt_doku_object_names
        WHERE id = c_longtext_id_msag
        AND object = lt_doku_object_names-table_line
        AND masterlang = abap_true
        ORDER BY PRIMARY KEY.
    ELSE.
      lt_language_filter = mo_i18n_params->build_language_filter( ).
      SELECT * FROM dokil
        INTO TABLE lt_dokil
        FOR ALL ENTRIES IN lt_doku_object_names
        WHERE id = c_longtext_id_msag
        AND object = lt_doku_object_names-table_line
        AND langu IN lt_language_filter
        ORDER BY PRIMARY KEY.
    ENDIF.

    CLEAR ls_dokil-dokstate.
    MODIFY lt_dokil FROM ls_dokil TRANSPORTING dokstate WHERE dokstate IS NOT INITIAL.

    IF lines( lt_dokil ) > 0.
      serialize_longtexts( ii_xml   = ii_xml
                           it_dokil = lt_dokil ).
    ENDIF.

  ENDMETHOD.

  METHOD serialize_texts.

    DATA: lv_msg_id          TYPE rglif-message_id,
          lt_t100_texts      TYPE ty_t100_texts,
          lt_t100t           TYPE TABLE OF t100t,
          lt_i18n_langs      TYPE TABLE OF langu,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    lv_msg_id = ms_item-obj_name.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN. " skip
    ENDIF.

    " Collect additional languages
    " Skip main lang - it has been already serialized and also technical languages
    lt_language_filter = mo_i18n_params->build_language_filter( ).

    SELECT DISTINCT sprsl AS langu INTO TABLE lt_i18n_langs
      FROM t100t
      WHERE arbgb = lv_msg_id
      AND sprsl IN lt_language_filter
      AND sprsl <> mv_language
      ORDER BY langu.                    "#EC CI_BYPASS "#EC CI_GENBUFF

    SORT lt_i18n_langs ASCENDING.

    IF lines( lt_i18n_langs ) > 0.

      SELECT * FROM t100t INTO CORRESPONDING FIELDS OF TABLE lt_t100t
        WHERE sprsl IN lt_language_filter
        AND sprsl <> mv_language
        AND arbgb = lv_msg_id
        ORDER BY PRIMARY KEY.                           "#EC CI_GENBUFF

      SELECT * FROM t100 INTO CORRESPONDING FIELDS OF TABLE lt_t100_texts
        WHERE sprsl IN lt_language_filter
        AND sprsl <> mv_language
        AND arbgb = lv_msg_id
        ORDER BY PRIMARY KEY.             "#EC CI_SUBRC "#EC CI_GENBUFF

      SORT lt_t100t BY sprsl ASCENDING.
      SORT lt_t100_texts BY sprsl msgnr ASCENDING.

      ii_xml->add( iv_name = 'I18N_LANGS'
                   ig_data = lt_i18n_langs ).

      ii_xml->add( iv_name = 'T100T'
                   ig_data = lt_t100t ).

      ii_xml->add( iv_name = 'T100_TEXTS'
                   ig_data = lt_t100_texts ).

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE lastuser FROM t100a INTO rv_user
      WHERE arbgb = ms_item-obj_name.                   "#EC CI_GENBUFF
    IF sy-subrc <> 0 OR rv_user = ''.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.
    DATA: ls_t100a      TYPE t100a,
          lv_frozen     TYPE abap_bool,
          lv_message_id TYPE arbgb.

* parameter SUPPRESS_DIALOG doesn't exist in all versions of FM RS_DELETE_MESSAGE_ID
* replaced with a copy
    lv_message_id = ms_item-obj_name.
    IF ms_item-obj_name = space.
      zcx_abapgit_exception=>raise( 'Error from (copy of) RS_DELETE_MESSAGE_ID' )."blank message id
    ENDIF.

    SELECT SINGLE * FROM t100a INTO ls_t100a WHERE arbgb = ms_item-obj_name.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'Error from (copy of) RS_DELETE_MESSAGE_ID' )."not found
    ENDIF.

    CLEAR lv_frozen.
    CALL FUNCTION 'RS_ACCESS_PERMISSION'
      EXPORTING
        authority_check = 'X'
        global_lock     = 'X'
        mode            = 'MODIFY'
        object          = lv_message_id
        object_class    = 'T100'
      IMPORTING
        frozen          = lv_frozen
      EXCEPTIONS
        OTHERS          = 1.

    IF sy-subrc <> 0 OR lv_frozen <> space.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    zcl_abapinst_factory=>get_cts_api( )->insert_transport_object(
      iv_object   = 'MSAG'
      iv_obj_name = lv_message_id
      iv_package  = iv_package
      iv_language = mv_language
      iv_mode     = zif_abapgit_cts_api=>c_transport_mode-delete ).

    delete_msgid( lv_message_id ).

    free_access_permission( lv_message_id ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.
* fm RPY_MESSAGE_ID_INSERT almost works, but not in older versions

    DATA: ls_t100a  TYPE t100a,
          ls_t100t  TYPE t100t,
          ls_t100u  TYPE t100u,
          lt_t100   TYPE TABLE OF t100,
          lt_before TYPE TABLE OF t100u.

    FIELD-SYMBOLS: <ls_t100> LIKE LINE OF lt_t100.

    io_xml->read( EXPORTING iv_name = 'T100A'
                  CHANGING cg_data = ls_t100a ).
    io_xml->read( EXPORTING iv_name = 'T100'
                  CHANGING cg_data = lt_t100 ).

    corr_insert( iv_package ).

    SELECT * FROM t100u INTO TABLE lt_before
      WHERE arbgb = ls_t100a-arbgb ORDER BY msgnr. "#EC CI_GENBUFF "#EC CI_BYPASS

    LOOP AT lt_t100 ASSIGNING <ls_t100>.
      DELETE lt_before WHERE msgnr = <ls_t100>-msgnr.
      MODIFY t100 FROM <ls_t100>.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( 'MSAG: Table T100 modify failed' ).
      ENDIF.
      CLEAR ls_t100u.
      MOVE-CORRESPONDING <ls_t100> TO ls_t100u ##ENH_OK.
      ls_t100u-name    = sy-uname.
      ls_t100u-datum   = sy-datum.
      ls_t100u-selfdef = '3'.
      MODIFY t100u FROM ls_t100u.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( 'MSAG: Table T100U modify failed' ).
      ENDIF.
    ENDLOOP.

    ls_t100a-masterlang = mv_language.
    ls_t100a-lastuser = sy-uname.
    ls_t100a-respuser = sy-uname.
    ls_t100a-ldate = sy-datum.
    ls_t100a-ltime = sy-uzeit.
    MODIFY t100a FROM ls_t100a.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'MSAG: Table T100A modify failed' ).
    ENDIF.

    ls_t100t-sprsl = mv_language.
    ls_t100t-arbgb = ls_t100a-arbgb.
    ls_t100t-stext = ls_t100a-stext.
    MODIFY t100t FROM ls_t100t.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'MSAG: Table T100T modify failed' ).
    ENDIF.

    LOOP AT lt_before INTO ls_t100u.
      DELETE FROM t100 WHERE arbgb = ls_t100u-arbgb
        AND msgnr = ls_t100u-msgnr.                       "#EC CI_SUBRC

      DELETE FROM t100u WHERE arbgb = ls_t100u-arbgb
        AND msgnr = ls_t100u-msgnr.                       "#EC CI_SUBRC
    ENDLOOP.

    deserialize_longtexts( ii_xml         = io_xml
                           iv_longtext_id = c_longtext_id_msag ).

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      deserialize_texts( io_xml ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_arbgb TYPE t100a-arbgb.

    SELECT SINGLE arbgb FROM t100a INTO lv_arbgb
      WHERE arbgb = ms_item-obj_name.                   "#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_argument TYPE seqg3-garg.

    lv_argument   = |{ ms_item-obj_name }|.
    OVERLAY lv_argument WITH '                     '.
    lv_argument = lv_argument && '*'.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = |ES_MSGSI|
                                            iv_argument    = lv_argument ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by zcl_abapinst_objects=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_msg_id TYPE rglif-message_id,
          ls_inf    TYPE t100a,
          lt_source TYPE ty_t100s.

    lv_msg_id = ms_item-obj_name.

    SELECT SINGLE * FROM t100a INTO ls_inf
      WHERE arbgb = lv_msg_id.                          "#EC CI_GENBUFF
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    CLEAR ls_inf-respuser.

    SELECT * FROM t100 INTO TABLE lt_source
      WHERE sprsl = mv_language
      AND arbgb = lv_msg_id
      ORDER BY PRIMARY KEY.               "#EC CI_SUBRC "#EC CI_GENBUFF

    CLEAR: ls_inf-lastuser,
           ls_inf-ldate,
           ls_inf-ltime.

    io_xml->add( iv_name = 'T100A'
                 ig_data = ls_inf ).
    io_xml->add( ig_data = lt_source
                 iv_name = 'T100' ).

    serialize_longtexts_msag( it_t100 = lt_source
                              ii_xml  = io_xml ).

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      serialize_texts( io_xml ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_nspc IMPLEMENTATION.

  METHOD add_to_transport.

    DATA: li_sap_package TYPE REF TO zif_abapgit_sap_package.

    li_sap_package = zcl_abapinst_factory=>get_sap_package( iv_package ).

    IF li_sap_package->are_changes_recorded_in_tr_req( ) = abap_true.
      corr_insert( iv_package ).
    ENDIF.

  ENDMETHOD.

  METHOD constructor.

    super->constructor(
      is_item        = is_item
      iv_language    = iv_language
      io_files       = io_files
      io_i18n_params = io_i18n_params ).

    mv_component = replace( val  = is_item-obj_name
                            sub  = '/'
                            with = ''
                            occ  = 0 ).

  ENDMETHOD.

  METHOD deserialize_sw_component.

    DATA:
      ls_cvers_old TYPE cvers,
      ls_cvers_new TYPE cvers,
      ls_cvers_ref TYPE cvers_ref.

    ii_xml->read( EXPORTING iv_name = 'CVERS'
                  CHANGING  cg_data = ls_cvers_new ).

    ii_xml->read( EXPORTING iv_name = 'CVERS_REF'
                  CHANGING  cg_data = ls_cvers_ref ).

    IF ls_cvers_new IS NOT INITIAL.
      SELECT SINGLE * FROM cvers INTO ls_cvers_old WHERE component = mv_component.
      IF sy-subrc = 0.
        IF ls_cvers_old <> ls_cvers_new.
          zcx_abapgit_exception=>raise( `Update of software component not supported.`
            && ` Use Software Update Manager (SUM)` ).
        ENDIF.
      ELSE.
        INSERT cvers FROM ls_cvers_new.
      ENDIF.
    ENDIF.

    IF ls_cvers_ref IS NOT INITIAL.
      MODIFY cvers_ref FROM ls_cvers_ref.
      IF sy-subrc <> 0.
        INSERT cvers_ref FROM ls_cvers_ref.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD deserialize_texts.

    DATA:
      ls_trnspacett TYPE trnspacett,
      lt_i18n_langs TYPE TABLE OF langu,
      lt_cvers_refs TYPE TABLE OF cvers_ref,
      ls_cvers_ref  TYPE cvers_ref,
      lt_nspc_texts TYPE ty_nspc_texts.

    FIELD-SYMBOLS:
      <lv_lang>      LIKE LINE OF lt_i18n_langs,
      <ls_nspc_text> LIKE LINE OF lt_nspc_texts.

    ii_xml->read( EXPORTING iv_name = 'I18N_LANGS'
                  CHANGING  cg_data = lt_i18n_langs ).

    ii_xml->read( EXPORTING iv_name = 'NSPC_TEXTS'
                  CHANGING  cg_data = lt_nspc_texts ).

    ii_xml->read( EXPORTING iv_name = 'CVERS_REFS'
                  CHANGING  cg_data = lt_cvers_refs ).

    SORT lt_i18n_langs.
    SORT lt_nspc_texts BY spras. " Optimization
    SORT lt_cvers_refs BY langu. " Optimization

    LOOP AT lt_i18n_langs ASSIGNING <lv_lang>.
      ls_trnspacett-namespace = iv_namespace.
      READ TABLE lt_nspc_texts ASSIGNING <ls_nspc_text> WITH KEY spras = <lv_lang>.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( |Cannot find language { <lv_lang> } in XML| ).
      ENDIF.
      MOVE-CORRESPONDING <ls_nspc_text> TO ls_trnspacett.

      MODIFY trnspacett FROM ls_trnspacett.
      IF sy-subrc <> 0.
        INSERT trnspacett FROM ls_trnspacett.
      ENDIF.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( |Error upserting text for namespace| ).
      ENDIF.

      READ TABLE lt_cvers_refs INTO ls_cvers_ref WITH KEY langu = <lv_lang>.
      IF sy-subrc = 0.
        MODIFY cvers_ref FROM ls_cvers_ref.
        IF sy-subrc <> 0.
          INSERT cvers_ref FROM ls_cvers_ref.
        ENDIF.
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise( |Error upserting text for software component| ).
        ENDIF.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_sw_component.

    DATA:
      ls_cvers     TYPE cvers,
      ls_cvers_ref TYPE cvers_ref.

    SELECT SINGLE * FROM cvers INTO ls_cvers WHERE component = mv_component.
    IF sy-subrc = 0.
      ii_xml->add( iv_name = 'CVERS'
                   ig_data = ls_cvers ).
    ENDIF.

    SELECT SINGLE * FROM cvers_ref INTO ls_cvers_ref WHERE component = mv_component AND langu = mv_language.
    IF sy-subrc = 0.
      ii_xml->add( iv_name = 'CVERS_REF'
                   ig_data = ls_cvers_ref ).
    ENDIF.

  ENDMETHOD.

  METHOD serialize_texts.

    DATA:
      ls_trnspacett TYPE trnspacett,
      lt_nspc_texts TYPE ty_nspc_texts,
      lt_cvers_refs TYPE TABLE OF cvers_ref,
      lt_i18n_langs TYPE TABLE OF langu.

    FIELD-SYMBOLS:
      <lv_lang>      LIKE LINE OF lt_i18n_langs,
      <ls_nspc_text> LIKE LINE OF lt_nspc_texts.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN.
    ENDIF.

    " Collect additional languages, skip main lang - it was serialized already
    SELECT DISTINCT spras AS langu FROM trnspacett INTO TABLE lt_i18n_langs
      WHERE namespace = ms_item-obj_name AND spras <> mv_language
      ORDER BY langu.                                     "#EC CI_SUBRC

    LOOP AT lt_i18n_langs ASSIGNING <lv_lang>.
      SELECT SINGLE * FROM trnspacett INTO ls_trnspacett
        WHERE namespace = ms_item-obj_name AND spras = <lv_lang>.
      IF sy-subrc = 0.
        APPEND INITIAL LINE TO lt_nspc_texts ASSIGNING <ls_nspc_text>.
        MOVE-CORRESPONDING ls_trnspacett TO <ls_nspc_text>.
      ENDIF.

      SELECT * FROM cvers_ref APPENDING TABLE lt_cvers_refs
        WHERE component = mv_component AND langu = <lv_lang>
        ORDER BY PRIMARY KEY.
    ENDLOOP.

    SORT lt_i18n_langs ASCENDING.
    SORT lt_nspc_texts BY spras ASCENDING.
    SORT lt_cvers_refs.

    IF lines( lt_i18n_langs ) > 0.
      ii_xml->add( iv_name = 'I18N_LANGS'
                   ig_data = lt_i18n_langs ).

      ii_xml->add( iv_name = 'NSPC_TEXTS'
                   ig_data = lt_nspc_texts ).

      ii_xml->add( iv_name = 'CVERS_REFS'
                   ig_data = lt_cvers_refs ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    SELECT SINGLE changeuser FROM trnspacet INTO rv_user
       WHERE namespace = ms_item-obj_name.
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_object~delete.
    RETURN. " not supported
  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA:
      ls_nspc       TYPE ty_nspc,
      ls_nspc_text  TYPE ty_nspc_text,
      lv_modifiable TYPE abap_bool,
      ls_trnspacet  TYPE trnspacet,
      ls_trnspacett TYPE trnspacett.

    io_xml->read( EXPORTING iv_name = 'NSPC'
                  CHANGING  cg_data = ls_nspc ).

    io_xml->read( EXPORTING iv_name = 'NSPC_TEXT'
                  CHANGING  cg_data = ls_nspc_text ).

    add_to_transport( iv_package ).

    SELECT SINGLE * FROM trnspacet INTO ls_trnspacet WHERE namespace = ls_nspc-namespace.
    IF sy-subrc = 0.
      " For existing namespace, check if it's modifiable (SE03)
      SELECT SINGLE editflag FROM trnspace INTO lv_modifiable WHERE namespace = ls_nspc-namespace.
      IF sy-subrc = 0 AND lv_modifiable = abap_false.
        zcx_abapgit_exception=>raise( |Namespace is not modifiable| ).
      ENDIF.

      " keep existing role
      ls_trnspacet-replicense = ls_nspc-replicense.
      ls_trnspacet-sscrflag   = ls_nspc-sscrflag.
      ls_trnspacet-sapflag    = ls_nspc-sapflag.
      ls_trnspacet-gen_only   = ls_nspc-gen_only.
      ls_trnspacet-changeuser = sy-uname.
      ls_trnspacet-changedate = sy-datum.
      MODIFY trnspacet FROM ls_trnspacet.
    ELSE.
      MOVE-CORRESPONDING ls_nspc TO ls_trnspacet.
      ls_trnspacet-role       = 'C'. " customer repair license
      ls_trnspacet-changeuser = sy-uname.
      ls_trnspacet-changedate = sy-datum.
      INSERT trnspacet FROM ls_trnspacet.
    ENDIF.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Error upserting namespace| ).
    ENDIF.

    SELECT SINGLE * FROM trnspacett INTO ls_trnspacett
      WHERE namespace = ls_nspc-namespace AND spras = mv_language.
    IF sy-subrc = 0.
      ls_trnspacett-descriptn = ls_nspc_text-descriptn.
      ls_trnspacett-owner     = ls_nspc_text-owner.
      MODIFY trnspacett FROM ls_trnspacett.
    ELSE.
      MOVE-CORRESPONDING ls_nspc_text TO ls_trnspacett.
      ls_trnspacett-namespace = ls_nspc-namespace.
      INSERT trnspacett FROM ls_trnspacett.
    ENDIF.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Error upserting text for namespace| ).
    ENDIF.

    deserialize_texts( ii_xml       = io_xml
                       iv_namespace = ls_nspc-namespace ).

    deserialize_sw_component( io_xml ).

    " Fill trnspace and trnspacel tables
    CALL FUNCTION 'TR_ACTIVATE_NAMESPACE'
      EXPORTING
        iv_namespace         = ls_nspc-namespace
      EXCEPTIONS
        deletion_not_allowed = 1
        OTHERS               = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Error activating namespace| ).
    ENDIF.

    " Make namespace modifiable
    UPDATE trnspace SET editflag = abap_true WHERE namespace = ls_nspc-namespace.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA lv_namespace TYPE trnspace-namespace.

    lv_namespace = ms_item-obj_name.

    CALL FUNCTION 'TR_CHECK_NAMESPACE'
      EXPORTING
        iv_namespace        = lv_namespace
      EXCEPTIONS
        namespace_not_valid = 1
        OTHERS              = 2.

    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = zif_abapgit_object~exists( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Launch general maintenance for namespaces
    CALL FUNCTION 'VIEW_MAINTENANCE_CALL'
      EXPORTING
        action                       = 'S'
        view_name                    = 'V_TRNSPACE'
        no_warning_for_clientindep   = 'X'
        variant_for_selection        = 'STANDARD'
      EXCEPTIONS
        client_reference             = 1
        foreign_lock                 = 2
        invalid_action               = 3
        no_clientindependent_auth    = 4
        no_database_function         = 5
        no_editor_function           = 6
        no_show_auth                 = 7
        no_tvdir_entry               = 8
        no_upd_auth                  = 9
        only_show_allowed            = 10
        system_failure               = 11
        unknown_field_in_dba_sellist = 12
        view_not_found               = 13
        OTHERS                       = 14.

    rv_exit = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA:
      ls_nspc      TYPE ty_nspc,
      ls_nspc_text TYPE ty_nspc_text.

    SELECT SINGLE * FROM trnspacet INTO CORRESPONDING FIELDS OF ls_nspc
      WHERE namespace = ms_item-obj_name.

    SELECT SINGLE * FROM trnspacett INTO CORRESPONDING FIELDS OF ls_nspc_text
      WHERE namespace = ms_item-obj_name AND spras = mv_language.

    io_xml->add( iv_name = 'NSPC'
                 ig_data = ls_nspc ).

    io_xml->add( iv_name = 'NSPC_TEXT'
                 ig_data = ls_nspc_text ).

    serialize_texts( io_xml ).

    serialize_sw_component( io_xml ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_para IMPLEMENTATION.

  METHOD unlock.

    CALL FUNCTION 'RS_ACCESS_PERMISSION'
      EXPORTING
        mode         = 'FREE'
        object       = iv_paramid
        object_class = 'PARA'.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
* looks like "changed by user" is not stored in the database
    rv_user = c_user_unknown.
  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    " We can't use FM RS_PARAMETER_DELETE because of the popup to confirm
    "Therefore we have to reimplement most of the FMs logic

    DATA lv_paramid TYPE tpara-paramid.

    lv_paramid = ms_item-obj_name.

    CALL FUNCTION 'RS_ACCESS_PERMISSION'
      EXPORTING
        global_lock              = abap_true
        language_upd_exit        = 'RS_PARAMETER_LANGUAGE_EXIT'    " Name FuBa for maintenance language change
        object                   = lv_paramid
        object_class             = ms_item-obj_type
        suppress_language_check  = space
      EXCEPTIONS
        canceled_in_corr         = 1
        enqueued_by_user         = 2
        enqueue_system_failure   = 3
        illegal_parameter_values = 4
        locked_by_author         = 5
        no_modify_permission     = 6
        no_show_permission       = 7
        permission_failure       = 8
        request_language_denied  = 9
        OTHERS                   = 10.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    SELECT COUNT(*) FROM cross
      WHERE ( type = 'P' OR type = 'Q' ) AND name = lv_paramid.
    IF sy-subrc = 0.
      unlock( lv_paramid ).
      zcx_abapgit_exception=>raise( 'PARA: Parameter is still used' ).
    ELSE.
      SELECT COUNT(*) FROM dd04l BYPASSING BUFFER
        WHERE memoryid = lv_paramid
        AND as4local = 'A'.
      IF sy-subrc = 0.
        unlock( lv_paramid ).
        zcx_abapgit_exception=>raise( 'PARA: Parameter is still used' ).
      ENDIF.
    ENDIF.

    unlock( lv_paramid ).

    zcl_abapinst_factory=>get_cts_api( )->insert_transport_object(
      iv_object   = 'PARA'
      iv_obj_name = lv_paramid
      iv_package  = iv_package
      iv_language = mv_language
      iv_mode     = zif_abapgit_cts_api=>c_transport_mode-delete ).

    DELETE FROM tpara WHERE paramid = lv_paramid.
    DELETE FROM tparat WHERE paramid = lv_paramid.

    CALL FUNCTION 'RS_TREE_OBJECT_PLACEMENT'
      EXPORTING
        object    = lv_paramid
        operation = 'DELETE'
        type      = 'CR'.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.
* see fm RS_PARAMETER_ADD and RS_PARAMETER_EDIT

    DATA: lv_mode   TYPE c LENGTH 1,
          ls_tpara  TYPE tpara,
          ls_tparat TYPE tparat.

    SELECT SINGLE * FROM tpara INTO ls_tpara
      WHERE paramid = ms_item-obj_name.                 "#EC CI_GENBUFF
    IF sy-subrc = 0.
      lv_mode = 'M'.
    ELSE.
      lv_mode = 'I'.
    ENDIF.

    io_xml->read( EXPORTING iv_name = 'TPARA'
                  CHANGING cg_data = ls_tpara ).

    CALL FUNCTION 'RS_CORR_INSERT'
      EXPORTING
        object              = ms_item-obj_name
        object_class        = 'PARA'
        mode                = lv_mode
        global_lock         = abap_true
        devclass            = iv_package
        master_language     = mv_language
        suppress_dialog     = abap_true
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    MODIFY tpara FROM ls_tpara.                           "#EC CI_SUBRC
    ASSERT sy-subrc = 0.

    io_xml->read(
      EXPORTING iv_name = 'TPARAT'
      CHANGING  cg_data = ls_tparat ).

    MODIFY tparat FROM ls_tparat.                         "#EC CI_SUBRC
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_paramid TYPE tpara-paramid.

    SELECT SINGLE paramid FROM tpara INTO lv_paramid
      WHERE paramid = ms_item-obj_name.                 "#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-ddic TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = 'EEUDB'
                                            iv_argument    = ms_item-obj_name
                                            iv_prefix      = 'PA' ).
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by zcl_abapinst_objects=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_tpara  TYPE tpara,
          ls_tparat TYPE tparat.

    SELECT SINGLE * FROM tpara INTO ls_tpara
      WHERE paramid = ms_item-obj_name.                 "#EC CI_GENBUFF
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM tparat INTO ls_tparat
      WHERE paramid = ms_item-obj_name
      AND sprache = mv_language.          "#EC CI_GENBUFF "#EC CI_SUBRC

    io_xml->add( iv_name = 'TPARA'
                 ig_data = ls_tpara ).

    io_xml->add(
      iv_name = 'TPARAT'
      ig_data = ls_tparat ).
    " Here only the original language is serialized,
    " so it should be present for the moment. LXEs are just translations

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_prog IMPLEMENTATION.

  METHOD deserialize_texts.

    DATA: lt_tpool_i18n TYPE ty_tpools_i18n,
          lt_tpool      TYPE textpool_table.

    FIELD-SYMBOLS <ls_tpool> LIKE LINE OF lt_tpool_i18n.

    ii_xml->read( EXPORTING iv_name = 'I18N_TPOOL'
                  CHANGING  cg_data = lt_tpool_i18n ).

    LOOP AT lt_tpool_i18n ASSIGNING <ls_tpool>.
      lt_tpool = read_tpool( <ls_tpool>-textpool ).
      deserialize_textpool( iv_program  = ms_item-obj_name
                            iv_language = <ls_tpool>-language
                            it_tpool    = lt_tpool ).
    ENDLOOP.

  ENDMETHOD.

  METHOD deserialize_with_ext.

    " Special treatment for extensions
    " If the program name exceeds 30 characters it is not a usual ABAP program but might be
    " some extension, which requires the internal addition EXTENSION TYPE
    " https://help.sap.com/doc/abapdocu_755_index_htm/7.55/en-US/index.htm?file=abapinsert_report_internal.htm
    " This e.g. occurs in case of transportable Code Inspector variants (ending with ===VC)

    zcl_abapinst_factory=>get_sap_report( )->insert_report(
      iv_name           = is_progdir-name
      iv_package        = iv_package
      it_source         = it_source
      iv_state          = 'I'
      iv_version        = is_progdir-uccheck
      iv_program_type   = is_progdir-subc
      iv_extension_type = is_progdir-name+30 ).

    zcl_abapinst_factory=>get_sap_report( )->update_progdir(
      is_progdir = is_progdir
      iv_state   = 'I'
      iv_package = iv_package ).

    zcl_abapgit_objects_activation=>add(
      iv_type = 'REPS'
      iv_name = is_progdir-name ).

  ENDMETHOD.

  METHOD is_program_locked.

    rv_is_program_locked = exists_a_lock_entry_for( iv_lock_object = 'ESRDIRE'
                                                    iv_argument    = |{ ms_item-obj_name }| ).

  ENDMETHOD.

  METHOD serialize_texts.

    DATA: lt_tpool_i18n      TYPE ty_tpools_i18n,
          lt_tpool           TYPE textpool_table,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    FIELD-SYMBOLS <ls_tpool> LIKE LINE OF lt_tpool_i18n.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN.
    ENDIF.

    " Table d010tinf stores info. on languages in which program is maintained
    " Select all active translations of program texts
    " Skip main language - it was already serialized
    lt_language_filter = mo_i18n_params->build_language_filter( ).

    SELECT DISTINCT language
      INTO CORRESPONDING FIELDS OF TABLE lt_tpool_i18n
      FROM d010tinf
      WHERE r3state = 'A'
      AND prog = ms_item-obj_name
      AND language <> mv_language
      AND language IN lt_language_filter
      ORDER BY language ##TOO_MANY_ITAB_FIELDS.

    SORT lt_tpool_i18n BY language ASCENDING.
    LOOP AT lt_tpool_i18n ASSIGNING <ls_tpool>.
      READ TEXTPOOL ms_item-obj_name
        LANGUAGE <ls_tpool>-language
        INTO lt_tpool.
      <ls_tpool>-textpool = add_tpool( lt_tpool ).
    ENDLOOP.

    IF lines( lt_tpool_i18n ) > 0.
      ii_xml->add( iv_name = 'I18N_TPOOL'
                   ig_data = lt_tpool_i18n ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    SELECT SINGLE unam FROM reposrc INTO rv_user
      WHERE progname = ms_item-obj_name
      AND r3state = 'A'.
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA:
      lv_program  LIKE sy-repid,
      lv_obj_name TYPE e071-obj_name.

    lv_program = ms_item-obj_name.

    CALL FUNCTION 'RS_DELETE_PROGRAM'
      EXPORTING
        corrnumber                 = iv_transport
        program                    = lv_program
        suppress_popup             = abap_true
        mass_delete_call           = abap_true
        tadir_devclass             = iv_package
        force_delete_used_includes = abap_true
      EXCEPTIONS
        enqueue_lock               = 1
        object_not_found           = 2
        permission_failure         = 3
        reject_deletion            = 4
        OTHERS                     = 5.
    IF sy-subrc = 2.
      " Drop also any inactive code that is left in REPOSRC
      zcl_abapinst_factory=>get_sap_report( )->delete_report( lv_program ).

      " Remove inactive objects from work area
      lv_obj_name = lv_program.

      CALL FUNCTION 'RS_DELETE_FROM_WORKING_AREA'
        EXPORTING
          object                 = 'REPS'
          obj_name               = lv_obj_name
          immediate              = 'X'
          actualize_working_area = 'X'.

      CALL FUNCTION 'RS_DELETE_FROM_WORKING_AREA'
        EXPORTING
          object                 = 'REPT'
          obj_name               = lv_obj_name
          immediate              = 'X'
          actualize_working_area = 'X'.
    ELSEIF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    delete_longtexts( c_longtext_id_prog ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_program_name TYPE syrepid,
          ls_progdir      TYPE zif_abapgit_sap_report=>ty_progdir,
          lt_tpool        TYPE textpool_table,
          lt_dynpros      TYPE ty_dynpro_tt,
          lt_tpool_ext    TYPE zif_abapgit_definitions=>ty_tpool_tt,
          ls_cua          TYPE ty_cua,
          lt_source       TYPE abaptxt255_tab.

    " Add R3TR PROG to transport first, otherwise we get several LIMUs
    corr_insert( iv_package ).

    lv_program_name = ms_item-obj_name.

    lt_source = mo_files->read_abap( ).

    io_xml->read( EXPORTING iv_name = 'TPOOL'
                  CHANGING cg_data = lt_tpool_ext ).
    lt_tpool = read_tpool( lt_tpool_ext ).

    io_xml->read( EXPORTING iv_name = 'PROGDIR'
                  CHANGING cg_data  = ls_progdir ).

    set_abap_language_version( CHANGING cv_abap_language_version = ls_progdir-uccheck ).

    IF strlen( lv_program_name ) > 30.

      " Objects with extension for example transportable Code Inspector variants (ending with ===VC)
      deserialize_with_ext( is_progdir = ls_progdir
                            iv_package = iv_package
                            it_source  = lt_source ).

    ELSE.

      deserialize_program( is_progdir = ls_progdir
                           it_source  = lt_source
                           it_tpool   = lt_tpool
                           iv_package = iv_package ).

      io_xml->read( EXPORTING iv_name = 'DYNPROS'
                    CHANGING cg_data  = lt_dynpros ).
      deserialize_dynpros( lt_dynpros ).

      io_xml->read( EXPORTING iv_name = 'CUA'
                    CHANGING cg_data  = ls_cua ).
      deserialize_cua( iv_program_name = lv_program_name
                       is_cua = ls_cua ).

      " Texts deserializing (English)
      deserialize_textpool( iv_program = lv_program_name
                            it_tpool   = lt_tpool ).

      " Texts deserializing (translations)
      IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
        deserialize_texts( io_xml ).
      ENDIF.

      deserialize_longtexts( ii_xml         = io_xml
                             iv_longtext_id = c_longtext_id_prog ).

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_progname TYPE reposrc-progname.

    SELECT SINGLE progname FROM reposrc INTO lv_progname
      WHERE progname = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

    " Skip PROG generated by CHDO
    IF rv_bool = abap_true.
      FIND REGEX '^F.*CD[C|F|T|V]' IN ms_item-obj_name.
      IF sy-subrc <> 0.
        FIND REGEX '^/.*/F.*CD[C|F|T|V]' IN ms_item-obj_name.
      ENDIF.
      rv_bool = boolc( sy-subrc <> 0 ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    IF is_program_locked( ) = abap_true
        OR is_any_dynpro_locked( ms_item-obj_name ) = abap_true
        OR is_cua_locked( ms_item-obj_name ) = abap_true
        OR is_text_locked( ms_item-obj_name ) = abap_true.

      rv_is_locked = abap_true.

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by zcl_abapinst_objects=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

* see SAP note 1025291, run report DELETE_TADIR_FOR_EIMP_INCLUDE to clean bad TADIR entries
    ASSERT NOT ms_item-obj_name CP '*=E'.

    serialize_program( io_xml   = io_xml
                       is_item  = ms_item
                       io_files = mo_files ).

    " Texts serializing (translations)
    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      serialize_texts( io_xml ).
    ENDIF.

    serialize_longtexts( ii_xml         = io_xml
                         iv_longtext_id = c_longtext_id_prog ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_shlp IMPLEMENTATION.

  METHOD adjust_exit.

    CONSTANTS lc_standard_exit TYPE dd30v-selmexit VALUE 'RS_DD_SELMEXIT'.

    IF cv_exit IS NOT INITIAL
    AND zcl_abapinst_factory=>get_function_module( )->function_exists( cv_exit ) = abap_false.
      " If exit function does not exist, replace it with standard SAP function
      " which exists in 7.02 and higher
      cv_exit = lc_standard_exit.
    ENDIF.

  ENDMETHOD.

  METHOD check_exit.

    DATA lv_exit TYPE dd30v-selmexit.

    rv_done = abap_true.

    IF iv_exit IS NOT INITIAL.
      " Check if exit function is set correctly
      SELECT SINGLE selmexit FROM dd30v INTO lv_exit WHERE shlpname = ms_item-obj_name.
      IF sy-subrc = 0 AND lv_exit <> iv_exit.
        rv_done = abap_false.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD handle_dependencies.

    " For search helps with dependency on exit function, we use two phases:
    " 1) DDIC phase:
    "    - If function does not exit, replace it with a standard SAP function
    " 2) LATE phase
    "    - If function was replaced, change it to the correct exit function
    CASE iv_step.
      WHEN zif_abapgit_object=>gc_step_id-ddic.
        adjust_exit( CHANGING cv_exit = cv_exit ).

      WHEN zif_abapgit_object=>gc_step_id-late.
        cv_done = check_exit( cv_exit ).

      WHEN OTHERS.
        ASSERT 0 = 1.
    ENDCASE.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE as4user FROM dd30l INTO rv_user
      WHERE shlpname = ms_item-obj_name
      AND as4local = 'A'.                               "#EC CI_GENBUFF
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    delete_ddic( 'H' ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_name  TYPE ddobjname,
          lv_done  TYPE abap_bool,
          ls_dd30v TYPE dd30v,
          lt_dd31v TYPE TABLE OF dd31v,
          lt_dd32p TYPE TABLE OF dd32p,
          lt_dd33v TYPE TABLE OF dd33v.

    io_xml->read( EXPORTING iv_name = 'DD30V'
                  CHANGING cg_data = ls_dd30v ).

    handle_dependencies(
      EXPORTING
        iv_step = iv_step
      CHANGING
        cv_exit = ls_dd30v-selmexit
        cv_done = lv_done ).

    IF lv_done = abap_true.
      RETURN.
    ENDIF.

    io_xml->read( EXPORTING iv_name = 'DD31V_TABLE'
                  CHANGING cg_data = lt_dd31v ).
    io_xml->read( EXPORTING iv_name = 'DD32P_TABLE'
                  CHANGING cg_data = lt_dd32p ).
    io_xml->read( EXPORTING iv_name = 'DD33V_TABLE'
                  CHANGING cg_data = lt_dd33v ).

    corr_insert( iv_package = iv_package
                 ig_object_class = 'DICT' ).

    lv_name = ms_item-obj_name.

    CALL FUNCTION 'DDIF_SHLP_PUT'
      EXPORTING
        name              = lv_name
        dd30v_wa          = ls_dd30v
      TABLES
        dd31v_tab         = lt_dd31v
        dd32p_tab         = lt_dd32p
        dd33v_tab         = lt_dd33v
      EXCEPTIONS
        shlp_not_found    = 1
        name_inconsistent = 2
        shlp_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    zcl_abapgit_objects_activation=>add_item( ms_item ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_shlpname TYPE dd30l-shlpname.

    SELECT SINGLE shlpname FROM dd30l INTO lv_shlpname
      WHERE shlpname = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-ddic TO rt_steps.
    APPEND zif_abapgit_object=>gc_step_id-late TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by ZCL_ABAPGIT_OBJECT=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_name  TYPE ddobjname,
          lv_state TYPE ddgotstate,
          ls_dd30v TYPE dd30v,
          lt_dd31v TYPE TABLE OF dd31v,
          lt_dd32p TYPE TABLE OF dd32p,
          lt_dd33v TYPE TABLE OF dd33v.

    FIELD-SYMBOLS: <ls_dd32p> LIKE LINE OF lt_dd32p.

    lv_name = ms_item-obj_name.

    CALL FUNCTION 'DDIF_SHLP_GET'
      EXPORTING
        name          = lv_name
        state         = 'A'
        langu         = mv_language
      IMPORTING
        gotstate      = lv_state
        dd30v_wa      = ls_dd30v
      TABLES
        dd31v_tab     = lt_dd31v
        dd32p_tab     = lt_dd32p
        dd33v_tab     = lt_dd33v
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    IF ls_dd30v IS INITIAL OR lv_state <> 'A'.
      RETURN.
    ENDIF.

    CLEAR: ls_dd30v-as4user,
           ls_dd30v-as4date,
           ls_dd30v-as4time.

    LOOP AT lt_dd32p ASSIGNING <ls_dd32p>.
* clear information inherited from domain
      CLEAR: <ls_dd32p>-domname,
        <ls_dd32p>-headlen,
        <ls_dd32p>-scrlen1,
        <ls_dd32p>-scrlen2,
        <ls_dd32p>-datatype,
        <ls_dd32p>-leng,
        <ls_dd32p>-outputlen,
        <ls_dd32p>-decimals,
        <ls_dd32p>-lowercase,
        <ls_dd32p>-signflag,
        <ls_dd32p>-convexit.
    ENDLOOP.

    io_xml->add( iv_name = 'DD30V'
                 ig_data = ls_dd30v ).
    io_xml->add( ig_data = lt_dd31v
                 iv_name = 'DD31V_TABLE' ).
    io_xml->add( ig_data = lt_dd32p
                 iv_name = 'DD32P_TABLE' ).
    io_xml->add( ig_data = lt_dd33v
                 iv_name = 'DD33V_TABLE' ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_sots IMPLEMENTATION.

  METHOD create_sots.

    " Reimplementation of SOTR_STRING_CREATE_CONCEPT because we can't supply
    " concept and it would then be generated.

    DATA: lv_subrc                 TYPE sy-subrc,
          lv_source_langu          TYPE spras,
          ls_header                TYPE btfr_head,
          lv_flag_is_string        TYPE btfr_flag VALUE abap_true,
          lt_text_tab              TYPE sotr_text_tt,
          lv_concept_default       TYPE sotr_conc,
          lt_entries               TYPE sotr_textl_tt,
          lv_concept               LIKE is_sots-header-concept,
          lv_flag_correction_entry TYPE abap_bool VALUE abap_true.

    lt_entries = is_sots-entries.

    ls_header-paket          = iv_package.
    ls_header-crea_lan       = mv_language.
    ls_header-alias_name     = is_sots-header-alias_name.
    lv_source_langu          = mv_language.
    lv_concept               = is_sots-header-concept.

    PERFORM btfr_create
      IN PROGRAM saplsotr_db_string
      USING iv_object
            lv_source_langu
            lv_flag_correction_entry
            lv_flag_is_string
      CHANGING lt_text_tab
               lt_entries
               ls_header
               lv_concept
               lv_concept_default
               lv_subrc.

    CASE lv_subrc.
      WHEN 1.
        zcx_abapgit_exception=>raise( |No entry found| ).
      WHEN 2.
        zcx_abapgit_exception=>raise( |OTR concept not found| ).
      WHEN 3.
        zcx_abapgit_exception=>raise( |Enter a permitted object type| ).
      WHEN 4.
        "The concept will be created in the non-original system (not an error)
        RETURN.
      WHEN 5.
        zcx_abapgit_exception=>raise( |Invalid alias| ).
      WHEN 6.
        zcx_abapgit_exception=>raise( |No correction entry has been created| ).
      WHEN 7.
        zcx_abapgit_exception=>raise( |Error in database operation| ).
      WHEN 9.
        zcx_abapgit_exception=>raise( |Action canceled by user| ).
    ENDCASE.

  ENDMETHOD.

  METHOD get_raw_text_filename.

    DATA lv_langu TYPE string.

    " Lower case language codes can cause duplicate filenames therefore add suffix to make them unique
    " Note: Using ISO code would be better but is not compatible with existing files
    lv_langu = is_entry-langu.
    IF lv_langu = to_lower( lv_langu ).
      lv_langu = lv_langu && '-'.
    ENDIF.

    rv_filename =
        to_lower( |{ is_entry-concept }_|
               && |{ lv_langu         }_|
               && |{ is_entry-object  }_|
               && |{ is_entry-lfd_num }| ).

  ENDMETHOD.

  METHOD read_sots.

    DATA: lt_sotr_head TYPE STANDARD TABLE OF sotr_headu,
          lt_objects   TYPE sotr_objects,
          lv_object    LIKE LINE OF lt_objects,
          ls_sots      LIKE LINE OF rt_sots.

    FIELD-SYMBOLS: <ls_sotr_head> TYPE sotr_head,
                   <ls_entry>     LIKE LINE OF ls_sots-entries.

    SELECT * FROM sotr_headu
             INTO TABLE lt_sotr_head
             WHERE paket = ms_item-obj_name
             ORDER BY PRIMARY KEY.

    LOOP AT lt_sotr_head ASSIGNING <ls_sotr_head>.

      CALL FUNCTION 'SOTR_OBJECT_GET_OBJECTS'
        EXPORTING
          object_vector    = <ls_sotr_head>-objid_vec
        IMPORTING
          objects          = lt_objects
        EXCEPTIONS
          object_not_found = 1
          OTHERS           = 2.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

      READ TABLE lt_objects INDEX 1 INTO lv_object.
      ASSERT sy-subrc = 0.

      " Handled by object serializer
      CHECK lv_object <> 'SICF' AND lv_object <> 'CPUB'.

      CLEAR: ls_sots.

      CALL FUNCTION 'SOTR_STRING_GET_CONCEPT'
        EXPORTING
          concept        = <ls_sotr_head>-concept
        IMPORTING
          header         = ls_sots-header
          entries        = ls_sots-entries
        EXCEPTIONS
          no_entry_found = 1
          OTHERS         = 2.

      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

      CLEAR:
        ls_sots-header-paket,
        ls_sots-header-crea_name,
        ls_sots-header-crea_tstut,
        ls_sots-header-chan_name,
        ls_sots-header-chan_tstut.

      LOOP AT ls_sots-entries ASSIGNING <ls_entry>.
        CLEAR: <ls_entry>-version,
               <ls_entry>-crea_name,
               <ls_entry>-crea_tstut,
               <ls_entry>-chan_name,
               <ls_entry>-chan_tstut.
      ENDLOOP.

      INSERT ls_sots INTO TABLE rt_sots.

    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    SELECT SINGLE chan_name FROM sotr_headu INTO rv_user
      WHERE paket = ms_item-obj_name.                   "#EC CI_NOORDER
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lt_sots TYPE ty_sots_tt.

    FIELD-SYMBOLS: <ls_sots> TYPE ty_sots.

    lt_sots = read_sots( ).

    LOOP AT lt_sots ASSIGNING <ls_sots>.
      " Remove any usage to ensure deletion, see function module BTFR_CHECK
      DELETE FROM sotr_useu WHERE concept = <ls_sots>-header-concept.

      CALL FUNCTION 'BTFR_DELETE_SINGLE_TEXT'
        EXPORTING
          concept             = <ls_sots>-header-concept
          flag_string         = abap_true
        EXCEPTIONS
          text_not_found      = 1
          invalid_package     = 2
          text_not_changeable = 3
          text_enqueued       = 4
          no_correction       = 5
          parameter_error     = 6
          OTHERS              = 7.

      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lt_sots    TYPE ty_sots_tt,
          lt_objects TYPE sotr_objects,
          lv_object  LIKE LINE OF lt_objects.

    FIELD-SYMBOLS: <ls_sots>  TYPE ty_sots,
                   <ls_entry> LIKE LINE OF <ls_sots>-entries.

    io_xml->read(
      EXPORTING
        iv_name = 'SOTS'
      CHANGING
        cg_data = lt_sots ).

    tadir_insert( iv_package ).

    LOOP AT lt_sots ASSIGNING <ls_sots>.

      CLEAR: lt_objects.

      CALL FUNCTION 'SOTR_OBJECT_GET_OBJECTS'
        EXPORTING
          object_vector    = <ls_sots>-header-objid_vec
        IMPORTING
          objects          = lt_objects
        EXCEPTIONS
          object_not_found = 1
          OTHERS           = 2.

      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( 'error from SOTR_OBJECT_GET_OBJECTS' ).
      ENDIF.

      READ TABLE lt_objects INDEX 1 INTO lv_object.
      ASSERT sy-subrc = 0.

      LOOP AT <ls_sots>-entries ASSIGNING <ls_entry>.

        TRY.
            <ls_entry>-text = mo_files->read_string(
              iv_extra = get_raw_text_filename( <ls_entry> )
              iv_ext   = 'txt' ).

          CATCH zcx_abapgit_exception.
            " Most probably file not found -> ignore
            CONTINUE.
        ENDTRY.

      ENDLOOP.

      create_sots(
          is_sots    = <ls_sots>
          iv_package = iv_package
          iv_object  = lv_object ).

    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_object_type TYPE trobjtype,
          lv_object_name TYPE trobj_name.

    lv_object_type = ms_item-obj_type.
    lv_object_name = ms_item-obj_name.

    CALL FUNCTION 'SOTR_WBO_OBJECTS_CHECK'
      EXPORTING
        pgmid          = 'R3TR'
        object         = lv_object_type
        obj_name       = lv_object_name
      IMPORTING
        object_exist   = rv_bool
      EXCEPTIONS
        unknown_object = 1
        OTHERS         = 2.

    IF sy-subrc <> 0.
      rv_bool = abap_false.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by zcl_abapinst_objects=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lt_sots TYPE ty_sots_tt.

    FIELD-SYMBOLS: <ls_sots>  TYPE ty_sots,
                   <ls_entry> TYPE sotr_textl.

    lt_sots = read_sots( ).

    LOOP AT lt_sots ASSIGNING <ls_sots>.

      LOOP AT <ls_sots>-entries ASSIGNING <ls_entry>.

        mo_files->add_string(
          iv_extra  = get_raw_text_filename( <ls_entry> )
          iv_ext    = 'txt'
          iv_string = <ls_entry>-text ).

        CLEAR: <ls_entry>-text.

      ENDLOOP.

    ENDLOOP.

    io_xml->add( iv_name = 'SOTS'
                 ig_data = lt_sots ).

  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_OBJECT_TABL_COMPAR IMPLEMENTATION.

  METHOD constructor.

    mi_local = ii_local.

  ENDMETHOD.

  METHOD get_where_used_recursive.

    DATA: lt_findstrings TYPE string_table,
          lt_founds      TYPE STANDARD TABLE OF rsfindlst,
          lt_scope       TYPE ty_seu_obj,
          lv_findstring  LIKE LINE OF lt_findstrings.

    FIELD-SYMBOLS: <ls_found> TYPE rsfindlst.

    IF iv_object_name IS INITIAL.
      RETURN.
    ENDIF.

    lt_scope = it_scope.

    lv_findstring = iv_object_name.
    INSERT lv_findstring INTO TABLE lt_findstrings.

    DO iv_depth TIMES.

      CLEAR: lt_founds.

      CALL FUNCTION 'RS_EU_CROSSREF'
        EXPORTING
          i_find_obj_cls           = iv_object_type
          no_dialog                = 'X'
        TABLES
          i_findstrings            = lt_findstrings
          o_founds                 = lt_founds
          i_scope_object_cls       = lt_scope
        EXCEPTIONS
          not_executed             = 1
          not_found                = 2
          illegal_object           = 3
          no_cross_for_this_object = 4
          batch                    = 5
          batchjob_error           = 6
          wrong_type               = 7
          object_not_exist         = 8
          OTHERS                   = 9.

      IF sy-subrc = 1 OR sy-subrc = 2 OR lines( lt_founds ) = 0.
        EXIT.
      ELSEIF sy-subrc > 2.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      INSERT LINES OF lt_founds INTO TABLE rt_founds_all.

      CLEAR: lt_findstrings.

      LOOP AT lt_founds ASSIGNING <ls_found>.

        lv_findstring = <ls_found>-object.
        INSERT lv_findstring INTO TABLE lt_findstrings.

      ENDLOOP.

    ENDDO.

  ENDMETHOD.

  METHOD is_structure_used_in_db_table.

    DATA: lt_scope  TYPE ty_seu_obj,
          lt_founds TYPE ty_founds.

    APPEND 'TABL' TO lt_scope.
    APPEND 'STRU' TO lt_scope.

    lt_founds = get_where_used_recursive( iv_object_name = iv_object_name
                                          iv_object_type = 'STRU'
                                          it_scope       = lt_scope
                                          iv_depth       = 5 ).

    DELETE lt_founds WHERE object_cls <> 'DT'.

    rv_is_structure_used_in_db_tab = boolc( lines( lt_founds ) > 0 ).

  ENDMETHOD.

  METHOD validate.

    DATA: lt_previous_table_fields TYPE TABLE OF dd03p,
          ls_previous_table_field  LIKE LINE OF lt_previous_table_fields,
          lt_current_table_fields  TYPE TABLE OF dd03p,
          ls_current_table_field   LIKE LINE OF lt_current_table_fields,
          ls_dd02v                 TYPE dd02v,
          ls_item                  TYPE zif_abapgit_definitions=>ty_item,
          lv_inconsistent          TYPE abap_bool.

    FIELD-SYMBOLS <lv_is_gtt> TYPE abap_bool.

    ii_remote_version->read(
      EXPORTING
        iv_name = 'DD02V'
      CHANGING
        cg_data = ls_dd02v ).

    " We only want to compare transparent tables, or structures used in transparent tables
    IF ls_dd02v-tabclass <> 'TRANSP' AND is_structure_used_in_db_table( ls_dd02v-tabname ) = abap_false.
      RETURN.
    ENDIF.

    " No comparison for global temporary tables
    ASSIGN COMPONENT 'IS_GTT' OF STRUCTURE ls_dd02v TO <lv_is_gtt>.
    IF sy-subrc = 0 AND <lv_is_gtt> = abap_true.
      RETURN.
    ENDIF.

    ii_remote_version->read(
      EXPORTING
        iv_name       = 'DD03P_TABLE'
      CHANGING
        cg_data       = lt_previous_table_fields ).

    ii_local_version->read(
      EXPORTING
        iv_name       = 'DD03P_TABLE'
      CHANGING
        cg_data       = lt_current_table_fields ).

    ls_item-obj_name = ls_dd02v-tabname.
    ls_item-obj_type = 'TABL'.

    LOOP AT lt_previous_table_fields INTO ls_previous_table_field.
      READ TABLE lt_current_table_fields WITH KEY fieldname = ls_previous_table_field-fieldname
        INTO ls_current_table_field.
      IF sy-subrc = 0.
        IF ls_current_table_field-rollname <> ls_previous_table_field-rollname.
          IF ls_current_table_field-rollname IS NOT INITIAL AND ls_previous_table_field-rollname IS NOT INITIAL.
            ii_log->add_info(
              iv_msg  = |Field { ls_previous_table_field-fieldname }: | &
                        |Data element changed from { ls_previous_table_field-rollname } | &
                        |to { ls_current_table_field-rollname }|
              is_item = ls_item ).
          ELSEIF ls_current_table_field-rollname IS NOT INITIAL.
            ii_log->add_info(
              iv_msg  = |Field { ls_previous_table_field-fieldname }: | &
                        |Data type changed from internal type | &
                        |{ ls_previous_table_field-inttype }(length { ls_previous_table_field-intlen }) | &
                        |to data element { ls_current_table_field-rollname }|
              is_item = ls_item ).
          ELSEIF ls_previous_table_field-rollname IS NOT INITIAL.
            ii_log->add_info(
              iv_msg  = |Field { ls_previous_table_field-fieldname }: | &
                        |Data type changed from date element { ls_previous_table_field-rollname } | &
                        |to internal type | &
                        |{ ls_current_table_field-inttype }(length { ls_current_table_field-intlen })|
              is_item = ls_item ).
          ENDIF.
          "TODO: perform several other checks, e.g. field length truncated, ...
          lv_inconsistent = abap_true.
        ENDIF.
      ELSE.
        ii_log->add_info( iv_msg = |Field { ls_previous_table_field-fieldname } removed|
                          is_item = ls_item ).
        lv_inconsistent = abap_true.
      ENDIF.
    ENDLOOP.
    IF lv_inconsistent = abap_true.
      rv_message = |Database Table { ls_dd02v-tabname }: Fields were changed. This may lead to inconsistencies!|.
    ENDIF.

    IF NOT rv_message IS INITIAL.
      rv_message = |Database Table { ls_dd02v-tabname }: { rv_message }|.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_comparator~compare.

    rs_result-text = validate(
      ii_remote_version = ii_remote
      ii_local_version  = mi_local
      ii_log            = ii_log ).

  ENDMETHOD.
ENDCLASS.

CLASS lcl_tabl_xml DEFINITION FINAL.
  PUBLIC SECTION.
    CLASS-METHODS add
      IMPORTING
        io_xml      TYPE REF TO zif_abapgit_xml_output
        is_internal TYPE zif_abapgit_object_tabl=>ty_internal
      RAISING
        zcx_abapgit_exception.

    CLASS-METHODS read
      IMPORTING
        io_xml             TYPE REF TO zif_abapgit_xml_input
      RETURNING
        VALUE(rs_internal) TYPE zif_abapgit_object_tabl=>ty_internal
      RAISING
        zcx_abapgit_exception.
ENDCLASS.

CLASS lcl_tabl_xml IMPLEMENTATION.
  METHOD add.

* adding to xml must be done in the right sequence to avoid changes
    io_xml->add( iv_name = 'DD02V'
                 ig_data = is_internal-dd02v ).
    IF NOT is_internal-dd09l IS INITIAL.
      io_xml->add( iv_name = 'DD09L'
                   ig_data = is_internal-dd09l ).
    ENDIF.
    io_xml->add( iv_name = 'DD03P_TABLE'
                 ig_data = is_internal-dd03p ).
    io_xml->add( iv_name = 'DD05M_TABLE'
                 ig_data = is_internal-dd05m ).
    io_xml->add( iv_name = 'DD08V_TABLE'
                 ig_data = is_internal-dd08v ).
    io_xml->add( iv_name = 'DD12V'
                 ig_data = is_internal-dd12v ).
    io_xml->add( iv_name = 'DD17V'
                 ig_data = is_internal-dd17v ).
    io_xml->add( iv_name = 'DD35V_TALE'
                 ig_data = is_internal-dd35v ).
    io_xml->add( iv_name = 'DD36M'
                 ig_data = is_internal-dd36m ).

    IF lines( is_internal-i18n_langs ) > 0.
      io_xml->add( iv_name = 'I18N_LANGS'
                   ig_data = is_internal-i18n_langs ).

      io_xml->add( iv_name = 'DD02_TEXTS'
                   ig_data = is_internal-dd02_texts ).
    ENDIF.

    io_xml->add( iv_name = 'LONGTEXTS'
                 ig_data = is_internal-longtexts ).

    io_xml->add( iv_name = zif_abapgit_object_tabl=>c_s_dataname-segment_definition
                 ig_data = is_internal-segment_definitions ).

    io_xml->add( iv_name = zif_abapgit_object_tabl=>c_s_dataname-tabl_extras
                 ig_data = is_internal-extras ).

  ENDMETHOD.

  METHOD read.

    io_xml->read(
      EXPORTING iv_name = zif_abapgit_object_tabl=>c_s_dataname-segment_definition
      CHANGING  cg_data = rs_internal-segment_definitions ).
    io_xml->read(
      EXPORTING iv_name = 'DD02V'
      CHANGING cg_data = rs_internal-dd02v ).
    io_xml->read(
      EXPORTING iv_name = 'DD09L'
      CHANGING cg_data = rs_internal-dd09l ).
    io_xml->read(
      EXPORTING iv_name  = 'DD03P_TABLE'
      CHANGING cg_data = rs_internal-dd03p ).
    io_xml->read(
      EXPORTING iv_name = 'DD05M_TABLE'
      CHANGING cg_data = rs_internal-dd05m ).
    io_xml->read(
      EXPORTING iv_name = 'DD08V_TABLE'
      CHANGING cg_data = rs_internal-dd08v ).
    io_xml->read(
      EXPORTING iv_name = 'DD35V_TALE'
      CHANGING cg_data = rs_internal-dd35v ).
    io_xml->read(
      EXPORTING iv_name = 'DD36M'
      CHANGING cg_data = rs_internal-dd36m ).
    io_xml->read(
      EXPORTING iv_name = zif_abapgit_object_tabl=>c_s_dataname-tabl_extras
      CHANGING cg_data = rs_internal-extras ).
    io_xml->read(
      EXPORTING iv_name = 'DD12V'
      CHANGING cg_data = rs_internal-dd12v ).
    io_xml->read(
      EXPORTING iv_name = 'DD17V'
      CHANGING cg_data = rs_internal-dd17v ).
    io_xml->read(
      EXPORTING iv_name = 'I18N_LANGS'
      CHANGING  cg_data = rs_internal-i18n_langs ).
    io_xml->read(
      EXPORTING iv_name = 'DD02_TEXTS'
      CHANGING  cg_data = rs_internal-dd02_texts ).
    io_xml->read(
      EXPORTING iv_name = 'LONGTEXTS'
      CHANGING  cg_data = rs_internal-longtexts ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_tabl IMPLEMENTATION.

  METHOD clear_dd03p_fields.

    CONSTANTS lc_comptype_dataelement TYPE comptype VALUE 'E'.

    DATA: lv_masklen TYPE c LENGTH 4.

    FIELD-SYMBOLS: <ls_dd03p> TYPE dd03p.

* remove nested structures
    DELETE ct_dd03p WHERE depth <> '00'.
* remove fields from .INCLUDEs
    DELETE ct_dd03p WHERE adminfield <> '0'.

    LOOP AT ct_dd03p ASSIGNING <ls_dd03p> WHERE NOT rollname IS INITIAL.

      clear_dd03p_fields_common( CHANGING cs_dd03p = <ls_dd03p> ).

      lv_masklen = <ls_dd03p>-masklen.
      IF lv_masklen = '' OR NOT lv_masklen CO '0123456789'.
* make sure the field contains valid data, or the XML will dump
        CLEAR <ls_dd03p>-masklen.
      ENDIF.

      IF <ls_dd03p>-comptype = lc_comptype_dataelement.
        clear_dd03p_fields_dataelement( CHANGING cs_dd03p = <ls_dd03p> ).
      ENDIF.

      IF <ls_dd03p>-shlporigin = 'D'.
* search help from domain
        CLEAR: <ls_dd03p>-shlpfield,
               <ls_dd03p>-shlpname.
      ENDIF.

* XML output assumes correct field content
      IF <ls_dd03p>-routputlen = '      '.
        CLEAR <ls_dd03p>-routputlen.
      ENDIF.

    ENDLOOP.

    " Clear position to avoid issues with include structures that contain different number of fields
    LOOP AT ct_dd03p ASSIGNING <ls_dd03p>.
      CLEAR: <ls_dd03p>-position, <ls_dd03p>-tabname, <ls_dd03p>-ddlanguage.
    ENDLOOP.

  ENDMETHOD.

  METHOD clear_dd03p_fields_common.

    CLEAR: cs_dd03p-ddlanguage,
           cs_dd03p-dtelmaster,
           cs_dd03p-logflag,
           cs_dd03p-ddtext,
           cs_dd03p-reservedte,
           cs_dd03p-reptext,
           cs_dd03p-scrtext_s,
           cs_dd03p-scrtext_m,
           cs_dd03p-scrtext_l.

  ENDMETHOD.

  METHOD clear_dd03p_fields_dataelement.

* type specified via data element
    CLEAR: cs_dd03p-domname,
           cs_dd03p-inttype,
           cs_dd03p-intlen,
           cs_dd03p-mask,
           cs_dd03p-memoryid,
           cs_dd03p-headlen,
           cs_dd03p-scrlen1,
           cs_dd03p-scrlen2,
           cs_dd03p-scrlen3,
           cs_dd03p-datatype,
           cs_dd03p-leng,
           cs_dd03p-outputlen,
           cs_dd03p-deffdname,
           cs_dd03p-convexit,
           cs_dd03p-entitytab,
           cs_dd03p-dommaster,
           cs_dd03p-domname3l,
           cs_dd03p-decimals,
           cs_dd03p-lowercase,
           cs_dd03p-signflag.

  ENDMETHOD.

  METHOD delete_extras.

    DELETE FROM tddat WHERE tabname = iv_tabname.

  ENDMETHOD.

  METHOD delete_idoc_segment.

    DATA lv_segment_type        TYPE edilsegtyp.
    DATA lv_result              LIKE sy-subrc.

    IF is_idoc_segment( ) = abap_false.
      rv_deleted = abap_false.
      RETURN. "previous XML version or no IDoc segment
    ENDIF.

    rv_deleted = abap_true.
    lv_segment_type = ms_item-obj_name.

    CALL FUNCTION 'SEGMENT_DELETE'
      EXPORTING
        segmenttyp = lv_segment_type
      IMPORTING
        result     = lv_result
      EXCEPTIONS
        OTHERS     = 1.
    IF sy-subrc <> 0 OR lv_result <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.
  ENDMETHOD.

  METHOD deserialize_idoc_segment.

    DATA lv_result              LIKE sy-subrc.
    DATA lv_package             TYPE devclass.
    DATA lv_uname               TYPE sy-uname.
    DATA lv_transport           TYPE trkorr.
    DATA ls_edisdef             TYPE edisdef.
    DATA ls_segment_definition  TYPE zif_abapgit_object_tabl=>ty_segment_definition.
    FIELD-SYMBOLS <ls_segment_definition> TYPE zif_abapgit_object_tabl=>ty_segment_definition.

    rv_deserialized = abap_false.

    IF lines( is_internal-segment_definitions ) = 0.
      RETURN. "no IDoc segment
    ENDIF.

    rv_deserialized = abap_true.

    lv_package = iv_package.
    lv_transport = iv_transport.

    LOOP AT is_internal-segment_definitions ASSIGNING <ls_segment_definition>.
      ls_segment_definition = <ls_segment_definition>.
      ls_segment_definition-segmentheader-presp = sy-uname.
      ls_segment_definition-segmentheader-pwork = sy-uname.

      CALL FUNCTION 'SEGMENT_READ'
        EXPORTING
          segmenttyp = ls_segment_definition-segmentdefinition-segtyp
        IMPORTING
          result     = lv_result
        EXCEPTIONS
          OTHERS     = 1.
      IF sy-subrc <> 0 OR lv_result <> 0.
        CALL FUNCTION 'SEGMENT_CREATE'
          IMPORTING
            segmentdefinition = ls_segment_definition-segmentdefinition
          TABLES
            segmentstructure  = ls_segment_definition-segmentstructures
          CHANGING
            segmentheader     = ls_segment_definition-segmentheader
            devclass          = lv_package
          EXCEPTIONS
            OTHERS            = 1.
      ELSE.

        CALL FUNCTION 'SEGMENT_MODIFY'
          CHANGING
            segmentheader = ls_segment_definition-segmentheader
            devclass      = lv_package
          EXCEPTIONS
            OTHERS        = 1.
        IF sy-subrc = 0.
          CALL FUNCTION 'SEGMENTDEFINITION_MODIFY'
            TABLES
              segmentstructure  = ls_segment_definition-segmentstructures
            CHANGING
              segmentdefinition = ls_segment_definition-segmentdefinition
            EXCEPTIONS
              OTHERS            = 1.
        ENDIF.
      ENDIF.

      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      " Check status of segment as stored in repo (field-symbol)
      IF <ls_segment_definition>-segmentdefinition-closed = abap_true.
        IF lv_transport IS NOT INITIAL.
          CALL FUNCTION 'SEGMENTDEFINITION_CLOSE'
            EXPORTING
              segmenttyp = ls_segment_definition-segmentdefinition-segtyp
            CHANGING
              order      = lv_transport
            EXCEPTIONS
              OTHERS     = 1.
          IF sy-subrc <> 0.
            zcx_abapgit_exception=>raise_t100( ).
          ENDIF.
        ENDIF.

        " SEGMENTDEFINITION_CLOSE saves current release but it should be same as in repo
        SELECT SINGLE * FROM edisdef INTO ls_edisdef
          WHERE segtyp  = ls_segment_definition-segmentdefinition-segtyp
            AND version = ls_segment_definition-segmentdefinition-version.
        ls_edisdef-released = <ls_segment_definition>-segmentdefinition-released.
        ls_edisdef-applrel  = <ls_segment_definition>-segmentdefinition-applrel.
        ls_edisdef-closed   = <ls_segment_definition>-segmentdefinition-closed.
        UPDATE edisdef FROM ls_edisdef.
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise( |Error updating IDOC segment {
            ls_segment_definition-segmentdefinition-segtyp }| ).
        ENDIF.
      ENDIF.
    ENDLOOP.

    lv_uname = sy-uname.

    CALL FUNCTION 'TR_TADIR_INTERFACE'
      EXPORTING
        wi_test_modus       = abap_false
        wi_tadir_pgmid      = 'R3TR'
        wi_tadir_object     = ms_item-obj_type
        wi_tadir_obj_name   = ms_item-obj_name
        wi_tadir_author     = lv_uname
        wi_tadir_devclass   = iv_package
        wi_tadir_masterlang = mv_language
        iv_set_edtflag      = abap_true
        iv_delflag          = abap_false
      EXCEPTIONS
        OTHERS              = 1.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.
  ENDMETHOD.

  METHOD deserialize_indexes.

    DATA:
      lv_name      TYPE ddobjname,
      lv_subrc     TYPE sy-subrc,
      lt_dd12v_db  LIKE is_internal-dd12v,
      ls_dd12v     LIKE LINE OF is_internal-dd12v,
      ls_dd17v     LIKE LINE OF is_internal-dd17v,
      lt_secondary LIKE is_internal-dd17v.

    lv_name = ms_item-obj_name.

    " Get existing indexes and drop the ones that are not included in remote
    CALL FUNCTION 'DDIF_TABL_GET'
      EXPORTING
        name          = lv_name
        langu         = mv_language
      TABLES
        dd12v_tab     = lt_dd12v_db
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'error from DDIF_TABL_GET' ).
    ENDIF.

    LOOP AT lt_dd12v_db INTO ls_dd12v.
      READ TABLE is_internal-dd12v TRANSPORTING NO FIELDS WITH KEY
        sqltab    = ls_dd12v-sqltab
        indexname = ls_dd12v-indexname.
      IF sy-subrc <> 0.
        CALL FUNCTION 'DD_INDX_DEL'
          EXPORTING
            sqltab    = ls_dd12v-sqltab
            indexname = ls_dd12v-indexname
            del_state = 'M'     "all states
          IMPORTING
            rc        = lv_subrc.
        IF lv_subrc <> 0.
          zcx_abapgit_exception=>raise( |Error deleting index { ls_dd12v-sqltab }~{ ls_dd12v-indexname }| ).
        ENDIF.
      ENDIF.
    ENDLOOP.

    " Create new or update existing indexes
    LOOP AT is_internal-dd12v INTO ls_dd12v.

      CLEAR lt_secondary.
      LOOP AT is_internal-dd17v INTO ls_dd17v
          WHERE sqltab = ls_dd12v-sqltab AND indexname = ls_dd12v-indexname.
        APPEND ls_dd17v TO lt_secondary.
      ENDLOOP.

      CALL FUNCTION 'DDIF_INDX_PUT'
        EXPORTING
          name              = ls_dd12v-sqltab
          id                = ls_dd12v-indexname
          dd12v_wa          = ls_dd12v
        TABLES
          dd17v_tab         = lt_secondary
        EXCEPTIONS
          indx_not_found    = 1
          name_inconsistent = 2
          indx_inconsistent = 3
          put_failure       = 4
          put_refused       = 5
          OTHERS            = 6.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      " Secondary indexes are automatically activated as part of R3TR TABL
      " So there's no need to add them to activation queue
    ENDLOOP.

  ENDMETHOD.

  METHOD deserialize_texts.

    DATA: lv_name      TYPE ddobjname,
          ls_dd02v_tmp TYPE dd02v.

    FIELD-SYMBOLS: <lv_lang>      LIKE LINE OF cs_internal-i18n_langs,
                   <ls_dd02_text> LIKE LINE OF cs_internal-dd02_texts.

    lv_name = ms_item-obj_name.

    mo_i18n_params->trim_saplang_list( CHANGING ct_sap_langs = cs_internal-i18n_langs ).

    SORT cs_internal-i18n_langs.
    SORT cs_internal-dd02_texts BY ddlanguage. " Optimization

    LOOP AT cs_internal-i18n_langs ASSIGNING <lv_lang>.

      " Table description
      ls_dd02v_tmp = cs_internal-dd02v.
      READ TABLE cs_internal-dd02_texts ASSIGNING <ls_dd02_text> WITH KEY ddlanguage = <lv_lang>.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( |DD02_TEXTS cannot find lang { <lv_lang> } in XML| ).
      ENDIF.
      MOVE-CORRESPONDING <ls_dd02_text> TO ls_dd02v_tmp.
      CALL FUNCTION 'DDIF_TABL_PUT'
        EXPORTING
          name              = lv_name
          dd02v_wa          = ls_dd02v_tmp
        EXCEPTIONS
          tabl_not_found    = 1
          name_inconsistent = 2
          tabl_inconsistent = 3
          put_failure       = 4
          put_refused       = 5
          OTHERS            = 6.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD is_db_table_category.

    " values from domain TABCLASS
    rv_is_db_table_type = boolc( iv_tabclass = 'TRANSP'
                              OR iv_tabclass = 'CLUSTER'
                              OR iv_tabclass = 'POOL' ).

  ENDMETHOD.

  METHOD is_idoc_segment.

    DATA lv_segment_type TYPE edilsegtyp.

    lv_segment_type = ms_item-obj_name.

    SELECT SINGLE segtyp
           FROM edisegment
           INTO lv_segment_type
           WHERE segtyp = lv_segment_type.
    rv_is_idoc_segment = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD read_extras.

    SELECT SINGLE * FROM tddat INTO rs_tabl_extras-tddat WHERE tabname = iv_tabname.

  ENDMETHOD.

  METHOD serialize_idoc_segment.

    DATA lv_segment_type        TYPE edilsegtyp.
    DATA lv_result              LIKE sy-subrc.
    DATA lv_devclass            TYPE devclass.
    DATA lt_segmentdefinitions  TYPE STANDARD TABLE OF edisegmdef.
    DATA ls_segment_definition  TYPE zif_abapgit_object_tabl=>ty_segment_definition.

    FIELD-SYMBOLS: <ls_segemtndefinition> TYPE edisegmdef.

    IF is_idoc_segment( ) = abap_false.
      RETURN.
    ENDIF.

    lv_segment_type = ms_item-obj_name.
    CALL FUNCTION 'SEGMENT_READ'
      EXPORTING
        segmenttyp        = lv_segment_type
      IMPORTING
        result            = lv_result
      TABLES
        segmentdefinition = lt_segmentdefinitions
      EXCEPTIONS
        OTHERS            = 1.
    IF sy-subrc <> 0 OR lv_result <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    LOOP AT lt_segmentdefinitions ASSIGNING <ls_segemtndefinition>.
      CLEAR ls_segment_definition.
      CALL FUNCTION 'SEGMENTDEFINITION_READ'
        EXPORTING
          segmenttyp           = <ls_segemtndefinition>-segtyp
        IMPORTING
          result               = lv_result
          devclass             = lv_devclass
          segmentheader        = ls_segment_definition-segmentheader
          segmentdefinition    = ls_segment_definition-segmentdefinition
        TABLES
          segmentstructure     = ls_segment_definition-segmentstructures
        CHANGING
          version              = <ls_segemtndefinition>-version
        EXCEPTIONS
          no_authority         = 1
          segment_not_existing = 2
          OTHERS               = 3.
      IF sy-subrc <> 0 OR lv_result <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      zcl_abapgit_object_idoc=>clear_idoc_segement_fields(
                                 CHANGING cg_structure = ls_segment_definition-segmentdefinition ).
      zcl_abapgit_object_idoc=>clear_idoc_segement_fields(
                                 CHANGING cg_structure = ls_segment_definition-segmentheader ).

      APPEND ls_segment_definition TO cs_internal-segment_definitions.
    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_texts.

    DATA: lv_name            TYPE ddobjname,
          lv_index           TYPE i,
          ls_dd02v           TYPE dd02v,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    FIELD-SYMBOLS: <lv_lang>      LIKE LINE OF cs_internal-i18n_langs,
                   <ls_dd02_text> LIKE LINE OF cs_internal-dd02_texts.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN.
    ENDIF.

    lv_name = ms_item-obj_name.

    " Collect additional languages, skip main lang - it was serialized already
    lt_language_filter = mo_i18n_params->build_language_filter( ).

    SELECT DISTINCT ddlanguage AS langu INTO TABLE cs_internal-i18n_langs
      FROM dd02v
      WHERE tabname = lv_name
      AND ddlanguage IN lt_language_filter
      AND ddlanguage <> mv_language
      ORDER BY langu.                                     "#EC CI_SUBRC

    LOOP AT cs_internal-i18n_langs ASSIGNING <lv_lang>.
      lv_index = sy-tabix.
      CALL FUNCTION 'DDIF_TABL_GET'
        EXPORTING
          name          = lv_name
          langu         = <lv_lang>
        IMPORTING
          dd02v_wa      = ls_dd02v
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.
      IF sy-subrc <> 0 OR ls_dd02v-ddlanguage IS INITIAL.
        DELETE cs_internal-i18n_langs INDEX lv_index. " Don't save this lang
        CONTINUE.
      ENDIF.

      APPEND INITIAL LINE TO cs_internal-dd02_texts ASSIGNING <ls_dd02_text>.
      MOVE-CORRESPONDING ls_dd02v TO <ls_dd02_text>.
    ENDLOOP.

    SORT cs_internal-i18n_langs ASCENDING.
    SORT cs_internal-dd02_texts BY ddlanguage ASCENDING.

  ENDMETHOD.

  METHOD update_extras.

    IF is_tabl_extras-tddat IS INITIAL.
      delete_extras( iv_tabname ).
    ELSE.
      MODIFY tddat FROM is_tabl_extras-tddat.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    TYPES: BEGIN OF ty_data,
             as4user TYPE dd02l-as4user,
             as4date TYPE dd02l-as4date,
             as4time TYPE dd02l-as4time,
           END OF ty_data.

    DATA: lt_data TYPE STANDARD TABLE OF ty_data WITH DEFAULT KEY,
          ls_data LIKE LINE OF lt_data.

    SELECT as4user as4date as4time
      FROM dd02l INTO TABLE lt_data
      WHERE tabname = ms_item-obj_name
      AND as4local = 'A'
      AND as4vers = '0000'
      ORDER BY PRIMARY KEY.

    SELECT as4user as4date as4time
      APPENDING TABLE lt_data
      FROM dd09l
      WHERE tabname = ms_item-obj_name
      AND as4local = 'A'
      AND as4vers = '0000'
      ORDER BY PRIMARY KEY.

    SELECT as4user as4date as4time
      APPENDING TABLE lt_data
      FROM dd12l
      WHERE sqltab = ms_item-obj_name
      AND as4local = 'A'
      AND as4vers = '0000'
      ORDER BY PRIMARY KEY.

    SORT lt_data BY as4date DESCENDING as4time DESCENDING.

    READ TABLE lt_data INDEX 1 INTO ls_data.
    IF sy-subrc = 0.
      rv_user = ls_data-as4user.
    ELSE.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_objname TYPE rsedd0-ddobjname,
          lv_no_ask  TYPE abap_bool,
          lv_subrc   TYPE sy-subrc,
          BEGIN OF ls_dd02l,
            tabname  TYPE dd02l-tabname,
            tabclass TYPE dd02l-tabclass,
            sqltab   TYPE dd02l-sqltab,
          END OF ls_dd02l.

    IF zif_abapgit_object~exists( ) = abap_false.
      " Proxies e.g. delete on its own, nothing todo here then.
      RETURN.
    ENDIF.

    lv_objname = ms_item-obj_name.

    IF delete_idoc_segment( ) = abap_false.

      lv_no_ask = abap_true.
      SELECT SINGLE tabname tabclass sqltab FROM dd02l
        INTO CORRESPONDING FIELDS OF ls_dd02l
        WHERE tabname = ms_item-obj_name
        AND as4local = 'A'
        AND as4vers = '0000'.
      IF sy-subrc = 0 AND is_db_table_category( ls_dd02l-tabclass ) = abap_true.

        CALL FUNCTION 'DD_EXISTS_DATA'
          EXPORTING
            reftab          = ls_dd02l-sqltab
            tabclass        = ls_dd02l-tabclass
            tabname         = ls_dd02l-tabname
          IMPORTING
            subrc           = lv_subrc
          EXCEPTIONS
            missing_reftab  = 1
            sql_error       = 2
            buffer_overflow = 3
            unknown_error   = 4
            OTHERS          = 5.

        IF sy-subrc = 0 AND lv_subrc = 0.
          lv_no_ask = abap_false.
        ENDIF.

      ENDIF.

      delete_ddic( iv_objtype = 'T'
                   iv_no_ask  = lv_no_ask ).

      delete_longtexts( c_longtext_id_tabl ).

      delete_extras( lv_objname ).

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_name     TYPE ddobjname,
          ls_internal TYPE zif_abapgit_object_tabl=>ty_internal.

    FIELD-SYMBOLS: <ls_dd03p>      TYPE dd03p,
                   <ls_dd05m>      TYPE dd05m,
                   <ls_dd08v>      TYPE dd08v,
                   <ls_dd35v>      TYPE dd35v,
                   <ls_dd36m>      TYPE dd36m,
                   <lg_roworcolst> TYPE any.

    lv_name = ms_item-obj_name. " type conversion

    ls_internal = lcl_tabl_xml=>read( io_xml ).

    IF deserialize_idoc_segment( is_internal  = ls_internal
                                 iv_transport = iv_transport
                                 iv_package   = iv_package ) = abap_false.

      ASSIGN COMPONENT 'ROWORCOLST' OF STRUCTURE ls_internal-dd09l TO <lg_roworcolst>.
      IF sy-subrc = 0 AND <lg_roworcolst> IS INITIAL.
        <lg_roworcolst> = 'C'. "Reverse fix from serialize
      ENDIF.

      " Number fields sequentially and fill table name
      LOOP AT ls_internal-dd03p ASSIGNING <ls_dd03p>.
        <ls_dd03p>-position   = sy-tabix.
        <ls_dd03p>-tabname    = lv_name.
        <ls_dd03p>-ddlanguage = mv_language.
      ENDLOOP.

      LOOP AT ls_internal-dd05m ASSIGNING <ls_dd05m>.
        <ls_dd05m>-tabname = lv_name.
      ENDLOOP.
      LOOP AT ls_internal-dd08v ASSIGNING <ls_dd08v>.
        <ls_dd08v>-tabname = lv_name.
        <ls_dd08v>-ddlanguage = mv_language.
      ENDLOOP.
      LOOP AT ls_internal-dd35v ASSIGNING <ls_dd35v>.
        <ls_dd35v>-tabname = lv_name.
      ENDLOOP.
      LOOP AT ls_internal-dd36m ASSIGNING <ls_dd36m>.
        <ls_dd36m>-tabname = lv_name.
      ENDLOOP.

      corr_insert( iv_package = iv_package
                   ig_object_class = 'DICT' ).

      CALL FUNCTION 'DD_TABL_EXPAND'
        EXPORTING
          dd02v_wa          = ls_internal-dd02v
        TABLES
          dd03p_tab         = ls_internal-dd03p
          dd05m_tab         = ls_internal-dd05m
          dd08v_tab         = ls_internal-dd08v
          dd35v_tab         = ls_internal-dd35v
          dd36m_tab         = ls_internal-dd36m
        EXCEPTIONS
          illegal_parameter = 1
          OTHERS            = 2.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      CALL FUNCTION 'DDIF_TABL_PUT'
        EXPORTING
          name              = lv_name
          dd02v_wa          = ls_internal-dd02v
          dd09l_wa          = ls_internal-dd09l
        TABLES
          dd03p_tab         = ls_internal-dd03p
          dd05m_tab         = ls_internal-dd05m
          dd08v_tab         = ls_internal-dd08v
          dd35v_tab         = ls_internal-dd35v
          dd36m_tab         = ls_internal-dd36m
        EXCEPTIONS
          tabl_not_found    = 1
          name_inconsistent = 2
          tabl_inconsistent = 3
          put_failure       = 4
          put_refused       = 5
          OTHERS            = 6.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      zcl_abapgit_objects_activation=>add_item( ms_item ).

      deserialize_indexes( ls_internal ).

      IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
        deserialize_texts( CHANGING cs_internal = ls_internal ).
      ENDIF.

      deserialize_longtexts( ii_xml         = io_xml
                             iv_longtext_id = c_longtext_id_tabl ).

      update_extras( iv_tabname     = lv_name
                     is_tabl_extras = ls_internal-extras ).

    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_tabname TYPE dd02l-tabname.

    lv_tabname = ms_item-obj_name.

    " Check nametab because it's fast
    CALL FUNCTION 'DD_GET_NAMETAB_HEADER'
      EXPORTING
        tabname   = lv_tabname
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc <> 0.
      " Check for new, inactive, or modified versions that might not be in nametab
      SELECT SINGLE tabname FROM dd02l INTO lv_tabname
        WHERE tabname = lv_tabname.                     "#EC CI_NOORDER
    ENDIF.
    rv_bool = boolc( sy-subrc = 0 ).

    " Skip TABL generated by CHDO
    IF rv_bool = abap_true.
      SELECT SINGLE tabname FROM tcdrs INTO lv_tabname WHERE tabname = lv_tabname.
      IF sy-subrc = 0.
        rv_bool = abap_false.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.

    DATA: li_local_version_output TYPE REF TO zif_abapgit_xml_output,
          li_local_version_input  TYPE REF TO zif_abapgit_xml_input.

    CREATE OBJECT li_local_version_output TYPE zcl_abapgit_xml_output.

    zif_abapgit_object~serialize( li_local_version_output ).

    CREATE OBJECT li_local_version_input
      TYPE zcl_abapgit_xml_input
      EXPORTING
        iv_xml = li_local_version_output->render( ).

    CREATE OBJECT ri_comparator TYPE zcl_abapgit_object_tabl_compar
      EXPORTING
        ii_local = li_local_version_input.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-ddic TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = 'ESDICT'
                                            iv_argument    = |{ ms_item-obj_type }{ ms_item-obj_name }| ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by ZCL_ABAPGIT_OBJECT=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_name     TYPE ddobjname,
          lv_state    TYPE ddgotstate,
          ls_internal TYPE zif_abapgit_object_tabl=>ty_internal,
          lv_index    LIKE sy-index.

    FIELD-SYMBOLS: <ls_dd12v>      LIKE LINE OF ls_internal-dd12v,
                   <ls_dd05m>      LIKE LINE OF ls_internal-dd05m,
                   <ls_dd08v>      LIKE LINE OF ls_internal-dd08v,
                   <ls_dd35v>      LIKE LINE OF ls_internal-dd35v,
                   <ls_dd36m>      LIKE LINE OF ls_internal-dd36m,
                   <lg_roworcolst> TYPE any.

    lv_name = ms_item-obj_name.

    CALL FUNCTION 'DDIF_TABL_GET'
      EXPORTING
        name          = lv_name
        langu         = mv_language
      IMPORTING
        gotstate      = lv_state
        dd02v_wa      = ls_internal-dd02v
        dd09l_wa      = ls_internal-dd09l
      TABLES
        dd03p_tab     = ls_internal-dd03p
        dd05m_tab     = ls_internal-dd05m
        dd08v_tab     = ls_internal-dd08v
        dd12v_tab     = ls_internal-dd12v
        dd17v_tab     = ls_internal-dd17v
        dd35v_tab     = ls_internal-dd35v
        dd36m_tab     = ls_internal-dd36m
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'error from DDIF_TABL_GET' ).
    ENDIF.

    " Check if any active version was returned
    IF lv_state <> 'A'.
      RETURN.
    ENDIF.

    CLEAR: ls_internal-dd02v-as4user,
           ls_internal-dd02v-as4date,
           ls_internal-dd02v-as4time.

* reset numeric field, so XML does not crash
    IF ls_internal-dd02v-prozpuff = ''.
      CLEAR ls_internal-dd02v-prozpuff.
    ENDIF.
    IF ls_internal-dd02v-datmin = ''.
      CLEAR ls_internal-dd02v-datmin.
    ENDIF.
    IF ls_internal-dd02v-datmax = ''.
      CLEAR ls_internal-dd02v-datmax.
    ENDIF.
    IF ls_internal-dd02v-datavg = ''.
      CLEAR ls_internal-dd02v-datavg.
    ENDIF.

    CLEAR: ls_internal-dd09l-as4user,
           ls_internal-dd09l-as4date,
           ls_internal-dd09l-as4time.

    ASSIGN COMPONENT 'ROWORCOLST' OF STRUCTURE ls_internal-dd09l TO <lg_roworcolst>.
    IF sy-subrc = 0 AND <lg_roworcolst> = 'C'.
      CLEAR <lg_roworcolst>. "To avoid diff errors. This field doesn't exist in all releases
    ENDIF.

    LOOP AT ls_internal-dd12v ASSIGNING <ls_dd12v>.
      CLEAR: <ls_dd12v>-as4user,
             <ls_dd12v>-as4date,
             <ls_dd12v>-as4time,
             <ls_dd12v>-dbindex.
      IF <ls_dd12v>-dbstate IS INITIAL OR <ls_dd12v>-dbstate = 'O'.
        " These settings are only relevant if database-specific indexes are defined (dbstate = 'D')
        CLEAR:
          <ls_dd12v>-dbinclexcl,
          <ls_dd12v>-dbsyssel1,
          <ls_dd12v>-dbsyssel2,
          <ls_dd12v>-dbsyssel3,
          <ls_dd12v>-dbsyssel4.
      ENDIF.
    ENDLOOP.

    clear_dd03p_fields( CHANGING ct_dd03p = ls_internal-dd03p ).

* remove foreign keys inherited from .INCLUDEs
    DELETE ls_internal-dd08v WHERE noinherit = 'N'.
    LOOP AT ls_internal-dd05m ASSIGNING <ls_dd05m>.
      CLEAR <ls_dd05m>-tabname.
      CLEAR <ls_dd05m>-leng.
      lv_index = sy-tabix.
      READ TABLE ls_internal-dd08v WITH KEY fieldname = <ls_dd05m>-fieldname TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        DELETE ls_internal-dd05m INDEX lv_index.
      ENDIF.
    ENDLOOP.

    LOOP AT ls_internal-dd08v ASSIGNING <ls_dd08v>.
      CLEAR: <ls_dd08v>-tabname, <ls_dd08v>-ddlanguage.
    ENDLOOP.
    LOOP AT ls_internal-dd35v ASSIGNING <ls_dd35v>.
      CLEAR <ls_dd35v>-tabname.
    ENDLOOP.

* remove inherited search helps
    DELETE ls_internal-dd35v WHERE shlpinher = abap_true.
    LOOP AT ls_internal-dd36m ASSIGNING <ls_dd36m>.
      CLEAR <ls_dd36m>-tabname.
      lv_index = sy-tabix.
      READ TABLE ls_internal-dd35v WITH KEY fieldname = <ls_dd36m>-fieldname TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        DELETE ls_internal-dd36m INDEX lv_index.
      ENDIF.
    ENDLOOP.

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      serialize_texts( CHANGING cs_internal = ls_internal ).
    ENDIF.

    ls_internal-longtexts = zcl_abapinst_factory=>get_longtexts( )->serialize(
      iv_object_name = ms_item-obj_name
      iv_longtext_id = c_longtext_id_tabl
      io_i18n_params = mo_i18n_params
      ii_xml         = io_xml ).

    serialize_idoc_segment( CHANGING cs_internal = ls_internal ).

    ls_internal-extras = read_extras( lv_name ).

    lcl_tabl_xml=>add(
      io_xml      = io_xml
      is_internal = ls_internal ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_tabl_ddl IMPLEMENTATION.

  METHOD deserialize.

* https://help.sap.com/doc/abapdocu_cp_index_htm/CLOUD/en-US/abenddicddl_define_table.htm

* CL_SBD_STRUCTURE_OBJDATA has serializer in local class

    DATA lv_ddl    TYPE string.
    DATA lv_fields TYPE string.
    DATA lv_start  TYPE i.
    DATA lv_length TYPE i.
    DATA lv_end    TYPE i.
    DATA lt_fields TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    DATA lv_field  TYPE string.

    lv_ddl = iv_ddl.

    parse_top_annotations( CHANGING
      cs_data = rs_data
      cv_ddl  = lv_ddl ).

    FIND FIRST OCCURRENCE OF '{' IN lv_ddl MATCH OFFSET lv_start.
    ASSERT lv_start > 0.
    FIND FIRST OCCURRENCE OF '}' IN lv_ddl MATCH OFFSET lv_end.
    ASSERT lv_end > 0.

    lv_start = lv_start + 1.
    lv_length = lv_end - lv_start - 1.
    lv_fields = lv_ddl+lv_start(lv_length).
    SPLIT lv_fields AT |;| INTO TABLE lt_fields.

    LOOP AT lt_fields INTO lv_field WHERE table_line IS NOT INITIAL.
      parse_field( EXPORTING iv_field = lv_field CHANGING cs_data = rs_data ).
    ENDLOOP.

  ENDMETHOD.

  METHOD escape_string.
    rv_string = |'{ replace( val  = iv_string
                             sub  = |'|
                             with = |''|
                             occ  = 0 ) }'|.
  ENDMETHOD.

  METHOD parse_field.

    CONSTANTS: BEGIN OF lc_mode,
                 start     TYPE i VALUE 0,
                 colon     TYPE i VALUE 1,
                 type      TYPE i VALUE 2,
                 aftertype TYPE i VALUE 3,
                 null      TYPE i VALUE 4,
                 afternull TYPE i VALUE 5,
               END OF lc_mode.

    DATA lv_field  TYPE string.
    DATA lv_mode   TYPE i.
    DATA lt_tokens TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    DATA lv_token  TYPE string.
    DATA ls_dd08v  TYPE dd08v.

    FIELD-SYMBOLS <ls_dd03p> LIKE LINE OF cs_data-dd03p.

    lv_field = iv_field.
    parse_field_annotations(
      IMPORTING es_dd08v = ls_dd08v
      CHANGING cv_ddl = lv_field ).

    SPLIT lv_field AT space INTO TABLE lt_tokens.

    APPEND INITIAL LINE TO cs_data-dd03p ASSIGNING <ls_dd03p>.

    LOOP AT lt_tokens INTO lv_token WHERE table_line IS NOT INITIAL.
      CASE lv_mode.
        WHEN lc_mode-start.
* todo, is it possible to have a key field named "key" ?
          IF lv_token = 'key'.
            <ls_dd03p>-keyflag = abap_true.
          ELSE.
            <ls_dd03p>-fieldname = to_upper( lv_token ).
            lv_mode = lc_mode-colon.
          ENDIF.
        WHEN lc_mode-colon.
          ASSERT lv_token = ':'.
          lv_mode = lc_mode-type.
        WHEN lc_mode-type.
          parse_type(
            EXPORTING iv_token = lv_token
            CHANGING cs_dd03p = <ls_dd03p> ).
          RETURN.
        WHEN lc_mode-aftertype.
          IF lv_token = 'not'.
            <ls_dd03p>-notnull = abap_true.
            lv_mode = lc_mode-null.
          ENDIF.
        WHEN lc_mode-null.
          ASSERT lv_token = 'null'.
          lv_mode = lc_mode-afternull.
        WHEN lc_mode-afternull.
          ASSERT lv_token = 'with'.
          RETURN. " todo
        WHEN OTHERS.
          ASSERT 1 = 'todo'.
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.

  METHOD parse_field_annotations.

    DATA lv_annotation TYPE string.
    DATA lv_name       TYPE string.
    DATA lv_value      TYPE string.

    REPLACE FIRST OCCURRENCE OF REGEX '^[\n ]*' IN cv_ddl WITH ||.

    WHILE cv_ddl CP '@*'.
      SPLIT cv_ddl AT |\n| INTO lv_annotation cv_ddl.
      CONDENSE cv_ddl.

      SPLIT lv_annotation AT ':' INTO lv_name lv_value.
      CONDENSE lv_name.
      CONDENSE lv_value.
      ASSERT lv_name IS NOT INITIAL.
      ASSERT lv_value IS NOT INITIAL.

      CASE lv_name.
        WHEN '@AbapCatalog.foreignKey.label'.
          es_dd08v-ddtext = unescape_string( lv_value ).
        WHEN '@AbapCatalog.foreignKey.keyType'.
          ASSERT lv_value(1) = '#'.
          es_dd08v-frkart = lv_value+1.
        WHEN '@AbapCatalog.foreignKey.screenCheck'.
          ASSERT lv_value = 'true'.
        WHEN OTHERS.
          WRITE: / 'todo:', lv_name, lv_value.
          ASSERT 1 = 'todo'.
      ENDCASE.
    ENDWHILE.

  ENDMETHOD.

  METHOD parse_top_annotations.

    DATA lv_annotation TYPE string.
    DATA lv_name       TYPE string.
    DATA lv_value      TYPE string.

    WHILE cv_ddl CP '@*'.
      SPLIT cv_ddl AT |\n| INTO lv_annotation cv_ddl.
      SPLIT lv_annotation AT ':' INTO lv_name lv_value.
      CONDENSE lv_name.
      CONDENSE lv_value.
      ASSERT lv_name IS NOT INITIAL.
      ASSERT lv_value IS NOT INITIAL.

      CASE lv_name.
        WHEN '@EndUserText.label'.
          cs_data-dd02v-ddtext = unescape_string( lv_value ).
        WHEN '@AbapCatalog.enhancementCategory'.
          CASE lv_value.
            WHEN '#NOT_EXTENSIBLE'.
              cs_data-dd02v-contflag = '1'.
            WHEN OTHERS.
              ASSERT 1 = 'todo'.
          ENDCASE.
        WHEN '@AbapCatalog.tableCategory'.
          CASE lv_value.
            WHEN '#TRANSPARENT'.
              cs_data-dd02v-tabclass = 'TRANSP'.
            WHEN OTHERS.
              ASSERT 1 = 'todo'.
          ENDCASE.
        WHEN '@AbapCatalog.deliveryClass'.
          ASSERT lv_value(1) = '#'.
          cs_data-dd02v-contflag = lv_value+1.
        WHEN '@AbapCatalog.dataMaintenance'.
          CASE lv_value.
            WHEN '#ALLOWED'.
              cs_data-dd02v-mainflag = abap_true.
            WHEN '#LIMITED'.
              cs_data-dd02v-mainflag = abap_false.
            WHEN OTHERS.
              ASSERT 1 = 'todo'.
          ENDCASE.
        WHEN OTHERS.
          WRITE: / 'todo:', lv_name, lv_value.
          ASSERT 1 = 'todo'.
      ENDCASE.

    ENDWHILE.

  ENDMETHOD.

  METHOD parse_type.

    DATA lv_token TYPE string.

    lv_token = iv_token.
    IF lv_token CP 'abap.*'.
      lv_token = lv_token+5.
      IF lv_token(4) = 'char'.
* todo, length
        cs_dd03p-datatype = 'CHAR'.
      ELSEIF lv_token(6) = 'string'.
        cs_dd03p-intlen = 8.
        cs_dd03p-inttype = 'g'.
        cs_dd03p-datatype = 'STRG'.
      ELSE.
        ASSERT 1 = 'todo'.
      ENDIF.
    ELSE.
      cs_dd03p-rollname = to_upper( lv_token ).
    ENDIF.

  ENDMETHOD.

  METHOD read_data.
* temporary method for testing

    DATA lv_name TYPE ddobjname.

    lv_name = iv_name.

    CALL FUNCTION 'DDIF_TABL_GET'
      EXPORTING
        name          = lv_name
        langu         = 'E'
      IMPORTING
        dd02v_wa      = rs_data-dd02v
        dd09l_wa      = rs_data-dd09l
      TABLES
        dd03p_tab     = rs_data-dd03p
        dd05m_tab     = rs_data-dd05m
        dd08v_tab     = rs_data-dd08v
        dd12v_tab     = rs_data-dd12v
        dd17v_tab     = rs_data-dd17v
        dd35v_tab     = rs_data-dd35v
        dd36m_tab     = rs_data-dd36m
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD serialize.

    DATA ls_dd03p   LIKE LINE OF is_data-dd03p.
    DATA lv_key     TYPE string.
    DATA lv_type    TYPE string.
    DATA lv_pre     TYPE string.
    DATA lv_int     TYPE i.
    DATA lv_suffix  TYPE string.
    DATA lv_notnull TYPE string.
    DATA lv_colon   TYPE i.

    rv_ddl = rv_ddl && serialize_top( is_data ).

    rv_ddl = rv_ddl && |define table { to_lower( is_data-dd02v-tabname ) } \{\n|.

    LOOP AT is_data-dd03p INTO ls_dd03p
        WHERE ( fieldname NP '.INCLU*' OR groupname IS NOT INITIAL )
        AND adminfield = '0'.
      lv_int = 0.
      IF ls_dd03p-keyflag = abap_true.
        lv_int = 4.
      ENDIF.
      IF ls_dd03p-groupname IS INITIAL.
        lv_int = lv_int + strlen( ls_dd03p-fieldname ).
      ELSE.
        lv_int = lv_int + strlen( ls_dd03p-groupname ).
      ENDIF.
      IF lv_int > lv_colon.
        lv_colon = lv_int.
      ENDIF.
    ENDLOOP.

* ADMINFIELD: skip fields inside .INCLUDEs
    LOOP AT is_data-dd03p INTO ls_dd03p WHERE adminfield = '0'.
      CLEAR lv_key.
      CLEAR lv_notnull.
      IF ls_dd03p-keyflag = abap_true.
        lv_key = |key |.
      ENDIF.

      lv_pre = |{ lv_key }{ to_lower( ls_dd03p-fieldname ) }|.
      IF ls_dd03p-groupname IS NOT INITIAL.
        lv_pre = |{ lv_key }{ to_lower( ls_dd03p-groupname ) }|.
      ENDIF.
      IF strlen( lv_pre ) < lv_colon.
        lv_pre = lv_pre && repeat(
          val = | |
          occ = lv_colon - strlen( lv_pre ) ).
      ENDIF.

      IF ls_dd03p-fieldname = '.INCLU--AP'.
        CONTINUE.
      ELSEIF ls_dd03p-fieldname CP '.INCLU*'.
        IF ls_dd03p-notnull = abap_true.
          lv_notnull = | not null|.
        ENDIF.
        CLEAR lv_suffix.
        IF ls_dd03p-fieldname CA '-'.
          SPLIT ls_dd03p-fieldname AT '-' INTO lv_suffix lv_suffix.
          lv_suffix = | with suffix { to_lower( lv_suffix ) }|.
        ENDIF.
        IF ls_dd03p-groupname IS INITIAL.
          rv_ddl = rv_ddl && |  { lv_key }include { to_lower( ls_dd03p-precfield ) }{ lv_suffix }{ lv_notnull }|.
        ELSE.
          rv_ddl = rv_ddl && |  { lv_pre } : include { to_lower( ls_dd03p-precfield ) }{ lv_suffix }{ lv_notnull }|.
        ENDIF.
        rv_ddl = rv_ddl && serialize_extend(
          is_dd03p = ls_dd03p
          is_data  = is_data ).
        rv_ddl = rv_ddl && |;\n|.
        CONTINUE.
      ENDIF.

      rv_ddl = rv_ddl && serialize_field_annotations(
        iv_fieldname = ls_dd03p-fieldname
        is_data      = is_data ).
      rv_ddl = rv_ddl && serialize_fkey_annotations(
        iv_fieldname = ls_dd03p-fieldname
        is_data      = is_data ).

      lv_type = serialize_type( ls_dd03p ).
      rv_ddl = rv_ddl && |  { lv_pre } : { lv_type }|.
      rv_ddl = rv_ddl && serialize_field_foreign_key(
        iv_fieldname = ls_dd03p-fieldname
        is_data      = is_data ).
      rv_ddl = rv_ddl && serialize_value_help(
        iv_fieldname = ls_dd03p-fieldname
        is_data      = is_data ).
      rv_ddl = rv_ddl && |;\n|.
    ENDLOOP.
    rv_ddl = rv_ddl && |\n|.

    rv_ddl = rv_ddl && |\}|.

  ENDMETHOD.

  METHOD serialize_adt.

    DATA ls_object_type TYPE wbobjtype.
    DATA lv_object_key  TYPE seu_objkey.
    DATA li_object_data TYPE REF TO if_wb_object_data_model.
    DATA lo_operator    TYPE REF TO object.

    ls_object_type-objtype_tr = 'TABL'.
    ls_object_type-subtype_wb = 'DT'.

    lv_object_key = iv_name.

    CALL METHOD ('CL_WB_OBJECT_OPERATOR')=>('CREATE_INSTANCE')
      EXPORTING
        object_type = ls_object_type
        object_key  = lv_object_key
      RECEIVING
        result      = lo_operator.

    CALL METHOD lo_operator->('IF_WB_OBJECT_OPERATOR~READ')
      EXPORTING
        version        = 'A'
      IMPORTING
        eo_object_data = li_object_data.

    CALL METHOD li_object_data->('GET_CONTENT') IMPORTING p_data = rv_ddl.

  ENDMETHOD.

  METHOD serialize_extend.

    DATA lv_index  TYPE i.
    DATA ls_dd03p  LIKE LINE OF is_data-dd03p.
    DATA lt_fields TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    DATA lv_field  LIKE LINE OF lt_fields.
    DATA ls_dd08v  LIKE LINE OF is_data-dd08v.
    DATA ls_dd35v  LIKE LINE OF is_data-dd35v.

    READ TABLE is_data-dd03p TRANSPORTING NO FIELDS
      WITH KEY fieldname = is_dd03p-fieldname precfield = is_dd03p-precfield.
    ASSERT sy-subrc = 0.
    lv_index = sy-tabix + 1.

* the extended keys are not sorted by the fieldname positions
    LOOP AT is_data-dd03p FROM lv_index INTO ls_dd03p.
      IF ls_dd03p-adminfield = '0'.
        EXIT.
      ENDIF.
      APPEND ls_dd03p-fieldname TO lt_fields.
    ENDLOOP.
    CLEAR ls_dd03p.

    LOOP AT is_data-dd08v INTO ls_dd08v
        WHERE ( noinherit = 'Y' OR checktable = '*' ) AND noinherit <> 'N'.
      READ TABLE lt_fields TRANSPORTING NO FIELDS
        WITH KEY table_line = ls_dd08v-fieldname.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.
      DELETE lt_fields WHERE table_line = ls_dd08v-fieldname.

      rv_ddl = rv_ddl && |\n|.

      IF ls_dd08v-checktable <> '*'.
        rv_ddl = rv_ddl && serialize_fkey_annotations(
          iv_fieldname = ls_dd08v-fieldname
          is_data      = is_data ).
      ENDIF.

      rv_ddl = rv_ddl && |  extend { to_lower( ls_dd08v-fieldname ) } :|.

      IF ls_dd08v-checktable = '*'.
        rv_ddl = rv_ddl && |\n    remove foreign key|.
      ELSE.
        rv_ddl = rv_ddl && serialize_field_foreign_key(
          iv_fieldname = ls_dd08v-fieldname
          is_data      = is_data ).
      ENDIF.

      READ TABLE is_data-dd35v INTO ls_dd35v WITH KEY fieldname = ls_dd08v-fieldname.
      IF sy-subrc = 0.
        IF ls_dd35v-shlpname = '*'.
          rv_ddl = rv_ddl && |\n    remove value help|.
        ELSEIF ls_dd35v-shlpinher <> abap_true.
          rv_ddl = rv_ddl && serialize_value_help(
            iv_fieldname = ls_dd08v-fieldname
            is_data      = is_data ).
        ENDIF.
      ENDIF.
    ENDLOOP.

    LOOP AT is_data-dd35v INTO ls_dd35v.
      READ TABLE lt_fields INTO lv_field
        WITH KEY table_line = ls_dd35v-fieldname.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

      IF ls_dd35v-shlpname = '*'.
        rv_ddl = rv_ddl && |\n|.
        rv_ddl = rv_ddl && |  extend { to_lower( lv_field ) } :|.
        rv_ddl = rv_ddl && |\n    remove value help|.
      ELSEIF ls_dd35v-shlpinher <> abap_true.
        rv_ddl = rv_ddl && |\n|.
        rv_ddl = rv_ddl && |  extend { to_lower( lv_field ) } :|.
        rv_ddl = rv_ddl && serialize_value_help(
          iv_fieldname = lv_field
          is_data      = is_data ).
      ENDIF.
    ENDLOOP.

    REPLACE ALL OCCURRENCES OF |\n  | IN rv_ddl WITH |\n    |.

  ENDMETHOD.

  METHOD serialize_field_annotations.

    DATA ls_dd03p LIKE LINE OF is_data-dd03p.

    READ TABLE is_data-dd03p INTO ls_dd03p WITH KEY fieldname = iv_fieldname.
    IF sy-subrc = 0.
      IF ( ls_dd03p-rollname IS INITIAL AND ls_dd03p-precfield IS INITIAL
        OR ls_dd03p-comptype = 'R' AND ls_dd03p-reftype = 'B' )
        AND ls_dd03p-ddtext IS NOT INITIAL.
        rv_ddl = rv_ddl && |  @EndUserText.label : { escape_string( ls_dd03p-ddtext ) }\n|.
      ENDIF.

      IF ls_dd03p-languflag = abap_true.
        rv_ddl = rv_ddl && |  @AbapCatalog.textLanguage\n|.
      ENDIF.

      IF ls_dd03p-reftable IS NOT INITIAL AND ls_dd03p-reffield IS NOT INITIAL.
* this is not completely correct, it must lookup the type of the field in REFTABLE?
        IF ls_dd03p-datatype = 'CURR' OR ls_dd03p-reffield = 'WAERS'.
          rv_ddl = rv_ddl && |  @Semantics.amount.currencyCode : '{ to_lower( ls_dd03p-reftable ) }.{
            to_lower( ls_dd03p-reffield ) }'\n|.
        ELSE.
          rv_ddl = rv_ddl && |  @Semantics.quantity.unitOfMeasure : '{ to_lower( ls_dd03p-reftable ) }.{
            to_lower( ls_dd03p-reffield ) }'\n|.
        ENDIF.
      ENDIF.

      IF ls_dd03p-rollname IS INITIAL AND ( ls_dd03p-datatype(3) = 'D16' OR ls_dd03p-datatype(3) = 'D34' ).
* ls_dd03p-outputstyle
        rv_ddl = rv_ddl && |  @AbapCatalog.decfloat.outputStyle : #NORMAL\n|.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD serialize_field_foreign_key.

    DATA ls_dd08v       LIKE LINE OF is_data-dd08v.
    DATA ls_dd05m       LIKE LINE OF is_data-dd05m.
    DATA lv_pre         TYPE string.
    DATA lv_cardinality TYPE string.

    READ TABLE is_data-dd08v INTO ls_dd08v WITH KEY fieldname = iv_fieldname.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    IF ls_dd08v-cardleft = 'C' AND ls_dd08v-card = '1'.
      lv_cardinality = | [1,0..1] |.
    ELSEIF ls_dd08v-cardleft = '1' AND ls_dd08v-card = 'C'.
      lv_cardinality = | [0..1,1] |.
    ELSEIF ls_dd08v-cardleft = '1' AND ls_dd08v-card = '1'.
      lv_cardinality = | [1,1] |.
    ELSEIF ls_dd08v-cardleft = '1' AND ls_dd08v-card = 'N'.
      lv_cardinality = | [1..*,1] |.
    ELSEIF ls_dd08v-cardleft = '1' AND ls_dd08v-card = 'CN'.
      lv_cardinality = | [0..*,1] |.
    ELSEIF ls_dd08v-cardleft = 'C' AND ls_dd08v-card = 'CN'.
      lv_cardinality = | [0..*,0..1] |.
    ELSEIF ls_dd08v-cardleft = 'C' AND ls_dd08v-card = 'C'.
      lv_cardinality = | [0..1,0..1] |.
    ELSEIF ls_dd08v-cardleft = 'N' AND ls_dd08v-card = 'N'.
      lv_cardinality = | [1..*,] |.
    ELSEIF ls_dd08v-cardleft = 'C' AND ls_dd08v-card = 'N'.
      lv_cardinality = | [1..*,0..1] |.
    ELSEIF ls_dd08v-cardleft IS INITIAL OR ls_dd08v-card IS INITIAL.
      lv_cardinality = | |.
    ELSE.
      ASSERT 1 = 'todo'.
    ENDIF.

    rv_ddl = rv_ddl && |\n    with foreign key{ lv_cardinality }{ to_lower( ls_dd08v-checktable ) }|.

* assumption: dd05m table is sorted by PRIMPOS ascending
    LOOP AT is_data-dd05m INTO ls_dd05m WHERE fieldname = iv_fieldname AND fortable <> '*'.
      IF lv_pre IS INITIAL.
        lv_pre = |\n      where |.
      ELSE.
        lv_pre = |\n        and |.
      ENDIF.
      IF ls_dd05m-fortable(1) = |'|.
        rv_ddl = rv_ddl && |{ lv_pre }{ to_lower( ls_dd05m-checkfield ) } = {
          ls_dd05m-fortable }|.
      ELSE.
        rv_ddl = rv_ddl && |{ lv_pre }{ to_lower( ls_dd05m-checkfield ) } = {
          to_lower( ls_dd05m-fortable ) }.{ to_lower( ls_dd05m-forkey ) }|.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_fkey_annotations.

    DATA ls_dd08v LIKE LINE OF is_data-dd08v.

    READ TABLE is_data-dd08v INTO ls_dd08v WITH KEY fieldname = iv_fieldname.
    IF sy-subrc = 0.
      IF ls_dd08v-ddtext IS NOT INITIAL.
        rv_ddl = rv_ddl && |  @AbapCatalog.foreignKey.label : { escape_string( ls_dd08v-ddtext ) }\n|.
      ENDIF.

      IF ls_dd08v-frkart IS NOT INITIAL.
        CASE ls_dd08v-frkart.
          WHEN 'TEXT'.
            rv_ddl = rv_ddl && |  @AbapCatalog.foreignKey.keyType : #TEXT_KEY\n|.
          WHEN 'REF'.
            rv_ddl = rv_ddl && |  @AbapCatalog.foreignKey.keyType : #NON_KEY\n|.
          WHEN OTHERS.
            rv_ddl = rv_ddl && |  @AbapCatalog.foreignKey.keyType : #{ ls_dd08v-frkart }\n|.
        ENDCASE.
      ENDIF.

      IF ls_dd08v-checkflag = abap_false OR ls_dd08v-checkflag = 'N'.
        rv_ddl = rv_ddl && |  @AbapCatalog.foreignKey.screenCheck : true\n|.
      ELSE.
        rv_ddl = rv_ddl && |  @AbapCatalog.foreignKey.screenCheck : false\n|.
      ENDIF.

      IF ls_dd08v-arbgb IS NOT INITIAL.
        rv_ddl = rv_ddl && |  @AbapCatalog.foreignKey.messageClass : '{ ls_dd08v-arbgb }'\n|.
      ENDIF.
      IF ls_dd08v-msgnr IS NOT INITIAL.
        rv_ddl = rv_ddl && |  @AbapCatalog.foreignKey.messageNumber : '{ ls_dd08v-msgnr }'\n|.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD serialize_top.
    FIELD-SYMBOLS: <lv_pk_is_invhash> TYPE c, " ddpk_is_invhash
                   <lv_is_gtt>        TYPE abap_bool.

    rv_ddl = rv_ddl && |@EndUserText.label : { escape_string( is_data-dd02v-ddtext ) }\n|.

    CASE is_data-dd02v-exclass.
      WHEN '0'.
        rv_ddl = rv_ddl && |@AbapCatalog.enhancementCategory : #NOT_CLASSIFIED\n|.
      WHEN '1'.
        rv_ddl = rv_ddl && |@AbapCatalog.enhancementCategory : #NOT_EXTENSIBLE\n|.
      WHEN '2'.
        rv_ddl = rv_ddl && |@AbapCatalog.enhancementCategory : #EXTENSIBLE_CHARACTER\n|.
      WHEN '3'.
        rv_ddl = rv_ddl && |@AbapCatalog.enhancementCategory : #EXTENSIBLE_CHARACTER_NUMERIC\n|.
      WHEN '4'.
        rv_ddl = rv_ddl && |@AbapCatalog.enhancementCategory : #EXTENSIBLE_ANY\n|.
      WHEN OTHERS.
        ASSERT 1 = 'todo'.
    ENDCASE.

    CASE is_data-dd02v-tabclass.
      WHEN 'TRANSP'.
        " doesn't exist on NW < 750
        ASSIGN COMPONENT 'IS_GTT' OF STRUCTURE is_data-dd02v TO <lv_is_gtt>.
        IF sy-subrc = 0 AND <lv_is_gtt> = abap_true.
          rv_ddl = rv_ddl && |@AbapCatalog.tableCategory : #GLOBAL_TEMPORARY\n|.
        ELSE.
          rv_ddl = rv_ddl && |@AbapCatalog.tableCategory : #TRANSPARENT\n|.
        ENDIF.
      WHEN OTHERS.
        ASSERT 1 = 'todo'.
    ENDCASE.

    IF is_data-dd02v-authclass = '01'.
      rv_ddl = rv_ddl && |@AbapCatalog.activationType : #NAMETAB_GENERATION_OFFLINE\n|.
    ELSEIF is_data-dd02v-authclass = '02'.
      rv_ddl = rv_ddl && |@AbapCatalog.activationType : #ADAPT_C_STRUCTURES\n|.
    ENDIF.

    rv_ddl = rv_ddl && |@AbapCatalog.deliveryClass : #{ is_data-dd02v-contflag }\n|.

    IF is_data-dd02v-mainflag = abap_true.
      rv_ddl = rv_ddl && |@AbapCatalog.dataMaintenance : #ALLOWED\n|.
    ELSEIF is_data-dd02v-mainflag = 'N'.
      rv_ddl = rv_ddl && |@AbapCatalog.dataMaintenance : #NOT_ALLOWED\n|.
    ELSEIF is_data-dd02v-mainflag IS INITIAL.
      rv_ddl = rv_ddl && |@AbapCatalog.dataMaintenance : #LIMITED\n|.
    ELSE.
      rv_ddl = rv_ddl && |@AbapCatalog.dataMaintenance : \n|.
    ENDIF.

    " doesn't exist on NW <= 750
    ASSIGN
      COMPONENT 'PK_IS_INVHASH'
      OF STRUCTURE is_data-dd02v
      TO <lv_pk_is_invhash>.
    IF sy-subrc = 0 AND <lv_pk_is_invhash> = abap_true.
      rv_ddl = rv_ddl && |@AbapCatalog.primaryKey.invertedHashIndex : true\n|.
    ENDIF.

  ENDMETHOD.

  METHOD serialize_type.

    DATA lv_notnull TYPE string.
    DATA lv_leng TYPE i.
    DATA lv_decimals TYPE i.

    IF is_dd03p-notnull = abap_true.
      lv_notnull = | not null|.
    ENDIF.

    IF is_dd03p-rollname IS NOT INITIAL.
      rv_type = |{ to_lower( is_dd03p-rollname ) }{ lv_notnull }|.
    ELSE.
      lv_leng = is_dd03p-leng.
      lv_decimals = is_dd03p-decimals.
      CASE is_dd03p-datatype.
        WHEN 'STRG'.
          rv_type = |abap.string({ lv_leng }){ lv_notnull }|.
        WHEN 'RSTR'.
          rv_type = |abap.rawstring({ lv_leng }){ lv_notnull }|.
        WHEN 'INT4'.
          rv_type = |abap.int4{ lv_notnull }|.
        WHEN 'ACCP'.
          rv_type = |abap.accp{ lv_notnull }|.
        WHEN 'LANG'.
          rv_type = |abap.lang{ lv_notnull }|.
        WHEN 'DATN'.
          rv_type = |abap.datn{ lv_notnull }|.
        WHEN 'TIMN'.
          rv_type = |abap.timn{ lv_notnull }|.
        WHEN 'UTCL'.
          rv_type = |abap.utcl{ lv_notnull }|.
        WHEN 'INT8'.
          rv_type = |abap.int8{ lv_notnull }|.
        WHEN 'D16D'.
          rv_type = |abap.df16_dec({ lv_leng },{ lv_decimals }){ lv_notnull }|.
        WHEN 'D16R'.
          rv_type = |abap.df16_raw{ lv_notnull }|.
        WHEN 'D16S'.
          rv_type = |abap.df16_scl{ lv_notnull }|.
        WHEN 'D16N'.
          rv_type = |abap.d16n{ lv_notnull }|.
        WHEN 'D34S'.
          rv_type = |abap.df34_scl{ lv_notnull }|.
        WHEN 'D34D'.
          rv_type = |abap.df34_dec({ lv_leng },{ lv_decimals }){ lv_notnull }|.
        WHEN 'D34R'.
          rv_type = |abap.df34_raw{ lv_notnull }|.
        WHEN 'D34N'.
          rv_type = |abap.d34n{ lv_notnull }|.
        WHEN 'INT2'.
          rv_type = |abap.int2{ lv_notnull }|.
        WHEN 'INT1'.
          rv_type = |abap.int1{ lv_notnull }|.
        WHEN 'CUKY'.
          rv_type = |abap.cuky{ lv_notnull }|.
        WHEN 'DATS'.
          rv_type = |abap.dats{ lv_notnull }|.
        WHEN 'TIMS'.
          rv_type = |abap.tims{ lv_notnull }|.
        WHEN 'FLTP'.
          rv_type = |abap.fltp{ lv_notnull }|.
        WHEN 'CLNT'.
          rv_type = |abap.clnt{ lv_notnull }|.
        WHEN 'SSTR'.
          rv_type = |abap.sstring({ lv_leng }){ lv_notnull }|.
        WHEN 'QUAN'.
          rv_type = |abap.quan({ lv_leng },{ lv_decimals }){ lv_notnull }|.
        WHEN 'CURR'.
          rv_type = |abap.curr({ lv_leng },{ lv_decimals }){ lv_notnull }|.
        WHEN 'DEC'.
          rv_type = |abap.dec({ lv_leng },{ lv_decimals }){ lv_notnull }|.
        WHEN OTHERS.
          rv_type = |abap.{ to_lower( is_dd03p-datatype ) }({ lv_leng }){ lv_notnull }|.
      ENDCASE.
    ENDIF.

  ENDMETHOD.

  METHOD serialize_value_help.

    DATA ls_dd35v       LIKE LINE OF is_data-dd35v.
    DATA ls_dd36m       LIKE LINE OF is_data-dd36m.
    DATA lv_pre         TYPE string.

    READ TABLE is_data-dd35v INTO ls_dd35v WITH KEY fieldname = iv_fieldname.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    rv_ddl = rv_ddl && |\n    with value help { to_lower( ls_dd35v-shlpname ) }|.

    LOOP AT is_data-dd36m INTO ls_dd36m
        WHERE fieldname = iv_fieldname
        AND shlpname = ls_dd35v-shlpname
        AND shtype <> 'G'.
      IF lv_pre IS INITIAL.
        lv_pre = |\n      where |.
      ELSE.
        lv_pre = |\n        and |.
      ENDIF.
      IF ls_dd36m-shtype = 'C'.
        rv_ddl = rv_ddl && |{ lv_pre }{ to_lower( ls_dd36m-shlpfield ) } = {
          ls_dd36m-shtable }|.
      ELSE.
        rv_ddl = rv_ddl && |{ lv_pre }{ to_lower( ls_dd36m-shlpfield ) } = {
          to_lower( ls_dd36m-shtable ) }.{ to_lower( ls_dd36m-shfield ) }|.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD unescape_string.
    rv_string = iv_string.
    REPLACE FIRST OCCURRENCE OF REGEX |^'| IN rv_string WITH ||.
    REPLACE FIRST OCCURRENCE OF REGEX |'$| IN rv_string WITH ||.
    REPLACE ALL OCCURRENCES OF |''| IN rv_string WITH |'|.
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_tobj IMPLEMENTATION.

  METHOD delete_extra.

    DELETE FROM tddat WHERE tabname = iv_tabname.
    DELETE FROM tvdir WHERE tabname = iv_tabname.
    DELETE FROM tvimf WHERE tabname = iv_tabname.

  ENDMETHOD.

  METHOD read_extra.

    SELECT SINGLE * FROM tddat INTO rs_tobj-tddat WHERE tabname = iv_tabname.

    SELECT SINGLE * FROM tvdir INTO rs_tobj-tvdir WHERE tabname = iv_tabname.
    CLEAR: rs_tobj-tvdir-gendate, rs_tobj-tvdir-gentime, rs_tobj-tvdir-devclass.

    SELECT * FROM tvimf INTO TABLE rs_tobj-tvimf WHERE tabname = iv_tabname
      ORDER BY PRIMARY KEY.

  ENDMETHOD.

  METHOD update_extra.
    DATA: lt_current_tvimf TYPE STANDARD TABLE OF tvimf.
    FIELD-SYMBOLS: <ls_tvimf> TYPE tvimf.

    MODIFY tddat FROM is_tobj-tddat.
    MODIFY tvdir FROM is_tobj-tvdir.

    SELECT * INTO TABLE lt_current_tvimf
      FROM tvimf
      WHERE tabname = is_tobj-tddat-tabname
      ORDER BY PRIMARY KEY.

    LOOP AT lt_current_tvimf ASSIGNING <ls_tvimf>.
      READ TABLE is_tobj-tvimf WITH KEY tabname = <ls_tvimf>-tabname
                                        event   = <ls_tvimf>-event
                               TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
        DELETE FROM tvimf
          WHERE tabname = <ls_tvimf>-tabname
          AND event = <ls_tvimf>-event.
      ENDIF.
    ENDLOOP.

    MODIFY tvimf FROM TABLE is_tobj-tvimf.
  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    DATA: lv_type_pos TYPE i.

    lv_type_pos = strlen( ms_item-obj_name ) - 1.

    SELECT SINGLE luser FROM objh INTO rv_user
      WHERE objectname = ms_item-obj_name(lv_type_pos)
      AND objecttype = ms_item-obj_name+lv_type_pos.    "#EC CI_GENBUFF
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: ls_objh     TYPE objh,
          lv_type_pos TYPE i.

    lv_type_pos = strlen( ms_item-obj_name ) - 1.

    ls_objh-objectname = ms_item-obj_name(lv_type_pos).
    ls_objh-objecttype = ms_item-obj_name+lv_type_pos.

    IF ls_objh-objecttype = 'L'.
      zcx_abapgit_exception=>raise( |Use transaction SOBJ to delete transport objects { ls_objh-objectname }| ).
    ENDIF.

    CALL FUNCTION 'OBJ_GENERATE'
      EXPORTING
        iv_korrnum            = iv_transport
        iv_objectname         = ls_objh-objectname
        iv_objecttype         = ls_objh-objecttype
        iv_maint_mode         = 'D'
      EXCEPTIONS
        illegal_call          = 1
        object_not_found      = 2
        generate_error        = 3
        transport_error       = 4
        object_enqueue_failed = 5
        OTHERS                = 6.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    delete_extra( ls_objh-objectname ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: ls_objh  TYPE objh,
          ls_objt  TYPE objt,
          lt_objs  TYPE tt_objs,
          lt_objsl TYPE tt_objsl,
          lt_objm  TYPE tt_objm,
          ls_tobj  TYPE ty_tobj.

    io_xml->read( EXPORTING iv_name = 'OBJH'
                  CHANGING cg_data = ls_objh ).
    io_xml->read( EXPORTING iv_name = 'OBJT'
                  CHANGING cg_data = ls_objt ).
    io_xml->read( EXPORTING iv_name = 'OBJS'
                  CHANGING cg_data = lt_objs ).
    io_xml->read( EXPORTING iv_name = 'OBJSL'
                  CHANGING cg_data = lt_objsl ).
    io_xml->read( EXPORTING iv_name = 'OBJM'
                  CHANGING cg_data = lt_objm ).

    CALL FUNCTION 'OBJ_GENERATE'
      EXPORTING
        iv_korrnum            = iv_transport
        iv_objectname         = ls_objh-objectname
        iv_objecttype         = ls_objh-objecttype
        iv_maint_mode         = 'I'
        iv_objecttext         = ls_objt-ddtext
        iv_objcateg           = ls_objh-objcateg
        iv_objtransp          = ls_objh-objtransp
        iv_devclass           = iv_package
      TABLES
        tt_v_obj_s            = lt_objs
        tt_objm               = lt_objm
      EXCEPTIONS
        illegal_call          = 1
        object_not_found      = 2
        generate_error        = 3
        transport_error       = 4
        object_enqueue_failed = 5
        OTHERS                = 6.
    IF sy-subrc <> 0.
* TOBJ has to be saved/generated after the DDIC tables have been
* activated - fixed with late deserialization
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    CALL FUNCTION 'OBJ_SET_IMPORTABLE'
      EXPORTING
        iv_objectname         = ls_objh-objectname
        iv_objecttype         = ls_objh-objecttype
        iv_importable         = ls_objh-importable
      EXCEPTIONS
        object_not_defined    = 1
        invalid               = 2
        transport_error       = 3
        object_enqueue_failed = 4
        OTHERS                = 5.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

* fm OBJ_GENERATE takes the defaults from the DDIC object
* set OBJTRANSP directly, should be okay looking at the code in OBJ_SET_IMPORTABLE
* locking has been done in OBJ_SET_IMPORTABLE plus recording of transport
    UPDATE objh SET objtransp = ls_objh-objtransp
      WHERE objectname = ls_objh-objectname
      AND objecttype = ls_objh-objecttype.

    io_xml->read( EXPORTING iv_name = 'TOBJ'
                  CHANGING cg_data = ls_tobj ).
    ls_tobj-tvdir-gendate = sy-datum.
    ls_tobj-tvdir-gentime = sy-uzeit.
    ls_tobj-tvdir-devclass = iv_package.

    update_extra( ls_tobj ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_objectname TYPE objh-objectname,
          lv_type_pos   TYPE i.

    lv_type_pos = strlen( ms_item-obj_name ) - 1.

    SELECT SINGLE objectname FROM objh INTO lv_objectname
      WHERE objectname = ms_item-obj_name(lv_type_pos)
      AND objecttype = ms_item-obj_name+lv_type_pos.    "#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-late TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = abap_false.
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA: lv_object_name TYPE e071-obj_name.

    lv_object_name = ms_item-obj_name.

    CALL FUNCTION 'TR_OBJECT_JUMP_TO_TOOL'
      EXPORTING
        iv_pgmid          = 'R3TR'
        iv_object         = ms_item-obj_type
        iv_obj_name       = lv_object_name
      EXCEPTIONS
        jump_not_possible = 1
        OTHERS            = 2.

    rv_exit = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: ls_objh     TYPE objh,
          ls_objt     TYPE objt,
          lt_objs     TYPE tt_objs,
          lt_objsl    TYPE tt_objsl,
          lt_objm     TYPE tt_objm,
          ls_tobj     TYPE ty_tobj,
          lv_type_pos TYPE i.

    lv_type_pos = strlen( ms_item-obj_name ) - 1.

    ls_objh-objectname = ms_item-obj_name(lv_type_pos).
    ls_objh-objecttype = ms_item-obj_name+lv_type_pos.

    CALL FUNCTION 'CTO_OBJECT_GET'
      EXPORTING
        iv_objectname      = ls_objh-objectname
        iv_objecttype      = ls_objh-objecttype
        iv_language        = mv_language
        iv_sel_objt        = abap_true
        iv_sel_objs        = abap_true
        iv_sel_objsl       = abap_true
        iv_sel_objm        = abap_true
      IMPORTING
        es_objh            = ls_objh
        es_objt            = ls_objt
      TABLES
        tt_objs            = lt_objs
        tt_objsl           = lt_objsl
        tt_objm            = lt_objm
      EXCEPTIONS
        object_not_defined = 1
        OTHERS             = 2.
    IF sy-subrc = 1.
      RETURN.
    ELSEIF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    CLEAR: ls_objh-luser,
           ls_objh-ldate.

    SORT lt_objs BY objectname objecttype tabname.
    SORT lt_objsl BY objectname objecttype trwcount.
    SORT lt_objm BY objectname objecttype method.

    io_xml->add( iv_name = 'OBJH'
                 ig_data = ls_objh ).
    io_xml->add( iv_name = 'OBJT'
                 ig_data = ls_objt ).
    io_xml->add( iv_name = 'OBJS'
                 ig_data = lt_objs ).
    io_xml->add( iv_name = 'OBJSL'
                 ig_data = lt_objsl ).
    io_xml->add( iv_name = 'OBJM'
                 ig_data = lt_objm ).

    ls_tobj = read_extra( ls_objh-objectname ).

    IF ls_tobj-tvdir-detail = ``.
      " to prevent xslt serialization error,
      " force clear if numc field is empty
      CLEAR ls_tobj-tvdir-detail.
    ENDIF.

    io_xml->add( iv_name = 'TOBJ'
                 ig_data = ls_tobj ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_tran IMPLEMENTATION.

  METHOD add_data.

    DATA: ls_bcdata LIKE LINE OF mt_bcdata.

    ls_bcdata-fnam = iv_fnam.
    ls_bcdata-fval = iv_fval.
    APPEND ls_bcdata TO mt_bcdata.

  ENDMETHOD.

  METHOD call_se93.

    DATA: lt_message TYPE STANDARD TABLE OF bdcmsgcoll.
    DATA lv_msg TYPE string.

    FIELD-SYMBOLS: <ls_message> TYPE bdcmsgcoll.

    CALL FUNCTION 'ABAP4_CALL_TRANSACTION'
      EXPORTING
        tcode     = 'SE93'
        mode_val  = 'N'
      TABLES
        using_tab = mt_bcdata
        mess_tab  = lt_message
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Error deserializing { ms_item-obj_type } { ms_item-obj_name }| ).
    ENDIF.

    LOOP AT lt_message ASSIGNING <ls_message> WHERE msgtyp CA 'EAX'.
      MESSAGE ID <ls_message>-msgid
        TYPE <ls_message>-msgtyp
        NUMBER <ls_message>-msgnr
        WITH <ls_message>-msgv1 <ls_message>-msgv2 <ls_message>-msgv3 <ls_message>-msgv4
        INTO lv_msg.
      zcx_abapgit_exception=>raise_t100( ).
    ENDLOOP.

  ENDMETHOD.

  METHOD clear_functiongroup_globals.
    TYPES ty_param_vari TYPE abap_bool.

    DATA lt_error_list TYPE STANDARD TABLE OF rsmp_check WITH DEFAULT KEY.
    FIELD-SYMBOLS <lv_param_vari> TYPE ty_param_vari.

    " only way to clear global fields in function group
    CALL FUNCTION 'RS_TRANSACTION_INCONSISTENCIES'
      EXPORTING
        transaction_code = 'ZTHISTCODENEVEREXIST'
      TABLES
        error_list       = lt_error_list
      EXCEPTIONS
        object_not_found = 1
        OTHERS           = 2.
    IF sy-subrc <> 0.
      "Expected - fine

      " but there is no other way to clear this field
      ASSIGN ('(SAPLSEUK)PARAM_VARI') TO <lv_param_vari>.
      IF sy-subrc = 0.
        CLEAR <lv_param_vari>.
      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD deserialize_oo_transaction.

    " You should remember that we don't use batch input just for fun,
    " but because FM RPY_TRANSACTION_INSERT doesn't support OO transactions.

    DATA: ls_bcdata  TYPE bdcdata.

    CLEAR mt_bcdata.

    ls_bcdata-program  = 'SAPLSEUK'.
    ls_bcdata-dynpro   = '0390'.
    ls_bcdata-dynbegin = 'X'.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam = 'TSTC-TCODE'
              iv_fval = is_tstc-tcode ).

    IF zif_abapgit_object~exists( ) = abap_true.

      add_data( iv_fnam = 'BDC_OKCODE'
                iv_fval = '=CHNG' ).

    ELSE.

      add_data( iv_fnam = 'BDC_OKCODE'
                iv_fval = '=ADD' ).

    ENDIF.

    ls_bcdata-program  = 'SAPLSEUK'.
    ls_bcdata-dynpro   = '0300'.
    ls_bcdata-dynbegin = 'X'.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam     = 'TSTCT-TTEXT'
              iv_fval     = is_tstct-ttext ).

    add_data( iv_fnam     = 'RSSTCD-S_CLASS'
              iv_fval     = 'X' ).

    add_data( iv_fnam = 'BDC_OKCODE'
              iv_fval = '=ENTR' ).

    ls_bcdata-program  = 'SAPLSEUK'.
    ls_bcdata-dynpro   = '0360'.
    ls_bcdata-dynbegin = 'X'.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam     = 'RSSTCD-S_TRFRAME'
              iv_fval     = is_rsstcd-s_trframe ).

    add_data( iv_fnam     = 'RSSTCD-S_UPDTASK'
              iv_fval     = is_rsstcd-s_updtask ).

    add_data( iv_fnam = 'BDC_OKCODE'
              iv_fval = '=TR_FRAMEWORK' ).

    ls_bcdata-program  = 'SAPLSEUK'.
    ls_bcdata-dynpro   = '0360'.
    ls_bcdata-dynbegin = 'X'.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam     = 'RSSTCD-CLASSNAME'
              iv_fval     = is_rsstcd-classname ).

    add_data( iv_fnam     = 'RSSTCD-METHOD'
              iv_fval     = is_rsstcd-method ).

    IF is_rsstcd-s_local IS NOT INITIAL.
      add_data( iv_fnam     = 'RSSTCD-S_LOCAL'
                iv_fval     = is_rsstcd-s_local ).
    ENDIF.

    IF is_rsstcd-s_updlok IS NOT INITIAL.
      add_data( iv_fnam     = 'RSSTCD-S_UPDLOK'
                iv_fval     = is_rsstcd-s_updlok ).
    ENDIF.

    add_data( iv_fnam     = 'TSTC-PGMNA'
              iv_fval     = is_tstc-pgmna ).

    IF is_tstcc-s_webgui = '2'.

      add_data( iv_fnam     = 'G_IAC_EWT'
                iv_fval     = abap_true ).

      add_data( iv_fnam = 'BDC_OKCODE'
                iv_fval = 'MAKE_PROFI' ).

      ls_bcdata-program  = 'SAPLSEUK'.
      ls_bcdata-dynpro   = '0360'.
      ls_bcdata-dynbegin = 'X'.
      APPEND ls_bcdata TO mt_bcdata.

    ELSEIF is_tstcc-s_webgui IS NOT INITIAL.

      add_data( iv_fnam     = 'TSTCC-S_WEBGUI'
                iv_fval     = is_tstcc-s_webgui ).

    ENDIF.

    IF is_tstcc-s_pervas IS NOT INITIAL.
      add_data( iv_fnam     = 'TSTCC-S_PERVAS'
                iv_fval     = is_tstcc-s_pervas ).
    ENDIF.

    IF is_tstcc-s_service IS NOT INITIAL.
      add_data( iv_fnam     = 'TSTCC-S_SERVICE'
                iv_fval     = is_tstcc-s_service ).
    ENDIF.

    IF is_tstcc-s_platin IS NOT INITIAL.
      add_data( iv_fnam     = 'TSTCC-S_PLATIN'
                iv_fval     = is_tstcc-s_platin ).
    ENDIF.

    IF is_tstcc-s_win32 IS NOT INITIAL.
      add_data( iv_fnam     = 'TSTCC-S_WIN32'
                iv_fval     = is_tstcc-s_win32 ).
    ENDIF.

    add_data( iv_fnam = 'BDC_OKCODE'
              iv_fval = '=WB_SAVE' ).

    ls_bcdata-program  = 'SAPLSTRD'.
    ls_bcdata-dynpro   = '0100'.
    ls_bcdata-dynbegin = 'X'.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam     = 'KO007-L_DEVCLASS'
              iv_fval     = iv_package ).

    add_data( iv_fnam = 'BDC_OKCODE'
              iv_fval = '=ADD' ).

    ls_bcdata-program  = 'BDC_OKCODE'.
    ls_bcdata-dynpro   = '0360'.
    ls_bcdata-dynbegin = 'X'.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam = 'BDC_OKCODE'
              iv_fval = '=WB_BACK' ).

    ls_bcdata-program  = 'BDC_OKCODE'.
    ls_bcdata-dynpro   = '0360'.
    ls_bcdata-dynbegin = 'X'.
    APPEND ls_bcdata TO mt_bcdata.

    add_data( iv_fnam = 'BDC_OKCODE'
              iv_fval = '=WB_BACK' ).

    call_se93( ).

  ENDMETHOD.

  METHOD deserialize_texts.

    DATA lt_tpool_i18n TYPE TABLE OF tstct.

    FIELD-SYMBOLS <ls_tpool> LIKE LINE OF lt_tpool_i18n.

    " Read XML-files data
    ii_xml->read( EXPORTING iv_name = 'I18N_TPOOL'
                  CHANGING  cg_data = lt_tpool_i18n ).

    mo_i18n_params->trim_saplang_keyed_table(
      EXPORTING
        iv_lang_field_name = 'SPRSL'
      CHANGING
        ct_tab = lt_tpool_i18n ).

    " Force t-code name (security reasons)
    LOOP AT lt_tpool_i18n ASSIGNING <ls_tpool>.
      <ls_tpool>-tcode = ms_item-obj_name.
    ENDLOOP.

    IF lines( lt_tpool_i18n ) > 0.
      MODIFY tstct FROM TABLE lt_tpool_i18n.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( 'Update of t-code translations failed' ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD is_variant_transaction.

    rv_variant_transaction = boolc( is_tstcp-param(1) = '@' ).

  ENDMETHOD.

  METHOD save_authorizations.

    CONSTANTS: lc_hex_chk TYPE x VALUE '04'.
    DATA: ls_transaction TYPE tstc.

    transaction_read( EXPORTING iv_transaction = iv_transaction
                      IMPORTING es_transaction = ls_transaction ).

    DELETE FROM tstca WHERE tcode = iv_transaction.

    IF ls_transaction IS NOT INITIAL.
      INSERT tstca FROM TABLE it_authorizations.
      ls_transaction-cinfo = ls_transaction-cinfo + lc_hex_chk.
      UPDATE tstc SET cinfo = ls_transaction-cinfo WHERE tcode = ls_transaction-tcode.
    ENDIF.

  ENDMETHOD.

  METHOD serialize_texts.

    DATA lt_tpool_i18n TYPE TABLE OF tstct.

    IF mo_i18n_params->ms_params-main_language_only = abap_true.
      RETURN.
    ENDIF.

    " Skip main language - it was already serialized
    " Don't serialize t-code itself
    SELECT sprsl ttext
      INTO CORRESPONDING FIELDS OF TABLE lt_tpool_i18n
      FROM tstct
      WHERE sprsl <> mv_language
      AND   tcode = ms_item-obj_name
      ORDER BY sprsl ##TOO_MANY_ITAB_FIELDS.            "#EC CI_GENBUFF

    mo_i18n_params->trim_saplang_keyed_table(
      EXPORTING
        iv_lang_field_name = 'SPRSL'
      CHANGING
        ct_tab = lt_tpool_i18n ).

    IF lines( lt_tpool_i18n ) > 0.
      SORT lt_tpool_i18n BY sprsl ASCENDING.
      ii_xml->add( iv_name = 'I18N_TPOOL'
                   ig_data = lt_tpool_i18n ).
    ENDIF.

  ENDMETHOD.

  METHOD set_oo_parameters.

    DATA: ls_param LIKE LINE OF it_rsparam.

    IF cs_rsstcd-call_tcode = c_oo_tcode.
      cs_rsstcd-s_trframe = c_true.
      LOOP AT it_rsparam INTO ls_param.
        CASE ls_param-field.
          WHEN c_oo_frclass.
            cs_rsstcd-classname = ls_param-value.
          WHEN c_oo_frmethod.
            cs_rsstcd-method   = ls_param-value.
          WHEN c_oo_frupdtask.
            IF ls_param-value = c_oo_synchron.
              cs_rsstcd-s_upddir  = c_true.
              cs_rsstcd-s_updtask = c_false.
              cs_rsstcd-s_updlok  = c_false.
            ELSEIF ls_param-value = c_oo_asynchron.
              cs_rsstcd-s_upddir  = c_false.
              cs_rsstcd-s_updtask = c_true.
              cs_rsstcd-s_updlok  = c_false.
            ELSE.
              cs_rsstcd-s_upddir  = c_false.
              cs_rsstcd-s_updtask = c_false.
              cs_rsstcd-s_updlok  = c_true.
            ENDIF.
        ENDCASE.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.

  METHOD shift_param.

    DATA: ls_param  LIKE LINE OF ct_rsparam,
          lv_fdpos  TYPE sy-fdpos,
          lv_length TYPE i.

    FIELD-SYMBOLS <lg_f> TYPE any.

    DO 254 TIMES.
      IF cs_tstcp-param = space.
        EXIT.
      ENDIF.
      CLEAR ls_param.
      IF cs_tstcp-param CA '='.
        CHECK sy-fdpos <> 0.
        ASSIGN cs_tstcp-param(sy-fdpos) TO <lg_f>.
        ls_param-field = <lg_f>.
        IF ls_param-field(1) = space.
          SHIFT ls_param-field.
        ENDIF.
        lv_fdpos = sy-fdpos + 1.
        SHIFT cs_tstcp-param BY lv_fdpos PLACES.
        IF cs_tstcp-param CA ';'.
          IF sy-fdpos <> 0.
            ASSIGN cs_tstcp-param(sy-fdpos) TO <lg_f>.
            ls_param-value = <lg_f>.
            IF ls_param-value(1) = space.
              SHIFT ls_param-value.
            ENDIF.
          ENDIF.
          lv_fdpos = sy-fdpos + 1.
          SHIFT cs_tstcp-param BY lv_fdpos PLACES.
          APPEND ls_param TO ct_rsparam.
        ELSE.
          lv_length = strlen( cs_tstcp-param ).
          CHECK lv_length > 0.
          ASSIGN cs_tstcp-param(lv_length) TO <lg_f>.
          ls_param-value = <lg_f>.
          IF ls_param-value(1) = space.
            SHIFT ls_param-value.
          ENDIF.
          lv_length = lv_length + 1.
          SHIFT cs_tstcp-param BY lv_length PLACES.
          APPEND ls_param TO ct_rsparam.
        ENDIF.
      ENDIF.
    ENDDO.

  ENDMETHOD.

  METHOD split_parameters.
* see subroutine split_parameters in include LSEUKF01

    DATA: lv_off       TYPE i,
          lv_fdpos     TYPE sy-fdpos,
          lv_param_beg TYPE i.

    CLEAR cs_rsstcd-s_vari.

    IF cs_tstcp-param(1) = '\'.             " OO-Transaction without FR
      split_parameters_comp( EXPORTING ig_type = c_oo_program
                                       ig_param = cs_tstcp-param
                             CHANGING  cg_value = cs_tstc-pgmna ).
      split_parameters_comp( EXPORTING ig_type = c_oo_class
                                       ig_param = cs_tstcp-param
                             CHANGING  cg_value = cs_rsstcd-classname ).
      split_parameters_comp( EXPORTING ig_type = c_oo_method
                                       ig_param = cs_tstcp-param
                             CHANGING  cg_value = cs_rsstcd-method ).

      IF NOT cs_tstc-pgmna IS INITIAL.
        cs_rsstcd-s_local = c_true.
      ENDIF.
      RETURN.
    ELSEIF cs_tstcp-param(1) = '@'.         " Transaction variant
      cs_rsstcd-s_vari = c_true.
      IF cs_tstcp-param(2) = '@@'.
        cs_rsstcd-s_ind_vari = c_true.
        lv_off = 2.
      ELSE.
        CLEAR cs_rsstcd-s_ind_vari.
        lv_off = 1.
      ENDIF.
      IF cs_tstcp-param CA ' '.
      ENDIF.
      lv_fdpos = sy-fdpos - lv_off.
      IF lv_fdpos > 0.
        cs_rsstcd-call_tcode = cs_tstcp-param+lv_off(sy-fdpos).
        lv_fdpos = lv_fdpos + 1 + lv_off.
        cs_rsstcd-variant = cs_tstcp-param+lv_fdpos.
      ENDIF.
    ELSEIF cs_tstcp-param(1) = '/'.
      cs_rsstcd-st_tcode = c_true.
      cs_rsstcd-st_prog  = space.
      IF cs_tstcp-param+1(1) = '*'.
        cs_rsstcd-st_skip_1 = c_true.
      ELSE.
        CLEAR cs_rsstcd-st_skip_1.
      ENDIF.
      IF cs_tstcp-param CA ' '.
      ENDIF.
      lv_param_beg = sy-fdpos + 1.
      lv_fdpos = sy-fdpos - 2.
      IF lv_fdpos > 0.
        cs_rsstcd-call_tcode = cs_tstcp-param+2(lv_fdpos).
      ENDIF.
      SHIFT cs_tstcp-param BY lv_param_beg PLACES.
    ELSE.
      cs_rsstcd-st_tcode = space.
      cs_rsstcd-st_prog  = c_true.
    ENDIF.

    shift_param(
      CHANGING ct_rsparam = ct_rsparam
               cs_tstcp   = cs_tstcp ).

    set_oo_parameters(
      EXPORTING it_rsparam = ct_rsparam
      CHANGING cs_rsstcd = cs_rsstcd ).

  ENDMETHOD.

  METHOD split_parameters_comp.
    DATA: lv_off TYPE i.

    IF ig_param CS ig_type.
      lv_off = sy-fdpos + strlen( ig_type ).
      cg_value = ig_param+lv_off.
      IF cg_value CA '\'.
        CLEAR cg_value+sy-fdpos.
      ENDIF.
    ENDIF.
  ENDMETHOD.

  METHOD transaction_read.

    DATA: lt_tcodes   TYPE TABLE OF tstc,
          lt_gui_attr TYPE TABLE OF tstcc.

    CLEAR: es_transaction, es_gui_attr.

    CALL FUNCTION 'RPY_TRANSACTION_READ'
      EXPORTING
        transaction      = iv_transaction
      TABLES
        tcodes           = lt_tcodes
        gui_attributes   = lt_gui_attr
      EXCEPTIONS
        permission_error = 1
        cancelled        = 2
        not_found        = 3
        object_not_found = 4
        OTHERS           = 5.
    IF sy-subrc = 4 OR sy-subrc = 3.
      RETURN.
    ELSEIF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    READ TABLE lt_tcodes INDEX 1 INTO es_transaction.
    ASSERT sy-subrc = 0.
    READ TABLE lt_gui_attr INDEX 1 INTO es_gui_attr.
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.
    " Changed-by-user is not stored in transaction metadata
    " Instead, use owner of last transport or object directory

    DATA lv_transport TYPE trkorr.

    lv_transport = zcl_abapinst_factory=>get_cts_api( )->get_transport_for_object( ms_item ).

    IF lv_transport IS NOT INITIAL.
      SELECT SINGLE as4user FROM e070 INTO rv_user WHERE trkorr = lv_transport.
    ELSE.
      SELECT SINGLE author FROM tadir INTO rv_user
        WHERE pgmid = 'R3TR' AND object = ms_item-obj_type AND obj_name = ms_item-obj_name.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    DATA: lv_transaction TYPE tstc-tcode.

    lv_transaction = ms_item-obj_name.

    CALL FUNCTION 'RPY_TRANSACTION_DELETE'
      EXPORTING
        transaction      = lv_transaction
      EXCEPTIONS
        not_excecuted    = 1
        object_not_found = 0
        OTHERS           = 3.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    CONSTANTS: lc_hex_tra TYPE x VALUE '00',
*               lc_hex_men TYPE x VALUE '01',
               lc_hex_par TYPE x VALUE '02',
               lc_hex_rep TYPE x VALUE '80',
*               lc_hex_rpv TYPE x VALUE '10',
               lc_hex_obj TYPE x VALUE '08'.

    DATA: lv_dynpro       TYPE d020s-dnum,
          ls_tstc         TYPE tstc,
          lv_type         TYPE rglif-docutype,
          ls_tstct        TYPE tstct,
          ls_tstcc        TYPE tstcc,
          ls_tstcp        TYPE tstcp,
          lt_tstca        TYPE ty_tstca,
          lt_param_values TYPE ty_param_values,
          ls_rsstcd       TYPE rsstcd.

    IF zif_abapgit_object~exists( ) = abap_true.
      zif_abapgit_object~delete( iv_package   = iv_package
                                 iv_transport = iv_transport ).
    ENDIF.

    io_xml->read( EXPORTING iv_name = 'TSTC'
                  CHANGING cg_data = ls_tstc ).
    io_xml->read( EXPORTING iv_name = 'TSTCC'
                  CHANGING cg_data = ls_tstcc ).
    io_xml->read( EXPORTING iv_name = 'TSTCT'
                  CHANGING cg_data = ls_tstct ).
    io_xml->read( EXPORTING iv_name = 'TSTCP'
                  CHANGING cg_data = ls_tstcp ).
    io_xml->read( EXPORTING iv_name = 'AUTHORIZATIONS'
                  CHANGING cg_data = lt_tstca ).

    lv_dynpro = ls_tstc-dypno.

    IF ls_tstc-cinfo O lc_hex_rep.
      lv_type = c_variant_type-report.
    ELSEIF ls_tstc-cinfo O lc_hex_obj.
      lv_type = c_variant_type-object.
    ELSEIF ls_tstc-cinfo O lc_hex_par.
      IF is_variant_transaction( ls_tstcp ) = abap_true.
        lv_type = c_variant_type-variant.
      ELSE.
        lv_type = c_variant_type-parameters.
      ENDIF.
    ELSEIF ls_tstc-cinfo O lc_hex_tra.
      lv_type = c_variant_type-dialog.
    ELSE.
      zcx_abapgit_exception=>raise( 'Transaction, unknown CINFO' ).
    ENDIF.

    IF ls_tstcp IS NOT INITIAL.
      split_parameters( CHANGING ct_rsparam = lt_param_values
                                 cs_rsstcd  = ls_rsstcd
                                 cs_tstcp   = ls_tstcp
                                 cs_tstc    = ls_tstc ).
    ENDIF.

    CASE lv_type.
      WHEN c_variant_type-object.

        deserialize_oo_transaction( iv_package      = iv_package
                                    is_tstc         = ls_tstc
                                    is_tstcc        = ls_tstcc
                                    is_tstct        = ls_tstct
                                    is_rsstcd       = ls_rsstcd ).

      WHEN OTHERS.

        clear_functiongroup_globals( ).

        corr_insert( iv_package ).

        CALL FUNCTION 'RPY_TRANSACTION_INSERT'
          EXPORTING
            transaction             = ls_tstc-tcode
            program                 = ls_tstc-pgmna
            dynpro                  = lv_dynpro
            language                = mv_language
            development_class       = iv_package
            transaction_type        = lv_type
            shorttext               = ls_tstct-ttext
            called_transaction      = ls_rsstcd-call_tcode
            called_transaction_skip = ls_rsstcd-st_skip_1
            variant                 = ls_rsstcd-variant
            cl_independend          = ls_rsstcd-s_ind_vari
            html_enabled            = ls_tstcc-s_webgui
            java_enabled            = ls_tstcc-s_platin
            wingui_enabled          = ls_tstcc-s_win32
            suppress_corr_insert    = abap_true
          TABLES
            param_values            = lt_param_values
          EXCEPTIONS
            cancelled               = 1
            already_exist           = 2
            permission_error        = 3
            name_not_allowed        = 4
            name_conflict           = 5
            illegal_type            = 6
            object_inconsistent     = 7
            db_access_error         = 8
            OTHERS                  = 9.
        IF sy-subrc <> 0.
          zcx_abapgit_exception=>raise_t100( ).
        ENDIF.

    ENDCASE.

    IF lt_tstca IS NOT INITIAL.
      save_authorizations( iv_transaction    = ls_tstc-tcode
                           it_authorizations = lt_tstca ).
    ENDIF.

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      deserialize_texts( io_xml ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_tcode TYPE tstc-tcode.

    SELECT SINGLE tcode FROM tstc INTO lv_tcode
      WHERE tcode = ms_item-obj_name.                   "#EC CI_GENBUFF
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.
    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = 'EEUDB'
                                            iv_argument    = ms_item-obj_name
                                            iv_prefix      = 'TN' ).
  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA: lt_bdcdata TYPE TABLE OF bdcdata.

    FIELD-SYMBOLS: <ls_bdcdata> LIKE LINE OF lt_bdcdata.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING <ls_bdcdata>.
    <ls_bdcdata>-program  = 'SAPLSEUK'.
    <ls_bdcdata>-dynpro   = '0390'.
    <ls_bdcdata>-dynbegin = abap_true.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING <ls_bdcdata>.
    <ls_bdcdata>-fnam = 'BDC_OKCODE'.
    <ls_bdcdata>-fval = '=SHOW'.

    APPEND INITIAL LINE TO lt_bdcdata ASSIGNING <ls_bdcdata>.
    <ls_bdcdata>-fnam = 'TSTC-TCODE'.
    <ls_bdcdata>-fval = ms_item-obj_name.

    zcl_abapgit_objects_factory=>get_gui_jumper( )->jump_batch_input(
      iv_tcode      = 'SE93'
      it_bdcdata    = lt_bdcdata ).

    rv_exit = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_transaction TYPE tstc-tcode,
          ls_tcode       TYPE tstc,
          ls_tstct       TYPE tstct,
          ls_tstcp       TYPE tstcp,
          lt_tstca       TYPE ty_tstca,
          ls_gui_attr    TYPE tstcc.

    lv_transaction = ms_item-obj_name.

    transaction_read( EXPORTING iv_transaction = lv_transaction
                      IMPORTING es_transaction = ls_tcode
                                es_gui_attr    = ls_gui_attr ).
    IF ls_tcode IS INITIAL.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM tstct INTO ls_tstct
      WHERE sprsl = mv_language
      AND tcode = lv_transaction.         "#EC CI_SUBRC "#EC CI_GENBUFF

    SELECT SINGLE * FROM tstcp INTO ls_tstcp
      WHERE tcode = lv_transaction.       "#EC CI_SUBRC "#EC CI_GENBUFF

    SELECT * FROM tstca INTO TABLE lt_tstca
      WHERE tcode = lv_transaction
      ORDER BY PRIMARY KEY.
    IF sy-subrc <> 0.
      CLEAR: lt_tstca.
    ENDIF.

    io_xml->add( iv_name = 'TSTC'
                 ig_data = ls_tcode ).
    io_xml->add( iv_name = 'TSTCC'
                 ig_data = ls_gui_attr ).
    io_xml->add( iv_name = 'TSTCT'
                 ig_data = ls_tstct ).
    IF ls_tstcp IS NOT INITIAL.
      io_xml->add( iv_name = 'TSTCP'
                   ig_data = ls_tstcp ).
    ENDIF.
    io_xml->add( iv_name = 'AUTHORIZATIONS'
                 ig_data = lt_tstca ).

    IF mo_i18n_params->is_lxe_applicable( ) = abap_false.
      serialize_texts( io_xml ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_ttyp IMPLEMENTATION.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE as4user FROM dd40l INTO rv_user
      WHERE typename = ms_item-obj_name
      AND as4local = 'A'.
    IF sy-subrc <> 0.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    IF zif_abapgit_object~exists( ) = abap_false.
      RETURN.
    ENDIF.

    delete_ddic( 'A' ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA: lv_name  TYPE ddobjname,
          lt_dd42v TYPE dd42v_tab,
          lt_dd43v TYPE dd43v_tab,
          ls_dd40v TYPE dd40v,
          lv_msg   TYPE string.

    io_xml->read( EXPORTING iv_name = 'DD40V'
                  CHANGING cg_data = ls_dd40v ).

    io_xml->read( EXPORTING iv_name = 'DD42V'
                  CHANGING cg_data = lt_dd42v ).
    io_xml->read( EXPORTING iv_name = 'DD43V'
                  CHANGING cg_data = lt_dd43v ).

    corr_insert( iv_package = iv_package
                 ig_object_class = 'DICT' ).

    lv_name = ms_item-obj_name. " type conversion

    CALL FUNCTION 'DDIF_TTYP_PUT'
      EXPORTING
        name              = lv_name
        dd40v_wa          = ls_dd40v
      TABLES
        dd42v_tab         = lt_dd42v
        dd43v_tab         = lt_dd43v
      EXCEPTIONS
        ttyp_not_found    = 1
        name_inconsistent = 2
        ttyp_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.

    IF sy-subrc <> 0.
      lv_msg = |Error in DDIF_TTYP_PUT on object { lv_name }|.

      CASE sy-subrc.
        WHEN 1.
          lv_msg = lv_msg && | (TTYP_NOT_FOUND)|.
        WHEN 2.
          lv_msg = lv_msg && | (NAME_INCONSISTENT)|.
        WHEN 3.
          lv_msg = lv_msg && | (TTYP_INCONSISTENT)|.
        WHEN 4.
          lv_msg = lv_msg && | (PUT_FAILURE)|.
        WHEN 5.
          lv_msg = lv_msg && | (PUT_REFUSED)|.
        WHEN OTHERS.
      ENDCASE.

      zcx_abapgit_exception=>raise( lv_msg ).
    ENDIF.

    deserialize_longtexts( ii_xml         = io_xml
                           iv_longtext_id = c_longtext_id_ttyp ).

    zcl_abapgit_objects_activation=>add_item( ms_item ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    DATA: lv_typename TYPE dd40l-typename.

    SELECT SINGLE typename FROM dd40l INTO lv_typename
      WHERE typename = ms_item-obj_name.
    rv_bool = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-ddic TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata = get_metadata( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = 'ESDICT'
                                            iv_argument    = |{ ms_item-obj_type }{ ms_item-obj_name }| ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.
    " Covered by ZCL_ABAPGIT_OBJECT=>JUMP
  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA: lv_name  TYPE ddobjname,
          lv_state TYPE ddgotstate,
          lt_dd42v TYPE dd42v_tab,
          lt_dd43v TYPE dd43v_tab,
          ls_dd40v TYPE dd40v.

    lv_name = ms_item-obj_name.

    CALL FUNCTION 'DDIF_TTYP_GET'
      EXPORTING
        name          = lv_name
        state         = 'A'
        langu         = mv_language
      IMPORTING
        gotstate      = lv_state
        dd40v_wa      = ls_dd40v
      TABLES
        dd42v_tab     = lt_dd42v
        dd43v_tab     = lt_dd43v
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    IF ls_dd40v IS INITIAL OR lv_state <> 'A'.
      RETURN.
    ENDIF.

    CLEAR: ls_dd40v-as4user,
           ls_dd40v-as4date,
           ls_dd40v-as4time.

    IF NOT ls_dd40v-rowkind IS INITIAL.
      CLEAR ls_dd40v-typelen.
    ENDIF.

    io_xml->add( iv_name = 'DD40V'
                 ig_data = ls_dd40v ).
    io_xml->add( iv_name = 'DD42V'
                 ig_data = lt_dd42v ).
    io_xml->add( iv_name = 'DD43V'
                 ig_data = lt_dd43v ).

    serialize_longtexts( ii_xml         = io_xml
                         iv_longtext_id = c_longtext_id_ttyp ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_w3xx_super IMPLEMENTATION.

  METHOD constructor.

    super->constructor(
      is_item        = is_item
      iv_language    = iv_language
      io_files       = io_files
      io_i18n_params = io_i18n_params ).

    ms_key-relid = ms_item-obj_type+2(2).
    ms_key-objid = ms_item-obj_name.

  ENDMETHOD.

  METHOD find_param.

    FIELD-SYMBOLS <ls_param> LIKE LINE OF it_params.

    READ TABLE it_params ASSIGNING <ls_param> WITH KEY name = iv_name.
    IF sy-subrc > 0.
      zcx_abapgit_exception=>raise( |W3xx: Cannot find { iv_name } for { ms_key-objid }| ).
    ENDIF.

    rv_value = <ls_param>-value.

  ENDMETHOD.

  METHOD get_ext.

    rv_ext = find_param( it_params = it_params
                         iv_name = c_param_names-fileext ).
    SHIFT rv_ext LEFT DELETING LEADING '.'.

  ENDMETHOD.

  METHOD normalize_params.

    FIELD-SYMBOLS <ls_param> LIKE LINE OF ct_params.

    " Ensure filesize param exists
    READ TABLE ct_params ASSIGNING <ls_param> WITH KEY name = c_param_names-filesize.
    IF sy-subrc <> 0.
      APPEND INITIAL LINE TO ct_params ASSIGNING <ls_param>.
      <ls_param>-name  = c_param_names-filesize.
    ENDIF.

    LOOP AT ct_params ASSIGNING <ls_param>.
      <ls_param>-relid = ms_key-relid. " Ensure param key = object key
      <ls_param>-objid = ms_key-objid.
      IF <ls_param>-name = c_param_names-filesize. " Patch filesize = real file size
        <ls_param>-value = iv_size.
        CONDENSE <ls_param>-value.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD strip_params.

    FIELD-SYMBOLS <ls_param> LIKE LINE OF ct_params.

    " Remove path from filename
    find_param( it_params = ct_params
                iv_name = c_param_names-filename ). " Check exists
    READ TABLE ct_params ASSIGNING <ls_param> WITH KEY name = c_param_names-filename.
    <ls_param>-value = zcl_abapgit_path=>get_filename_from_syspath( |{ <ls_param>-value }| ).

    " Clear id and object name
    LOOP AT ct_params ASSIGNING <ls_param>.
      CLEAR: <ls_param>-relid, <ls_param>-objid.
    ENDLOOP.

    " Clear version & filesize
    DELETE ct_params WHERE name = c_param_names-version.
    DELETE ct_params WHERE name = c_param_names-filesize.

    " Avoid diffs due to different order
    SORT ct_params.

  ENDMETHOD.

  METHOD zif_abapgit_object~changed_by.

    SELECT SINGLE chname INTO rv_user
      FROM wwwdata
      WHERE relid = ms_key-relid
      AND objid = ms_key-objid
      AND srtf2 = 0.

    IF sy-subrc IS NOT INITIAL OR rv_user IS INITIAL.
      rv_user = c_user_unknown.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_object~delete.

    CALL FUNCTION 'WWWDATA_DELETE'
      EXPORTING
        key               = ms_key
      EXCEPTIONS
        wrong_object_type = 1
        delete_error      = 2.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=>raise( 'Cannot delete W3xx data' ).
    ENDIF.

    CALL FUNCTION 'WWWPARAMS_DELETE_ALL'
      EXPORTING
        key          = ms_key
      EXCEPTIONS
        delete_error = 1.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=>raise( 'Cannot delete W3xx params' ).
    ENDIF.

    corr_insert( iv_package ).

  ENDMETHOD.

  METHOD zif_abapgit_object~deserialize.

    DATA lv_base64str TYPE string.
    DATA lt_w3params  TYPE STANDARD TABLE OF wwwparams.
    DATA lv_xstring   TYPE xstring.
    DATA lt_w3mime    TYPE STANDARD TABLE OF w3mime.
    DATA lt_w3html    TYPE STANDARD TABLE OF w3html.
    DATA lv_size      TYPE i.

    io_xml->read( EXPORTING iv_name = 'TEXT'
                  CHANGING  cg_data = ms_key-text ).

    io_xml->read( EXPORTING iv_name = 'PARAMS'
                  CHANGING  cg_data = lt_w3params ).

    CASE io_xml->get_metadata( )-version.
      WHEN 'v1.0.0'.
        io_xml->read( EXPORTING iv_name = 'DATA'
                      CHANGING  cg_data = lv_base64str ).
        lv_xstring = cl_http_utility=>decode_x_base64( lv_base64str ).
      WHEN 'v2.0.0'.
        lv_xstring = mo_files->read_raw( iv_extra = 'data'
                                         iv_ext   = get_ext( lt_w3params ) ).
      WHEN OTHERS.
        zcx_abapgit_exception=>raise( 'W3xx: Unknown serializer version' ).
    ENDCASE.

    CASE ms_key-relid.
      WHEN 'MI'.
        CALL FUNCTION 'SCMS_XSTRING_TO_BINARY'
          EXPORTING
            buffer        = lv_xstring
          IMPORTING
            output_length = lv_size
          TABLES
            binary_tab    = lt_w3mime.
      WHEN 'HT'.
        CALL FUNCTION 'SCMS_XSTRING_TO_BINARY'
          EXPORTING
            buffer        = lv_xstring
          IMPORTING
            output_length = lv_size
          TABLES
            binary_tab    = lt_w3mime.

        CALL FUNCTION 'SCMS_BINARY_TO_TEXT'
          EXPORTING
            input_length  = lv_size
          IMPORTING
            output_length = lv_size
          TABLES
            binary_tab    = lt_w3mime
            text_tab      = lt_w3html
          EXCEPTIONS
            failed        = 1.
        IF sy-subrc IS NOT INITIAL.
          zcx_abapgit_exception=>raise( 'Cannot update W3xx params' ).
        ENDIF.

        CLEAR lt_w3mime.
      WHEN OTHERS.
        zcx_abapgit_exception=>raise( 'Wrong W3xx type' ).
    ENDCASE.

    " Update size of file based on actual data file size, prove param object name
    normalize_params( EXPORTING iv_size   = lv_size
                      CHANGING  ct_params = lt_w3params ).

    CALL FUNCTION 'WWWPARAMS_UPDATE'
      TABLES
        params       = lt_w3params
      EXCEPTIONS
        update_error = 1.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=>raise( 'Cannot update W3xx params' ).
    ENDIF.

    ms_key-tdate    = sy-datum.
    ms_key-ttime    = sy-uzeit.
    ms_key-chname   = sy-uname.
    ms_key-devclass = iv_package.

    CALL FUNCTION 'WWWDATA_EXPORT'
      EXPORTING
        key               = ms_key
      TABLES
        mime              = lt_w3mime
        html              = lt_w3html
      EXCEPTIONS
        wrong_object_type = 1
        export_error      = 2.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=>raise( 'Cannot upload W3xx data' ).
    ENDIF.

    tadir_insert( iv_package ).

    corr_insert( iv_package ).

  ENDMETHOD.

  METHOD zif_abapgit_object~exists.

    SELECT SINGLE objid INTO ms_key-objid
      FROM wwwdata
      WHERE relid = ms_key-relid
      AND objid = ms_key-objid
      AND srtf2 = 0.

    IF sy-subrc IS NOT INITIAL.
      RETURN.
    ENDIF.

    rv_bool = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_object~get_comparator.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_order.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_deserialize_steps.
    APPEND zif_abapgit_object=>gc_step_id-abap TO rt_steps.
  ENDMETHOD.

  METHOD zif_abapgit_object~get_metadata.
    rs_metadata         = get_metadata( ).
    rs_metadata-version = 'v2.0.0'. " Serialization v2, separate data file
  ENDMETHOD.

  METHOD zif_abapgit_object~is_active.
    rv_active = is_active( ).
  ENDMETHOD.

  METHOD zif_abapgit_object~is_locked.

    DATA: lv_object TYPE eqegraarg.

    lv_object = |{ ms_item-obj_type+2(2) }{ ms_item-obj_name }|.
    OVERLAY lv_object WITH '                                          '.
    lv_object = lv_object && '*'.

    rv_is_locked = exists_a_lock_entry_for( iv_lock_object = 'E_WWW_HTML'
                                            iv_argument    = lv_object ).

  ENDMETHOD.

  METHOD zif_abapgit_object~jump.

    DATA: ls_bdcdata TYPE bdcdata,
          lt_bdcdata TYPE ty_bdcdata.

    ls_bdcdata-program  = 'SAPMWWW0'.
    ls_bdcdata-dynpro   = '0100'.
    ls_bdcdata-dynbegin = 'X'.
    APPEND ls_bdcdata TO lt_bdcdata.

    change_bdc_jump_data( CHANGING ct_bdcdata = lt_bdcdata ).

    CLEAR ls_bdcdata.
    ls_bdcdata-fnam = 'BDC_OKCODE'.
    ls_bdcdata-fval = '=CRO1'.
    APPEND ls_bdcdata TO lt_bdcdata.

    ls_bdcdata-program  = 'RSWWWSHW'.
    ls_bdcdata-dynpro   = '1000'.
    ls_bdcdata-dynbegin = 'X'.
    APPEND ls_bdcdata TO lt_bdcdata.

    CLEAR ls_bdcdata.
    ls_bdcdata-fnam     = 'SO_OBJID-LOW'.
    ls_bdcdata-fval     = ms_item-obj_name.
    APPEND ls_bdcdata TO lt_bdcdata.

    CLEAR ls_bdcdata.
    ls_bdcdata-fnam = 'BDC_OKCODE'.
    ls_bdcdata-fval = '=ONLI'.
    APPEND ls_bdcdata TO lt_bdcdata.

    zcl_abapgit_objects_factory=>get_gui_jumper( )->jump_batch_input(
      iv_tcode   = 'SMW0'
      it_bdcdata = lt_bdcdata ).

    rv_exit = abap_true.

  ENDMETHOD.

  METHOD zif_abapgit_object~map_filename_to_object.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~map_object_to_filename.
    RETURN.
  ENDMETHOD.

  METHOD zif_abapgit_object~serialize.

    DATA lt_w3mime    TYPE STANDARD TABLE OF w3mime.
    DATA lt_w3html    TYPE STANDARD TABLE OF w3html.
    DATA lt_w3params  TYPE STANDARD TABLE OF wwwparams.
    DATA lv_xstring   TYPE xstring.
    DATA lv_size      TYPE i.

    SELECT SINGLE * INTO CORRESPONDING FIELDS OF ms_key
      FROM wwwdata
      WHERE relid = ms_key-relid
      AND objid = ms_key-objid
      AND srtf2 = 0.

    IF sy-subrc IS NOT INITIAL.
      RETURN.
    ENDIF.

    CALL FUNCTION 'WWWDATA_IMPORT'
      EXPORTING
        key               = ms_key
      TABLES
        mime              = lt_w3mime
        html              = lt_w3html
      EXCEPTIONS
        wrong_object_type = 1
        import_error      = 2.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=>raise( 'Cannot read W3xx data' ).
    ENDIF.

    CALL FUNCTION 'WWWPARAMS_READ_ALL'
      EXPORTING
        type             = ms_key-relid
        objid            = ms_key-objid
      TABLES
        params           = lt_w3params
      EXCEPTIONS
        entry_not_exists = 1.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=>raise( 'Cannot read W3xx data' ).
    ENDIF.

    lv_size = find_param( it_params = lt_w3params
                          iv_name = c_param_names-filesize ).
    " Clean params (remove version, filesize & clear filename from path)
    strip_params( CHANGING  ct_params = lt_w3params ).

    CASE ms_key-relid.
      WHEN 'MI'.
        CALL FUNCTION 'SCMS_BINARY_TO_XSTRING'
          EXPORTING
            input_length = lv_size
          IMPORTING
            buffer       = lv_xstring
          TABLES
            binary_tab   = lt_w3mime
          EXCEPTIONS
            failed       = 1.
      WHEN 'HT'.
        CALL FUNCTION 'SCMS_TEXT_TO_XSTRING'
          IMPORTING
            buffer   = lv_xstring
          TABLES
            text_tab = lt_w3html
          EXCEPTIONS
            failed   = 1.
      WHEN OTHERS.
        zcx_abapgit_exception=>raise( 'Wrong W3xx type' ).
    ENDCASE.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=>raise( 'Cannot convert W3xx to xstring' ).
    ENDIF.

    io_xml->add( iv_name = 'NAME'
                 ig_data = ms_key-objid ).

    io_xml->add( iv_name = 'TEXT'
                 ig_data = ms_key-text ).

    SORT lt_w3params.

    io_xml->add( iv_name = 'PARAMS'
                 ig_data = lt_w3params ).

    " Serialization v2, separate data file. 'extra' added to prevent conflict with .xml
    mo_files->add_raw( iv_data  = lv_xstring
                       iv_extra = 'data'
                       iv_ext   = get_ext( lt_w3params ) ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_w3ht IMPLEMENTATION.

  METHOD change_bdc_jump_data.

    DATA: ls_bdcdata LIKE LINE OF ct_bdcdata.

    ls_bdcdata-fnam = 'RADIO_HT'.
    ls_bdcdata-fval = 'X'.
    APPEND ls_bdcdata TO ct_bdcdata.

    CLEAR ls_bdcdata.
    ls_bdcdata-fnam = 'RADIO_MI'.
    ls_bdcdata-fval = ' '.
    APPEND ls_bdcdata TO ct_bdcdata.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_object_w3mi IMPLEMENTATION.

  METHOD change_bdc_jump_data.

    DATA: ls_bdcdata LIKE LINE OF ct_bdcdata.

    ls_bdcdata-fnam = 'RADIO_HT'.
    ls_bdcdata-fval = ' '.
    APPEND ls_bdcdata TO ct_bdcdata.

    CLEAR ls_bdcdata.
    ls_bdcdata-fnam = 'RADIO_MI'.
    ls_bdcdata-fval = 'X'.
    APPEND ls_bdcdata TO ct_bdcdata.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_oo_base IMPLEMENTATION.

  METHOD convert_attrib_to_vseoattrib.
    FIELD-SYMBOLS: <ls_attribute>  LIKE LINE OF it_attributes,
                   <ls_vseoattrib> LIKE LINE OF rt_vseoattrib.

    LOOP AT it_attributes ASSIGNING <ls_attribute>.
      INSERT INITIAL LINE INTO TABLE rt_vseoattrib ASSIGNING <ls_vseoattrib>.
      MOVE-CORRESPONDING <ls_attribute> TO <ls_vseoattrib>.
      <ls_vseoattrib>-clsname = iv_clsname.
      <ls_vseoattrib>-state = seoc_state_implemented.
      <ls_vseoattrib>-exposure = <ls_attribute>-exposure.
      UNASSIGN <ls_vseoattrib>.
    ENDLOOP.
    UNASSIGN <ls_attribute>.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~add_to_activation_list.
    zcl_abapgit_objects_activation=>add_item( is_item ).
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~create.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~create_documentation.
    CALL FUNCTION 'DOCU_UPD'
      EXPORTING
        id            = iv_id
        langu         = iv_language
        object        = iv_object_name
        no_masterlang = iv_no_masterlang
        state         = c_docu_state_active
      TABLES
        line          = it_lines
      EXCEPTIONS
        ret_code      = 1
        OTHERS        = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~create_sotr.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~delete.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~delete_documentation.
    CALL FUNCTION 'DOCU_DEL'
      EXPORTING
        id       = iv_id
        langu    = iv_language
        object   = iv_object_name
        typ      = 'E'
      EXCEPTIONS
        ret_code = 1
        OTHERS   = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'Error from DOCU_DEL' ).
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~deserialize_source.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~exists.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~generate_locals.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_class_properties.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_includes.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_interface_properties.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_skip_test_classes.
    rv_skip = mv_skip_test_classes.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~insert_text_pool.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_attributes.
    SELECT cmpname attbusobj attkeyfld exposure
      FROM seocompodf
      INTO CORRESPONDING FIELDS OF TABLE rt_attributes
      WHERE clsname = iv_object_name
        AND ( attbusobj <> space OR attkeyfld <> space )
        AND version = '1'
      ORDER BY PRIMARY KEY.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_descriptions_class.
    FIELD-SYMBOLS <ls_description> LIKE LINE OF rt_descriptions.

    " Only translations i.e. not the main language
    SELECT * FROM seoclasstx INTO TABLE rt_descriptions
            WHERE clsname   = iv_object_name
              AND langu    <> iv_language
              AND descript <> ''
            ORDER BY PRIMARY KEY.                         "#EC CI_SUBRC

    LOOP AT rt_descriptions ASSIGNING <ls_description>.
      CLEAR <ls_description>-clsname.
    ENDLOOP.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_descriptions_compo.
    FIELD-SYMBOLS <ls_description> LIKE LINE OF rt_descriptions.

    IF iv_language IS INITIAL.
      " load all languages
      SELECT * FROM seocompotx INTO TABLE rt_descriptions
             WHERE clsname   = iv_object_name
               AND descript <> ''
             ORDER BY PRIMARY KEY.                        "#EC CI_SUBRC
    ELSE.
      " load main language
      SELECT * FROM seocompotx INTO TABLE rt_descriptions
              WHERE clsname   = iv_object_name
                AND langu     = iv_language
                AND descript <> ''
              ORDER BY PRIMARY KEY.                       "#EC CI_SUBRC
    ENDIF.

    LOOP AT rt_descriptions ASSIGNING <ls_description>.
      CLEAR <ls_description>-clsname.
    ENDLOOP.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_descriptions_subco.
    FIELD-SYMBOLS <ls_description> LIKE LINE OF rt_descriptions.

    IF iv_language IS INITIAL.
      " load all languages
      SELECT * FROM seosubcotx INTO TABLE rt_descriptions
             WHERE clsname   = iv_object_name
               AND descript <> ''
             ORDER BY PRIMARY KEY.                        "#EC CI_SUBRC
    ELSE.
      " load main language
      SELECT * FROM seosubcotx INTO TABLE rt_descriptions
              WHERE clsname   = iv_object_name
                AND langu     = iv_language
                AND descript <> ''
              ORDER BY PRIMARY KEY.                       "#EC CI_SUBRC
    ENDIF.

    LOOP AT rt_descriptions ASSIGNING <ls_description>.
      CLEAR <ls_description>-clsname.
    ENDLOOP.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_documentation.
    DATA: lv_state TYPE dokstate,
          lt_lines TYPE tlinetab.

    CALL FUNCTION 'DOCU_GET'
      EXPORTING
        id                     = iv_id
        langu                  = iv_language
        object                 = iv_object_name
        version_active_or_last = space " retrieve active version
      IMPORTING
        dokstate               = lv_state
      TABLES
        line                   = lt_lines
      EXCEPTIONS
        no_docu_on_screen      = 1
        no_docu_self_def       = 2
        no_docu_temp           = 3
        ret_code               = 4
        OTHERS                 = 5.
    IF sy-subrc = 0 AND lv_state = c_docu_state_active.
      rt_lines = lt_lines.
    ELSE.
      CLEAR rt_lines.
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_sotr.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_superclass.
    SELECT SINGLE refclsname FROM vseoextend INTO rv_superclass
      WHERE clsname = iv_classname.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_text_pool.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~serialize_abap.
    DATA lo_oo_serializer TYPE REF TO zcl_abapgit_oo_serializer.
    CREATE OBJECT lo_oo_serializer.
    CASE iv_type.
      WHEN seop_ext_class_locals_def.
        rt_source = lo_oo_serializer->serialize_locals_def( is_class_key ).
      WHEN seop_ext_class_locals_imp.
        rt_source = lo_oo_serializer->serialize_locals_imp( is_class_key ).
      WHEN seop_ext_class_macros.
        rt_source = lo_oo_serializer->serialize_macros( is_class_key ).
      WHEN seop_ext_class_testclasses.
        rt_source = lo_oo_serializer->serialize_testclasses( is_class_key ).
        mv_skip_test_classes = lo_oo_serializer->are_test_classes_skipped( ).
      WHEN OTHERS.
        rt_source = lo_oo_serializer->serialize_abap_clif_source( is_class_key ).
    ENDCASE.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~syntax_check.
    ASSERT 0 = 1. "Subclass responsibility
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~update_descriptions_class.
    DATA lt_descriptions LIKE it_descriptions.
    DATA ls_description LIKE LINE OF it_descriptions.

    IF it_descriptions IS INITIAL.
      RETURN.
    ENDIF.

    " Make sure we keep main language
    SELECT * FROM seoclasstx INTO TABLE lt_descriptions
      WHERE clsname = is_key-clsname AND langu = iv_language
      ORDER BY PRIMARY KEY.

    LOOP AT it_descriptions INTO ls_description WHERE langu <> iv_language.
      ls_description-clsname = is_key-clsname.
      INSERT ls_description INTO TABLE lt_descriptions.
    ENDLOOP.

    DELETE FROM seoclasstx WHERE clsname = is_key-clsname. "#EC CI_SUBRC
    INSERT seoclasstx FROM TABLE lt_descriptions.         "#EC CI_SUBRC
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~update_descriptions_compo.
    DATA lt_descriptions LIKE it_descriptions.
    DATA lt_components   TYPE seo_components.
    DATA ls_description  LIKE LINE OF it_descriptions.
    DATA lv_lang         TYPE tadir-masterlang.

    FIELD-SYMBOLS <ls_description> LIKE LINE OF it_descriptions.
    FIELD-SYMBOLS <ls_component> TYPE vseocompdf.

    lt_descriptions = it_descriptions.
    LOOP AT lt_descriptions ASSIGNING <ls_description>.
      <ls_description>-clsname = is_key-clsname.
    ENDLOOP.

    " make sure to not damage VSEO* views by deleting texts of all components - an empty text must be kept!!
    SELECT * FROM vseocompdf INTO TABLE lt_components
      WHERE clsname = is_key-clsname
        AND version <> seoc_version_deleted
        AND state = seoc_state_implemented
        AND alias = seox_false ORDER BY clsname cmpname version.

    IF lt_components IS NOT INITIAL.
      SELECT SINGLE masterlang FROM tadir INTO lv_lang
        WHERE pgmid = 'R3TR' AND ( object = 'CLAS' OR object = 'INTF' )
          AND obj_name = is_key-clsname.                "#EC CI_GENBUFF
      IF sy-subrc <> 0.
        lv_lang = sy-langu.
      ENDIF.

      LOOP AT lt_components ASSIGNING <ls_component>.
        READ TABLE lt_descriptions TRANSPORTING NO FIELDS WITH KEY
          clsname = is_key-clsname
          cmpname = <ls_component>-cmpname.
        IF sy-subrc <> 0.
          ls_description-clsname = is_key-clsname.
          ls_description-cmpname = <ls_component>-cmpname.
          ls_description-langu  = lv_lang.
          ls_description-descript = space.
          APPEND ls_description TO lt_descriptions.
        ENDIF.
      ENDLOOP.
    ENDIF.

    DELETE FROM seocompotx WHERE clsname = is_key-clsname. "#EC CI_SUBRC
    INSERT seocompotx FROM TABLE lt_descriptions.         "#EC CI_SUBRC
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~update_descriptions_subco.
    DATA lt_descriptions  LIKE it_descriptions.
    DATA lt_subcomponents TYPE seo_subcomponents.
    DATA ls_description   LIKE LINE OF it_descriptions.
    DATA lv_lang          TYPE tadir-masterlang.

    FIELD-SYMBOLS <ls_description> LIKE LINE OF it_descriptions.
    FIELD-SYMBOLS <ls_subcomponent> TYPE vseosubcdf.

    lt_descriptions = it_descriptions.
    LOOP AT lt_descriptions ASSIGNING <ls_description>.
      <ls_description>-clsname = is_key-clsname.
    ENDLOOP.

    " make sure to not damage VSEO* views by deleting texts of all subcomponents - an empty text must be kept!!
    SELECT * FROM vseosubcdf INTO TABLE lt_subcomponents
      WHERE clsname = is_key-clsname
        AND version <> seoc_version_deleted ORDER BY clsname cmpname sconame version.

    IF lt_subcomponents IS NOT INITIAL.
      SELECT SINGLE masterlang FROM tadir INTO lv_lang
        WHERE pgmid = 'R3TR' AND ( object = 'CLAS' OR object = 'INTF' )
          AND obj_name = is_key-clsname.                "#EC CI_GENBUFF
      IF sy-subrc <> 0.
        lv_lang = sy-langu.
      ENDIF.

      LOOP AT lt_subcomponents ASSIGNING <ls_subcomponent>.
        READ TABLE lt_descriptions TRANSPORTING NO FIELDS WITH KEY
          clsname = is_key-clsname
          cmpname = <ls_subcomponent>-cmpname
          sconame = <ls_subcomponent>-sconame.
        IF sy-subrc <> 0.
          ls_description-clsname = is_key-clsname.
          ls_description-cmpname = <ls_subcomponent>-cmpname.
          ls_description-sconame = <ls_subcomponent>-sconame.
          ls_description-langu  = lv_lang.
          ls_description-descript = space.
          APPEND ls_description TO lt_descriptions.
        ENDIF.
      ENDLOOP.
    ENDIF.

    DELETE FROM seosubcotx WHERE clsname = is_key-clsname. "#EC CI_SUBRC
    INSERT seosubcotx FROM TABLE lt_descriptions.         "#EC CI_SUBRC
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_oo_class IMPLEMENTATION.

  METHOD create_report.
    zcl_abapinst_factory=>get_sap_report( )->insert_report(
      iv_name           = iv_program
      iv_package        = iv_package
      it_source         = it_source
      iv_state          = iv_state
      iv_version        = iv_version
      iv_program_type   = iv_program_type
      iv_extension_type = iv_extension ).
  ENDMETHOD.

  METHOD delete_report.
    zcl_abapinst_factory=>get_sap_report( )->delete_report( iv_program ).
  ENDMETHOD.

  METHOD determine_method_include.

    DATA: ls_mtdkey TYPE seocpdkey.

    ls_mtdkey-clsname = iv_name.
    ls_mtdkey-cpdname = iv_method.

    cl_oo_classname_service=>get_method_include(
      EXPORTING
        mtdkey              = ls_mtdkey
      RECEIVING
        result              = rv_program
      EXCEPTIONS
        method_not_existing = 1 ).
    IF sy-subrc = 0.
      RETURN.
    ENDIF.

    CALL FUNCTION 'SEO_METHOD_GENERATE_INCLUDE'
      EXPORTING
        suppress_mtdkey_check          = abap_true
        mtdkey                         = ls_mtdkey
      EXCEPTIONS
        not_existing                   = 1
        model_only                     = 2
        include_existing               = 3
        method_imp_not_generated       = 4
        method_imp_not_initialised     = 5
        _internal_class_not_existing   = 6
        _internal_method_overflow      = 7
        cancelled                      = 8
        method_is_abstract_implemented = 9
        method_is_final_implemented    = 10
        internal_error_insert_report   = 11
        OTHERS                         = 12.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    rv_program = cl_oo_classname_service=>get_method_include( ls_mtdkey ).

  ENDMETHOD.

  METHOD generate_classpool.

    DATA: ls_clskey TYPE seoclskey.

    ls_clskey-clsname = iv_name.

    CALL FUNCTION 'SEO_CLASS_GENERATE_CLASSPOOL'
      EXPORTING
        clskey                        = ls_clskey
        suppress_corr                 = abap_true
      EXCEPTIONS
        not_existing                  = 1
        model_only                    = 2
        class_pool_not_generated      = 3
        class_stment_not_generated    = 4
        locals_not_generated          = 5
        macros_not_generated          = 6
        public_sec_not_generated      = 7
        protected_sec_not_generated   = 8
        private_sec_not_generated     = 9
        typeref_not_generated         = 10
        class_pool_not_initialised    = 11
        class_stment_not_initialised  = 12
        locals_not_initialised        = 13
        macros_not_initialised        = 14
        public_sec_not_initialised    = 15
        protected_sec_not_initialised = 16
        private_sec_not_initialised   = 17
        typeref_not_initialised       = 18
        _internal_class_overflow      = 19
        OTHERS                        = 20.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD get_method_includes.
    " get method includes for implemented interfaces
    " this will contain also leftover includes for deleted interface methods
    rt_includes = cl_oo_classname_service=>get_all_method_includes( iv_classname ).
  ENDMETHOD.

  METHOD init_scanner.

    DATA: lx_exc       TYPE REF TO cx_root,
          lv_message   TYPE string,
          lv_classname TYPE abap_abstypename.
    FIELD-SYMBOLS: <lv_line> TYPE i.

    TRY.
        ro_scanner = cl_oo_source_scanner_class=>create_class_scanner(
          clif_name = iv_name
          source    = it_source ).
        ro_scanner->scan( ).
      CATCH cx_clif_scan_error.
        zcx_abapgit_exception=>raise( 'error initializing CLAS scanner' ).
      CATCH cx_root INTO lx_exc.
        lv_classname = cl_abap_classdescr=>get_class_name( lx_exc ).
        IF lv_classname = '\CLASS=CX_OO_CLIF_SCAN_ERROR_DETAIL'.
          ASSIGN lx_exc->('SOURCE_POSITION-LINE') TO <lv_line>.
          ASSERT sy-subrc = 0.
          lv_message = |{ lx_exc->get_text( ) }, line { <lv_line> }|.
        ELSE.
          lv_message = lx_exc->get_text( ).
        ENDIF.
        zcx_abapgit_exception=>raise( lv_message ).
    ENDTRY.

  ENDMETHOD.

  METHOD repair_classpool.

    CALL FUNCTION 'SEO_CLASS_REPAIR_CLASSPOOL'
      EXPORTING
        clskey       = is_key
      EXCEPTIONS
        not_existing = 1
        OTHERS       = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Error repairing class { is_key-clsname }| ).
    ENDIF.

  ENDMETHOD.

  METHOD repair_redefinitions.

    " Same logic as SE24 > Utilities > Clean-up > Redefinitions (LSEODCCO)

    DATA:
      lt_inheritance     TYPE vseoextend,
      lt_redefinitions   TYPE seor_redefinitions_r,
      ls_cpdkey          TYPE seocpdkey,
      lv_tabix           TYPE sy-tabix,
      lv_exposure        TYPE n LENGTH 1,
      lv_update          TYPE abap_bool,
      lv_local_component TYPE abap_bool.

    FIELD-SYMBOLS <ls_redef> TYPE seoredef.

    CALL FUNCTION 'SEO_CLASS_TYPEINFO_GET'
      EXPORTING
        clskey        = is_key
        version       = seoc_version_active
      IMPORTING
        inheritance   = lt_inheritance
        redefinitions = lt_redefinitions
      EXCEPTIONS
        not_existing  = 1
        is_interface  = 2
        model_only    = 3
        OTHERS        = 4.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    " check redefinitions validity
    LOOP AT lt_redefinitions ASSIGNING <ls_redef>.
      lv_tabix = sy-tabix.

      ls_cpdkey-clsname = is_key-clsname.
      ls_cpdkey-cpdname = <ls_redef>-mtdname.

      CALL FUNCTION 'SEO_COMPONENT_BY_INHERITANCE'
        EXPORTING
          cpdkey             = ls_cpdkey
          version            = seoc_version_active
        IMPORTING
          exposure           = lv_exposure
          is_local_component = lv_local_component
        EXCEPTIONS
          not_existing       = 1
          model_only         = 2
          OTHERS             = 3.
      IF sy-subrc <> 0.
        DELETE lt_redefinitions INDEX lv_tabix.
        lv_update = abap_true.
      ELSEIF <ls_redef>-exposure <> lv_exposure.
        <ls_redef>-exposure = lv_exposure.
        lv_update = abap_true.
      ELSEIF lv_local_component = abap_true AND <ls_redef>-attvalue IS INITIAL AND
             <ls_redef>-mtdabstrct IS INITIAL AND <ls_redef>-mtdfinal IS INITIAL.
        DELETE lt_redefinitions INDEX lv_tabix.
        lv_update = abap_true.
      ENDIF.
    ENDLOOP.

    IF lv_update = abap_true.
      CALL FUNCTION 'SEO_INHERITANC_CHANGE_F_DATA'
        EXPORTING
          save            = abap_false
        CHANGING
          inheritance     = lt_inheritance
          redefinitions   = lt_redefinitions
        EXCEPTIONS
          not_existing    = 1
          deleted         = 2
          is_comprising   = 3
          is_implementing = 4
          not_changed     = 5
          db_error        = 6
          OTHERS          = 7.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( |Error repairing redefinitions for { is_key-clsname }| ).
      ENDIF.

      CALL FUNCTION 'SEO_CLIF_SAVE_ALL'
        EXPORTING
          cifkey                   = is_key
        EXCEPTIONS
          not_existing             = 1
          nothing_to_do            = 2
          access_error             = 3
          db_error                 = 4
          error_in_code_generation = 5
          OTHERS                   = 6.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( |Error repairing redefinitions for { is_key-clsname }| ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD update_cs_number_of_methods.

    " Indirect access to keep downward compatibility
    DATA lr_cache_entry TYPE REF TO data.

    FIELD-SYMBOLS: <lg_cache_entry> TYPE any,
                   <lg_field>       TYPE any.

    TRY.
        CREATE DATA lr_cache_entry TYPE ('SEO_CS_CACHE').
      CATCH cx_sy_create_data_error.
* does not exist in some older systems
        RETURN.
    ENDTRY.

    ASSIGN lr_cache_entry->* TO <lg_cache_entry>.
    ASSERT sy-subrc = 0.

    ASSIGN COMPONENT 'CLSNAME' OF STRUCTURE <lg_cache_entry>
           TO <lg_field>.
    ASSERT sy-subrc = 0.
    <lg_field> = iv_classname.

    ASSIGN COMPONENT 'NO_OF_METHOD_IMPLS' OF STRUCTURE <lg_cache_entry>
           TO <lg_field>.
    ASSERT sy-subrc = 0.
    <lg_field> = iv_number_of_impl_methods.

    MODIFY ('SEO_CS_CACHE') FROM <lg_cache_entry>.

  ENDMETHOD.

  METHOD update_full_class_include.

    CONSTANTS: lc_class_source_extension TYPE c LENGTH 2 VALUE 'CS',
               lc_include_program_type   TYPE c LENGTH 1 VALUE 'I',
               lc_active_version         TYPE r3state VALUE 'A'.

    create_report( iv_program      = cl_oo_classname_service=>get_cs_name( iv_classname )
                   iv_package      = iv_package
                   it_source       = it_source
                   iv_extension    = lc_class_source_extension
                   iv_program_type = lc_include_program_type
                   iv_state        = lc_active_version
                   iv_version      = iv_version ).

    " Assuming that all methods that were scanned are implemented
    update_cs_number_of_methods( iv_classname              = iv_classname
                                 iv_number_of_impl_methods = lines( it_methods ) ).

  ENDMETHOD.

  METHOD update_meta.

    DATA: lo_update     TYPE REF TO cl_oo_class_section_source,
          lx_error      TYPE REF TO cx_oo_source_save_failure,
          ls_clskey     TYPE seoclskey,
          lv_scan_error TYPE abap_bool.

    ls_clskey-clsname = iv_name.

    TRY.
        CALL FUNCTION 'SEO_BUFFER_REFRESH'
          EXPORTING
            cifkey  = ls_clskey
            version = seoc_version_active.
        CREATE OBJECT lo_update TYPE ('CL_OO_CLASS_SECTION_SOURCE')
          EXPORTING
            clskey                        = ls_clskey
            exposure                      = iv_exposure
            state                         = 'A'
            source                        = it_source
            suppress_constrctr_generation = abap_true
          EXCEPTIONS
            class_not_existing            = 1
            read_source_error             = 2
            OTHERS                        = 3 ##SUBRC_OK.
      CATCH cx_sy_dyn_call_param_not_found.
* downport to 702, see https://github.com/abapGit/abapGit/issues/933
* this will READ REPORT instead of using it_source, which should be okay
        CREATE OBJECT lo_update TYPE cl_oo_class_section_source
          EXPORTING
            clskey             = ls_clskey
            exposure           = iv_exposure
            state              = 'A'
          EXCEPTIONS
            class_not_existing = 1
            read_source_error  = 2
            OTHERS             = 3.
    ENDTRY.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    lo_update->set_dark_mode( abap_true ).
    TRY.
        CALL METHOD lo_update->('SET_AMDP_SUPPORT')
          EXPORTING
            enabled = abap_true.
      CATCH cx_sy_dyn_call_illegal_method ##NO_HANDLER.
* AMDP not supported in this system, ignore error
    ENDTRY.
    lo_update->scan_section_source(
      RECEIVING
        scan_error             = lv_scan_error
      EXCEPTIONS
        scan_abap_source_error = 1
        OTHERS                 = 2 ).
    IF sy-subrc <> 0 OR lv_scan_error = abap_true.
      zcx_abapgit_exception=>raise( |CLAS, error while scanning source. Subrc = { sy-subrc }| ).
    ENDIF.

* this will update the SEO* database tables
    TRY.
        lo_update->revert_scan_result( ).
      CATCH cx_oo_source_save_failure INTO lx_error.
        zcx_abapgit_exception=>raise_with_text( lx_error ).
    ENDTRY.

    IF iv_exposure = seoc_exposure_public.
      generate_classpool( iv_name ).
    ENDIF.

  ENDMETHOD.

  METHOD update_report.
    DATA lv_type TYPE c LENGTH 1.

    lv_type = zcl_abapgit_oo_base=>c_include_program_type.

    IF iv_program+30 = srext_ext_class_pool.
      lv_type = zcl_abapgit_oo_base=>c_cp_program_type.
    ENDIF.

    rv_updated = zcl_abapinst_factory=>get_sap_report( )->update_report(
      iv_name         = iv_program
      iv_package      = iv_package
      iv_version      = iv_version
      it_source       = it_source
      iv_program_type = lv_type ).
  ENDMETHOD.

  METHOD update_source_index.

    CONSTANTS:
      lc_version_active   TYPE r3state VALUE 'A',
      lc_version_inactive TYPE r3state VALUE 'I'.

    "    dynamic invocation, IF_OO_SOURCE_POS_INDEX_HELPER doesn't exist in 702.
    DATA lo_index_helper TYPE REF TO object.

    TRY.
        CREATE OBJECT lo_index_helper TYPE ('CL_OO_SOURCE_POS_INDEX_HELPER').

        CALL METHOD lo_index_helper->('IF_OO_SOURCE_POS_INDEX_HELPER~CREATE_INDEX_WITH_SCANNER')
          EXPORTING
            class_name = iv_clsname
            version    = lc_version_active
            scanner    = io_scanner.

        CALL METHOD lo_index_helper->('IF_OO_SOURCE_POS_INDEX_HELPER~DELETE_INDEX')
          EXPORTING
            class_name = iv_clsname
            version    = lc_version_inactive.

      CATCH cx_root.
        " it's probably okay to no update the index
        RETURN.
    ENDTRY.

  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~create.

    DATA:
      lt_vseoattrib TYPE seoo_attributes_r,
      ls_class_key  TYPE seoclskey,
      ls_properties TYPE vseoclass,
      lt_attributes TYPE zif_abapgit_oo_object_fnc=>ty_obj_attribute_tt.

    FIELD-SYMBOLS: <lv_clsname> TYPE seoclsname.

    ASSIGN COMPONENT 'CLSNAME' OF STRUCTURE cg_properties TO <lv_clsname>.
    ASSERT sy-subrc = 0.

    " Get existing class properties and attributes and check if the class
    " needs to be created/updated (or is the same)
    IF iv_check = abap_true.
      ls_class_key-clsname = <lv_clsname>.
      ls_properties = zif_abapgit_oo_object_fnc~get_class_properties( ls_class_key ).
      lt_attributes = zif_abapgit_oo_object_fnc~read_attributes( <lv_clsname> ).

      IF ls_properties = cg_properties AND lt_attributes = it_attributes.
        RETURN.
      ENDIF.
    ENDIF.

    lt_vseoattrib = convert_attrib_to_vseoattrib(
                      iv_clsname    = <lv_clsname>
                      it_attributes = it_attributes ).

    " Hardcode STATE (#2612)
    ls_properties = cg_properties.
    ls_properties-state = seoc_state_implemented.

    TRY.
        CALL FUNCTION 'SEO_CLASS_CREATE_COMPLETE'
          EXPORTING
            devclass        = iv_package
            overwrite       = abap_true
            version         = seoc_version_active
            suppress_dialog = abap_true " Parameter missing in 702
          CHANGING
            class           = ls_properties
            attributes      = lt_vseoattrib
          EXCEPTIONS
            existing        = 1
            is_interface    = 2
            db_error        = 3
            component_error = 4
            no_access       = 5
            other           = 6
            OTHERS          = 7 ##FM_SUBRC_OK.
      CATCH cx_sy_dyn_call_param_not_found.
        CALL FUNCTION 'SEO_CLASS_CREATE_COMPLETE'
          EXPORTING
            devclass        = iv_package
            overwrite       = abap_true
            version         = seoc_version_active
          CHANGING
            class           = ls_properties
            attributes      = lt_vseoattrib
          EXCEPTIONS
            existing        = 1
            is_interface    = 2
            db_error        = 3
            component_error = 4
            no_access       = 5
            other           = 6
            OTHERS          = 7 ##FM_SUBRC_OK.
    ENDTRY.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~create_sotr.
    zcl_abapgit_sotr_handler=>create_sotr(
      iv_package = iv_package
      io_xml     = ii_xml ).
    zcl_abapgit_sots_handler=>create_sots(
      iv_package = iv_package
      io_xml     = ii_xml ).
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~delete.

    " SEO_CLASS_DELETE_COMPLETE deletes OTR usage, only
    " Use handler to also delete OTR header and texts
    zcl_abapgit_sotr_handler=>delete_sotr(
      iv_pgmid    = 'LIMU'
      iv_object   = 'CPUB'
      iv_obj_name = is_deletion_key-clsname ).
    zcl_abapgit_sots_handler=>delete_sots(
      iv_pgmid    = 'LIMU'
      iv_object   = 'CPUB'
      iv_obj_name = is_deletion_key-clsname ).

    CALL FUNCTION 'SEO_CLASS_DELETE_COMPLETE'
      EXPORTING
        clskey       = is_deletion_key
      EXCEPTIONS
        not_existing = 1
        is_interface = 2
        db_error     = 3
        no_access    = 4
        other        = 5
        OTHERS       = 6.
    IF sy-subrc = 1.
* ignore deletion of objects that does not exist
* this can happen when the SXCI object is deleted before the implementing CLAS
      RETURN.
    ELSEIF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~deserialize_source.

    DATA: lv_updated TYPE abap_bool,
          lv_program TYPE program,
          lo_scanner TYPE REF TO cl_oo_source_scanner_class,
          lt_methods TYPE cl_oo_source_scanner_class=>type_method_implementations,
          lt_incls   TYPE seop_methods_w_include,
          lv_method  LIKE LINE OF lt_methods,
          lt_public  TYPE seop_source_string,
          lt_source  TYPE seop_source_string.

    "Buffer needs to be refreshed,
    "otherwise standard SAP CLIF_SOURCE reorder methods alphabetically
    CALL FUNCTION 'SEO_BUFFER_INIT'.
    CALL FUNCTION 'SEO_BUFFER_REFRESH'
      EXPORTING
        cifkey  = is_key
        version = seoc_version_inactive.

    lo_scanner = init_scanner(
      it_source = it_source
      iv_name   = is_key-clsname ).

* public
    lt_public = lo_scanner->get_public_section_source( ).
    IF lt_public IS NOT INITIAL.
      lv_program = cl_oo_classname_service=>get_pubsec_name( is_key-clsname ).
      lv_updated = update_report( iv_program = lv_program
                                  iv_package = iv_package
                                  iv_version = iv_version
                                  it_source  = lt_public ).
      IF lv_updated = abap_true.
        update_meta( iv_name     = is_key-clsname
                     iv_exposure = seoc_exposure_public
                     it_source   = lt_public ).
      ENDIF.
    ENDIF.

* protected
    lt_source = lo_scanner->get_protected_section_source( ).
    IF lt_source IS NOT INITIAL.
      lv_program = cl_oo_classname_service=>get_prosec_name( is_key-clsname ).
      lv_updated = update_report( iv_program = lv_program
                                  iv_package = iv_package
                                  iv_version = iv_version
                                  it_source  = lt_source ).
      IF lv_updated = abap_true.
        update_meta( iv_name     = is_key-clsname
                     iv_exposure = seoc_exposure_protected
                     it_source   = lt_source ).
      ENDIF.
    ENDIF.

* private
    lt_source = lo_scanner->get_private_section_source( ).
    IF lt_source IS NOT INITIAL.
      lv_program = cl_oo_classname_service=>get_prisec_name( is_key-clsname ).
      lv_updated = update_report( iv_program = lv_program
                                  iv_package = iv_package
                                  iv_version = iv_version
                                  it_source  = lt_source ).
      IF lv_updated = abap_true.
        update_meta( iv_name     = is_key-clsname
                     iv_exposure = seoc_exposure_private
                     it_source   = lt_source ).
      ENDIF.
    ENDIF.

* methods
    lt_methods = lo_scanner->get_method_implementations( ).

    lt_incls = get_method_includes( is_key-clsname ).

    LOOP AT lt_methods INTO lv_method.
      TRY.
          lt_source = lo_scanner->get_method_impl_source( lv_method ).
        CATCH cx_oo_clif_component.
          zcx_abapgit_exception=>raise( 'error from GET_METHOD_IMPL_SOURCE' ).
      ENDTRY.
      lv_program = determine_method_include(
        iv_name   = is_key-clsname
        iv_method = lv_method ).

      update_report(
        iv_program = lv_program
        iv_package = iv_package
        iv_version = iv_version
        it_source  = lt_source ).

      " If method was implemented before, remove from list
      DELETE lt_incls WHERE cpdkey-clsname = is_key-clsname AND cpdkey-cpdname = lv_method.
    ENDLOOP.

* full class include
    update_full_class_include( iv_classname = is_key-clsname
                               iv_package   = iv_package
                               iv_version   = iv_version
                               it_source    = it_source
                               it_methods   = lt_methods ).

    " If there are leftover method includes, then class needs to be repaired
    " which will delete the obsolete includes
    IF lt_incls IS NOT INITIAL.
      repair_classpool( is_key ).
      repair_redefinitions( is_key ).
    ENDIF.

    update_source_index(
      iv_clsname = is_key-clsname
      io_scanner = lo_scanner ).

  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~exists.
    DATA ls_object_name TYPE seoclskey.
    ls_object_name = iv_object_name.
    CALL FUNCTION 'SEO_CLASS_EXISTENCE_CHECK'
      EXPORTING
        clskey        = ls_object_name
      EXCEPTIONS
        not_specified = 1
        not_existing  = 2
        is_interface  = 3
        no_text       = 4
        inconsistent  = 5
        OTHERS        = 6.
    rv_exists = boolc( sy-subrc = 0 OR sy-subrc = 4 ).
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~generate_locals.

    DATA: lv_program TYPE syrepid.

    IF lines( it_local_definitions ) > 0.
      lv_program = cl_oo_classname_service=>get_ccdef_name( is_key-clsname ).
      update_report( iv_program = lv_program
                     iv_package = iv_package
                     iv_version = iv_version
                     it_source  = it_local_definitions ).
    ENDIF.

    IF lines( it_local_implementations ) > 0.
      lv_program = cl_oo_classname_service=>get_ccimp_name( is_key-clsname ).
      update_report( iv_program = lv_program
                     iv_package = iv_package
                     iv_version = iv_version
                     it_source  = it_local_implementations ).
    ENDIF.

    IF lines( it_local_macros ) > 0.
      lv_program = cl_oo_classname_service=>get_ccmac_name( is_key-clsname ).
      update_report( iv_program = lv_program
                     iv_package = iv_package
                     iv_version = iv_version
                     it_source  = it_local_macros ).
    ENDIF.

    lv_program = cl_oo_classname_service=>get_ccau_name( is_key-clsname ).
    IF lines( it_local_test_classes ) > 0.
      update_report( iv_program = lv_program
                     iv_package = iv_package
                     iv_version = iv_version
                     it_source  = it_local_test_classes ).
    ELSE.
      " Drop the include to remove left-over test classes
      delete_report( lv_program ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_class_properties.
    CALL FUNCTION 'SEO_CLIF_GET'
      EXPORTING
        cifkey       = is_class_key
        version      = seoc_version_active
      IMPORTING
        class        = rs_class_properties
      EXCEPTIONS
        not_existing = 1
        deleted      = 2
        model_only   = 3
        OTHERS       = 4.
    IF sy-subrc = 1.
      RETURN. " in case only inactive version exists
    ELSEIF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    CLEAR:
      " TODO 2023-08-01: Clear rs_class_properties-state (#2612)
      rs_class_properties-uuid,
      rs_class_properties-author,
      rs_class_properties-createdon,
      rs_class_properties-changedby,
      rs_class_properties-changedon,
      rs_class_properties-r3release,
      rs_class_properties-chgdanyby,
      rs_class_properties-chgdanyon,
      rs_class_properties-clsfinal,
      rs_class_properties-clsabstrct,
      rs_class_properties-exposure,
      rs_class_properties-version.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_includes.
* note: includes returned might not exist
* method cl_oo_classname_service=>GET_ALL_CLASS_INCLUDES does not exist in 702

    DATA: lv_class_name TYPE seoclsname,
          lt_methods    TYPE seop_methods_w_include.

    FIELD-SYMBOLS: <ls_method> LIKE LINE OF lt_methods.

    lv_class_name = iv_object_name.

    APPEND cl_oo_classname_service=>get_ccdef_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=>get_ccmac_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=>get_ccimp_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=>get_cl_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=>get_ccau_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=>get_pubsec_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=>get_prosec_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=>get_prisec_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=>get_classpool_name( lv_class_name ) TO rt_includes.
    APPEND cl_oo_classname_service=>get_ct_name( lv_class_name ) TO rt_includes.

* skip the CS include, as it is sometimes generated on the fly instead of
* when the methods are changed

    cl_oo_classname_service=>get_all_method_includes(
      EXPORTING
        clsname            = lv_class_name
      RECEIVING
        result             = lt_methods
      EXCEPTIONS
        class_not_existing = 1 ).

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Class { lv_class_name } not existing| ).
    ENDIF.

    LOOP AT lt_methods ASSIGNING <ls_method>.
      APPEND <ls_method>-incname TO rt_includes.
    ENDLOOP.

  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~insert_text_pool.
    DATA: lv_cp TYPE program.

    lv_cp = cl_oo_classname_service=>get_classpool_name( iv_class_name ).

    INSERT TEXTPOOL lv_cp
      FROM it_text_pool
      LANGUAGE iv_language
      STATE iv_state.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'error from INSERT TEXTPOOL' ).
    ENDIF.

    zcl_abapgit_objects_activation=>add( iv_type = 'REPT'
                                         iv_name = lv_cp ).
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_sotr.
    zcl_abapgit_sotr_handler=>read_sotr(
      iv_pgmid    = 'LIMU'
      iv_object   = 'CPUB'
      iv_obj_name = iv_object_name
      io_i18n_params = io_i18n_params
      io_xml      = ii_xml ).
    zcl_abapgit_sots_handler=>read_sots(
      iv_pgmid    = 'LIMU'
      iv_object   = 'CPUB'
      iv_obj_name = iv_object_name
      io_i18n_params = io_i18n_params
      io_xml      = ii_xml ).
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~read_text_pool.
    DATA: lv_cp TYPE program.

    lv_cp = cl_oo_classname_service=>get_classpool_name( iv_class_name ).
    READ TEXTPOOL lv_cp INTO rt_text_pool LANGUAGE iv_language. "#EC CI_READ_REP
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~syntax_check.
    DATA:
      ls_clskey      TYPE seoclskey,
      lv_syntaxerror TYPE abap_bool.

    ls_clskey-clsname = to_upper( iv_object_name ).

    CALL FUNCTION 'SEO_CLASS_CHECK_CLASSPOOL'
      EXPORTING
        clskey                       = ls_clskey
        suppress_error_popup         = abap_true
      IMPORTING
        syntaxerror                  = lv_syntaxerror
      EXCEPTIONS
        _internal_class_not_existing = 1
        error_message                = 2 " suppress S-message
        OTHERS                       = 3.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    IF lv_syntaxerror = abap_true.
      zcx_abapgit_exception=>raise( |Class { ls_clskey-clsname } has syntax errors | ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_oo_interface IMPLEMENTATION.

  METHOD init_scanner.

    DATA: lx_exc       TYPE REF TO cx_root,
          lv_message   TYPE string,
          lv_classname TYPE abap_abstypename.

    FIELD-SYMBOLS: <lv_line> TYPE i.

    TRY.
        ro_scanner = cl_oo_source_scanner_interface=>create_interface_scanner(
          clif_name = iv_name
          source    = it_source ).
        ro_scanner->scan( ).
      CATCH cx_clif_scan_error.
        zcx_abapgit_exception=>raise( 'error initializing INTF scanner' ).
      CATCH cx_root INTO lx_exc.
        lv_classname = cl_abap_classdescr=>get_class_name( lx_exc ).
        IF lv_classname = '\CLASS=CX_OO_CLIF_SCAN_ERROR_DETAIL'.
          ASSIGN lx_exc->('SOURCE_POSITION-LINE') TO <lv_line>.
          ASSERT sy-subrc = 0.
          lv_message = |{ lx_exc->get_text( ) }, line { <lv_line> }|.
        ELSE.
          lv_message = lx_exc->get_text( ).
        ENDIF.
        zcx_abapgit_exception=>raise( lv_message ).
    ENDTRY.

  ENDMETHOD.

  METHOD update_meta.

    DATA: lo_update     TYPE REF TO cl_oo_interface_section_source,
          lx_error      TYPE REF TO cx_oo_source_save_failure,
          ls_clskey     TYPE seoclskey,
          lv_scan_error TYPE abap_bool.

    ls_clskey-clsname = iv_name.

    TRY.
        CALL FUNCTION 'SEO_BUFFER_REFRESH'
          EXPORTING
            cifkey  = ls_clskey
            version = seoc_version_active.
        CREATE OBJECT lo_update TYPE ('CL_OO_INTERFACE_SECTION_SOURCE')
          EXPORTING
            intkey                        = ls_clskey
            state                         = 'A'
            source                        = it_source
          EXCEPTIONS
            interface_not_existing        = 1
            read_source_error             = 2
            OTHERS                        = 3 ##SUBRC_OK.
      CATCH cx_sy_dyn_call_param_not_found.
* downport to 702, see https://github.com/abapGit/abapGit/issues/933
* this will READ REPORT instead of using it_source, which should be okay
        CREATE OBJECT lo_update TYPE cl_oo_interface_section_source
          EXPORTING
            intkey                 = ls_clskey
            state                  = 'A'
          EXCEPTIONS
            interface_not_existing = 1
            read_source_error      = 2
            OTHERS                 = 3.
    ENDTRY.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    lo_update->set_dark_mode( abap_true ).

    lo_update->scan_section_source(
      RECEIVING
        scan_error             = lv_scan_error
      EXCEPTIONS
        scan_abap_source_error = 1
        OTHERS                 = 2 ).
    IF sy-subrc <> 0 OR lv_scan_error = abap_true.
      zcx_abapgit_exception=>raise( |INTF, error while scanning source. Subrc = { sy-subrc }| ).
    ENDIF.

* this will update the SEO* database tables
    TRY.
        lo_update->revert_scan_result( ).
      CATCH cx_oo_source_save_failure INTO lx_error.
        zcx_abapgit_exception=>raise_with_text( lx_error ).
    ENDTRY.

  ENDMETHOD.

  METHOD update_report.
    DATA lv_type TYPE c LENGTH 1.

    lv_type = zcl_abapgit_oo_base=>c_include_program_type.

    IF iv_program+30 = srext_ext_interface_pool.
      lv_type = zcl_abapgit_oo_base=>c_ip_program_type.
    ENDIF.

    rv_updated = zcl_abapinst_factory=>get_sap_report( )->update_report(
      iv_name         = iv_program
      iv_package      = iv_package
      iv_version      = iv_version
      it_source       = it_source
      iv_program_type = lv_type ).
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~create.

    DATA:
      lt_vseoattrib    TYPE seoo_attributes_r,
      ls_interface_key TYPE seoclskey,
      ls_properties    TYPE vseointerf.

    FIELD-SYMBOLS: <lv_clsname> TYPE seoclsname.

    ASSIGN COMPONENT 'CLSNAME' OF STRUCTURE cg_properties TO <lv_clsname>.
    ASSERT sy-subrc = 0.

    " Get existing interface properties and check if the interface
    " needs to be created/updated (or is the same)
    IF iv_check = abap_true.
      ls_interface_key-clsname = <lv_clsname>.
      ls_properties = zif_abapgit_oo_object_fnc~get_interface_properties( ls_interface_key ).

      IF ls_properties = cg_properties.
        RETURN.
      ENDIF.
    ENDIF.

    lt_vseoattrib = convert_attrib_to_vseoattrib(
                      iv_clsname    = <lv_clsname>
                      it_attributes = it_attributes ).

    " Hardcode STATE (#2612)
    ls_properties = cg_properties.
    ls_properties-state = seoc_state_implemented.

    TRY.
        CALL FUNCTION 'SEO_INTERFACE_CREATE_COMPLETE'
          EXPORTING
            devclass        = iv_package
            overwrite       = abap_true
            version         = seoc_version_active
            suppress_dialog = abap_true " Parameter missing in 702
          CHANGING
            interface       = ls_properties
            attributes      = lt_vseoattrib
          EXCEPTIONS
            existing        = 1
            is_class        = 2
            db_error        = 3
            component_error = 4
            no_access       = 5
            other           = 6
            OTHERS          = 7 ##FM_SUBRC_OK.
      CATCH cx_sy_dyn_call_param_not_found.
        CALL FUNCTION 'SEO_INTERFACE_CREATE_COMPLETE'
          EXPORTING
            devclass        = iv_package
            overwrite       = abap_true
            version         = seoc_version_active
          CHANGING
            interface       = ls_properties
            attributes      = lt_vseoattrib
          EXCEPTIONS
            existing        = 1
            is_class        = 2
            db_error        = 3
            component_error = 4
            no_access       = 5
            other           = 6
            OTHERS          = 7 ##FM_SUBRC_OK.
    ENDTRY.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~delete.
    CALL FUNCTION 'SEO_INTERFACE_DELETE_COMPLETE'
      EXPORTING
        intkey       = is_deletion_key
      EXCEPTIONS
        not_existing = 1
        is_class     = 2
        db_error     = 3
        no_access    = 4
        other        = 5
        OTHERS       = 6.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~deserialize_source.

    DATA: lv_updated TYPE abap_bool,
          lv_program TYPE program,
          lo_scanner TYPE REF TO cl_oo_source_scanner_interface,
          lt_public  TYPE seop_source_string.

    "Buffer needs to be refreshed,
    "otherwise standard SAP CLIF_SOURCE reorder methods alphabetically
    CALL FUNCTION 'SEO_BUFFER_INIT'.
    CALL FUNCTION 'SEO_BUFFER_REFRESH'
      EXPORTING
        cifkey  = is_key
        version = seoc_version_inactive.

    lo_scanner = init_scanner(
      it_source = it_source
      iv_name   = is_key-clsname ).

    lt_public = lo_scanner->get_interface_section_source( ).
    IF lt_public IS NOT INITIAL.
      lv_program = cl_oo_classname_service=>get_intfsec_name( is_key-clsname ).
      lv_updated = update_report( iv_program = lv_program
                                  iv_package = iv_package
                                  iv_version = iv_version
                                  it_source  = lt_public ).
      IF lv_updated = abap_true.
        update_meta( iv_name   = is_key-clsname
                     it_source = lt_public ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~exists.
    DATA ls_object_name TYPE seoclskey.
    ls_object_name = iv_object_name.
    CALL FUNCTION 'SEO_INTERFACE_EXISTENCE_CHECK'
      EXPORTING
        intkey        = ls_object_name
      EXCEPTIONS
        not_specified = 1
        not_existing  = 2
        is_class      = 3
        no_text       = 4
        inconsistent  = 5
        OTHERS        = 6.
    rv_exists = boolc( sy-subrc = 0 OR sy-subrc = 4 ).
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_includes.
    DATA lv_interface_name TYPE seoclsname.
    lv_interface_name = iv_object_name.
    APPEND cl_oo_classname_service=>get_interfacepool_name( lv_interface_name ) TO rt_includes.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~get_interface_properties.
    CALL FUNCTION 'SEO_CLIF_GET'
      EXPORTING
        cifkey       = is_interface_key
        version      = seoc_version_active
      IMPORTING
        interface    = rs_interface_properties
      EXCEPTIONS
        not_existing = 1
        deleted      = 2
        model_only   = 3
        OTHERS       = 4.
    IF sy-subrc = 1.
      RETURN. " in case only inactive version exists
    ELSEIF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    CLEAR:
      " TODO 2023-08-01: Clear rs_interface_properties-state (#2612)
      rs_interface_properties-uuid,
      rs_interface_properties-author,
      rs_interface_properties-createdon,
      rs_interface_properties-changedby,
      rs_interface_properties-changedon,
      rs_interface_properties-chgdanyby,
      rs_interface_properties-chgdanyon,
      rs_interface_properties-r3release,
      rs_interface_properties-version.
  ENDMETHOD.

  METHOD zif_abapgit_oo_object_fnc~syntax_check.
    DATA:
      ls_intkey      TYPE seoclskey,
      lv_syntaxerror TYPE abap_bool.

    ls_intkey-clsname = to_upper( iv_object_name ).

    CALL FUNCTION 'SEO_INTERFACE_CHECK_POOL'
      EXPORTING
        intkey               = ls_intkey
        suppress_error_popup = abap_true
      IMPORTING
        syntaxerror          = lv_syntaxerror
      EXCEPTIONS
        error_message        = 1 " suppress S-message
        OTHERS               = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    IF lv_syntaxerror = abap_true.
      zcx_abapgit_exception=>raise( |Interface { ls_intkey-clsname } has syntax errors | ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_OO_FACTORY IMPLEMENTATION.

  METHOD get_by_type.
    IF iv_object_type = 'CLAS'.
      CREATE OBJECT ri_object_oriented_object TYPE zcl_abapgit_oo_class.
    ELSEIF iv_object_type = 'INTF'.
      CREATE OBJECT ri_object_oriented_object TYPE zcl_abapgit_oo_interface.
    ENDIF.
  ENDMETHOD.

  METHOD get_by_name.

    DATA:
      li_interface   TYPE REF TO zif_abapgit_oo_object_fnc,
      li_class       TYPE REF TO zif_abapgit_oo_object_fnc,
      ls_object_name TYPE seoclskey.

    ls_object_name-clsname = to_upper( iv_object_name ).

    CREATE OBJECT li_class TYPE zcl_abapgit_oo_class.
    IF li_class->exists( ls_object_name-clsname ) = abap_true.
      ri_object_oriented_object = li_class.
      RETURN.
    ENDIF.

    CREATE OBJECT li_interface TYPE zcl_abapgit_oo_interface.
    IF li_interface->exists( ls_object_name-clsname ) = abap_true.
      ri_object_oriented_object = li_interface.
      RETURN.
    ENDIF.

    zcx_abapgit_exception=>raise( |{ iv_object_name } is neither a class nor an interface| ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_oo_serializer IMPLEMENTATION.

  METHOD are_test_classes_skipped.
    rv_return = mv_skip_testclass.
  ENDMETHOD.

  METHOD calculate_skip_testclass.

    DATA: lv_line1 LIKE LINE OF it_source,
          lv_line2 LIKE LINE OF it_source.

* when creating classes in Eclipse it automatically generates the
* testclass include, but it is not needed, so skip to avoid
* creating an extra file in the repository.
* Also remove it if the content is manually removed, but
* the class still thinks it contains tests

    rv_skip_testclass = abap_false.
    IF lines( it_source ) = 2.
      READ TABLE it_source INDEX 1 INTO lv_line1.
      ASSERT sy-subrc = 0.
      READ TABLE it_source INDEX 2 INTO lv_line2.
      ASSERT sy-subrc = 0.
      IF strlen( lv_line1 ) >= 3 AND lv_line1(3) = '*"*' AND lv_line2 IS INITIAL.
        rv_skip_testclass = abap_true.
      ENDIF.
    ELSEIF lines( it_source ) = 1.
      READ TABLE it_source INDEX 1 INTO lv_line1.
      ASSERT sy-subrc = 0.
      IF lv_line1 IS INITIAL
          OR ( strlen( lv_line1 ) >= 3 AND lv_line1(3) = '*"*' )
          OR ( strlen( lv_line1 ) = 1 AND lv_line1(1) = '*' ).
        rv_skip_testclass = abap_true.
      ENDIF.
    ELSEIF lines( it_source ) = 0.
      rv_skip_testclass = abap_true.
    ENDIF.

  ENDMETHOD.

  METHOD read_include.

    DATA ls_include TYPE progstruc.
    DATA lv_program TYPE syrepid.
    DATA lt_source  TYPE abaptxt255_tab.

    ASSERT iv_type = seop_ext_class_locals_def
      OR iv_type = seop_ext_class_locals_imp
      OR iv_type = seop_ext_class_macros
      OR iv_type = seop_ext_class_testclasses.

    ls_include-rootname = is_clskey-clsname.
    TRANSLATE ls_include-rootname USING ' ='.
    ls_include-categorya = iv_type(1).
    ls_include-codea = iv_type+1(4).

* it looks like there is an issue in function module SEO_CLASS_GET_INCLUDE_SOURCE
* on 750 kernels, where the READ REPORT without STATE addition does not
* return the active version, this method is a workaround for this issue
    lv_program = ls_include.
    TRY.
        lt_source = zcl_abapinst_factory=>get_sap_report( )->read_report( lv_program ).
      CATCH zcx_abapgit_exception ##NO_HANDLER.
* ignore if the report is not found, sometimes the CCDEF include does not exist
    ENDTRY.
    rt_source = lt_source.

  ENDMETHOD.

  METHOD reduce.

    DATA: lv_source LIKE LINE OF ct_source,
          lv_found  TYPE abap_bool.

* skip files that only contain the standard comments
    lv_found = abap_false.
    LOOP AT ct_source INTO lv_source.
      IF strlen( lv_source ) >= 3 AND lv_source(3) <> '*"*'.
        lv_found = abap_true.
      ENDIF.
    ENDLOOP.
    IF lv_found = abap_false.
      CLEAR ct_source.
    ENDIF.

  ENDMETHOD.

  METHOD remove_signatures.

* signatures messes up in CL_OO_SOURCE when deserializing and serializing
* within same session

    DATA: lv_begin  TYPE string,
          lv_end    TYPE string,
          lv_remove TYPE abap_bool,
          lv_source LIKE LINE OF ct_source.

    "@TODO: Put under test
    CONCATENATE '* <SIGNATURE>------------------------------------'
      '---------------------------------------------------+'
      INTO lv_begin.

    CONCATENATE '* +------------------------------------------------'
      '--------------------------------------</SIGNATURE>'
      INTO lv_end.

    lv_remove = abap_false.
    LOOP AT ct_source INTO lv_source.
      IF lv_source = lv_begin.
        lv_remove = abap_true.
      ENDIF.
      IF lv_remove = abap_true.
        DELETE ct_source INDEX sy-tabix.
      ENDIF.
      IF lv_source = lv_end.
        lv_remove = abap_false.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD serialize_abap_clif_source.
    rt_source = zcl_abapgit_exit=>get_instance( )->custom_serialize_abap_clif( is_class_key ).
    IF rt_source IS NOT INITIAL.
      RETURN.
    ENDIF.

    TRY.
        rt_source = serialize_abap_new( is_class_key ).
      CATCH cx_sy_dyn_call_error.
        rt_source = serialize_abap_old( is_class_key ).
    ENDTRY.

    " Call exit again for optional post-processing
    rt_source = zcl_abapgit_exit=>get_instance( )->custom_serialize_abap_clif(
      is_class_key = is_class_key
      it_source    = rt_source ).
  ENDMETHOD.

  METHOD serialize_abap_new.

    DATA: lo_source   TYPE REF TO object,
          lo_instance TYPE REF TO object.

* do not call the class/methods statically, as it will
* give syntax errors on old versions
    CALL METHOD ('CL_OO_FACTORY')=>('CREATE_INSTANCE')
      RECEIVING
        result = lo_instance.

    CALL METHOD lo_instance->('CREATE_CLIF_SOURCE')
      EXPORTING
        clif_name = is_clskey-clsname
        version   = 'A'
      RECEIVING
        result    = lo_source.

    CALL METHOD lo_source->('GET_SOURCE')
      IMPORTING
        source = rt_source.

  ENDMETHOD.

  METHOD serialize_abap_old.
* for old ABAP AS versions
    DATA: lo_source TYPE REF TO object.

    CREATE OBJECT lo_source TYPE ('CL_OO_SOURCE')
      EXPORTING
        clskey             = is_clskey
      EXCEPTIONS
        class_not_existing = 1
        OTHERS             = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    CALL METHOD lo_source->('READ')
      EXPORTING
        version = 'A'.
    CALL METHOD lo_source->('GET_OLD_SOURCE')
      RECEIVING
        old_source = rt_source.
    remove_signatures( CHANGING ct_source = rt_source ).

  ENDMETHOD.

  METHOD serialize_locals_def.

    rt_source = read_include( is_clskey = is_clskey
                              iv_type = seop_ext_class_locals_def ).

    reduce( CHANGING ct_source = rt_source ).

  ENDMETHOD.

  METHOD serialize_locals_imp.

    rt_source = read_include( is_clskey = is_clskey
                              iv_type = seop_ext_class_locals_imp ).

    reduce( CHANGING ct_source = rt_source ).

  ENDMETHOD.

  METHOD serialize_macros.

    rt_source = read_include( is_clskey = is_clskey
                              iv_type = seop_ext_class_macros ).

    reduce( CHANGING ct_source = rt_source ).

  ENDMETHOD.

  METHOD serialize_testclasses.

    DATA ls_vseoclass TYPE vseoclass.

    CALL FUNCTION 'SEO_CLIF_GET'
      EXPORTING
        cifkey       = is_clskey
        version      = seoc_version_active
      IMPORTING
        class        = ls_vseoclass
      EXCEPTIONS
        not_existing = 1
        deleted      = 2
        model_only   = 3
        OTHERS       = 4.
    IF sy-subrc <> 0 OR ls_vseoclass-with_unit_tests = abap_false.
      mv_skip_testclass = abap_true.
      RETURN.
    ENDIF.

    rt_source = read_include( is_clskey = is_clskey
                              iv_type = seop_ext_class_testclasses ).

    mv_skip_testclass = calculate_skip_testclass( rt_source ).

  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_PATH IMPLEMENTATION.

  METHOD change_dir.

    DATA: lv_last TYPE i,
          lv_temp TYPE string.

    lv_last = strlen( iv_cur_dir ) - 1.

    IF iv_cd = '' OR iv_cd = '.'. " No change
      rv_path = iv_cur_dir.
    ELSEIF iv_cd+0(1) = '/'.      " Absolute path
      rv_path = iv_cd.
    ELSEIF iv_cd = '..'.          " CD back
      IF iv_cur_dir = '/' OR iv_cur_dir = ''. " Back from root = root
        rv_path = iv_cur_dir.
      ELSE.
        lv_temp = reverse( iv_cur_dir ).
        IF lv_temp+0(1) = '/'.
          SHIFT lv_temp BY 1 PLACES LEFT.
        ENDIF.
        SHIFT lv_temp UP TO '/' LEFT.
        rv_path = reverse( lv_temp ).
      ENDIF.
    ELSEIF iv_cur_dir+lv_last(1) = '/'.  " Append cd to cur_dir separated by /
      rv_path = iv_cur_dir && iv_cd.
    ELSE.
      rv_path = iv_cur_dir && '/' && iv_cd.
    ENDIF.

    " TODO: improve logic and cases

  ENDMETHOD.

  METHOD get_filename_from_syspath.

    DATA: lv_split TYPE c LENGTH 1,
          lv_index TYPE i,
          lt_split TYPE TABLE OF string.

    " filename | c:\filename | /dir/filename | \\server\filename
    IF iv_path CA '/'.
      lv_split = '/'.
    ELSE.
      lv_split = '\'.
    ENDIF.

    SPLIT iv_path AT lv_split INTO TABLE lt_split.

    lv_index = lines( lt_split ).

    READ TABLE lt_split INDEX lv_index INTO rv_filename.

  ENDMETHOD.

  METHOD is_root.
    rv_yes = boolc( iv_path = '/' ).
  ENDMETHOD.

  METHOD is_subdir.

    DATA lv_len  TYPE i.
    DATA lv_last TYPE i.

    lv_len  = strlen( iv_parent ).
    lv_last = lv_len - 1.
    rv_yes  = boolc( strlen( iv_path ) > lv_len
                 AND iv_path+0(lv_len) = iv_parent
                 AND ( iv_parent+lv_last(1) = '/' OR iv_path+lv_len(1) = '/' ) ).

  ENDMETHOD.

  METHOD split_file_location.

    DATA: lv_cnt TYPE i,
          lv_len TYPE i.

    FIND FIRST OCCURRENCE OF REGEX '^/(.*/)?' IN iv_fullpath
      MATCH COUNT lv_cnt
      MATCH LENGTH lv_len.

    IF lv_cnt > 0.
      ev_path     = iv_fullpath+0(lv_len).
      ev_filename = iv_fullpath+lv_len.
    ELSE.
      CLEAR ev_path.
      ev_filename = iv_fullpath.
    ENDIF.

    ev_filename = cl_http_utility=>unescape_url( escaped = ev_filename ).

  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_PERSISTENCE_DB IMPLEMENTATION.

  METHOD add.

    DATA ls_table TYPE zif_abapgit_persistence=>ty_content.

    validate_entry_type( iv_type ).
    ls_table-type  = iv_type.
    ls_table-value = iv_value.
    ls_table-data_str = iv_data.

    INSERT (c_tabname) FROM ls_table.                     "#EC CI_SUBRC
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD delete.

    lock( iv_type  = iv_type
          iv_value = iv_value ).

    " Ignore errors since record might not exist
    DELETE FROM (c_tabname)
      WHERE type = iv_type
      AND value = iv_value.

  ENDMETHOD.

  METHOD get_instance.

    IF go_db IS NOT BOUND.
      CREATE OBJECT go_db.
    ENDIF.
    ro_db = go_db.

  ENDMETHOD.

  METHOD get_update_function.
    IF mv_update_function IS INITIAL.
      mv_update_function = 'CALL_V1_PING'.
      IF zcl_abapinst_factory=>get_function_module( )->function_exists( mv_update_function ) = abap_false.
        mv_update_function = 'BANK_OBJ_WORKL_RELEASE_LOCKS'.
      ENDIF.
    ENDIF.
    rv_funcname = mv_update_function.

  ENDMETHOD.

  METHOD list.
    SELECT * FROM (c_tabname)
      INTO TABLE rt_content.                              "#EC CI_SUBRC
  ENDMETHOD.

  METHOD list_by_keys.
    FIELD-SYMBOLS: <ls_key> LIKE LINE OF it_keys.
    LOOP AT it_keys ASSIGNING <ls_key>.
      SELECT * FROM (c_tabname)
      APPENDING TABLE rt_contents
      WHERE value = <ls_key> AND
            type  = iv_type.
    ENDLOOP.
  ENDMETHOD.

  METHOD list_by_type.
    SELECT * FROM (c_tabname)
      INTO TABLE rt_content
      WHERE type = iv_type
      ORDER BY PRIMARY KEY.                               "#EC CI_SUBRC
  ENDMETHOD.

  METHOD lock.
    DATA: lv_dummy_update_function TYPE funcname.

    CALL FUNCTION 'ENQUEUE_EZABAPGIT'
      EXPORTING
        mode_zabapgit  = iv_mode
        type           = iv_type
        value          = iv_value
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    lv_dummy_update_function = get_update_function( ).

* trigger dummy update task to automatically release locks at commit
    CALL FUNCTION lv_dummy_update_function
      IN UPDATE TASK.

  ENDMETHOD.

  METHOD modify.

    DATA: ls_content TYPE zif_abapgit_persistence=>ty_content.

    lock( iv_type  = iv_type
          iv_value = iv_value ).

    ls_content-type  = iv_type.
    ls_content-value = iv_value.
    ls_content-data_str = iv_data.

    MODIFY (c_tabname) FROM ls_content.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'DB modify failed' ).
    ENDIF.

  ENDMETHOD.

  METHOD read.

    SELECT SINGLE data_str FROM (c_tabname) INTO rv_data
      WHERE type = iv_type
      AND value = iv_value.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE zcx_abapgit_not_found.
    ENDIF.

  ENDMETHOD.

  METHOD update.

    DATA lv_data LIKE iv_data.

    IF iv_data CS '<?xml'.
      lv_data = validate_and_unprettify_xml( iv_data ).
    ELSE.
      lv_data = iv_data.
    ENDIF.

    lock( iv_type  = iv_type
          iv_value = iv_value ).

    UPDATE (c_tabname) SET data_str = lv_data
      WHERE type  = iv_type
      AND value = iv_value.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'DB update failed' ).
    ENDIF.

  ENDMETHOD.

  METHOD validate_and_unprettify_xml.

    rv_xml = zcl_abapgit_xml_pretty=>print(
      iv_xml           = iv_xml
      iv_unpretty      = abap_true
      iv_ignore_errors = abap_false ).

  ENDMETHOD.

  METHOD validate_entry_type.

    IF NOT (
      iv_type = c_type_repo OR
      iv_type = c_type_repo_csum OR
      iv_type = c_type_user OR
      iv_type = c_type_settings OR
      iv_type = c_type_background OR
      iv_type = c_type_packages ).
      zcx_abapgit_exception=>raise( |Invalid DB entry type [{ iv_type }]| ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_po_file IMPLEMENTATION.

  METHOD build_po_body.

    FIELD-SYMBOLS <ls_pair> LIKE LINE OF mt_pairs.
    FIELD-SYMBOLS <ls_comment> LIKE LINE OF <ls_pair>-comments.

    CREATE OBJECT ro_buf.

    LOOP AT mt_pairs ASSIGNING <ls_pair>.
      IF sy-tabix <> 1.
        ro_buf->add( '' ).
      ENDIF.

      " TODO integrate translator comments ?

      SORT <ls_pair>-comments BY kind.
      LOOP AT <ls_pair>-comments ASSIGNING <ls_comment>.
        ro_buf->add( |#{ get_comment_marker( <ls_comment>-kind ) } { <ls_comment>-text }| ).
      ENDLOOP.

      ro_buf->add( |msgid { quote( <ls_pair>-source ) }| ).
      ro_buf->add( |msgstr { quote( <ls_pair>-target ) }| ).
    ENDLOOP.

  ENDMETHOD.

  METHOD build_po_head.

    CREATE OBJECT ro_buf.

    " TODO, more headers ? sample: https://www.gnu.org/software/trans-coord/manual/gnun/html_node/PO-Header.html
    " TODO, does \n really necessary ? check editors support for non-\n
    " TODO, should be unfuzzy for final version, and potentially should have more fields

    ro_buf->add( '#, fuzzy' ).
    ro_buf->add( 'msgid ""' ).
    ro_buf->add( 'msgstr ""' ).
    ro_buf->add( '"MIME-Version: 1.0\n"' ).
    ro_buf->add( '"Content-Type: text/plain; charset=UTF-8\n"' ).
    ro_buf->add( '"Content-Transfer-Encoding: 8bit\n"' ).
    ro_buf->add( '' ).

  ENDMETHOD.

  METHOD constructor.
    mv_lang = to_lower( iv_lang ).
  ENDMETHOD.

  METHOD get_comment_marker.
    CASE iv_comment_kind.
      WHEN c_comment-translator.
        rv_marker = ''.
      WHEN c_comment-extracted.
        rv_marker = '.'.
      WHEN c_comment-reference.
        rv_marker = ':'.
      WHEN c_comment-flag.
        rv_marker = ','.
      WHEN c_comment-previous.
        rv_marker = '|'.
    ENDCASE.
  ENDMETHOD.

  METHOD parse.

    DATA lv_xdata TYPE xstring.
    DATA lv_data TYPE string.

    IF xstrlen( iv_xdata ) > 3 AND iv_xdata(3) = cl_abap_char_utilities=>byte_order_mark_utf8.
      lv_xdata = iv_xdata+3.
    ELSE.
      lv_xdata = iv_xdata.
    ENDIF.

    lv_data = zcl_abapgit_convert=>xstring_to_string_utf8( lv_xdata ).

    parse_po( lv_data ).

  ENDMETHOD.

  METHOD parse_po.

    CONSTANTS:
      BEGIN OF c_state,
        wait_id  TYPE i VALUE 0,
        wait_str TYPE i VALUE 1,
        wait_eos TYPE i VALUE 2,
        " TODO msgctx
      END OF c_state.

    DATA lv_state TYPE i VALUE c_state-wait_id.
    DATA lt_lines TYPE string_table.
    DATA ls_pair LIKE LINE OF mt_pairs.
    DATA lv_whitespace TYPE c LENGTH 2.
    FIELD-SYMBOLS <lv_i> TYPE string.

    lv_whitespace = ` ` && cl_abap_char_utilities=>horizontal_tab.

    SPLIT iv_data AT cl_abap_char_utilities=>newline INTO TABLE lt_lines.
    APPEND '' TO lt_lines. " terminator

    LOOP AT lt_lines ASSIGNING <lv_i>.
      IF lv_state = c_state-wait_eos.
        IF strlen( <lv_i> ) >= 1 AND <lv_i>+0(1) = '"'.
          ls_pair-target = ls_pair-target && unquote( <lv_i> ).
          CONTINUE.
        ELSE.
          lv_state = c_state-wait_id.
          IF ls_pair-source IS NOT INITIAL. " skip header entry for now
            INSERT ls_pair INTO TABLE mt_pairs. " Sorted, duplicates will not be inserted
          ENDIF.
          CLEAR ls_pair.
        ENDIF.
      ENDIF.

      CASE lv_state.
        WHEN c_state-wait_id.
          IF <lv_i> IS INITIAL
            OR <lv_i>+0(1) = '#' " TODO, potentially parse comments in future, to re-integrate
            OR <lv_i> CO lv_whitespace.
            CONTINUE.
          ENDIF.
          IF strlen( <lv_i> ) >= 6 AND <lv_i>+0(6) = `msgid `. " w/trailing space
            ls_pair-source = unquote( substring(
              val = <lv_i>
              off = 6 ) ).
            lv_state = c_state-wait_str.
          ELSE.
            zcx_abapgit_exception=>raise( 'PO file format error: expected msgid' ).
          ENDIF.

        WHEN c_state-wait_str.
          IF strlen( <lv_i> ) >= 7 AND <lv_i>+0(7) = `msgstr `. " w/trailing space
            ls_pair-target = unquote( substring(
              val = <lv_i>
              off = 7 ) ).
            lv_state = c_state-wait_eos.
          ELSE.
            zcx_abapgit_exception=>raise( 'PO file format error: expected msgstr' ).
          ENDIF.

      ENDCASE.
    ENDLOOP.

  ENDMETHOD.

  METHOD push_text_pairs.

    DATA ls_out LIKE LINE OF mt_pairs.
    FIELD-SYMBOLS <ls_in> LIKE LINE OF it_text_pairs.
    FIELD-SYMBOLS <ls_out> LIKE LINE OF mt_pairs.
    DATA ls_comment LIKE LINE OF <ls_out>-comments.

    LOOP AT it_text_pairs ASSIGNING <ls_in>.
      CHECK <ls_in>-s_text IS NOT INITIAL.

      READ TABLE mt_pairs ASSIGNING <ls_out> WITH KEY source = <ls_in>-s_text.
      IF sy-subrc <> 0.
        ls_out-source = <ls_in>-s_text.
        INSERT ls_out INTO TABLE mt_pairs ASSIGNING <ls_out>.
        ASSERT sy-subrc = 0.
      ENDIF.

      IF <ls_out>-target IS INITIAL. " For a case of orig text duplication
        <ls_out>-target = <ls_in>-t_text.
      ENDIF.

      ls_comment-kind = c_comment-reference.
      ls_comment-text = condense( |{ iv_objtype }/{ iv_objname }/{ <ls_in>-textkey }| )
        && |, maxlen={ <ls_in>-unitmlt }|.
      APPEND ls_comment TO <ls_out>-comments.
      ASSERT sy-subrc = 0.
    ENDLOOP.

  ENDMETHOD.

  METHOD quote.
    rv_text = '"' && replace(
      val  = iv_text
      sub  = '"'
      with = '\"'
      occ  = 0 ) && '"'.
  ENDMETHOD.

  METHOD unquote.

    DATA lv_len TYPE i.
    DATA lv_prev_char TYPE i.

    rv_text = iv_text.
    SHIFT rv_text RIGHT DELETING TRAILING space. " Measure perf ? Could be slowish, maybe use find
    SHIFT rv_text LEFT DELETING LEADING space.
    lv_len = strlen( rv_text ).

    IF lv_len < 2.
      zcx_abapgit_exception=>raise( 'PO file format error: bad quoting' ).
    ENDIF.

    lv_prev_char = lv_len - 1.
    IF rv_text+0(1) <> '"' OR rv_text+lv_prev_char(1) <> '"'.
      zcx_abapgit_exception=>raise( 'PO file format error: bad quoting' ).
    ENDIF.

    lv_prev_char = lv_prev_char - 1.
    IF lv_len >= 3 AND rv_text+lv_prev_char(1) = '\'. " escaped quote
      zcx_abapgit_exception=>raise( 'PO file format error: bad quoting' ).
    ENDIF.

    rv_text = substring(
      val = rv_text
      off = 1
      len = lv_len - 2 ).

    rv_text = replace(
      val  = rv_text
      sub  = '\"'
      with = '"'
      occ  = 0 ).

    rv_text = replace(
      val  = rv_text
      sub  = '\n'
      with = cl_abap_char_utilities=>newline
      occ  = 0 ).

    " TODO: theoretically there can be unescaped " - is it a problem ? check standard

  ENDMETHOD.

  METHOD zif_abapgit_i18n_file~ext.
    rv_ext = 'po'.
  ENDMETHOD.

  METHOD zif_abapgit_i18n_file~lang.
    rv_lang = mv_lang.
  ENDMETHOD.

  METHOD zif_abapgit_i18n_file~render.

    DATA lv_str TYPE string.

    lv_str = build_po_body( )->join_w_newline_and_flush( ).

    IF lv_str IS NOT INITIAL.
      lv_str = build_po_head( )->join_w_newline_and_flush( )
        && cl_abap_char_utilities=>newline
        && lv_str
        && cl_abap_char_utilities=>newline. " Trailing LF
      rv_data = zcl_abapgit_convert=>string_to_xstring_utf8_bom( lv_str ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_i18n_file~translate.

    FIELD-SYMBOLS <ls_lxe> LIKE LINE OF ct_text_pairs.
    FIELD-SYMBOLS <ls_tr> LIKE LINE OF mt_pairs.
    DATA lv_idx TYPE i.

    LOOP AT ct_text_pairs ASSIGNING <ls_lxe>.
      CHECK <ls_lxe>-s_text IS NOT INITIAL.
      lv_idx = sy-tabix.

      READ TABLE mt_pairs ASSIGNING <ls_tr> WITH KEY source = <ls_lxe>-s_text.
      IF sy-subrc = 0 AND <ls_tr>-target IS NOT INITIAL.
        <ls_lxe>-t_text = <ls_tr>-target.
      ELSE.
        DELETE ct_text_pairs INDEX lv_idx. " Otherwise error in LXE FMs for empty translation
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_progress IMPLEMENTATION.

  METHOD calc_pct.

    DATA: lv_f TYPE f.

    TRY.
        lv_f = ( iv_current / mv_total ) * 100.
        rv_pct = lv_f.

        IF rv_pct = 100.
          rv_pct = 99.
        ELSEIF rv_pct = 0.
          rv_pct = 1.
        ENDIF.
      CATCH cx_sy_zerodivide.
        rv_pct = 0.
    ENDTRY.

  ENDMETHOD.

  METHOD get_instance.

* max one progress indicator at a time is supported

    IF gi_progress IS INITIAL.
      CREATE OBJECT gi_progress TYPE zcl_abapgit_progress.
    ENDIF.

    gi_progress->set_total( iv_total ).

    ri_progress = gi_progress.

  ENDMETHOD.

  METHOD set_instance.

    gi_progress = ii_progress.

  ENDMETHOD.

  METHOD zif_abapgit_progress~off.

    " Clear the status bar
    CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'.

  ENDMETHOD.

  METHOD zif_abapgit_progress~set_total.

    mv_total = iv_total.

    CLEAR mv_cv_time_next.
    CLEAR mv_cv_datum_next.

  ENDMETHOD.

  METHOD zif_abapgit_progress~show.

    DATA: lv_pct  TYPE i,
          lv_time TYPE t.

    CONSTANTS: lc_wait_secs TYPE i VALUE 2.

    GET TIME.
    lv_time = sy-uzeit.
    IF mv_cv_time_next IS INITIAL AND mv_cv_datum_next IS INITIAL.
      mv_cv_time_next  = lv_time.
      mv_cv_datum_next = sy-datum.
    ENDIF.

    "We only do a progress indication if enough time has passed
    IF lv_time >= mv_cv_time_next
        AND sy-datum = mv_cv_datum_next
        OR sy-datum > mv_cv_datum_next.

      lv_pct = calc_pct( iv_current ).

      CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
        EXPORTING
          percentage = lv_pct
          text       = iv_text.
      mv_cv_time_next = lv_time + lc_wait_secs.

    ENDIF.
    IF sy-datum > mv_cv_datum_next.
      mv_cv_datum_next = sy-datum.
    ENDIF.
    IF mv_cv_time_next < lv_time.
      mv_cv_datum_next = sy-datum + 1.
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_properties_file IMPLEMENTATION.

  METHOD constructor.
    mv_lang = to_upper( iv_lang ).
  ENDMETHOD.

  METHOD get_translations.

    DATA:
      lv_translation TYPE string,
      lo_ajson       TYPE REF TO zif_abapgit_ajson,
      lo_json_path   TYPE REF TO zcl_abapgit_json_path,
      lx_exception   TYPE REF TO cx_static_check.

    CREATE OBJECT lo_json_path.

    TRY.
        lv_translation = lo_json_path->deserialize( mt_translation ).

        lo_ajson = zcl_abapgit_ajson=>parse( lv_translation
          )->map( zcl_abapgit_ajson_mapping=>create_to_snake_case( ) ).

        lo_ajson->to_abap( IMPORTING ev_container = ev_data ).

      CATCH cx_static_check INTO lx_exception.
        zcx_abapgit_exception=>raise_with_text( lx_exception ).
    ENDTRY.

  ENDMETHOD.

  METHOD parse.

    DATA lv_data TYPE string.

    lv_data = zcl_abapgit_convert=>xstring_to_string_utf8( iv_xdata ).

    SPLIT lv_data AT cl_abap_char_utilities=>newline INTO TABLE mt_translation.

  ENDMETHOD.

  METHOD push_text_pairs.
    mt_translation = it_translation.
  ENDMETHOD.

  METHOD zif_abapgit_i18n_file~ext.
    rv_ext = 'properties'.
  ENDMETHOD.

  METHOD zif_abapgit_i18n_file~lang.
    rv_lang = mv_lang.
  ENDMETHOD.

  METHOD zif_abapgit_i18n_file~render.

    DATA lv_translation TYPE string.

    lv_translation = concat_lines_of( table = mt_translation
                                      sep   = cl_abap_char_utilities=>newline ) && cl_abap_char_utilities=>newline.
    rv_data = zcl_abapgit_convert=>string_to_xstring_utf8( lv_translation ).

  ENDMETHOD.

  METHOD zif_abapgit_i18n_file~translate.
  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_SAP_NAMESPACE IMPLEMENTATION.

  METHOD zif_abapgit_sap_namespace~exists.
    DATA lv_editflag TYPE trnspace-editflag.
    DATA lo_obj TYPE REF TO object.
    DATA lo_nsp TYPE REF TO object.
    FIELD-SYMBOLS <lg_obj> TYPE any.
    TRY.
        SELECT SINGLE editflag FROM ('TRNSPACE') INTO lv_editflag WHERE namespace = iv_namespace.
        rv_yes = boolc( sy-subrc = 0 ).
      CATCH cx_sy_dynamic_osql_error.
        ASSIGN ('XCO_CP_SYSTEM=>NAMESPACE') TO <lg_obj>.
        lo_obj = <lg_obj>.
        CALL METHOD lo_obj->('IF_XCO_CP_NAMESPACE_FACTORY~FOR')
          EXPORTING
            iv_value     = iv_namespace
          RECEIVING
            ro_namespace = lo_nsp.
        CALL METHOD lo_nsp->('IF_XCO_CP_NAMESPACE~EXISTS')
          RECEIVING
            rv_exists = rv_yes.
    ENDTRY.
  ENDMETHOD.

  METHOD zif_abapgit_sap_namespace~is_editable.
    DATA lv_editflag TYPE trnspace-editflag.
    DATA lo_obj TYPE REF TO object.
    DATA lo_nsp TYPE REF TO object.
    FIELD-SYMBOLS <lg_obj> TYPE any.
    TRY.
        SELECT SINGLE editflag FROM ('TRNSPACE') INTO lv_editflag WHERE namespace = iv_namespace.
        rv_yes = boolc( sy-subrc = 0 AND lv_editflag = 'X' ).
      CATCH cx_sy_dynamic_osql_error.
        ASSIGN ('XCO_CP_SYSTEM=>NAMESPACE') TO <lg_obj>.
        lo_obj = <lg_obj>.
        CALL METHOD lo_obj->('IF_XCO_CP_NAMESPACE_FACTORY~FOR')
          EXPORTING
            iv_value     = iv_namespace
          RECEIVING
            ro_namespace = lo_nsp.
        CALL METHOD lo_nsp->('IF_XCO_CP_NAMESPACE~IS_CHANGEABLE')
          RECEIVING
            rv_exists = rv_yes.
    ENDTRY.
  ENDMETHOD.

  METHOD zif_abapgit_sap_namespace~split_by_name.
* use this method instead of function module RS_NAME_SPLIT_NAMESPACE
    DATA lv_regex  TYPE string.
    DATA lv_length TYPE i.
    DATA lr_ex     TYPE REF TO cx_root.

    lv_regex = '^\/[^\/]{1,8}\/'.

    TRY.
        FIND REGEX lv_regex IN iv_obj_with_namespace MATCH LENGTH lv_length.
      CATCH cx_root INTO lr_ex.
        zcx_abapgit_exception=>raise( lr_ex->get_text( ) ).
    ENDTRY.

    IF sy-subrc = 0 AND lv_length > 1.
      rs_obj_namespace-namespace = iv_obj_with_namespace(lv_length).
      rs_obj_namespace-obj_without_namespace = iv_obj_with_namespace+lv_length.
    ELSE.
      IF iv_obj_with_namespace(1) = '/'.
        zcx_abapgit_exception=>raise( |The object { iv_obj_with_namespace } has an invalid namespace| ).
      ENDIF.
      rs_obj_namespace-obj_without_namespace = iv_obj_with_namespace.
    ENDIF.

    IF iv_allow_slash_in_name = abap_false AND rs_obj_namespace-obj_without_namespace CA '/'.
      zcx_abapgit_exception=>raise(
       |Object without namespace { rs_obj_namespace-obj_without_namespace } contains a '/'| ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_sap_package IMPLEMENTATION.

  METHOD constructor.
    mv_package = iv_package.
  ENDMETHOD.

  METHOD get_transport_layer.

    " Get default transport layer
    CALL FUNCTION 'TR_GET_TRANSPORT_TARGET'
      EXPORTING
        iv_use_default             = abap_true
        iv_get_layer_only          = abap_true
      IMPORTING
        ev_layer                   = rv_transport_layer
      EXCEPTIONS
        wrong_call                 = 1
        invalid_input              = 2
        cts_initialization_failure = 3
        OTHERS                     = 4.
    IF sy-subrc <> 0.
      " Return empty layer (i.e. "local workbench request" for the package)
      CLEAR rv_transport_layer.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~are_changes_recorded_in_tr_req.

    DATA: li_package TYPE REF TO if_package.

    cl_package_factory=>load_package(
      EXPORTING
        i_package_name             = mv_package
      IMPORTING
        e_package                  = li_package
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        no_access                  = 4
        object_locked_and_modified = 5
        OTHERS                     = 6 ).

    CASE sy-subrc.
      WHEN 0.
        rv_are_changes_rec_in_tr_req = li_package->wbo_korr_flag.
      WHEN 1.
        " For new packages, derive from package name
        rv_are_changes_rec_in_tr_req = boolc( mv_package(1) <> '$' AND mv_package(1) <> 'T' ).
      WHEN OTHERS.
        zcx_abapgit_exception=>raise_t100( ).
    ENDCASE.

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~create.

    DATA: lv_err     TYPE string,
          li_package TYPE REF TO if_package,
          ls_package TYPE scompkdtln.

    ASSERT NOT is_package-devclass IS INITIAL.

    cl_package_factory=>load_package(
      EXPORTING
        i_package_name             = is_package-devclass
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        no_access                  = 4
        object_locked_and_modified = 5 ).
    IF sy-subrc = 0.
      " Package already exists. We assume this is fine. Its properties might be changed later at
      " DEVC deserialization.
      RETURN.
    ENDIF.

    MOVE-CORRESPONDING is_package TO ls_package.

    " Set software component to 'HOME' if none is set at this point.
    " Otherwise SOFTWARE_COMPONENT_INVALID will be raised.
    IF ls_package-dlvunit IS INITIAL.
      ls_package-dlvunit = 'HOME'.
    ENDIF.

    " For transportable packages, get default transport and layer
    IF ls_package-devclass(1) <> '$' AND ls_package-pdevclass IS INITIAL.
      ls_package-pdevclass = get_transport_layer( ).
    ENDIF.

    cl_package_factory=>create_new_package(
      EXPORTING
        i_reuse_deleted_object     = abap_true
*        i_suppress_dialog          = abap_true " does not exist in 730
      IMPORTING
        e_package                  = li_package
      CHANGING
        c_package_data             = ls_package
      EXCEPTIONS
        object_already_existing    = 1
        object_just_created        = 2
        not_authorized             = 3
        wrong_name_prefix          = 4
        undefined_name             = 5
        reserved_local_name        = 6
        invalid_package_name       = 7
        short_text_missing         = 8
        software_component_invalid = 9
        layer_invalid              = 10
        author_not_existing        = 11
        component_not_existing     = 12
        component_missing          = 13
        prefix_in_use              = 14
        unexpected_error           = 15
        intern_err                 = 16
        no_access                  = 17
*        invalid_translation_depth  = 18
*        wrong_mainpack_value       = 19
*        superpackage_invalid       = 20
*        error_in_cts_checks        = 21
        OTHERS                     = 18 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    li_package->save(
*      EXPORTING
*        i_suppress_dialog     = abap_true    " Controls whether popups can be transmitted
      EXCEPTIONS
        object_invalid        = 1
        object_not_changeable = 2
        cancelled_in_corr     = 3
        permission_failure    = 4
        unexpected_error      = 5
        intern_err            = 6
        OTHERS                = 7 ).
    IF sy-subrc <> 0.

      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_err.

      " Here we have to delete the package,
      " otherwise it would remain in the memory
      " and cannot created again in this session.
      li_package->delete(
        EXCEPTIONS
          object_not_empty      = 1
          object_not_changeable = 2
          object_invalid        = 3
          intern_err            = 4
          OTHERS                = 5 ).

      zcx_abapgit_exception=>raise( lv_err ).

    ENDIF.

    li_package->set_changeable( abap_false ).

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~create_child.

    DATA: li_parent TYPE REF TO if_package,
          ls_child  TYPE zif_abapgit_sap_package=>ty_create.

    cl_package_factory=>load_package(
      EXPORTING
        i_package_name             = mv_package
      IMPORTING
        e_package                  = li_parent
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        no_access                  = 4
        object_locked_and_modified = 5 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    ls_child-devclass  = iv_child.
    ls_child-dlvunit   = li_parent->software_component.
    ls_child-component = li_parent->application_component.
    ls_child-ctext     = iv_child.
    ls_child-parentcl  = mv_package.
    ls_child-pdevclass = li_parent->transport_layer.
    ls_child-as4user   = sy-uname.

    zif_abapgit_sap_package~create( ls_child ).

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~create_local.

    DATA: ls_package TYPE zif_abapgit_sap_package=>ty_create.

    ls_package-devclass  = mv_package.
    ls_package-ctext     = mv_package.
    ls_package-parentcl  = '$TMP'.
    ls_package-dlvunit   = 'LOCAL'.
    ls_package-as4user   = sy-uname.

    zif_abapgit_sap_package~create( ls_package ).

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~exists.

    cl_package_factory=>load_package(
      EXPORTING
        i_package_name             = mv_package
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        no_access                  = 4
        object_locked_and_modified = 5 ).
    rv_bool = boolc( sy-subrc <> 1 ).

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~get.

    DATA li_package TYPE REF TO if_package.

    cl_package_factory=>load_package(
      EXPORTING
        i_package_name             = mv_package
      IMPORTING
        e_package                  = li_package
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        no_access                  = 4
        object_locked_and_modified = 5
        OTHERS                     = 6 ).

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    rs_package-devclass  = li_package->package_name.
    rs_package-dlvunit   = li_package->software_component.
    rs_package-component = li_package->application_component.
    rs_package-ctext     = li_package->short_text.
    rs_package-parentcl  = li_package->super_package_name.
    rs_package-pdevclass = li_package->transport_layer.
    rs_package-as4user   = li_package->changed_by.

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~get_transport_type.

    DATA:
      lv_pkg_name TYPE e071-obj_name,
      lv_obj_name TYPE tadir-obj_name,
      lv_role     TYPE trnrole.

    lv_pkg_name = mv_package.
    lv_obj_name = mv_package.

    CALL FUNCTION 'TR_GET_REQUEST_TYPE'
      EXPORTING
        iv_pgmid          = 'R3TR'
        iv_object         = 'DEVC'
        iv_obj_name       = lv_pkg_name
      IMPORTING
        ev_request_type   = rs_transport_type-request
        ev_task_type      = rs_transport_type-task
      EXCEPTIONS
        no_request_needed = 1
        invalid_object    = 2
        system_error      = 3
        OTHERS            = 4.

    CASE sy-subrc.
      WHEN 0 OR 1.
        RETURN.
      WHEN 2.
        " For new packages, set to workbench request
        rs_transport_type-request = 'K'.

        CALL FUNCTION 'TR_GET_NAMESPACE_AND_ROLE'
          EXPORTING
            iv_pgmid                   = 'R3TR'
            iv_object                  = 'DEVC'
            iv_objname                 = lv_obj_name
          IMPORTING
            ev_role                    = lv_role
          EXCEPTIONS
            namespace_not_existing     = 1
            invalid_object             = 2
            namespace_not_determinable = 3
            OTHERS                     = 4.
        IF sy-subrc = 0 AND lv_role = 'C'.
          " Namespace with repair license requires repair task
          rs_transport_type-task = 'R'.
        ELSE.
          " Otherwise use correction task
          rs_transport_type-task = 'S'.
        ENDIF.
      WHEN OTHERS.
        zcx_abapgit_exception=>raise_t100( ).
    ENDCASE.

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~list_subpackages.

    DATA: lt_list     LIKE rt_list.

    SELECT devclass FROM tdevc
      INTO TABLE lt_list
      WHERE parentcl = mv_package
      ORDER BY PRIMARY KEY.               "#EC CI_SUBRC "#EC CI_GENBUFF

    rt_list = lt_list.
    WHILE lines( lt_list ) > 0.

      SELECT devclass FROM tdevc
        INTO TABLE lt_list
        FOR ALL ENTRIES IN lt_list
        WHERE parentcl = lt_list-table_line
        ORDER BY PRIMARY KEY.             "#EC CI_SUBRC "#EC CI_GENBUFF
      APPEND LINES OF lt_list TO rt_list.

    ENDWHILE.

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~list_superpackages.

    DATA: lt_list   LIKE rt_list,
          lv_parent TYPE tdevc-parentcl.

    APPEND mv_package TO rt_list.

    lv_parent = zif_abapgit_sap_package~read_parent( ).

    IF sy-subrc = 0 AND NOT lv_parent IS INITIAL.
      lt_list = zcl_abapinst_factory=>get_sap_package( lv_parent )->list_superpackages( ).
      APPEND LINES OF lt_list TO rt_list.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~read_description.

    SELECT SINGLE ctext FROM tdevct INTO rv_description
      WHERE devclass = mv_package AND spras = sy-langu ##SUBRC_OK.

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~read_parent.

    SELECT SINGLE parentcl FROM tdevc INTO rv_parentcl
      WHERE devclass = mv_package.                      "#EC CI_GENBUFF
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Inconsistent package structure! Cannot find parent for { mv_package }| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_sap_package~read_responsible.
    SELECT SINGLE as4user FROM tdevc
      INTO rv_responsible
      WHERE devclass = mv_package ##SUBRC_OK.           "#EC CI_GENBUFF
  ENDMETHOD.

  METHOD zif_abapgit_sap_package~validate_name.

    IF mv_package IS INITIAL.
      zcx_abapgit_exception=>raise( 'Package name must not be empty' ).
    ENDIF.

    IF mv_package = '$TMP'.
      zcx_abapgit_exception=>raise( 'It is not possible to use $TMP, use a different (local) package' ).
    ENDIF.

    " Check if package name is allowed
    cl_package_helper=>check_package_name(
      EXPORTING
        i_package_name       = mv_package
      EXCEPTIONS
        undefined_name       = 1
        wrong_name_prefix    = 2
        reserved_local_name  = 3
        invalid_package_name = 4 ).
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Package name { mv_package } is not valid| ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_sap_report IMPLEMENTATION.

  METHOD authorization_check.

    IF is_item IS NOT INITIAL.
      TRY.
          CALL FUNCTION 'RS_ACCESS_PERMISSION'
            EXPORTING
              mode                           = iv_mode
              object                         = is_item-obj_name
              object_class                   = is_item-obj_type
              suppress_corr_check            = abap_true
              suppress_language_check        = abap_true
              suppress_extend_dialog         = abap_true
              abap_langu_version_upon_insert = is_item-abap_language_version " does not exist on lower releases
            EXCEPTIONS
              canceled_in_corr               = 1
              enqueued_by_user               = 2
              enqueue_system_failure         = 3
              illegal_parameter_values       = 4
              locked_by_author               = 5
              no_modify_permission           = 6
              no_show_permission             = 7
              permission_failure             = 8
              request_language_denied        = 9
              OTHERS                         = 10 ##FM_SUBRC_OK.
        CATCH cx_sy_dyn_call_param_not_found.
          CALL FUNCTION 'RS_ACCESS_PERMISSION'
            EXPORTING
              mode                     = iv_mode
              object                   = is_item-obj_name
              object_class             = is_item-obj_type
              suppress_corr_check      = abap_true
              suppress_language_check  = abap_true
              suppress_extend_dialog   = abap_true
            EXCEPTIONS
              canceled_in_corr         = 1
              enqueued_by_user         = 2
              enqueue_system_failure   = 3
              illegal_parameter_values = 4
              locked_by_author         = 5
              no_modify_permission     = 6
              no_show_permission       = 7
              permission_failure       = 8
              request_language_denied  = 9
              OTHERS                   = 10 ##FM_SUBRC_OK.
      ENDTRY.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_sap_report~delete_report.

    authorization_check(
      iv_mode = 'DELETE'
      is_item = is_item ).

    DELETE REPORT iv_name.

    IF sy-subrc <> 0 AND iv_raise_error = abap_true.
      zcx_abapgit_exception=>raise( |Error deleting report { iv_name }| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_sap_report~insert_report.

    ASSERT iv_state CA ' AI'.
    ASSERT iv_program_type CA ' 1FIJKMST'.

    authorization_check(
      iv_mode = 'MODIFY'
      is_item = is_item ).

    IF iv_state IS INITIAL.
      INSERT REPORT iv_name FROM it_source.
    ELSEIF iv_program_type IS INITIAL AND iv_extension_type IS INITIAL.
      INSERT REPORT iv_name FROM it_source
        STATE iv_state.
    ELSEIF iv_extension_type IS INITIAL.
      INSERT REPORT iv_name FROM it_source
        STATE iv_state
        PROGRAM TYPE iv_program_type.
    ELSE.
      INSERT REPORT iv_name FROM it_source
        STATE iv_state
        EXTENSION TYPE iv_extension_type
        PROGRAM TYPE iv_program_type.
    ENDIF.

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Error inserting report { iv_name }| ).
    ENDIF.

    " In lower releases, INSERT REPORT does not support setting ABAP Language version (VERSION)
    " Therefore, update the flag directly
    UPDATE progdir SET uccheck = iv_version WHERE name = iv_name AND state = iv_state.

  ENDMETHOD.

  METHOD zif_abapgit_sap_report~read_progdir.

    DATA ls_sapdir TYPE progdir.

    CALL FUNCTION 'READ_PROGDIR'
      EXPORTING
        i_progname = iv_name
        i_state    = iv_state
      IMPORTING
        e_progdir  = ls_sapdir
      EXCEPTIONS
        not_exists = 1
        OTHERS     = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

    MOVE-CORRESPONDING ls_sapdir TO rs_progdir.

    CLEAR: rs_progdir-edtx,
           rs_progdir-cnam,
           rs_progdir-cdat,
           rs_progdir-unam,
           rs_progdir-udat,
           rs_progdir-levl,
           rs_progdir-vern,
           rs_progdir-rmand,
           rs_progdir-sdate,
           rs_progdir-stime,
           rs_progdir-idate,
           rs_progdir-itime,
           rs_progdir-varcl,
           rs_progdir-state.

  ENDMETHOD.

  METHOD zif_abapgit_sap_report~read_report.

    ASSERT iv_state CA ' AI'.

    authorization_check(
      iv_mode = 'SHOW'
      is_item = is_item ).

    IF iv_state IS INITIAL.
      READ REPORT iv_name INTO rt_source.
    ELSE.
      READ REPORT iv_name INTO rt_source STATE iv_state.
    ENDIF.

    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Error reading report { iv_name }| ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_sap_report~update_progdir.

    DATA ls_progdir_new TYPE progdir.

    CALL FUNCTION 'READ_PROGDIR'
      EXPORTING
        i_progname = is_progdir-name
        i_state    = iv_state
      IMPORTING
        e_progdir  = ls_progdir_new
      EXCEPTIONS
        not_exists = 1
        OTHERS     = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'Error reading program directory' ).
    ENDIF.

    ls_progdir_new-ldbname = is_progdir-ldbname.
    ls_progdir_new-dbna    = is_progdir-dbna.
    ls_progdir_new-dbapl   = is_progdir-dbapl.
    ls_progdir_new-rload   = is_progdir-rload.
    ls_progdir_new-fixpt   = is_progdir-fixpt.
    ls_progdir_new-appl    = is_progdir-appl.
    ls_progdir_new-rstat   = is_progdir-rstat.
    ls_progdir_new-uccheck = is_progdir-uccheck.
    ls_progdir_new-sqlx    = is_progdir-sqlx.
    ls_progdir_new-clas    = is_progdir-clas.
    ls_progdir_new-secu    = is_progdir-secu.

    CALL FUNCTION 'UPDATE_PROGDIR'
      EXPORTING
        i_progdir    = ls_progdir_new
        i_progname   = ls_progdir_new-name
        i_state      = ls_progdir_new-state
      EXCEPTIONS
        not_executed = 1
        OTHERS       = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( 'Error updating program directory' ).
    ENDIF.

    " Function UPDATE_PROGDIR does not update VARCL, so we do it here
    SELECT SINGLE * FROM progdir INTO ls_progdir_new
      WHERE name  = ls_progdir_new-name
        AND state = ls_progdir_new-state.
    IF sy-subrc = 0 AND is_progdir-varcl <> ls_progdir_new-varcl.
      UPDATE progdir SET varcl = is_progdir-varcl
        WHERE name  = ls_progdir_new-name
          AND state = ls_progdir_new-state.               "#EC CI_SUBRC
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_sap_report~update_report.

    DATA lt_new TYPE string_table.
    DATA lt_old TYPE string_table.

    lt_new = it_source.
    lt_old = zif_abapgit_sap_report~read_report( iv_name ).

    IF lt_old <> lt_new.
      zif_abapgit_sap_report~insert_report(
        iv_name           = iv_name
        it_source         = it_source
        iv_state          = iv_state
        iv_program_type   = iv_program_type
        iv_extension_type = iv_extension_type
        iv_package        = iv_package
        iv_version        = iv_version
        is_item           = is_item ).

      rv_updated = abap_true.
    ELSE.
      rv_updated = abap_false.
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_sotr_handler IMPLEMENTATION.

  METHOD change_sotr_package.

    DATA lt_concepts TYPE btfr_conc_tt.

    " Short texts
    SELECT concept FROM sotr_head INTO TABLE lt_concepts
      WHERE paket = iv_old_package
      ORDER BY PRIMARY KEY.

    IF lt_concepts IS NOT INITIAL.
      CALL FUNCTION 'BTFR_CHANGE_PACKAGE'
        EXPORTING
          concept_tab         = lt_concepts
          new_package         = iv_new_package
          flag_string         = abap_false
          flag_ignore_system  = abap_true
        EXCEPTIONS
          invalid_package     = 1
          invalid_tadir_entry = 2
          update_error        = 3
          OTHERS              = 4.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDIF.

    CLEAR lt_concepts.

    " Long texts
    SELECT concept FROM sotr_headu INTO TABLE lt_concepts
      WHERE paket = iv_old_package
      ORDER BY PRIMARY KEY.

    IF lt_concepts IS NOT INITIAL.
      CALL FUNCTION 'BTFR_CHANGE_PACKAGE'
        EXPORTING
          concept_tab         = lt_concepts
          new_package         = iv_new_package
          flag_string         = abap_true
          flag_ignore_system  = abap_true
        EXCEPTIONS
          invalid_package     = 1
          invalid_tadir_entry = 2
          update_error        = 3
          OTHERS              = 4.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD create_sotr.

    DATA:
      lt_sotr     TYPE ty_sotr_tt,
      lt_sotr_use TYPE ty_sotr_use_tt.

    io_xml->read( EXPORTING iv_name = 'SOTR'
                  CHANGING cg_data = lt_sotr ).
    io_xml->read( EXPORTING iv_name = 'SOTR_USE'
                  CHANGING cg_data = lt_sotr_use ).

    create_sotr_from_data(
      iv_package  = iv_package
      it_sotr     = lt_sotr
      it_sotr_use = lt_sotr_use ).

  ENDMETHOD.

  METHOD create_sotr_from_data.

    DATA:
      lt_objects TYPE sotr_objects,
      ls_paket   TYPE sotr_pack,
      lv_alias   TYPE sotr_head-alias_name,
      lv_object  LIKE LINE OF lt_objects.

    FIELD-SYMBOLS: <ls_sotr> LIKE LINE OF it_sotr.

    LOOP AT it_sotr ASSIGNING <ls_sotr>.
      CALL FUNCTION 'SOTR_OBJECT_GET_OBJECTS'
        EXPORTING
          object_vector    = <ls_sotr>-header-objid_vec
        IMPORTING
          objects          = lt_objects
        EXCEPTIONS
          object_not_found = 1
          OTHERS           = 2.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      READ TABLE lt_objects INDEX 1 INTO lv_object.
      ASSERT sy-subrc = 0.

      ls_paket-paket = iv_package.

      " Replace package in alias with new package
      lv_alias = <ls_sotr>-header-alias_name.
      IF lv_alias CS '/'.
        lv_alias = iv_package && lv_alias+sy-fdpos(*).
      ENDIF.

      CALL FUNCTION 'SOTR_CREATE_CONCEPT'
        EXPORTING
          paket                         = ls_paket
          crea_lan                      = <ls_sotr>-header-crea_lan
          alias_name                    = lv_alias
          object                        = lv_object
          entries                       = <ls_sotr>-entries
          concept_default               = <ls_sotr>-header-concept
        EXCEPTIONS
          package_missing               = 1
          crea_lan_missing              = 2
          object_missing                = 3
          paket_does_not_exist          = 4
          alias_already_exist           = 5
          object_type_not_found         = 6
          langu_missing                 = 7
          identical_context_not_allowed = 8
          text_too_long                 = 9
          error_in_update               = 10
          no_master_langu               = 11
          error_in_concept_id           = 12
          alias_not_allowed             = 13
          tadir_entry_creation_failed   = 14
          internal_error                = 15
          error_in_correction           = 16
          user_cancelled                = 17
          no_entry_found                = 18
          OTHERS                        = 19.
      IF sy-subrc <> 0 AND sy-subrc <> 5.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.
    ENDLOOP.

    CALL FUNCTION 'SOTR_USAGE_MODIFY'
      EXPORTING
        sotr_usage = it_sotr_use.

  ENDMETHOD.

  METHOD delete_sotr.

    DATA lt_sotr_use TYPE ty_sotr_use_tt.

    FIELD-SYMBOLS <ls_sotr_use> LIKE LINE OF lt_sotr_use.

    lt_sotr_use = get_sotr_usage( iv_pgmid    = iv_pgmid
                                  iv_object   = iv_object
                                  iv_obj_name = iv_obj_name ).

    " Remove any usage to ensure deletion, see function module BTFR_CHECK
    DELETE sotr_use FROM TABLE lt_sotr_use ##SUBRC_OK.

    LOOP AT lt_sotr_use ASSIGNING <ls_sotr_use> WHERE concept IS NOT INITIAL.

      CALL FUNCTION 'SOTR_DELETE_CONCEPT'
        EXPORTING
          concept             = <ls_sotr_use>-concept
        EXCEPTIONS
          no_entry_found      = 1
          text_not_found      = 2
          invalid_package     = 3
          text_not_changeable = 4
          text_enqueued       = 5
          no_correction       = 6
          parameter_error     = 7
          OTHERS              = 8.
      IF sy-subrc > 2.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD delete_sotr_package.

    DATA lt_sotr_head TYPE STANDARD TABLE OF sotr_head WITH DEFAULT KEY.
    DATA lv_obj_name TYPE tadir-obj_name.

    FIELD-SYMBOLS <ls_sotr_head> LIKE LINE OF lt_sotr_head.

    SELECT * FROM sotr_head INTO TABLE lt_sotr_head WHERE paket = iv_package ORDER BY PRIMARY KEY.

    LOOP AT lt_sotr_head ASSIGNING <ls_sotr_head> WHERE concept IS NOT INITIAL.

      CALL FUNCTION 'SOTR_DELETE_CONCEPT'
        EXPORTING
          concept             = <ls_sotr_head>-concept
        EXCEPTIONS
          no_entry_found      = 1
          text_not_found      = 2
          invalid_package     = 3
          text_not_changeable = 4
          text_enqueued       = 5
          no_correction       = 6
          parameter_error     = 7
          OTHERS              = 8.
      IF sy-subrc > 2.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

    ENDLOOP.

    " Nothing left, then delete SOTR from TADIR
    SELECT * FROM sotr_head INTO TABLE lt_sotr_head WHERE paket = iv_package ORDER BY PRIMARY KEY.
    IF sy-subrc <> 0.
      SELECT SINGLE obj_name FROM tadir INTO lv_obj_name
        WHERE pgmid = 'R3TR' AND object = 'SOTR' AND obj_name = iv_package.
      IF sy-subrc = 0.
        CALL FUNCTION 'TR_TADIR_INTERFACE'
          EXPORTING
            wi_delete_tadir_entry = abap_true
            wi_test_modus         = abap_false
            wi_tadir_pgmid        = 'R3TR'
            wi_tadir_object       = 'SOTR'
            wi_tadir_obj_name     = lv_obj_name
          EXCEPTIONS
            OTHERS                = 1 ##FM_SUBRC_OK.

        IF zcl_abapinst_factory=>get_sap_package( iv_package )->are_changes_recorded_in_tr_req( ) = abap_true.

          zcl_abapinst_factory=>get_cts_api( )->insert_transport_object(
            iv_object   = 'SOTR'
            iv_obj_name = lv_obj_name
            iv_package  = iv_package
            iv_mode     = zif_abapgit_cts_api=>c_transport_mode-delete ).

        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD get_sotr_4_concept.

    DATA: ls_header  TYPE ty_sotr-header,
          lv_paket   LIKE ls_header-alias_name,
          lt_entries TYPE ty_sotr-entries.

    FIELD-SYMBOLS: <ls_entry> LIKE LINE OF lt_entries.

    CALL FUNCTION 'SOTR_GET_CONCEPT'
      EXPORTING
        concept        = iv_concept
      IMPORTING
        header         = ls_header
      TABLES
        entries        = lt_entries
      EXCEPTIONS
        no_entry_found = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    " If alias contains package, remove it
    lv_paket = ls_header-paket && '/'.
    IF ls_header-alias_name CS lv_paket.
      ls_header-alias_name = replace(
        val  = ls_header-alias_name
        sub  = lv_paket
        with = '/'
        occ  = 1 ).
    ENDIF.

    CLEAR: ls_header-paket,
           ls_header-crea_name,
           ls_header-crea_tstut,
           ls_header-chan_name,
           ls_header-chan_tstut,
           ls_header-system_id.

    LOOP AT lt_entries ASSIGNING <ls_entry>.
      CLEAR: <ls_entry>-version,
             <ls_entry>-crea_name,
             <ls_entry>-crea_tstut,
             <ls_entry>-chan_name,
             <ls_entry>-chan_tstut.
    ENDLOOP.

    rs_sotr-header  = ls_header.
    rs_sotr-entries = lt_entries.

  ENDMETHOD.

  METHOD get_sotr_usage.

    DATA: lv_obj_name TYPE trobj_name.

    lv_obj_name = iv_obj_name.

    " Objects with multiple components
    IF iv_pgmid = 'LIMU' AND ( iv_object CP 'WDY*' OR iv_object = 'WAPP' ).
      lv_obj_name+30 = '%'.
    ENDIF.

    CALL FUNCTION 'SOTR_USAGE_READ'
      EXPORTING
        pgmid          = iv_pgmid
        object         = iv_object
        obj_name       = lv_obj_name
      IMPORTING
        sotr_usage     = rt_sotr_use
      EXCEPTIONS
        no_entry_found = 1
        error_in_pgmid = 2
        OTHERS         = 3.
    IF sy-subrc = 0.
      SORT rt_sotr_use.
    ENDIF.

  ENDMETHOD.

  METHOD read_sotr.

    FIELD-SYMBOLS <ls_sotr_use> LIKE LINE OF et_sotr_use.

    DATA: lv_sotr            TYPE ty_sotr,
          lt_language_filter TYPE zif_abapgit_environment=>ty_system_language_filter.

    " OTR short text usage: see TABLE BTFR_OBJ_IDS
    " LIMU: CPUB, WAPP, WDYC, WDYD, WDYV
    " R3TR: ENHC, ENHO, ENHS, ENSC, SCGR, SMIF, WDCA, WDCC, WEBI, WEBS

    et_sotr_use = get_sotr_usage( iv_pgmid    = iv_pgmid
                                  iv_object   = iv_object
                                  iv_obj_name = iv_obj_name ).

    LOOP AT et_sotr_use ASSIGNING <ls_sotr_use> WHERE concept IS NOT INITIAL.
      lv_sotr = get_sotr_4_concept( <ls_sotr_use>-concept ).

      IF io_xml IS BOUND AND io_i18n_params->ms_params-main_language_only = abap_true.
        DELETE lv_sotr-entries WHERE langu <> io_i18n_params->ms_params-main_language.
        CHECK lv_sotr-entries IS NOT INITIAL.
      ENDIF.
      lt_language_filter = io_i18n_params->build_language_filter( ).
      DELETE lv_sotr-entries WHERE NOT langu IN lt_language_filter
        AND langu <> io_i18n_params->ms_params-main_language.
      CHECK lv_sotr-entries IS NOT INITIAL.

      INSERT lv_sotr INTO TABLE et_sotr.
    ENDLOOP.

    IF io_xml IS BOUND.
      io_xml->add( iv_name = 'SOTR'
                   ig_data = et_sotr ).
      io_xml->add( iv_name = 'SOTR_USE'
                   ig_data = et_sotr_use ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_SOTS_HANDLER IMPLEMENTATION.

  METHOD create_sots.

    DATA:
      lt_sots     TYPE ty_sots_tt,
      lt_sots_use TYPE ty_sots_use_tt.

    io_xml->read( EXPORTING iv_name = 'SOTS'
                  CHANGING  cg_data = lt_sots ).
    io_xml->read( EXPORTING iv_name = 'SOTS_USE'
                  CHANGING  cg_data = lt_sots_use ).

    create_sots_from_data(
      iv_package  = iv_package
      it_sots     = lt_sots
      it_sots_use = lt_sots_use ).

  ENDMETHOD.

  METHOD create_sots_from_data.

    DATA:
      lt_objects         TYPE sotr_objects,
      lv_object          LIKE LINE OF lt_objects,
      lv_subrc           TYPE sy-subrc,
      ls_header          TYPE btfr_head,
      lt_text_tab        TYPE sotr_text_tt,
      lt_string_tab      TYPE sotr_textl_tt,
      ls_entry           LIKE LINE OF lt_string_tab,
      lv_concept         TYPE sotr_conc,
      lv_concept_default TYPE sotr_conc.

    FIELD-SYMBOLS <ls_sots> LIKE LINE OF it_sots.

    LOOP AT it_sots ASSIGNING <ls_sots>.

      CALL FUNCTION 'SOTR_OBJECT_GET_OBJECTS'
        EXPORTING
          object_vector    = <ls_sots>-header-objid_vec
        IMPORTING
          objects          = lt_objects
        EXCEPTIONS
          object_not_found = 1
          OTHERS           = 2.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

      READ TABLE lt_objects INDEX 1 INTO lv_object.
      ASSERT sy-subrc = 0.

      " Reimplementation of SOTR_STRING_CREATE_CONCEPT because we can't supply
      " concept and it would then be generated.

      LOOP AT <ls_sots>-entries INTO ls_entry.
        ls_entry-langu   = <ls_sots>-header-crea_lan.
        ls_entry-concept = <ls_sots>-header-concept.
        INSERT ls_entry INTO TABLE lt_string_tab.
      ENDLOOP.

      MOVE-CORRESPONDING <ls_sots>-header TO ls_header.
      ls_header-paket = iv_package.

      lv_concept = <ls_sots>-header-concept.

      PERFORM btfr_create IN PROGRAM saplsotr_db_string
        USING lv_object
              sy-langu
              abap_false
              abap_true
        CHANGING lt_text_tab
                 lt_string_tab
                 ls_header
                 lv_concept
                 lv_concept_default
                 lv_subrc.

      CASE lv_subrc.
        WHEN 1.
          MESSAGE e100(sotr_mess) INTO zcx_abapgit_exception=>null.
        WHEN 2.
          MESSAGE e101(sotr_mess) INTO zcx_abapgit_exception=>null.
        WHEN 3.
          MESSAGE i305(sotr_mess) INTO zcx_abapgit_exception=>null.
        WHEN 4.
          " The concept will be created in the non-original system (not an error)
        WHEN 5.
          MESSAGE e504(sotr_mess) INTO zcx_abapgit_exception=>null.
        WHEN 6.
          MESSAGE e035(sotr_mess) INTO zcx_abapgit_exception=>null.
        WHEN 7.
          MESSAGE e170(sotr_mess) INTO zcx_abapgit_exception=>null.
        WHEN 9.
          MESSAGE e102(sotr_mess) INTO zcx_abapgit_exception=>null.
      ENDCASE.

      IF lv_subrc <> 0 AND lv_subrc <> 4.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

    ENDLOOP.

    CALL FUNCTION 'SOTR_USAGE_STRING_MODIFY'
      EXPORTING
        sotr_usage = it_sots_use.

  ENDMETHOD.

  METHOD delete_sots.

    DATA lt_sots_use TYPE ty_sots_use_tt.

    FIELD-SYMBOLS <ls_sots_use> LIKE LINE OF lt_sots_use.

    lt_sots_use = get_sots_usage( iv_pgmid    = iv_pgmid
                                  iv_object   = iv_object
                                  iv_obj_name = iv_obj_name ).

    " Remove any usage to ensure deletion, see function module BTFR_CHECK
    DELETE sotr_useu FROM TABLE lt_sots_use ##SUBRC_OK.

    LOOP AT lt_sots_use ASSIGNING <ls_sots_use> WHERE concept IS NOT INITIAL.

      CALL FUNCTION 'BTFR_DELETE_SINGLE_TEXT'
        EXPORTING
          concept             = <ls_sots_use>-concept
          flag_string         = abap_true
        EXCEPTIONS
          text_not_found      = 1 "ok
          invalid_package     = 3
          text_not_changeable = 4
          text_enqueued       = 5
          no_correction       = 6
          parameter_error     = 7
          OTHERS              = 8.
      IF sy-subrc > 2.
        zcx_abapgit_exception=>raise_t100( ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD get_sots_4_concept.

    DATA: ls_header  TYPE ty_sots-header,
          lt_entries TYPE ty_sots-entries.

    FIELD-SYMBOLS <ls_entry> LIKE LINE OF lt_entries.

    CALL FUNCTION 'SOTR_STRING_GET_CONCEPT'
      EXPORTING
        concept        = iv_concept
      IMPORTING
        header         = ls_header
        entries        = lt_entries
      EXCEPTIONS
        no_entry_found = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    CLEAR: ls_header-paket,
           ls_header-crea_name,
           ls_header-crea_tstut,
           ls_header-chan_name,
           ls_header-chan_tstut,
           ls_header-system_id.

    LOOP AT lt_entries ASSIGNING <ls_entry>.
      CLEAR: <ls_entry>-version,
             <ls_entry>-crea_name,
             <ls_entry>-crea_tstut,
             <ls_entry>-chan_name,
             <ls_entry>-chan_tstut.
    ENDLOOP.

    rs_sots-header  = ls_header.
    rs_sots-entries = lt_entries.

  ENDMETHOD.

  METHOD get_sots_usage.

    DATA: lv_obj_name TYPE trobj_name.

    lv_obj_name = iv_obj_name.

    " Objects with multiple components
    IF iv_pgmid = 'LIMU' AND ( iv_object CP 'WDY*' OR iv_object = 'WAPP' ).
      lv_obj_name+30 = '%'.
    ENDIF.

    CALL FUNCTION 'SOTR_USAGE_STRING_READ'
      EXPORTING
        pgmid          = iv_pgmid
        object         = iv_object
        obj_name       = lv_obj_name
      IMPORTING
        sotr_usage     = rt_sots_use
      EXCEPTIONS
        no_entry_found = 1
        error_in_pgmid = 2
        OTHERS         = 3.
    IF sy-subrc = 0.
      SORT rt_sots_use.
    ENDIF.

  ENDMETHOD.

  METHOD read_sots.

    FIELD-SYMBOLS <ls_sots_use> LIKE LINE OF et_sots_use.

    DATA ls_sots TYPE ty_sots.

    " OTR long text (string) usage: see TABLE BTFR_OBJ_IDS
    " LIMU: CPUB, WAPP
    " R3TR: ENHO, ENHS, SICF, SMIF, WEBI, XSLT

    et_sots_use = get_sots_usage( iv_pgmid    = iv_pgmid
                                  iv_object   = iv_object
                                  iv_obj_name = iv_obj_name ).

    LOOP AT et_sots_use ASSIGNING <ls_sots_use> WHERE concept IS NOT INITIAL.
      ls_sots = get_sots_4_concept( <ls_sots_use>-concept ).

      IF io_i18n_params->ms_params-main_language_only = abap_true.
        DELETE ls_sots-entries WHERE langu <> io_i18n_params->ms_params-main_language.
        CHECK ls_sots-entries IS NOT INITIAL.
      ENDIF.

      INSERT ls_sots INTO TABLE et_sots.
    ENDLOOP.

    IF io_xml IS BOUND.
      io_xml->add( iv_name = 'SOTS'
                   ig_data = et_sots ).
      io_xml->add( iv_name = 'SOTS_USE'
                   ig_data = et_sots_use ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_tadir IMPLEMENTATION.

  METHOD add_local_packages.

    FIELD-SYMBOLS:
      <lv_package> LIKE LINE OF it_packages,
      <ls_tadir>   LIKE LINE OF ct_tadir.

    LOOP AT it_packages ASSIGNING <lv_package>.

      " Local packages are not in TADIR, only in TDEVC, act as if they were
      IF <lv_package> CP '$*'. " OR <package> CP 'T*' ).
        APPEND INITIAL LINE TO ct_tadir ASSIGNING <ls_tadir>.
        <ls_tadir>-pgmid      = 'R3TR'.
        <ls_tadir>-object     = 'DEVC'.
        <ls_tadir>-obj_name   = <lv_package>.
        <ls_tadir>-devclass   = <lv_package>.
        <ls_tadir>-srcsystem  = sy-sysid.
        <ls_tadir>-masterlang = sy-langu.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD add_namespace.

    DATA ls_tadir TYPE zif_abapgit_definitions=>ty_tadir.
    DATA ls_obj_with_namespace TYPE zif_abapgit_definitions=>ty_obj_namespace.

    TRY.
        ls_obj_with_namespace = zcl_abapinst_factory=>get_sap_namespace( )->split_by_name( iv_object ).
      CATCH zcx_abapgit_exception.
        "Ignore the exception like before the replacement of the FM RS_NAME_SPLIT_NAMESPACE
        RETURN.
    ENDTRY.

    IF ls_obj_with_namespace-namespace IS NOT INITIAL.

      READ TABLE ct_tadir_nspc TRANSPORTING NO FIELDS
        WITH KEY pgmid = 'R3TR' object = 'NSPC' obj_name = ls_obj_with_namespace-namespace.
      IF sy-subrc <> 0.
        ls_tadir-pgmid      = 'R3TR'.
        ls_tadir-object     = 'NSPC'.
        ls_tadir-obj_name   = ls_obj_with_namespace-namespace.
        ls_tadir-devclass   = iv_package.
        ls_tadir-srcsystem  = sy-sysid.
        ls_tadir-masterlang = sy-langu.
        INSERT ls_tadir INTO TABLE ct_tadir.
        INSERT ls_tadir INTO TABLE ct_tadir_nspc.
      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD add_namespaces.

    DATA lt_tadir_nspc TYPE zif_abapgit_definitions=>ty_tadir_tt.

    FIELD-SYMBOLS <ls_tadir> LIKE LINE OF ct_tadir.

    " Namespaces are not in TADIR, but are necessary for creating objects in transportable packages
    LOOP AT ct_tadir ASSIGNING <ls_tadir> WHERE obj_name(1) = '/'.
      add_namespace(
        EXPORTING
          iv_package    = iv_package
          iv_object     = <ls_tadir>-obj_name
        CHANGING
          ct_tadir      = ct_tadir
          ct_tadir_nspc = lt_tadir_nspc ).
    ENDLOOP.

    " Root package of repo might not exist yet but needs to be considered, too
    IF iv_package CP '/*'.
      add_namespace(
        EXPORTING
          iv_package    = iv_package
          iv_object     = iv_package
        CHANGING
          ct_tadir      = ct_tadir
          ct_tadir_nspc = lt_tadir_nspc ).
    ENDIF.

  ENDMETHOD.

  METHOD build.

    DATA lt_packages TYPE zif_abapgit_sap_package=>ty_devclass_tt.

    select_objects(
      EXPORTING
        iv_package            = iv_package
        iv_ignore_subpackages = iv_ignore_subpackages
        iv_only_local_objects = iv_only_local_objects
      IMPORTING
        et_tadir              = rt_tadir
        et_packages           = lt_packages ).

    add_local_packages(
      EXPORTING
        it_packages = lt_packages
      CHANGING
        ct_tadir    = rt_tadir ).

    add_namespaces(
      EXPORTING
        iv_package = iv_package
      CHANGING
        ct_tadir   = rt_tadir ).

    determine_path(
      EXPORTING
        iv_package = iv_package
        io_dot     = io_dot
      CHANGING
        ct_tadir   = rt_tadir ).

  ENDMETHOD.

  METHOD check_exists.

    DATA: li_progress TYPE REF TO zif_abapgit_progress,
          ls_item     TYPE zif_abapgit_definitions=>ty_item.

    FIELD-SYMBOLS: <ls_tadir> LIKE LINE OF it_tadir.

    li_progress = zcl_abapgit_progress=>get_instance( lines( it_tadir ) ).

* rows from database table TADIR are not removed for
* transportable objects until the transport is released
    LOOP AT it_tadir ASSIGNING <ls_tadir>.
      IF sy-tabix MOD 200 = 0.
        li_progress->show(
          iv_current = sy-tabix
          iv_text    = |Check object exists { <ls_tadir>-object } { <ls_tadir>-obj_name }| ).
      ENDIF.

      ls_item-obj_type = <ls_tadir>-object.
      ls_item-obj_name = <ls_tadir>-obj_name.
      ls_item-devclass = <ls_tadir>-devclass.

      IF zcl_abapinst_objects=>exists( ls_item ) = abap_true.
        APPEND <ls_tadir> TO rt_tadir.
      ENDIF.
    ENDLOOP.

    li_progress->off( ).

  ENDMETHOD.

  METHOD determine_path.

    DATA:
      lv_path         TYPE string,
      lo_folder_logic TYPE REF TO zcl_abapgit_folder_logic,
      lv_last_package TYPE devclass VALUE cl_abap_char_utilities=>horizontal_tab.

    FIELD-SYMBOLS <ls_tadir> LIKE LINE OF ct_tadir.

    lo_folder_logic = zcl_abapgit_folder_logic=>get_instance( ).

    LOOP AT ct_tadir ASSIGNING <ls_tadir>.

      IF lv_last_package <> <ls_tadir>-devclass.
        "Change in Package
        lv_last_package = <ls_tadir>-devclass.

        IF NOT io_dot IS INITIAL.
          lv_path = lo_folder_logic->package_to_path(
            iv_top     = iv_package
            io_dot     = io_dot
            iv_package = <ls_tadir>-devclass ).
        ENDIF.
      ENDIF.

      <ls_tadir>-path = lv_path.
      <ls_tadir>-korrnum = ''.
    ENDLOOP.

  ENDMETHOD.

  METHOD select_objects.

    DATA:
      lt_excludes  TYPE RANGE OF trobjtype,
      ls_exclude   LIKE LINE OF lt_excludes,
      lt_srcsystem TYPE RANGE OF tadir-srcsystem,
      ls_srcsystem LIKE LINE OF lt_srcsystem.

    " Determine packages to read
    IF iv_ignore_subpackages = abap_false.
      et_packages = zcl_abapinst_factory=>get_sap_package( iv_package )->list_subpackages( ).
    ENDIF.
    INSERT iv_package INTO et_packages INDEX 1.

    " Exclude object types with tadir entries that are included elsewhere
    ls_exclude-sign   = 'I'.
    ls_exclude-option = 'EQ'.
    ls_exclude-low    = 'SOTR'. " automatically created for SAP packages (DEVC)
    APPEND ls_exclude TO lt_excludes.
    ls_exclude-low    = 'SOTS'. " automatically created for SAP packages (DEVC)
    APPEND ls_exclude TO lt_excludes.
    ls_exclude-low    = 'SFB1'. " covered by business function sets (SFBS)
    APPEND ls_exclude TO lt_excludes.
    ls_exclude-low    = 'SFB2'. " covered by business functions (SFBF)
    APPEND ls_exclude TO lt_excludes.
    ls_exclude-low    = 'STOB'. " auto generated by core data services (DDLS)
    APPEND ls_exclude TO lt_excludes.

    " Limit to objects belonging to this system
    IF iv_only_local_objects = abap_true.
      ls_srcsystem-sign   = 'I'.
      ls_srcsystem-option = 'EQ'.
      ls_srcsystem-low    = sy-sysid.
      APPEND ls_srcsystem TO lt_srcsystem.
    ENDIF.

    IF et_packages IS NOT INITIAL.
      SELECT * FROM tadir INTO CORRESPONDING FIELDS OF TABLE et_tadir
        FOR ALL ENTRIES IN et_packages
        WHERE devclass = et_packages-table_line
        AND pgmid      = 'R3TR'
        AND object     NOT IN lt_excludes
        AND delflag    = abap_false
        AND srcsystem  IN lt_srcsystem
        ORDER BY PRIMARY KEY ##TOO_MANY_ITAB_FIELDS. "#EC CI_GENBUFF "#EC CI_SUBRC
    ENDIF.

    SORT et_tadir BY devclass pgmid object obj_name.

  ENDMETHOD.

  METHOD zif_abapgit_tadir~get_object_package.

    DATA: ls_tadir TYPE zif_abapgit_definitions=>ty_tadir,
          ls_item  TYPE zif_abapgit_definitions=>ty_item.

    ls_tadir = zif_abapgit_tadir~read_single(
      iv_pgmid    = iv_pgmid
      iv_object   = iv_object
      iv_obj_name = iv_obj_name ).

    IF ls_tadir-delflag = abap_true.
      RETURN. "Mark for deletion -> return nothing
    ENDIF.

    ls_item-obj_type = ls_tadir-object.
    ls_item-obj_name = ls_tadir-obj_name.
    ls_item-devclass = ls_tadir-devclass.

    IF zcl_abapinst_objects=>exists( ls_item ) = abap_false.
      RETURN.
    ENDIF.

    rv_devclass = ls_tadir-devclass.

  ENDMETHOD.

  METHOD zif_abapgit_tadir~read.

    DATA li_exit TYPE REF TO zif_abapgit_exit.
    DATA lr_tadir TYPE REF TO zif_abapgit_definitions=>ty_tadir.
    DATA lt_filter TYPE zif_abapgit_definitions=>ty_tadir_tt.
    DATA ls_dot_data TYPE zif_abapgit_dot_abapgit=>ty_dot_abapgit.

    ASSERT iv_package IS NOT INITIAL.

    " Start recursion
    " hmm, some problems here, should TADIR also build path?
    rt_tadir = build(
      iv_package            = iv_package
      io_dot                = io_dot
      iv_ignore_subpackages = iv_ignore_subpackages
      iv_only_local_objects = iv_only_local_objects ).

    IF io_dot IS NOT INITIAL.
      ls_dot_data = io_dot->get_data( ).
    ENDIF.

    li_exit = zcl_abapgit_exit=>get_instance( ).
    li_exit->change_tadir(
      EXPORTING
        iv_package            = iv_package
        ii_log                = ii_log
        is_dot_abapgit        = ls_dot_data
        iv_ignore_subpackages = iv_ignore_subpackages
        iv_only_local_objects = iv_only_local_objects
      CHANGING
        ct_tadir              = rt_tadir ).

    IF it_filter IS NOT INITIAL.
      "Apply filter manually instead of calling zcl_abapgit_repo_filter->apply,
      "so that we can execute a unit test. The method applies addition filtering
      "and does therefore additional selects
      lt_filter = it_filter.
      SORT lt_filter BY object obj_name.
      LOOP AT rt_tadir REFERENCE INTO lr_tadir.
        READ TABLE lt_filter TRANSPORTING NO FIELDS
                 WITH KEY object = lr_tadir->object
                          obj_name = lr_tadir->obj_name
                          BINARY SEARCH.
        IF sy-subrc <> 0.
          DELETE rt_tadir.
        ENDIF.
      ENDLOOP.
    ENDIF.

    IF iv_check_exists = abap_true.
      rt_tadir = check_exists( rt_tadir ).
    ENDIF.

  ENDMETHOD.

  METHOD zif_abapgit_tadir~read_single.

    SELECT SINGLE * FROM tadir INTO CORRESPONDING FIELDS OF rs_tadir
      WHERE pgmid = iv_pgmid
      AND object = iv_object
      AND obj_name = iv_obj_name.                         "#EC CI_SUBRC
    CLEAR rs_tadir-korrnum.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_url IMPLEMENTATION.

  METHOD host.

    regex( EXPORTING iv_url = iv_url
           IMPORTING ev_host = rv_host ).

  ENDMETHOD.

  METHOD is_abapgit_repo.

    IF iv_url CS 'github.com' AND ( iv_url CP '*/abapGit' OR iv_url CP '*/abapGit.git' ).
      rv_abapgit = abap_true.
    ENDIF.

  ENDMETHOD.

  METHOD name.

    DATA: lv_path TYPE string.

    TRY.
        regex( EXPORTING iv_url = iv_url
               IMPORTING ev_name = rv_name
                         ev_path = lv_path ).

        IF rv_name IS INITIAL.
          FIND REGEX '([\w-]+)/$' IN lv_path SUBMATCHES rv_name.
          IF sy-subrc <> 0.
            zcx_abapgit_exception=>raise( 'Malformed URL' ).
          ENDIF.
        ENDIF.

      CATCH zcx_abapgit_exception.
        IF iv_validate = abap_true.
          zcx_abapgit_exception=>raise( 'Malformed URL' ).
        ELSE.
          rv_name = 'URL error (fix repo with "Advanced > Change Remote")'.
        ENDIF.
    ENDTRY.

  ENDMETHOD.

  METHOD path_name.

    DATA: lv_host TYPE string ##NEEDED.

    FIND REGEX '(.*://[^/]*)(.*)' IN iv_url
      SUBMATCHES lv_host rv_path_name.

  ENDMETHOD.

  METHOD regex.

    FIND REGEX '^(https?://[^/]*)(.*/)(.*)\.git$' IN iv_url
      SUBMATCHES ev_host ev_path ev_name.
    IF sy-subrc <> 0.
      FIND REGEX '^(https?://[^/]*)(.*/)(.*)$' IN iv_url
        SUBMATCHES ev_host ev_path ev_name.
      IF sy-subrc <> 0.
        zcx_abapgit_exception=>raise( 'Malformed URL' ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD url_address.

    DATA:
      lv_host TYPE string,
      lv_path TYPE string,
      lv_name TYPE string,
      lv_len  TYPE i.

    regex( EXPORTING iv_url  = iv_url
           IMPORTING ev_host = lv_host
                     ev_path = lv_path
                     ev_name = lv_name ).

    IF lv_path IS INITIAL AND lv_name IS INITIAL.
      zcx_abapgit_exception=>raise( 'Malformed URL' ).
    ELSEIF lv_name IS INITIAL.
      lv_len = strlen( lv_path ) - 1.
      IF lv_path+lv_len(1) = '/'.
        lv_path = lv_path(lv_len).
      ENDIF.
    ENDIF.

    rv_adress = |{ lv_host }{ lv_path }{ lv_name }|.

  ENDMETHOD.

  METHOD validate.

    name( iv_url      = iv_url
          iv_validate = abap_true ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapgit_version IMPLEMENTATION.

  METHOD check_dependant_version.

    CONSTANTS: lc_message TYPE string VALUE 'Current version is older than required'.

    IF is_dependant-major > is_current-major.
      zcx_abapgit_exception=>raise( lc_message ).
    ELSEIF is_dependant-major < is_current-major.
      RETURN.
    ENDIF.

    IF is_dependant-minor > is_current-minor.
      zcx_abapgit_exception=>raise( lc_message ).
    ELSEIF is_dependant-minor < is_current-minor.
      RETURN.
    ENDIF.

    IF is_dependant-patch > is_current-patch.
      zcx_abapgit_exception=>raise( lc_message ).
    ELSEIF is_dependant-patch < is_current-patch.
      RETURN.
    ENDIF.

    IF is_current-prerelase IS INITIAL.
      RETURN.
    ENDIF.

    CASE is_current-prerelase.
      WHEN 'rc'.
        IF is_dependant-prerelase = ''.
          zcx_abapgit_exception=>raise( lc_message ).
        ENDIF.

      WHEN 'beta'.
        IF is_dependant-prerelase = '' OR is_dependant-prerelase = 'rc'.
          zcx_abapgit_exception=>raise( lc_message ).
        ENDIF.

      WHEN 'alpha'.
        IF is_dependant-prerelase = '' OR is_dependant-prerelase = 'rc' OR is_dependant-prerelase = 'beta'.
          zcx_abapgit_exception=>raise( lc_message ).
        ENDIF.

    ENDCASE.

    IF is_dependant-prerelase = is_current-prerelase AND is_dependant-prerelase_patch > is_current-prerelase_patch.
      zcx_abapgit_exception=>raise( lc_message ).
    ENDIF.

  ENDMETHOD.

  METHOD compare.

    DATA: ls_version_a TYPE zif_abapgit_definitions=>ty_version,
          ls_version_b TYPE zif_abapgit_definitions=>ty_version.

    TRY.
        IF is_a IS NOT INITIAL.
          ls_version_a = is_a.
        ELSE.
          ls_version_a = conv_str_to_version( iv_a ).
        ENDIF.

        IF is_b IS NOT INITIAL.
          ls_version_b = is_b.
        ELSE.
          ls_version_b = conv_str_to_version( iv_b ).
        ENDIF.
      CATCH zcx_abapgit_exception.
        rv_result = 0.
        RETURN.
    ENDTRY.

    IF ls_version_a = ls_version_b.
      rv_result = 0.
    ELSE.
      TRY.
          check_dependant_version( is_current   = ls_version_a
                                   is_dependant = ls_version_b ).
          rv_result = 1.
        CATCH zcx_abapgit_exception.
          rv_result = -1.
          RETURN.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD conv_str_to_version.

    DATA: lt_segments TYPE STANDARD TABLE OF string,
          lt_parts    TYPE STANDARD TABLE OF string,
          lv_segment  TYPE string.

    SPLIT iv_version AT '-' INTO TABLE lt_segments.

    READ TABLE lt_segments INTO lv_segment INDEX 1. " Version
    IF sy-subrc <> 0.   " No version
      RETURN.
    ENDIF.

    SPLIT lv_segment AT '.' INTO TABLE lt_parts.

    LOOP AT lt_parts INTO lv_segment.

      TRY.
          CASE sy-tabix.
            WHEN 1.
              rs_version-major = lv_segment.
            WHEN 2.
              rs_version-minor = lv_segment.
            WHEN 3.
              rs_version-patch = lv_segment.
          ENDCASE.
        CATCH cx_sy_conversion_no_number.
          zcx_abapgit_exception=>raise( 'Incorrect format for Semantic Version' ).
      ENDTRY.

    ENDLOOP.

    READ TABLE lt_segments INTO lv_segment INDEX 2. " Pre-release Version
    IF sy-subrc <> 0.   " No version
      RETURN.
    ENDIF.

    SPLIT lv_segment AT '.' INTO TABLE lt_parts.

    LOOP AT lt_parts INTO lv_segment.

      CASE sy-tabix.
        WHEN 1.
          rs_version-prerelase = lv_segment.
          TRANSLATE rs_version-prerelase TO LOWER CASE.
        WHEN 2.
          rs_version-prerelase_patch = lv_segment.
      ENDCASE.

    ENDLOOP.

    IF rs_version-prerelase <> 'rc' AND rs_version-prerelase <> 'beta' AND rs_version-prerelase <> 'alpha'.
      zcx_abapgit_exception=>raise( 'Incorrect format for Semantic Version' ).
    ENDIF.

  ENDMETHOD.

  METHOD get_version_constant_value.
    DATA: lv_version_class     TYPE seoclsname,
          lv_version_component TYPE string.
    FIELD-SYMBOLS: <lv_version> TYPE string.

    IF iv_version_constant NP '*=>*'.
      zcx_abapgit_exception=>raise( 'Version constant needs to use the format CLASS/INTERFACE=>CONSTANT' ).
    ENDIF.

    SPLIT iv_version_constant AT '=>' INTO lv_version_class lv_version_component.
    IF sy-subrc <> 0 OR lv_version_class IS INITIAL OR lv_version_component IS INITIAL.
      zcx_abapgit_exception=>raise( 'Version constant cannot be parsed' ).
    ENDIF.

    " You should remember that accessing a class or an interface with syntax errors
    " gives us a shortdump. Therefore we do a syntax check here.
    zcl_abapgit_oo_factory=>get_by_name( lv_version_class )->syntax_check( lv_version_class ).

    ASSIGN (lv_version_class)=>(lv_version_component) TO <lv_version>.
    IF sy-subrc = 0.
      rv_version = <lv_version>.
    ELSE.
      zcx_abapgit_exception=>raise( |Could not access version at class { lv_version_class } component | &&
                                    |{ lv_version_component }| ).
    ENDIF.
  ENDMETHOD.

  METHOD normalize.

    " Internal program version should be in format "XXX.XXX.XXX" or "vXXX.XXX.XXX"
    CONSTANTS:
      lc_version_pattern    TYPE string VALUE '^v?(\d{1,3}\.\d{1,3}\.\d{1,3})\s*$',
      lc_prerelease_pattern TYPE string VALUE '^((rc|beta|alpha)\.\d{1,3})\s*$'.

    DATA: lv_version      TYPE string,
          lv_prerelease   TYPE string,
          lv_version_n    TYPE string,
          lv_prerelease_n TYPE string.

    SPLIT iv_version AT '-' INTO lv_version lv_prerelease.

    FIND FIRST OCCURRENCE OF REGEX lc_version_pattern
      IN lv_version SUBMATCHES lv_version_n.

    IF lv_prerelease IS NOT INITIAL.

      FIND FIRST OCCURRENCE OF REGEX lc_prerelease_pattern
        IN lv_prerelease SUBMATCHES lv_prerelease_n.

    ENDIF.

    IF lv_version_n IS INITIAL.
      RETURN.
    ENDIF.

    rv_version = lv_version_n.

    IF lv_prerelease_n IS NOT INITIAL.
      CONCATENATE rv_version '-' lv_prerelease_n INTO rv_version.
    ENDIF.

  ENDMETHOD.

  METHOD version_to_numeric.

    DATA: lv_major   TYPE n LENGTH 4,
          lv_minor   TYPE n LENGTH 4,
          lv_release TYPE n LENGTH 4.

    SPLIT iv_version AT '.' INTO lv_major lv_minor lv_release.

    " Calculated value of version number, empty version will become 0 which is OK
    rv_version = lv_major * 1000000 + lv_minor * 1000 + lv_release.

  ENDMETHOD.
ENDCLASS.

CLASS ZCL_ABAPGIT_XML_PRETTY IMPLEMENTATION.

  METHOD print.

    DATA: li_ixml           TYPE REF TO if_ixml,
          li_xml_doc        TYPE REF TO if_ixml_document,
          li_stream_factory TYPE REF TO if_ixml_stream_factory,
          li_istream        TYPE REF TO if_ixml_istream,
          li_parser         TYPE REF TO if_ixml_parser,
          lv_xstring        TYPE xstring,
          li_encoding       TYPE REF TO if_ixml_encoding,
          li_ostream        TYPE REF TO if_ixml_ostream,
          li_renderer       TYPE REF TO if_ixml_renderer.

    ASSERT NOT iv_xml IS INITIAL.

    li_ixml    = cl_ixml=>create( ).
    li_xml_doc = li_ixml->create_document( ).

    li_stream_factory = li_ixml->create_stream_factory( ).
    li_istream        = li_stream_factory->create_istream_xstring(
      zcl_abapgit_convert=>string_to_xstring_utf8( iv_xml ) ).
    li_parser         = li_ixml->create_parser( stream_factory = li_stream_factory
                                                istream        = li_istream
                                                document       = li_xml_doc ).
    li_parser->set_normalizing( abap_true ).
    IF li_parser->parse( ) <> 0.
      IF iv_ignore_errors = abap_true.
        rv_xml = iv_xml.
        RETURN.
      ELSE.
        zcx_abapgit_exception=>raise( 'error parsing xml' ).
      ENDIF.
    ENDIF.

    li_ostream  = li_stream_factory->create_ostream_xstring( lv_xstring ).

    li_encoding = li_ixml->create_encoding(
      character_set = 'utf-8'
      byte_order    = if_ixml_encoding=>co_big_endian ).

    li_xml_doc->set_encoding( li_encoding ).
    li_renderer = li_ixml->create_renderer( ostream  = li_ostream
                                            document = li_xml_doc ).

    li_renderer->set_normalizing( boolc( iv_unpretty = abap_false ) ).

    li_renderer->render( ).

    rv_xml = zcl_abapgit_convert=>xstring_to_string_utf8_bom( lv_xstring ).
    REPLACE FIRST OCCURRENCE OF 'utf-8' IN rv_xml WITH 'utf-16'.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapinst_factory IMPLEMENTATION.

  METHOD get_cts_api.
    IF gi_cts_api IS NOT BOUND.
      CREATE OBJECT gi_cts_api TYPE zcl_abapgit_cts_api.
    ENDIF.

    ri_cts_api = gi_cts_api.
  ENDMETHOD.

  METHOD get_default_transport.

    IF gi_default_transport IS NOT BOUND.
      CREATE OBJECT gi_default_transport TYPE zcl_abapgit_default_transport.
    ENDIF.

    ri_default_transport = gi_default_transport.

  ENDMETHOD.

  METHOD get_environment.
    IF gi_environment IS NOT BOUND.
      CREATE OBJECT gi_environment TYPE zcl_abapgit_environment.
    ENDIF.
    ri_environment = gi_environment.
  ENDMETHOD.

  METHOD get_frontend_services.

    IF gi_fe_serv IS INITIAL.
      CREATE OBJECT gi_fe_serv TYPE zcl_abapgit_frontend_services.
    ENDIF.

    ri_fe_serv = gi_fe_serv.

  ENDMETHOD.

  METHOD get_function_module.

    IF gi_function_module IS INITIAL.
      CREATE OBJECT gi_function_module TYPE zcl_abapgit_function_module.
    ENDIF.

    ri_function_module = gi_function_module.

  ENDMETHOD.

  METHOD get_longtexts.

    IF gi_longtext IS NOT BOUND.
      CREATE OBJECT gi_longtext TYPE zcl_abapgit_longtexts.
    ENDIF.
    ri_longtexts = gi_longtext.

  ENDMETHOD.

  METHOD get_lxe_texts.

    IF gi_lxe_texts IS NOT BOUND.
      CREATE OBJECT gi_lxe_texts TYPE zcl_abapgit_lxe_texts.
    ENDIF.
    ri_lxe_texts = gi_lxe_texts.

  ENDMETHOD.

  METHOD get_sap_namespace.

    IF gi_sap_namespace IS NOT BOUND.
      CREATE OBJECT gi_sap_namespace TYPE zcl_abapgit_sap_namespace.
    ENDIF.

    ri_namespace = gi_sap_namespace.

  ENDMETHOD.

  METHOD get_sap_package.

    DATA: ls_sap_package TYPE ty_sap_package.
    FIELD-SYMBOLS: <ls_sap_package> TYPE ty_sap_package.

    READ TABLE gt_sap_package ASSIGNING <ls_sap_package>
                              WITH TABLE KEY package = iv_package.
    IF sy-subrc <> 0.

      ls_sap_package-package = iv_package.
      CREATE OBJECT ls_sap_package-instance TYPE zcl_abapgit_sap_package
        EXPORTING
          iv_package = iv_package.

      INSERT ls_sap_package
             INTO TABLE gt_sap_package
             ASSIGNING <ls_sap_package>.

    ENDIF.

    ri_sap_package = <ls_sap_package>-instance.

  ENDMETHOD.

  METHOD get_sap_report.

    IF gi_sap_report IS NOT BOUND.
      CREATE OBJECT gi_sap_report TYPE zcl_abapgit_sap_report.
    ENDIF.

    ri_report = gi_sap_report.

  ENDMETHOD.

  METHOD get_tadir.

    IF gi_tadir IS INITIAL.
      CREATE OBJECT gi_tadir TYPE zcl_abapgit_tadir.
    ENDIF.

    ri_tadir = gi_tadir.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapinst_file IMPLEMENTATION.

  METHOD load_internet.

    DATA:
      li_client  TYPE REF TO if_http_client,
      lx_error   TYPE REF TO zcx_abapgit_exception,
      lv_url     TYPE string,
      lv_code    TYPE i,
      lv_message TYPE string,
      lv_reason  TYPE string.

    TRY.
        lv_url = zcl_abapgit_url=>host( iv_url ).
      CATCH zcx_abapgit_exception INTO lx_error.
        zcx_abapinst_exception=>raise( lx_error->get_text( ) ).
    ENDTRY.

    IF iv_proxy_host IS NOT INITIAL AND iv_proxy_port IS NOT INITIAL.
      cl_http_client=>create_by_url(
        EXPORTING
          url                = lv_url
          ssl_id             = 'ANONYM'
          proxy_host         = iv_proxy_host
          proxy_service      = iv_proxy_port
        IMPORTING
          client             = li_client
        EXCEPTIONS
          argument_not_found = 1
          plugin_not_active  = 2
          internal_error     = 3
          OTHERS             = 4 ).
    ELSE.
      cl_http_client=>create_by_url(
        EXPORTING
          url                = lv_url
          ssl_id             = 'ANONYM'
        IMPORTING
          client             = li_client
        EXCEPTIONS
          argument_not_found = 1
          plugin_not_active  = 2
          internal_error     = 3
          OTHERS             = 4 ).
    ENDIF.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( |Error creating HTTP client (check certificates in STRUST)| ).
    ENDIF.

    IF iv_proxy_user IS NOT INITIAL AND iv_proxy_password IS NOT INITIAL.
      li_client->authenticate(
        proxy_authentication = abap_true
        username             = iv_proxy_user
        password             = iv_proxy_password ).
    ENDIF.

    IF iv_user IS NOT INITIAL AND iv_password IS NOT INITIAL.
      li_client->authenticate(
        username = iv_user
        password = iv_password ).
    ENDIF.

    cl_http_utility=>set_request_uri(
      request = li_client->request
      uri     = iv_url ).

    li_client->request->set_method( 'GET' ).
    li_client->request->set_compression( ).
    li_client->request->set_header_field(
      name  = 'content-type'
      value = 'application/zip' ).

    li_client->send(
      EXPORTING
        timeout                    = '6000'
      EXCEPTIONS
        http_communication_failure = 1
        http_invalid_state         = 2
        http_processing_failed     = 3
        http_invalid_timeout       = 4
        OTHERS                     = 5 ).
    IF sy-subrc  = 0.
      li_client->receive(
        EXCEPTIONS
          http_communication_failure = 1
          http_invalid_state         = 2
          http_processing_failed     = 3
          OTHERS                     = 4 ).
    ENDIF.

    IF sy-subrc <> 0.
      li_client->get_last_error(
        IMPORTING
          code    = lv_code
          message = lv_message ).

      zcx_abapinst_exception=>raise( |{ lv_code } { lv_message }| ).
    ENDIF.

    li_client->response->get_status(
      IMPORTING
        code   = lv_code
        reason = lv_reason ).
    IF lv_code <> 200.
      zcx_abapinst_exception=>raise( |{ lv_code } { lv_reason }| ).
    ENDIF.

    rv_file = li_client->response->get_data( ).

    IF rv_file IS INITIAL.
      zcx_abapinst_exception=>raise( 'Error downloading file. No data returned.' ).
    ENDIF.

    li_client->close( ).

  ENDMETHOD.

  METHOD load_local.

    TYPES:
      ty_hex TYPE x LENGTH 255.

    DATA:
      lt_data   TYPE TABLE OF ty_hex WITH DEFAULT KEY,
      lv_length TYPE i.

    cl_gui_frontend_services=>gui_upload(
      EXPORTING
        filename                = |{ iv_filename }|
        filetype                = 'BIN'
      IMPORTING
        filelength              = lv_length
      CHANGING
        data_tab                = lt_data
      EXCEPTIONS
        file_open_error         = 1
        file_read_error         = 2
        no_batch                = 3
        gui_refuse_filetransfer = 4
        invalid_type            = 5
        no_authority            = 6
        unknown_error           = 7
        bad_data_format         = 8
        header_not_allowed      = 9
        separator_not_allowed   = 10
        header_too_long         = 11
        unknown_dp_error        = 12
        access_denied           = 13
        dp_out_of_memory        = 14
        disk_full               = 15
        dp_timeout              = 16
        not_supported_by_gui    = 17
        error_no_gui            = 18
        OTHERS                  = 19 ).
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise_t100( ).
    ENDIF.

    CONCATENATE LINES OF lt_data INTO rv_file IN BYTE MODE.
    rv_file = rv_file(lv_length).

  ENDMETHOD.

  METHOD load_server.

    DATA:
      lv_eps_inbox TYPE eps2path,
      lv_filename  TYPE file_name,
      lv_filesize  TYPE i,
      lv_data      TYPE x LENGTH 1024,
      lt_data      LIKE TABLE OF lv_data.

    CALL FUNCTION 'EPS_GET_DIRECTORY_PATH'
      EXPORTING
        eps_subdir             = 'in'
      IMPORTING
        ev_long_dir_name       = lv_eps_inbox
      EXCEPTIONS
        invalid_eps_subdir     = 1
        sapgparam_failed       = 2
        build_directory_failed = 3
        OTHERS                 = 4.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( |Error getting EPS directory from server| ).
    ENDIF.

    IF lv_eps_inbox CA '\'.
      lv_filename = lv_eps_inbox && '\' && iv_filename.
    ELSE.
      lv_filename = lv_eps_inbox && '/' && iv_filename.
    ENDIF.

    CALL FUNCTION 'SCMS_UPLOAD'
      EXPORTING
        filename = lv_filename
        binary   = abap_true
        frontend = abap_false
      IMPORTING
        filesize = lv_filesize
      TABLES
        data     = lt_data
      EXCEPTIONS
        error    = 1
        OTHERS   = 2.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( |Error loading file from server: { lv_filename }| ).
    ENDIF.

    CONCATENATE LINES OF lt_data INTO rv_file IN BYTE MODE.
    rv_file = rv_file(lv_filesize).

  ENDMETHOD.

  METHOD unzip.

    DATA:
      lo_zip  TYPE REF TO cl_abap_zip,
      lv_data TYPE xstring.

    FIELD-SYMBOLS:
      <ls_zipfile> LIKE LINE OF lo_zip->files,
      <ls_file>    LIKE LINE OF rt_files.

    CREATE OBJECT lo_zip.

    lo_zip->load(
      EXPORTING
        zip             = iv_xstr
      EXCEPTIONS
        zip_parse_error = 1
        OTHERS          = 2 ).
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( 'Error loading ZIP' ).
    ENDIF.

    LOOP AT lo_zip->files ASSIGNING <ls_zipfile>.

      lo_zip->get(
        EXPORTING
          name                    = <ls_zipfile>-name
        IMPORTING
          content                 = lv_data
        EXCEPTIONS
          zip_index_error         = 1
          zip_decompression_error = 2
          OTHERS                  = 3 ).
      IF sy-subrc <> 0.
        zcx_abapinst_exception=>raise( 'Error getting file from ZIP' ).
      ENDIF.

      APPEND INITIAL LINE TO rt_files ASSIGNING <ls_file>.

      _filename(
        EXPORTING
          iv_str      = <ls_zipfile>-name
        IMPORTING
          ev_path     = <ls_file>-path
          ev_filename = <ls_file>-filename ).

      <ls_file>-data = lv_data.

      TRY.
          <ls_file>-sha1 = zcl_abapgit_hash=>sha1( iv_type = zif_abapgit_git_definitions=>c_type-blob
                                                   iv_data = <ls_file>-data ).
        CATCH zcx_abapgit_exception.
          zcx_abapinst_exception=>raise( 'Error during hashing' ).
      ENDTRY.

    ENDLOOP.

    DELETE rt_files WHERE filename IS INITIAL.

    _normalize_path( CHANGING ct_files = rt_files ).

  ENDMETHOD.

  METHOD virus_scan.

    DATA:
      lo_scanner  TYPE REF TO cl_vsi,
      lv_scanrc   TYPE vscan_scanrc,
      lv_msg      TYPE string ##NEEDED,
      ls_message  TYPE bapiret2,
      lt_bapiret2 TYPE vscan_bapiret2_t.

    " Data was download from Internet and uploaded here
    " so we will use the HTTP_UPLOAD profile
    cl_vsi=>get_instance(
      EXPORTING
        if_profile         = '/SIHTTP/HTTP_UPLOAD'
      IMPORTING
        eo_instance        = lo_scanner
      EXCEPTIONS
        profile_not_active = 1
        OTHERS             = 2 ).
    CASE sy-subrc.
      WHEN 0.
        " Perform virus scan
        lo_scanner->if_vscan_instance~scan_bytes(
          EXPORTING
            if_data             = iv_data
          IMPORTING
            ef_scanrc           = lv_scanrc
            et_bapiret          = lt_bapiret2
          EXCEPTIONS
            not_available       = 1
            configuration_error = 2
            internal_error      = 3
            OTHERS              = 4 ).
        " Severe errors of the scanner (NOT: Virus found) are reported
        " as exceptions and must be reported as technical errors
        IF sy-subrc <> 0.
          zcx_abapinst_exception=>raise_t100( ).
        ENDIF.

        " Result of virus scan
        " Any scan error or virus infection will be reported there
        IF lv_scanrc <> 0.
          LOOP AT lt_bapiret2 INTO ls_message WHERE type = 'E'.
            MESSAGE ID ls_message-id TYPE 'E' NUMBER ls_message-number
              WITH ls_message-message_v1 ls_message-message_v2 ls_message-message_v3 ls_message-message_v4
              INTO lv_msg.
            zcx_abapinst_exception=>raise_t100( ).
          ENDLOOP.
        ENDIF.

      WHEN 1.
        " No Virus Scan active --> nothing to do
      WHEN 2.
        " Error getting scanner. Reporting needed
        zcx_abapinst_exception=>raise_t100( ).
    ENDCASE.

  ENDMETHOD.

  METHOD _filename.

    IF iv_str CA '/'.
      FIND REGEX '(.*/)(.*)' IN iv_str
        SUBMATCHES ev_path ev_filename.
      IF sy-subrc <> 0.
        zcx_abapinst_exception=>raise( 'Malformed path' ).
      ENDIF.
      IF ev_path <> '/'.
        CONCATENATE '/' ev_path INTO ev_path.
      ENDIF.
    ELSE.
      ev_path = '/'.
      ev_filename = iv_str.
    ENDIF.
    TRANSLATE ev_filename TO LOWER CASE.

  ENDMETHOD.

  METHOD _normalize_path.
* removes first folder from path if needed

    DATA:
      lt_split  TYPE TABLE OF string,
      lv_needed TYPE abap_bool,
      lv_length TYPE i,
      lv_split  LIKE LINE OF lt_split.

    FIELD-SYMBOLS:
      <ls_file> LIKE LINE OF ct_files.

    READ TABLE ct_files INDEX 1 ASSIGNING <ls_file>.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    SPLIT <ls_file>-path AT '/' INTO TABLE lt_split.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    READ TABLE lt_split INDEX 2 INTO lv_split.
    IF sy-subrc <> 0 OR strlen( lv_split ) = 0.
      RETURN.
    ENDIF.

    CONCATENATE '/' lv_split '/*' INTO lv_split.

    lv_needed = abap_true.
    LOOP AT ct_files ASSIGNING <ls_file>.
      IF <ls_file>-path NP lv_split.
        lv_needed = abap_false.
        EXIT. " current loop
      ENDIF.
    ENDLOOP.

    IF lv_needed = abap_true.
      lv_length = strlen( lv_split ) - 2.
      LOOP AT ct_files ASSIGNING <ls_file>.
        <ls_file>-path = <ls_file>-path+lv_length.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.
ENDCLASS.

"! Free Selections Dialog
CLASS lcl_abapgit_free_sel_dialog DEFINITION.

  PUBLIC SECTION.
    TYPES:
      BEGIN OF ty_free_sel_field,
        name             TYPE fieldname,
        only_parameter   TYPE abap_bool,
        param_obligatory TYPE abap_bool,
        value            TYPE string,
        value_range      TYPE rsds_selopt_t,
        ddic_tabname     TYPE tabname,
        ddic_fieldname   TYPE fieldname,
        text             TYPE rsseltext,
      END OF ty_free_sel_field,
      ty_free_sel_field_tab TYPE STANDARD TABLE OF ty_free_sel_field WITH DEFAULT KEY.

    TYPES: ty_syst_title TYPE c LENGTH 70.

    METHODS:
      constructor IMPORTING iv_title      TYPE ty_syst_title OPTIONAL
                            iv_frame_text TYPE ty_syst_title OPTIONAL,
      set_fields CHANGING ct_fields TYPE ty_free_sel_field_tab,
      show RAISING zcx_abapgit_cancel
                   zcx_abapinst_exception.
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES:
      ty_field_text_tab TYPE STANDARD TABLE OF rsdstexts WITH DEFAULT KEY.
    METHODS:
      convert_input_fields EXPORTING et_default_values TYPE rsds_trange
                                     es_restriction    TYPE sscr_restrict_ds
                                     et_fields         TYPE rsdsfields_t
                                     et_field_texts    TYPE ty_field_text_tab,
      free_selections_init IMPORTING it_default_values TYPE rsds_trange
                                     is_restriction    TYPE sscr_restrict_ds
                           EXPORTING ev_selection_id   TYPE dynselid
                           CHANGING  ct_fields         TYPE rsdsfields_t
                                     ct_field_texts    TYPE ty_field_text_tab
                           RAISING   zcx_abapinst_exception,
      free_selections_dialog IMPORTING iv_selection_id  TYPE dynselid
                             EXPORTING et_result_ranges TYPE rsds_trange
                             CHANGING  ct_fields        TYPE rsdsfields_t
                             RAISING   zcx_abapgit_cancel
                                       zcx_abapinst_exception,
      validate_results IMPORTING it_result_ranges TYPE rsds_trange
                       RAISING   zcx_abapinst_exception,
      transfer_results_to_input IMPORTING it_result_ranges TYPE rsds_trange.
    DATA:
      mr_fields     TYPE REF TO ty_free_sel_field_tab,
      mv_title      TYPE ty_syst_title,
      mv_frame_text TYPE ty_syst_title.
ENDCLASS.

CLASS lcl_abapgit_free_sel_dialog IMPLEMENTATION.

  METHOD constructor.
    mv_title = iv_title.
    mv_frame_text = iv_frame_text.
  ENDMETHOD.

  METHOD convert_input_fields.
    CONSTANTS: lc_only_eq_optlist_name TYPE c LENGTH 10 VALUE 'ONLYEQ'.
    DATA: ls_parameter_opt_list TYPE sscr_opt_list.
    FIELD-SYMBOLS: <ls_input_field>            TYPE ty_free_sel_field,
                   <lt_input_fields>           TYPE ty_free_sel_field_tab,
                   <ls_free_sel_field>         TYPE rsdsfields,
                   <ls_restriction_ass>        TYPE sscr_ass_ds,
                   <ls_text>                   TYPE rsdstexts,
                   <ls_default_value>          TYPE rsds_range,
                   <ls_default_value_range>    TYPE rsds_frange,
                   <ls_default_val_range_line> TYPE rsdsselopt.

    ASSERT mr_fields IS BOUND.
    ASSIGN mr_fields->* TO <lt_input_fields>.

    LOOP AT <lt_input_fields> ASSIGNING <ls_input_field>.
      APPEND INITIAL LINE TO et_fields ASSIGNING <ls_free_sel_field>.
      <ls_free_sel_field>-fieldname = <ls_input_field>-ddic_fieldname.
      <ls_free_sel_field>-tablename = <ls_input_field>-ddic_tabname.

      IF <ls_input_field>-only_parameter = abap_true.
        IF es_restriction IS INITIAL.
          ls_parameter_opt_list-name = lc_only_eq_optlist_name.
          ls_parameter_opt_list-options-eq = abap_true.
          APPEND ls_parameter_opt_list TO es_restriction-opt_list_tab.
        ENDIF.

        APPEND INITIAL LINE TO es_restriction-ass_tab ASSIGNING <ls_restriction_ass>.
        <ls_restriction_ass>-kind = 'S'.
        <ls_restriction_ass>-fieldname = <ls_input_field>-ddic_fieldname.
        <ls_restriction_ass>-tablename = <ls_input_field>-ddic_tabname.
        <ls_restriction_ass>-sg_main = 'I'.
        <ls_restriction_ass>-sg_addy = 'N'.
        <ls_restriction_ass>-op_main = lc_only_eq_optlist_name.
      ENDIF.

      IF <ls_input_field>-text IS NOT INITIAL.
        APPEND INITIAL LINE TO et_field_texts ASSIGNING <ls_text>.
        <ls_text>-fieldname = <ls_input_field>-ddic_fieldname.
        <ls_text>-tablename = <ls_input_field>-ddic_tabname.
        <ls_text>-text = <ls_input_field>-text.
      ENDIF.

      IF <ls_input_field>-value IS NOT INITIAL OR <ls_input_field>-value_range IS NOT INITIAL.
        READ TABLE et_default_values WITH KEY tablename = <ls_input_field>-ddic_tabname
                                     ASSIGNING <ls_default_value>.
        IF sy-subrc <> 0.
          APPEND INITIAL LINE TO et_default_values ASSIGNING <ls_default_value>.
          <ls_default_value>-tablename = <ls_input_field>-ddic_tabname.
        ENDIF.

        APPEND INITIAL LINE TO <ls_default_value>-frange_t ASSIGNING <ls_default_value_range>.
        <ls_default_value_range>-fieldname = <ls_input_field>-ddic_fieldname.

        IF <ls_input_field>-value IS NOT INITIAL.
          APPEND INITIAL LINE TO <ls_default_value_range>-selopt_t ASSIGNING <ls_default_val_range_line>.
          <ls_default_val_range_line>-sign = 'I'.
          <ls_default_val_range_line>-option = 'EQ'.
          <ls_default_val_range_line>-low = <ls_input_field>-value.
        ELSEIF <ls_input_field>-value_range IS NOT INITIAL.
          <ls_default_value_range>-selopt_t = <ls_input_field>-value_range.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD free_selections_dialog.

    DATA ls_position TYPE zif_abapgit_popups=>ty_popup_position.

    ls_position = zcl_abapinst_popups=>center(
      iv_width  = 60
      iv_height = lines( ct_fields ) + 15 ).

    CALL FUNCTION 'FREE_SELECTIONS_DIALOG'
      EXPORTING
        selection_id    = iv_selection_id
        title           = mv_title
        frame_text      = mv_frame_text
        status          = 1
        start_col       = ls_position-start_column
        start_row       = ls_position-start_row
        as_window       = abap_true
        no_intervals    = abap_true
        tree_visible    = abap_false
      IMPORTING
        field_ranges    = et_result_ranges
      TABLES
        fields_tab      = ct_fields
      EXCEPTIONS
        internal_error  = 1
        no_action       = 2
        selid_not_found = 3
        illegal_status  = 4
        OTHERS          = 5.
    CASE sy-subrc.
      WHEN 0 ##NEEDED.
      WHEN 2.
        RAISE EXCEPTION TYPE zcx_abapgit_cancel.
      WHEN OTHERS.
        zcx_abapinst_exception=>raise( |Error from FREE_SELECTIONS_DIALOG: { sy-subrc }| ).
    ENDCASE.
  ENDMETHOD.

  METHOD free_selections_init.
    CALL FUNCTION 'FREE_SELECTIONS_INIT'
      EXPORTING
        kind                     = 'F'
        field_ranges_int         = it_default_values
        restriction              = is_restriction
      IMPORTING
        selection_id             = ev_selection_id
      TABLES
        fields_tab               = ct_fields
        field_texts              = ct_field_texts
      EXCEPTIONS
        fields_incomplete        = 1
        fields_no_join           = 2
        field_not_found          = 3
        no_tables                = 4
        table_not_found          = 5
        expression_not_supported = 6
        incorrect_expression     = 7
        illegal_kind             = 8
        area_not_found           = 9
        inconsistent_area        = 10
        kind_f_no_fields_left    = 11
        kind_f_no_fields         = 12
        too_many_fields          = 13
        dup_field                = 14
        field_no_type            = 15
        field_ill_type           = 16
        dup_event_field          = 17
        node_not_in_ldb          = 18
        area_no_field            = 19
        OTHERS                   = 20.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( |Error from FREE_SELECTIONS_INIT: { sy-subrc }| ).
    ENDIF.
  ENDMETHOD.

  METHOD set_fields.
    GET REFERENCE OF ct_fields INTO mr_fields.
  ENDMETHOD.

  METHOD show.
    DATA: lt_default_values   TYPE rsds_trange,
          ls_restriction      TYPE sscr_restrict_ds,
          lt_fields           TYPE rsdsfields_t,
          lt_field_texts      TYPE ty_field_text_tab,
          lv_repeat_dialog    TYPE abap_bool VALUE abap_true,
          lv_selection_id     TYPE dynselid,
          lt_results          TYPE rsds_trange,
          lx_validation_error TYPE REF TO zcx_abapinst_exception.

    convert_input_fields(
      IMPORTING
        et_default_values = lt_default_values
        es_restriction    = ls_restriction
        et_fields         = lt_fields
        et_field_texts    = lt_field_texts ).

    WHILE lv_repeat_dialog = abap_true.
      lv_repeat_dialog = abap_false.

      free_selections_init(
        EXPORTING
          it_default_values = lt_default_values
          is_restriction    = ls_restriction
        IMPORTING
          ev_selection_id   = lv_selection_id
        CHANGING
          ct_fields         = lt_fields
          ct_field_texts    = lt_field_texts ).

      free_selections_dialog(
        EXPORTING
          iv_selection_id  = lv_selection_id
        IMPORTING
          et_result_ranges = lt_results
        CHANGING
          ct_fields        = lt_fields ).

      TRY.
          validate_results( lt_results ).
        CATCH zcx_abapinst_exception INTO lx_validation_error.
          lv_repeat_dialog = abap_true.
          lt_default_values = lt_results.
          MESSAGE lx_validation_error TYPE 'I' DISPLAY LIKE 'E'.
          CONTINUE.
      ENDTRY.

      transfer_results_to_input( lt_results ).
    ENDWHILE.
  ENDMETHOD.

  METHOD transfer_results_to_input.
    FIELD-SYMBOLS: <ls_input_field>          TYPE ty_free_sel_field,
                   <lt_input_fields>         TYPE ty_free_sel_field_tab,
                   <ls_result_range_for_tab> TYPE rsds_range,
                   <ls_result_range_line>    TYPE rsds_frange,
                   <ls_selopt_line>          TYPE rsdsselopt.

    ASSIGN mr_fields->* TO <lt_input_fields>.
    ASSERT sy-subrc = 0.

    LOOP AT <lt_input_fields> ASSIGNING <ls_input_field>.
      READ TABLE it_result_ranges WITH KEY tablename = <ls_input_field>-ddic_tabname
                                  ASSIGNING <ls_result_range_for_tab>.
      IF sy-subrc = 0.
        READ TABLE <ls_result_range_for_tab>-frange_t WITH KEY fieldname = <ls_input_field>-ddic_fieldname
                                                      ASSIGNING <ls_result_range_line>.
        IF sy-subrc = 0 AND <ls_result_range_line>-selopt_t IS NOT INITIAL.
          IF <ls_input_field>-only_parameter = abap_true.
            ASSERT lines( <ls_result_range_line>-selopt_t ) = 1.

            READ TABLE <ls_result_range_line>-selopt_t INDEX 1 ASSIGNING <ls_selopt_line>.
            ASSERT sy-subrc = 0.

            ASSERT <ls_selopt_line>-sign = 'I' AND
                   <ls_selopt_line>-option = 'EQ' AND
                   <ls_selopt_line>-high IS INITIAL.

            <ls_input_field>-value = <ls_selopt_line>-low.
          ELSE.
            <ls_input_field>-value_range = <ls_result_range_line>-selopt_t.
          ENDIF.
        ELSE.
          CLEAR: <ls_input_field>-value, <ls_input_field>-value_range.
        ENDIF.
      ELSE.
        CLEAR: <ls_input_field>-value, <ls_input_field>-value_range.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD validate_results.
    DATA: ls_error_msg      TYPE symsg,
          lv_ddut_fieldname TYPE fnam_____4,
          lv_value          TYPE rsdsselop_.
    FIELD-SYMBOLS: <ls_result_range_for_tab> TYPE rsds_range,
                   <ls_result_range_line>    TYPE rsds_frange,
                   <ls_input_field>          TYPE ty_free_sel_field,
                   <lt_input_fields>         TYPE ty_free_sel_field_tab,
                   <ls_selopt_line>          TYPE rsdsselopt.

    ASSIGN mr_fields->* TO <lt_input_fields>.
    ASSERT sy-subrc = 0.

    LOOP AT it_result_ranges ASSIGNING <ls_result_range_for_tab>.
      LOOP AT <ls_result_range_for_tab>-frange_t ASSIGNING <ls_result_range_line>.
        READ TABLE <lt_input_fields> WITH KEY ddic_tabname = <ls_result_range_for_tab>-tablename
                                              ddic_fieldname = <ls_result_range_line>-fieldname
                                     ASSIGNING <ls_input_field>.
        ASSERT sy-subrc = 0.
        IF <ls_input_field>-only_parameter = abap_false.
          CONTINUE.
        ENDIF.

        CASE lines( <ls_result_range_line>-selopt_t ).
          WHEN 0.
            CLEAR lv_value.
          WHEN 1.
            READ TABLE <ls_result_range_line>-selopt_t INDEX 1 ASSIGNING <ls_selopt_line>.
            ASSERT sy-subrc = 0.
            lv_value = <ls_selopt_line>-low.
          WHEN OTHERS.
            ASSERT 1 = 2.
        ENDCASE.

        CLEAR ls_error_msg.
        lv_ddut_fieldname = <ls_input_field>-ddic_fieldname.

        CALL FUNCTION 'DDUT_INPUT_CHECK'
          EXPORTING
            tabname            = <ls_input_field>-ddic_tabname
            fieldname          = lv_ddut_fieldname
            value              = lv_value
            accept_all_initial = abap_true
            value_list         = 'S'
          IMPORTING
            msgid              = ls_error_msg-msgid
            msgty              = ls_error_msg-msgty
            msgno              = ls_error_msg-msgno
            msgv1              = ls_error_msg-msgv1
            msgv2              = ls_error_msg-msgv2
            msgv3              = ls_error_msg-msgv3
            msgv4              = ls_error_msg-msgv4.
        IF ls_error_msg IS NOT INITIAL.
          zcx_abapinst_exception=>raise_t100(
            iv_msgid = ls_error_msg-msgid
            iv_msgno = ls_error_msg-msgno
            iv_msgv1 = ls_error_msg-msgv1
            iv_msgv2 = ls_error_msg-msgv2
            iv_msgv3 = ls_error_msg-msgv3
            iv_msgv4 = ls_error_msg-msgv4 ).
        ELSEIF <ls_input_field>-param_obligatory = abap_true AND lv_value IS INITIAL.
          zcx_abapinst_exception=>raise( |Field '{ <ls_input_field>-name }' is obligatory| ).
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapinst_popups IMPLEMENTATION.

  METHOD center.

    CONSTANTS:
      lc_min_size TYPE i VALUE 10,
      lc_min_pos  TYPE i VALUE 5.

    " Magic math to approximate starting position of popup
    IF sy-scols > lc_min_size AND iv_width > 0 AND sy-scols > iv_width.
      rs_position-start_column = nmax(
        val1 = ( sy-scols - iv_width ) / 2
        val2 = lc_min_pos ).
    ELSE.
      rs_position-start_column = lc_min_pos.
    ENDIF.

    IF sy-srows > lc_min_size AND iv_height > 0 AND sy-srows > iv_height.
      rs_position-start_row = nmax(
        val1 = ( sy-srows - iv_height ) / 2 - 1
        val2 = lc_min_pos ).
    ELSE.
      rs_position-start_row = lc_min_pos.
    ENDIF.

    rs_position-end_column = rs_position-start_column + iv_width.
    rs_position-end_row = rs_position-start_row + iv_height.

  ENDMETHOD.

  METHOD popup_to_confirm.

    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        titlebar              = iv_title
        text_question         = iv_question
        text_button_1         = iv_text_button_1
        icon_button_1         = iv_icon_button_1
        text_button_2         = iv_text_button_2
        icon_button_2         = iv_icon_button_2
        default_button        = iv_default_button
        display_cancel_button = iv_display_cancel_button
      IMPORTING
        answer                = rv_answer
      EXCEPTIONS
        text_not_found        = 1
        OTHERS                = 2.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( 'Error from POPUP_TO_CONFIRM' ).
    ENDIF.

  ENDMETHOD.

  METHOD popup_to_enter_packaging.

    TYPES:
      BEGIN OF ty_free_sel_field,
        name             TYPE fieldname,
        only_parameter   TYPE abap_bool,
        param_obligatory TYPE abap_bool,
        value            TYPE string,
        value_range      TYPE rsds_selopt_t,
        ddic_tabname     TYPE tabname,
        ddic_fieldname   TYPE fieldname,
        text             TYPE rsseltext,
      END OF ty_free_sel_field,
      ty_free_sel_field_tab TYPE STANDARD TABLE OF ty_free_sel_field WITH DEFAULT KEY.

    DATA:
      lt_fields TYPE ty_free_sel_field_tab,
      lo_dialog TYPE REF TO lcl_abapgit_free_sel_dialog,
      lx_error  TYPE REF TO zcx_abapgit_exception.

    FIELD-SYMBOLS:
      <ls_field> TYPE ty_free_sel_field.

    APPEND INITIAL LINE TO lt_fields ASSIGNING <ls_field>.
    <ls_field>-name             = 'NAME'.
    <ls_field>-text             = 'Name'.
    <ls_field>-only_parameter   = abap_true.
    <ls_field>-ddic_tabname     = 'E071'.
    <ls_field>-ddic_fieldname   = 'OBJ_NAME'.
    <ls_field>-param_obligatory = abap_true.
    <ls_field>-value            = iv_name.

    APPEND INITIAL LINE TO lt_fields ASSIGNING <ls_field>.
    <ls_field>-name             = 'VERSION'.
    <ls_field>-text             = 'Version'.
    <ls_field>-only_parameter   = abap_true.
    <ls_field>-ddic_tabname     = 'TTREV'.
    <ls_field>-ddic_fieldname   = 'VERSION'.
    <ls_field>-param_obligatory = abap_true.
    <ls_field>-value            = iv_version.

    TRY.
        CREATE OBJECT lo_dialog
          EXPORTING
            iv_title      = |abapinst|
            iv_frame_text = |Packaging Details|.

        lo_dialog->set_fields( CHANGING ct_fields = lt_fields ).
        lo_dialog->show( ).

        LOOP AT lt_fields ASSIGNING <ls_field>.
          CASE <ls_field>-name.
            WHEN 'NAME'.
              rs_packaging-name = <ls_field>-value.
            WHEN 'VERSION'.
              rs_packaging-version = <ls_field>-value.
              rs_packaging-sem_version = zcl_abapgit_version=>conv_str_to_version( rs_packaging-version ).
          ENDCASE.
        ENDLOOP.

      CATCH zcx_abapgit_cancel.
        RETURN.
      CATCH zcx_abapgit_exception INTO lx_error.
        zcx_abapinst_exception=>raise_with_text( lx_error ).
    ENDTRY.

  ENDMETHOD.

  METHOD popup_to_select_from_list.

    DATA:
      lv_pfstatus     TYPE sypfkey,
      lo_events       TYPE REF TO cl_salv_events_table,
      lo_columns      TYPE REF TO cl_salv_columns_table,
      lt_columns      TYPE salv_t_column_ref,
      ls_column       TYPE salv_s_column_ref,
      lo_column       TYPE REF TO cl_salv_column_list,
      lo_table_header TYPE REF TO cl_salv_form_text.

    FIELD-SYMBOLS:
      <lt_table>             TYPE STANDARD TABLE,
      <ls_column_to_display> TYPE ty_alv_column.

    CLEAR: et_list.

    _create_new_table( it_list ).

    ASSIGN mr_table->* TO <lt_table>.
    ASSERT sy-subrc = 0.

    TRY.
        cl_salv_table=>factory( IMPORTING r_salv_table = mo_select_list_popup
                                CHANGING  t_table = <lt_table> ).

        CASE iv_selection_mode.
          WHEN if_salv_c_selection_mode=>single.
            lv_pfstatus = '110'.

          WHEN OTHERS.
            lv_pfstatus = '102'.

        ENDCASE.

        mo_select_list_popup->set_screen_status( pfstatus = lv_pfstatus
                                                 report = 'SAPMSVIM' ).

        mo_select_list_popup->set_screen_popup( start_column = iv_start_column
                                                end_column   = iv_end_column
                                                start_line   = iv_start_line
                                                end_line     = iv_end_line ).

        lo_events = mo_select_list_popup->get_event( ).

        SET HANDLER _on_select_list_link_click FOR lo_events.
        SET HANDLER _on_select_list_function_click FOR lo_events.
        SET HANDLER _on_double_click FOR lo_events.

        IF iv_title CN ' _0'.
          mo_select_list_popup->get_display_settings( )->set_list_header( iv_title ).
        ENDIF.

        IF iv_header_text CN ' _0'.
          CREATE OBJECT lo_table_header
            EXPORTING
              text = iv_header_text.
          mo_select_list_popup->set_top_of_list( lo_table_header ).
        ENDIF.

        mo_select_list_popup->get_display_settings( )->set_striped_pattern( iv_striped_pattern ).
        mo_select_list_popup->get_selections( )->set_selection_mode( iv_selection_mode ).

        lo_columns = mo_select_list_popup->get_columns( ).
        lt_columns = lo_columns->get( ).
        lo_columns->set_optimize( iv_optimize_col_width ).

        LOOP AT lt_columns INTO ls_column.

          lo_column ?= ls_column-r_column.

          IF iv_selection_mode = if_salv_c_selection_mode=>multiple
            AND ls_column-columnname = c_fieldname_selected.
            lo_column->set_cell_type( if_salv_c_cell_type=>checkbox_hotspot ).
            lo_column->set_output_length( 20 ).
            lo_column->set_short_text( |{ iv_select_column_text }| ).
            lo_column->set_medium_text( |{ iv_select_column_text }| ).
            lo_column->set_long_text( |{ iv_select_column_text }| ).
            CONTINUE.
          ENDIF.

          READ TABLE it_columns_to_display
            ASSIGNING <ls_column_to_display>
            WITH KEY name = ls_column-columnname.

          CASE sy-subrc.
            WHEN 0.
              IF <ls_column_to_display>-text CN ' _0'.
                lo_column->set_short_text( |{ <ls_column_to_display>-text }| ).
                lo_column->set_medium_text( |{ <ls_column_to_display>-text }| ).
                lo_column->set_long_text( |{ <ls_column_to_display>-text }| ).
              ENDIF.

              IF <ls_column_to_display>-length > 0.
                lo_column->set_output_length( <ls_column_to_display>-length ).
              ENDIF.

              lo_column->set_key( <ls_column_to_display>-key ).

            WHEN OTHERS.
              " Hide column
              lo_column->set_technical( abap_true ).

          ENDCASE.

        ENDLOOP.

        mo_select_list_popup->display( ).

      CATCH cx_salv_msg.
        zcx_abapinst_exception=>raise( 'Error from POPUP_TO_SELECT_FROM_LIST' ).
    ENDTRY.

    IF mv_cancel = abap_true.
      mv_cancel = abap_false.
      RETURN.
    ENDIF.

    _get_selected_rows( IMPORTING et_list = et_list ).

    CLEAR: mo_select_list_popup,
           mr_table,
           mo_table_descr.

  ENDMETHOD.

  METHOD _create_new_table.

    " create and populate a table on the fly derived from
    " it_data with a select column

    DATA:
      lr_struct        TYPE REF TO data,
      lt_components    TYPE cl_abap_structdescr=>component_table,
      lo_data_descr    TYPE REF TO cl_abap_datadescr,
      lo_elem_descr    TYPE REF TO cl_abap_elemdescr,
      lo_struct_descr  TYPE REF TO cl_abap_structdescr,
      lo_struct_descr2 TYPE REF TO cl_abap_structdescr.

    FIELD-SYMBOLS:
      <lt_table>     TYPE STANDARD TABLE,
      <ls_component> TYPE abap_componentdescr,
      <lg_line>      TYPE data,
      <lg_data>      TYPE any,
      <lg_value>     TYPE any.

    mo_table_descr ?= cl_abap_tabledescr=>describe_by_data( it_list ).
    lo_data_descr = mo_table_descr->get_table_line_type( ).

    CASE lo_data_descr->kind.
      WHEN cl_abap_elemdescr=>kind_elem.
        lo_elem_descr ?= mo_table_descr->get_table_line_type( ).
        INSERT INITIAL LINE INTO lt_components ASSIGNING <ls_component> INDEX 1.
        <ls_component>-name = c_default_column.
        <ls_component>-type = lo_elem_descr.

      WHEN cl_abap_elemdescr=>kind_struct.
        lo_struct_descr ?= mo_table_descr->get_table_line_type( ).
        lt_components = lo_struct_descr->get_components( ).

    ENDCASE.

    IF lt_components IS INITIAL.
      RETURN.
    ENDIF.

    INSERT INITIAL LINE INTO lt_components ASSIGNING <ls_component> INDEX 1.
    <ls_component>-name = c_fieldname_selected.
    <ls_component>-type ?= cl_abap_datadescr=>describe_by_name( 'FLAG' ).

    lo_struct_descr2 = cl_abap_structdescr=>create( lt_components ).
    mo_table_descr = cl_abap_tabledescr=>create( lo_struct_descr2 ).

    CREATE DATA mr_table TYPE HANDLE mo_table_descr.
    ASSIGN mr_table->* TO <lt_table>.
    ASSERT sy-subrc = 0.

    CREATE DATA lr_struct TYPE HANDLE lo_struct_descr2.
    ASSIGN lr_struct->* TO <lg_line>.
    ASSERT sy-subrc = 0.

    LOOP AT it_list ASSIGNING <lg_data>.
      CLEAR <lg_line>.
      CASE lo_data_descr->kind.
        WHEN cl_abap_elemdescr=>kind_elem.
          ASSIGN COMPONENT c_default_column OF STRUCTURE <lg_data> TO <lg_value>.
          ASSERT <lg_value> IS ASSIGNED.
          <lg_line> = <lg_value>.

        WHEN OTHERS.
          MOVE-CORRESPONDING <lg_data> TO <lg_line>.

      ENDCASE.
      INSERT <lg_line> INTO TABLE <lt_table>.
    ENDLOOP.

  ENDMETHOD.

  METHOD _get_selected_rows.

    DATA:
      lv_condition TYPE string,
      lr_exporting TYPE REF TO data.

    FIELD-SYMBOLS:
      <lg_exporting>    TYPE any,
      <lt_table>        TYPE STANDARD TABLE,
      <lg_line>         TYPE any,
      <lg_value>        TYPE any,
      <lv_selected>     TYPE abap_bool,
      <lv_selected_row> TYPE LINE OF salv_t_row.

    DATA: lo_data_descr    TYPE REF TO cl_abap_datadescr,
          lo_selections    TYPE REF TO cl_salv_selections,
          lt_selected_rows TYPE salv_t_row.

    ASSIGN mr_table->* TO <lt_table>.
    ASSERT sy-subrc = 0.

    lo_selections = mo_select_list_popup->get_selections( ).

    IF lo_selections->get_selection_mode( ) = if_salv_c_selection_mode=>single.

      lt_selected_rows = lo_selections->get_selected_rows( ).

      LOOP AT lt_selected_rows ASSIGNING <lv_selected_row>.

        READ TABLE <lt_table>
          ASSIGNING <lg_line>
          INDEX <lv_selected_row>.
        CHECK <lg_line> IS ASSIGNED.

        ASSIGN COMPONENT c_fieldname_selected
           OF STRUCTURE <lg_line>
           TO <lv_selected>.
        CHECK <lv_selected> IS ASSIGNED.

        <lv_selected> = abap_true.

      ENDLOOP.

    ENDIF.

    lv_condition = |{ c_fieldname_selected } = ABAP_TRUE|.

    CREATE DATA lr_exporting LIKE LINE OF et_list.
    ASSIGN lr_exporting->* TO <lg_exporting>.
    ASSERT sy-subrc = 0.

    mo_table_descr ?= cl_abap_tabledescr=>describe_by_data( et_list ).
    lo_data_descr = mo_table_descr->get_table_line_type( ).

    LOOP AT <lt_table> ASSIGNING <lg_line> WHERE (lv_condition).
      CLEAR <lg_exporting>.

      CASE lo_data_descr->kind.
        WHEN cl_abap_elemdescr=>kind_elem.
          ASSIGN COMPONENT c_default_column OF STRUCTURE <lg_line> TO <lg_value>.
          ASSERT sy-subrc = 0.
          <lg_exporting> = <lg_value>.

        WHEN OTHERS.
          MOVE-CORRESPONDING <lg_line> TO <lg_exporting>.

      ENDCASE.
      APPEND <lg_exporting> TO et_list.
    ENDLOOP.

  ENDMETHOD.

  METHOD _on_double_click.

    DATA lo_selections TYPE REF TO cl_salv_selections.

    lo_selections = mo_select_list_popup->get_selections( ).

    IF lo_selections->get_selection_mode( ) = if_salv_c_selection_mode=>single.
      mo_select_list_popup->close_screen( ).
    ENDIF.

  ENDMETHOD.

  METHOD _on_select_list_function_click.

    FIELD-SYMBOLS:
      <lt_table>    TYPE STANDARD TABLE,
      <lg_line>     TYPE any,
      <lv_selected> TYPE abap_bool.

    ASSIGN mr_table->* TO <lt_table>.
    ASSERT sy-subrc = 0.

    CASE e_salv_function.
      WHEN 'O.K.'.
        mv_cancel = abap_false.
        mo_select_list_popup->close_screen( ).

      WHEN 'ABR'.
        "Canceled: clear list to overwrite nothing
        CLEAR <lt_table>.
        mv_cancel = abap_true.
        mo_select_list_popup->close_screen( ).

      WHEN 'SALL'.
        LOOP AT <lt_table> ASSIGNING <lg_line>.

          ASSIGN COMPONENT c_fieldname_selected
                 OF STRUCTURE <lg_line>
                 TO <lv_selected>.
          ASSERT sy-subrc = 0.

          <lv_selected> = abap_true.

        ENDLOOP.

        mo_select_list_popup->refresh( ).

      WHEN 'DSEL'.
        LOOP AT <lt_table> ASSIGNING <lg_line>.

          ASSIGN COMPONENT c_fieldname_selected
                 OF STRUCTURE <lg_line>
                 TO <lv_selected>.
          ASSERT sy-subrc = 0.

          <lv_selected> = abap_false.

        ENDLOOP.

        mo_select_list_popup->refresh( ).

      WHEN OTHERS.
        CLEAR <lt_table>.
        mo_select_list_popup->close_screen( ).
    ENDCASE.

  ENDMETHOD.

  METHOD _on_select_list_link_click.

    FIELD-SYMBOLS:
      <lt_table>    TYPE STANDARD TABLE,
      <lg_line>     TYPE any,
      <lv_selected> TYPE abap_bool.

    ASSIGN mr_table->* TO <lt_table>.
    ASSERT sy-subrc = 0.

    READ TABLE <lt_table> ASSIGNING <lg_line> INDEX row.
    IF sy-subrc = 0.

      ASSIGN COMPONENT c_fieldname_selected
             OF STRUCTURE <lg_line>
             TO <lv_selected>.
      ASSERT sy-subrc = 0.

      IF <lv_selected> = abap_true.
        <lv_selected> = abap_false.
      ELSE.
        <lv_selected> = abap_true.
      ENDIF.

    ENDIF.

    mo_select_list_popup->refresh( ).

  ENDMETHOD.
ENDCLASS.

CLASS lcl_tar_helpers DEFINITION.

  PUBLIC SECTION.

    CLASS-METHODS from_octal
      IMPORTING
        !octal        TYPE string
      RETURNING
        VALUE(result) TYPE i.

    CLASS-METHODS to_octal
      IMPORTING
        !number       TYPE numeric
      RETURNING
        VALUE(result) TYPE string.

    CLASS-METHODS from_xstring
      IMPORTING
        !data         TYPE xstring
      RETURNING
        VALUE(result) TYPE string
      RAISING
        zcx_error.

    CLASS-METHODS to_xstring
      IMPORTING
        !data         TYPE simple
      RETURNING
        VALUE(result) TYPE xstring
      RAISING
        zcx_error.

  PRIVATE SECTION.

    CLASS-DATA:
      convert_in  TYPE REF TO cl_abap_conv_in_ce,
      convert_out TYPE REF TO cl_abap_conv_out_ce.

ENDCLASS.

CLASS lcl_tar_helpers IMPLEMENTATION.

  METHOD from_octal.

    DATA(offset) = 0.

    DO strlen( octal ) TIMES.
      result = result * 8 + octal+offset(1).
      offset = offset + 1.
    ENDDO.

  ENDMETHOD.

  METHOD to_octal.

    DATA(temp_number) = CONV i( number ).

    WHILE temp_number > 0.
      result      = |{ temp_number MOD 8 }{ result }|.
      temp_number = temp_number DIV 8.
    ENDWHILE.

    IF result IS INITIAL.
      result = '0'.
    ENDIF.

  ENDMETHOD.

  METHOD from_xstring.

    IF convert_in IS INITIAL.
      convert_in = cl_abap_conv_in_ce=>create( encoding = 'UTF-8' ).
    ENDIF.

    TRY.
        convert_in->convert(
          EXPORTING
            input = data
            n     = xstrlen( data )
          IMPORTING
            data  = result ).

      CATCH cx_sy_codepage_converter_init
            cx_sy_conversion_codepage
            cx_parameter_invalid_type.
        zcx_error=>raise( 'Error converting from xstring' ).
    ENDTRY.

  ENDMETHOD.

  METHOD to_xstring.

    IF convert_out IS INITIAL.
      convert_out = cl_abap_conv_out_ce=>create( encoding = 'UTF-8' ).
    ENDIF.

    DATA(string_data) = CONV string( data ).

    TRY.
        convert_out->convert(
          EXPORTING
            data   = string_data
          IMPORTING
            buffer = result ).

      CATCH cx_sy_codepage_converter_init
            cx_sy_conversion_codepage
            cx_parameter_invalid_type.
        zcx_error=>raise( 'Error converting to xstring' ).
    ENDTRY.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_pax DEFINITION.

* Pax format stores keyword lists in ustar blocks
* https://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html
*
* A keyword list consists of records constructed as follows:
* "%d %s=%s\n", <length>, <keyword>, <value>

  PUBLIC SECTION.

    CLASS-METHODS decode_keywords
      IMPORTING
        block         TYPE xstring
      RETURNING
        VALUE(result) TYPE zcl_tar=>ty_keywords.

    CLASS-METHODS encode_keywords
      IMPORTING
        keywords      TYPE zcl_tar=>ty_keywords
      RETURNING
        VALUE(result) TYPE xstring.

    CLASS-METHODS merge_keywords
      IMPORTING
        global        TYPE zcl_tar=>ty_keywords
        extended      TYPE zcl_tar=>ty_keywords
      RETURNING
        VALUE(result) TYPE zcl_tar=>ty_keywords.

ENDCLASS.

CLASS lcl_pax IMPLEMENTATION.

  METHOD decode_keywords.

    DATA pax_records TYPE string_table.

    DATA(pax_data) = cl_binary_convert=>xstring_utf8_to_string( block ).

    SPLIT pax_data AT cl_abap_char_utilities=>newline INTO TABLE pax_records.

    LOOP AT pax_records ASSIGNING FIELD-SYMBOL(<record>).
      SPLIT <record> AT ` ` INTO DATA(octal_len) DATA(key_val).
      DATA(len) = lcl_tar_helpers=>from_octal( octal_len ) - 1.
      IF strlen( key_val ) <> len.
        ASSERT 0 = 0. " ignore this inconsistency
      ENDIF.

      SPLIT key_val AT `=` INTO DATA(key) DATA(value).
      DATA(keyword) = VALUE zcl_tar=>ty_keyword(
        keyword = key
        value   = value ).
      INSERT keyword INTO TABLE result.
    ENDLOOP.

  ENDMETHOD.

  METHOD encode_keywords.

    DATA pax_records TYPE string_table.
    DATA block TYPE x LENGTH zcl_tar=>c_blocksize.

    LOOP AT keywords ASSIGNING FIELD-SYMBOL(<keyword>).
      DATA(pax_record) = |{ <keyword>-keyword }={ <keyword>-value }|.
      DATA(len) = strlen( pax_record ) + 1. " +1 for newline
      DATA(octal_len) = lcl_tar_helpers=>to_octal( len ).
      pax_record = octal_len && pax_record.
      INSERT pax_record INTO TABLE pax_records.
    ENDLOOP.

    DATA(pax_data) = concat_lines_of(
      table = pax_records
      sep   = cl_abap_char_utilities=>newline ).

    pax_data = pax_data && cl_abap_char_utilities=>newline.

    result = cl_binary_convert=>string_to_xstring_utf8( pax_data ).

    len = zcl_tar=>c_blocksize - xstrlen( result ).

    IF len < 0.
      " TODO: What if the keywords don't fit into a blocK?
      ASSERT 1 = 2.
    ELSE.
      result = result && block(len).
    ENDIF.

  ENDMETHOD.

  METHOD merge_keywords.

    result = global.

    LOOP AT extended ASSIGNING FIELD-SYMBOL(<extended>).
      READ TABLE result ASSIGNING FIELD-SYMBOL(<result>)
        WITH TABLE KEY keyword = <extended>-keyword.
      IF sy-subrc = 0.
        <result>-value = <extended>-value.
      ELSE.
        INSERT <extended> INTO TABLE result.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_7zip DEFINITION.

  PUBLIC SECTION.

    CLASS-METHODS decode_longlink
      IMPORTING
        block_1       TYPE xstring
        block_2       TYPE xstring
      RETURNING
        VALUE(result) TYPE string
      RAISING
        zcx_error.

ENDCLASS.

CLASS lcl_7zip IMPLEMENTATION.

  METHOD decode_longlink.

    CONSTANTS c_longlink TYPE string VALUE `././@LongLink`.

    DATA(header) = CONV zcl_tar=>ty_header( lcl_tar_helpers=>from_xstring( block_1 ) ).

    IF header-name = c_longlink.
      result = lcl_tar_helpers=>from_xstring( block_2 ).
    ENDIF.

  ENDMETHOD.

ENDCLASS.

CLASS zcl_tar IMPLEMENTATION.

  METHOD append.

    " TODO: Support long filenames (pax)
    IF strlen( name ) > 100.
      zcx_error=>raise( |Filename longer than 100 characters: { name }| ).
    ENDIF.

    " List
    DATA(file) = VALUE ty_file(
      name     = name
      date     = date
      time     = time
      mode     = mode
      typeflag = typeflag
      keywords = keywords
      size     = xstrlen( content ) ).

    IF date IS INITIAL.
      file-date = sy-datum.
    ENDIF.
    IF time IS INITIAL.
      file-time = sy-uzeit.
    ENDIF.
    IF mode IS INITIAL.
      file-mode = c_mode_default.
    ENDIF.
    IF typeflag IS INITIAL.
      file-typeflag = c_typeflag-file.
    ENDIF.
    file-unixtime = _to_unixtime( date = file-date time = file-time ).

    INSERT file INTO TABLE tar_files.
    IF sy-subrc <> 0.
      zcx_error=>raise( 'Error adding file (list)' ).
    ENDIF.

    " Data
    DATA(item) = VALUE ty_tar_item(
      name    = name
      content = content ).
    INSERT item INTO TABLE tar_data.
    IF sy-subrc <> 0.
      zcx_error=>raise( 'Error adding file (data)' ).
    ENDIF.

    result = me.

  ENDMETHOD.

  METHOD class_constructor.

    " Generate a char 256 null
    DATA x TYPE x LENGTH 4 VALUE '00000000'.

    FIELD-SYMBOLS <c> TYPE c.

    ASSIGN x TO <c> CASTING ##SUBRC_OK.

    null = <c>.
    DO 8 TIMES.
      null = null && null.
    ENDDO.

  ENDMETHOD.

  METHOD constructor.

    me->force_ustar = force_ustar.

  ENDMETHOD.

  METHOD delete.

    DELETE tar_files WHERE name = CONV string( name ).
    IF sy-subrc <> 0.
      zcx_error=>raise( 'Error deleting file (list)' ).
    ENDIF.

    DELETE tar_data WHERE name = CONV string( name ).
    IF sy-subrc <> 0.
      zcx_error=>raise( 'Error deleting file (data)' ).
    ENDIF.

    result = me.

  ENDMETHOD.

  METHOD file_count.

    LOOP AT tar_files TRANSPORTING NO FIELDS WHERE typeflag = c_typeflag-file.
      result = result + 1.
    ENDLOOP.

  ENDMETHOD.

  METHOD get.

    READ TABLE tar_data ASSIGNING FIELD-SYMBOL(<item>) WITH TABLE KEY name = name.
    IF sy-subrc = 0.
      result = <item>-content.
    ELSE.
      zcx_error=>raise( 'Error getting file' ).
    ENDIF.

  ENDMETHOD.

  METHOD gunzip.

    cl_abap_gzip=>decompress_binary_with_header(
      EXPORTING
        gzip_in = gzip
      IMPORTING
        raw_out = result ).

  ENDMETHOD.

  METHOD gzip.

    cl_abap_gzip=>compress_binary_with_header(
      EXPORTING
        raw_in   = tar
      IMPORTING
        gzip_out = result ).

  ENDMETHOD.

  METHOD list.

    result = tar_files.

  ENDMETHOD.

  METHOD load.

    DATA(size) = xstrlen( tar ).

    IF size = 0 OR size MOD c_blocksize <> 0.
      zcx_error=>raise( 'Error loading file (blocksize)' ).
    ENDIF.

    CLEAR tar_files.

    DATA(offset) = 0.
    DO.
      IF offset + c_blocksize > size.
        EXIT.
      ENDIF.

      " Header block
      DATA(block) = tar+offset(c_blocksize).
      offset = offset + c_blocksize.

      DATA(header) = CONV ty_header( _from_xstring( block ) ).

      _remove_nulls( CHANGING data = header ).

      IF header IS INITIAL.
        CONTINUE.
      ENDIF.

      " Get extended header for keywords and filename
      CASE header-typeflag.
        WHEN c_typeflag-global_header.
          DATA(global) = lcl_pax=>decode_keywords( block ).
          CONTINUE.
        WHEN c_typeflag-extended_header.
          DATA(extended) = lcl_pax=>decode_keywords( block ).
          CONTINUE.
        WHEN c_typeflag-long_link.
          " Two blocks
          DATA(next_block) = tar+offset(c_blocksize).
          DATA(longlink) = lcl_7zip=>decode_longlink(
            block_1 = block
            block_2 = next_block ).
          offset = offset + c_blocksize.
          CONTINUE.
      ENDCASE.

      IF force_ustar = abap_true.
        IF header-magic <> c_ustar_magic.
          zcx_error=>raise( 'Error loading file (ustar)' ).
        ELSEIF header-version <> c_ustar_version AND header-version <> ` `.
          zcx_error=>raise( 'Error loading file (version)' ).
        ENDIF.
      ENDIF.

      DATA(file) = VALUE ty_file(
        name     = _to_filename( prefix = header-prefix name = header-name )
        size     = _unpad( header-size )
        mode     = _unpad( header-mode )
        unixtime = _unpad( header-mtime ) ).

      _from_unixtime(
        EXPORTING
          unixtime = file-unixtime
        IMPORTING
          date     = file-date
          time     = file-time ).

      IF header-typeflag IS INITIAL.
        file-typeflag = c_typeflag-file.
      ELSE.
        file-typeflag = header-typeflag.
      ENDIF.

      file-keywords = lcl_pax=>merge_keywords(
        global   = global
        extended = extended ).

      " Long filename
      IF longlink IS NOT INITIAL.
        " 7-zip
        file-name = longlink.
        CLEAR longlink.
      ELSE.
        " Pax
        READ TABLE file-keywords ASSIGNING FIELD-SYMBOL(<keyword>)
          WITH TABLE KEY keyword = 'path'.
        IF sy-subrc = 0.
          file-name = <keyword>-value.
        ENDIF.
      ENDIF.

      INSERT file INTO TABLE tar_files.

      CLEAR extended.

      " Data blocks
      DATA(item)   = VALUE ty_tar_item( name = file-name ).
      DATA(length) = file-size.
      DATA(count)  = ( file-size - 1 ) DIV c_blocksize + 1.

      DO count TIMES.
        IF length > c_blocksize.
          block = tar+offset(c_blocksize).
        ELSE.
          block = tar+offset(length).
        ENDIF.
        CONCATENATE item-content block INTO item-content IN BYTE MODE.
        offset = offset + c_blocksize.
        length = length - c_blocksize.
      ENDDO.

      INSERT item INTO TABLE tar_data.
    ENDDO.

    result = me.

  ENDMETHOD.

  METHOD new.

    result = NEW #( force_ustar ).

  ENDMETHOD.

  METHOD save.

    " TODO?: Support other types
    LOOP AT tar_files ASSIGNING FIELD-SYMBOL(<file>)
      WHERE typeflag = c_typeflag-file OR typeflag = c_typeflag-directory.

      IF strlen( <file>-name ) > 255.
        zcx_error=>raise( 'Error saving file (name)' ).
      ELSEIF <file>-name CA '\'.
        zcx_error=>raise( 'Error saving file (path)' ).
      ENDIF.

      " Add extended header block for pax keywords
      IF <file>-keywords IS NOT INITIAL.
        DATA(pax) = abap_true.
        DATA(keywords) = lcl_pax=>encode_keywords( <file>-keywords ).
        CONCATENATE result keywords INTO result IN BYTE MODE.
        CONTINUE.
      ENDIF.

      " Header block
      DATA(header) = VALUE ty_header(
        mode     = _pad( number = <file>-mode length = 7 )
        uid      = ''
        gid      = ''
        size     = _pad( number = <file>-size length = 11 )
        mtime    = _pad( number = <file>-unixtime length = 11 )
        typeflag = <file>-typeflag
        magic    = c_ustar_magic
        version  = c_ustar_version
        uname    = to_lower( cl_abap_syst=>get_user_name( ) )
        gname    = ''
        linkname = ''
        devminor = ''
        devmajor = ''
        padding  = '' ).

      _from_filename(
        EXPORTING
          filename = <file>-name
        IMPORTING
          prefix   = header-prefix
          name     = header-name ).

      _append_nulls( CHANGING data = header ).

      header-chksum = `        `. " 8 spaces
      header-chksum = _pad( number = _checksum( header ) length = 7 ) && null.

      DATA(block)  = CONV ty_block( _to_xstring( header ) ).
      CONCATENATE result block INTO result IN BYTE MODE.

      " Data blocks
      READ TABLE tar_data ASSIGNING FIELD-SYMBOL(<item>) WITH TABLE KEY name = <file>-name.
      IF sy-subrc <> 0.
        zcx_error=>raise( 'Error saving file (data)' ).
      ENDIF.

      DATA(offset) = 0.
      DATA(length) = <file>-size.
      DATA(count)  = ( length - 1 ) DIV c_blocksize + 1.

      DO count TIMES.
        IF length > c_blocksize.
          block = <item>-content+offset(c_blocksize).
        ELSE.
          block = <item>-content+offset(length).
        ENDIF.
        CONCATENATE result block INTO result IN BYTE MODE.
        offset = offset + c_blocksize.
        length = length - c_blocksize.
      ENDDO.

    ENDLOOP.

    IF pax = abap_true.
      " Add two null blocks
      CLEAR block.
      CONCATENATE result block block INTO result IN BYTE MODE.
    ENDIF.

  ENDMETHOD.

  METHOD unpacked_size.

    LOOP AT tar_files ASSIGNING FIELD-SYMBOL(<file>) WHERE typeflag = c_typeflag-file.
      result = result + <file>-size.
    ENDLOOP.

  ENDMETHOD.

  METHOD _append_nulls.

    DATA(count) = 0.
    DO.
      count = count + 1.
      ASSIGN COMPONENT count OF STRUCTURE data TO FIELD-SYMBOL(<field>).
      IF sy-subrc <> 0.
        EXIT.
      ENDIF.
      <field> = <field> && null.
    ENDDO.

  ENDMETHOD.

  METHOD _checksum.

    DATA(xstring) = _to_xstring( data ).
    DATA(i) = 0.

    DO xstrlen( xstring ) TIMES.
      DATA(x) = xstring+i(1).
      result = result + x.
      i = i + 1.
    ENDDO.

  ENDMETHOD.

  METHOD _from_filename.

    DATA(temp_name) = filename.
    DO.
      IF strlen( temp_name ) <= 100.
        name = temp_name.
        EXIT.
      ENDIF.

      " Shorten name by moving part of path to prefix
      SPLIT temp_name AT c_path_sep INTO DATA(temp_prefix) temp_name.
      IF sy-subrc <> 0.
        zcx_error=>raise( 'Error file name too long' ).
      ENDIF.

      IF prefix IS INITIAL.
        prefix = temp_prefix.
      ELSE.
        prefix = prefix && c_path_sep && temp_prefix.
      ENDIF.
    ENDDO.

  ENDMETHOD.

  METHOD _from_octal.
    result = lcl_tar_helpers=>from_octal( octal ).
  ENDMETHOD.

  METHOD _from_unixtime.

    TRY.
        DATA(timestamp) = cl_abap_tstmp=>add(
          tstmp = c_epoch
          secs  = unixtime ).

      CATCH cx_parameter_invalid_range
            cx_parameter_invalid_type.
        zcx_error=>raise( 'Error converting from UNIX time' ).
    ENDTRY.

    CONVERT TIME STAMP timestamp TIME ZONE 'UTC' INTO DATE date TIME time.

  ENDMETHOD.

  METHOD _from_xstring.
    result = lcl_tar_helpers=>from_xstring( data ).
  ENDMETHOD.

  METHOD _pad.

    result = |{ _to_octal( number ) ALIGN = RIGHT PAD = '0' WIDTH = length }|.

  ENDMETHOD.

  METHOD _remove_nulls.

    DATA(count) = 0.

    DO.
      count = count + 1.
      ASSIGN COMPONENT count OF STRUCTURE data TO FIELD-SYMBOL(<field>).
      IF sy-subrc <> 0.
        EXIT.
      ENDIF.
      REPLACE ALL OCCURRENCES OF null(1) IN <field> WITH ''.
    ENDDO.

  ENDMETHOD.

  METHOD _to_filename.

    IF prefix IS INITIAL.
      result = name.
    ELSE.
      result = prefix && c_path_sep && name.
    ENDIF.

  ENDMETHOD.

  METHOD _to_octal.
    result = lcl_tar_helpers=>to_octal( number ).
  ENDMETHOD.

  METHOD _to_unixtime.

    DATA timestamp TYPE timestamp.

    CONVERT DATE date TIME time INTO TIME STAMP timestamp TIME ZONE 'UTC'.

    TRY.
        result = cl_abap_tstmp=>subtract(
          tstmp1 = timestamp
          tstmp2 = c_epoch ).

      CATCH cx_parameter_invalid_range
            cx_parameter_invalid_type.
        zcx_error=>raise( 'Error converting to UNIX time' ).
    ENDTRY.

  ENDMETHOD.

  METHOD _to_xstring.
    result = lcl_tar_helpers=>to_xstring( data ).
  ENDMETHOD.

  METHOD _unpad.

    DATA(temp_data) = CONV string( data ).

    temp_data = replace(
      val  = temp_data
      sub  = ` `
      with = ''
      occ  = 0 ).

    result = _from_octal( condense( data ) ).

  ENDMETHOD.
ENDCLASS.

CLASS lcl_abapgit_data_supporter DEFINITION.

  PUBLIC SECTION.

    INTERFACES zif_abapgit_data_supporter.

ENDCLASS.

CLASS lcl_abapgit_data_supporter IMPLEMENTATION.

  METHOD zif_abapgit_data_supporter~is_object_supported.
    " Allow all MBT tables for updates
    IF iv_type = 'TABU' AND iv_name CP '/MBTOOLS/*'.
      rv_supported = abap_true.
    ENDIF.
  ENDMETHOD.

ENDCLASS.

CLASS zcl_abapinst_installer IMPLEMENTATION.

  METHOD f4.

    DATA:
      lt_list     TYPE zif_abapinst_definitions=>ty_list,
      lt_selected LIKE lt_list,
      lo_popup    TYPE REF TO zcl_abapinst_popups,
      lt_columns  TYPE zcl_abapinst_popups=>ty_alv_column_tt,
      lv_question TYPE string,
      lv_answer   TYPE sy-input.

    FIELD-SYMBOLS:
      <ls_column> LIKE LINE OF lt_columns.

    init( ).

    lt_list = go_db->list( ).

    CHECK _nothing_found( lt_list ) IS INITIAL.

    APPEND INITIAL LINE TO lt_columns ASSIGNING <ls_column>.
    <ls_column>-name   = 'NAME'.
    <ls_column>-text   = 'Name'.
    <ls_column>-length = 30.
    <ls_column>-key    = abap_true.
    APPEND INITIAL LINE TO lt_columns ASSIGNING <ls_column>.
    <ls_column>-name   = 'PACK'.
    <ls_column>-text   = 'Package'.
    <ls_column>-length = 30.
    <ls_column>-key    = abap_true.
    APPEND INITIAL LINE TO lt_columns ASSIGNING <ls_column>.
    <ls_column>-name   = 'VERSION'.
    <ls_column>-text   = 'Version'.
    <ls_column>-length = 15.
    APPEND INITIAL LINE TO lt_columns ASSIGNING <ls_column>.
    <ls_column>-name   = 'DESCRIPTION'.
    <ls_column>-text   = 'Description'.
    <ls_column>-length = 60.

    CREATE OBJECT lo_popup.

    TRY.
        lo_popup->popup_to_select_from_list(
          EXPORTING
            it_list               = lt_list
            iv_title              = sy-title
            iv_header_text        = |Select the { gv_name } that you want to uninstall:|
            iv_end_column         = 150
            iv_striped_pattern    = abap_true
            iv_optimize_col_width = abap_false
            iv_selection_mode     = if_salv_c_selection_mode=>single
            it_columns_to_display = lt_columns
          IMPORTING
            et_list               = lt_selected ).
      CATCH zcx_abapinst_exception.
        RETURN.
    ENDTRY.

    IF lt_selected IS INITIAL.
      RETURN.
    ENDIF.

    READ TABLE lt_selected INTO rs_inst INDEX 1.
    ASSERT sy-subrc = 0.

    TRY.
        lv_question = |Are you sure, you want to uninstall "{ rs_inst-description } ({ rs_inst-name })"?|.

        lv_answer = lo_popup->popup_to_confirm(
          iv_title          = sy-title
          iv_question       = lv_question
          iv_default_button = '2' ).

        IF lv_answer <> '1'.
          CLEAR rs_inst.
        ENDIF.
      CATCH zcx_abapinst_exception ##NO_HANDLER.
    ENDTRY.

  ENDMETHOD.

  METHOD init.

    IF go_db IS NOT BOUND.
      IF iv_tabname IS INITIAL AND iv_lock IS INITIAL.
        go_db = zcl_abapinst_persistence=>get_instance( ).
      ELSE.
        go_db = zcl_abapinst_persistence=>get_instance(
          iv_tabname = iv_tabname
          iv_lock    = iv_lock ).
      ENDIF.
    ENDIF.

    IF iv_name IS NOT INITIAL OR iv_names IS NOT INITIAL.
      gv_name  = iv_name.
      gv_names = iv_names.
    ENDIF.

  ENDMETHOD.

  METHOD install.

    DATA:
      lx_error TYPE REF TO zcx_abapgit_exception.

    gs_apm-name    = iv_apm_name.
    gs_apm-version = iv_apm_version.

    init( ).

    TRY.
        _clear( ).

        _log_start( ).

        _system_check( ).

        _files(
          iv_enum_zip       = iv_enum_zip
          iv_name           = iv_name
          iv_data           = iv_data
          iv_user           = iv_user
          iv_password       = iv_password
          iv_proxy_host     = iv_proxy_host
          iv_proxy_service  = iv_proxy_service
          iv_proxy_user     = iv_proxy_user
          iv_proxy_password = iv_proxy_password ).

        _packaging( ).

        _sap_package(
          iv_enum_package = iv_enum_package
          iv_package      = iv_package ).

        _check( ).

        _folder_logic( iv_enum_folder_logic ).

        _transport(
          iv_enum_transport = iv_enum_transport
          iv_transport      = iv_transport ).

        _confirm_messages( ).

        _namespaces( ).

        _deserialize_objects( ).

        _deserialize_data( ).

      CATCH zcx_abapgit_exception INTO lx_error.
        _transport_reset( ).

        gi_log->add_exception( lx_error ).
    ENDTRY.

    TRY.
        _log_end( ).

        IF gs_apm-name IS INITIAL.
          _save( ).
        ENDIF.

        _restore_messages( ).

        _final_message( 'Installation' ).

      CATCH zcx_abapgit_exception INTO lx_error.
        ASSERT 1 = 2.
    ENDTRY.

  ENDMETHOD.

  METHOD list.

    DATA:
      lt_list          TYPE zif_abapinst_definitions=>ty_list,
      lo_list          TYPE REF TO cl_salv_table,
      lo_disp_settings TYPE REF TO cl_salv_display_settings,
      lo_functions     TYPE REF TO cl_salv_functions,
      lo_columns       TYPE REF TO cl_salv_columns_table,
      ls_column        TYPE salv_s_column_ref,
      lt_columns       TYPE salv_t_column_ref,
      lo_column        TYPE REF TO cl_salv_column,
      lr_column        TYPE REF TO cl_salv_column_table,
      lx_error         TYPE REF TO cx_salv_error.

    FIELD-SYMBOLS:
      <ls_list> LIKE LINE OF lt_list.

    init( ).

    lt_list = go_db->list( ).

    CHECK _nothing_found( lt_list ) IS INITIAL.

    LOOP AT lt_list ASSIGNING <ls_list>.
      CASE <ls_list>-status.
        WHEN space.
          <ls_list>-status = icon_led_inactive.
        WHEN c_success.
          <ls_list>-status = icon_led_green.
        WHEN c_warning.
          <ls_list>-status = icon_led_yellow.
        WHEN OTHERS.
          <ls_list>-status = icon_led_red.
      ENDCASE.
    ENDLOOP.

    TRY.
        cl_salv_table=>factory(
          IMPORTING
            r_salv_table = lo_list
          CHANGING
            t_table      = lt_list ).

        lo_functions = lo_list->get_functions( ).
        lo_functions->set_all( ).

        lo_columns = lo_list->get_columns( ).
        lo_columns->set_optimize( ).

        lo_column = lo_columns->get_column( 'NAME' ).
        lo_column->set_medium_text( 'Name' ).
        lo_column->set_output_length( 30 ).
        lr_column ?= lo_columns->get_column( 'NAME' ).
        lr_column->set_key( ).

        lo_column = lo_columns->get_column( 'PACK' ).
        lo_column->set_medium_text( 'SAP Package' ).
        lo_column->set_output_length( 30 ).
        lr_column ?= lo_columns->get_column( 'PACK' ).
        lr_column->set_key( ).

        lo_column = lo_columns->get_column( 'VERSION' ).
        lo_column->set_medium_text( 'Version' ).
        lo_column->set_output_length( 12 ).

        lt_columns = lo_columns->get( ).
        LOOP AT lt_columns INTO ls_column WHERE columnname CP 'SEM_VERSION-*'.
          ls_column-r_column->set_technical( ).
        ENDLOOP.

        lo_column = lo_columns->get_column( 'STATUS' ).
        lo_column->set_medium_text( 'Status' ).
        lo_column->set_output_length( 6 ).

        lo_column = lo_columns->get_column( 'DESCRIPTION' ).
        lo_column->set_medium_text( 'Description' ).
        lo_column->set_output_length( 60 ).

        lo_column = lo_columns->get_column( 'SOURCE_TYPE' ).
        lo_column->set_medium_text( 'Type' ).
        lo_column->set_output_length( 10 ).

        lo_column = lo_columns->get_column( 'SOURCE_NAME' ).
        lo_column->set_medium_text( 'Source' ).
        lo_column->set_output_length( 50 ).

        lo_column = lo_columns->get_column( 'TRANSPORT' ).
        lo_column->set_medium_text( 'Transport' ).
        lo_column->set_output_length( 12 ).

        lo_column = lo_columns->get_column( 'FOLDER_LOGIC' ).
        lo_column->set_medium_text( 'Folder Logic' ).
        lo_column->set_output_length( 10 ).

        lo_column = lo_columns->get_column( 'INSTALLED_LANGU' ).
        lo_column->set_medium_text( 'Installed Language' ).
        lo_column->set_output_length( 12 ).

        lo_column = lo_columns->get_column( 'INSTALLED_BY' ).
        lo_column->set_medium_text( 'Installed By' ).
        lo_column->set_output_length( 12 ).

        lo_column = lo_columns->get_column( 'INSTALLED_AT' ).
        lo_column->set_short_text( 'Installed' ).
        lo_column->set_medium_text( 'Installed At' ).
        lo_column->set_output_length( 18 ).

        lo_column = lo_columns->get_column( 'UPDATED_BY' ).
        lo_column->set_medium_text( 'Updated By' ).
        lo_column->set_output_length( 12 ).

        lo_column = lo_columns->get_column( 'UPDATED_AT' ).
        lo_column->set_short_text( 'Updated' ).
        lo_column->set_medium_text( 'Updated At' ).
        lo_column->set_output_length( 18 ).

        lo_disp_settings = lo_list->get_display_settings( ).
        lo_disp_settings->set_list_header( sy-title ).
        lo_disp_settings->set_fit_column_to_table_size( ).

        lo_list->display( ).
      CATCH cx_salv_error INTO lx_error.
        zcx_abapinst_exception=>raise( lx_error->get_text( ) ).
    ENDTRY.

  ENDMETHOD.

  METHOD uninstall.

    DATA:
      lx_error TYPE REF TO zcx_abapgit_exception,
      lt_tadir TYPE zif_abapgit_definitions=>ty_tadir_tt.

    IF iv_apm IS INITIAL.
      init( ).

    ENDIF.

    TRY.
        _clear( ).

        _log_start( ).

        _system_check( ).

        IF iv_apm IS INITIAL.
          gs_inst = _load(
            iv_name = iv_name
            iv_pack = iv_pack ).

          IF gs_inst IS INITIAL.
            zcx_abapgit_exception=>raise( |Package { iv_name } ({ iv_pack }) not found| ).
          ENDIF.

          " TODO: needs to work for apm
          _transport( c_enum_transport-prompt ).
        ELSE.
          gs_inst-pack = iv_pack.
        ENDIF.

        _confirm_messages( ).

        " A few tries to tackle dependencies
        DO 3 TIMES.
          lt_tadir = zcl_abapinst_factory=>get_tadir( )->read( gs_inst-pack ).

          DELETE lt_tadir WHERE object = 'NSPC'.

          IF lt_tadir IS NOT INITIAL.
            _uninstall_sotr( lt_tadir ).

            _uninstall_sots( lt_tadir ).

            zcl_abapinst_objects=>delete(
              it_tadir     = lt_tadir
              iv_transport = gs_inst-transport
              ii_log       = gi_log ).
          ENDIF.
        ENDDO.

      CATCH zcx_abapgit_exception INTO lx_error.
        _transport_reset( ).

        gi_log->add_exception( lx_error ).
    ENDTRY.

    TRY.
        _log_end( ).

        _check_uninstalled( lt_tadir ).

        IF iv_apm IS INITIAL.
          IF gs_inst-status = c_success.
            _delete( ).
          ELSE.
            _save( ).
          ENDIF.
        ENDIF.

        _restore_messages( ).

        _final_message( 'Uninstall' ).

      CATCH zcx_abapgit_exception INTO lx_error.
        ASSERT 1 = 2.
    ENDTRY.

  ENDMETHOD.

  METHOD _check.

    DATA ls_inst TYPE zif_abapinst_definitions=>ty_inst.

    IF gs_apm-name IS INITIAL.
      ls_inst = _load(
        iv_name = gs_inst-name
        iv_pack = gs_inst-pack ).

      IF ls_inst IS INITIAL.

        ls_inst = _load( iv_pack = gs_inst-pack ).

        IF ls_inst IS NOT INITIAL.
          zcx_abapinst_exception=>raise( |SAP package { gs_inst-pack } already contains a different { gv_name }| ).
        ENDIF.

      ELSE.

        _check_version(
          is_new_version       = gs_inst-sem_version
          is_installed_version = ls_inst-sem_version
          iv_force             = iv_force ).

      ENDIF.
    ENDIF.

    _check_requirements( ).

    _check_dependencies( ).

  ENDMETHOD.

  METHOD _check_dependencies.

    DATA:
      ls_deps LIKE LINE OF gs_packaging-dependencies,
      ls_inst TYPE zif_abapinst_definitions=>ty_inst,
      lv_comp TYPE i,
      lv_msg  TYPE string.

    LOOP AT gs_packaging-dependencies INTO ls_deps.

      ls_inst = _load( iv_name = |{ ls_deps-name }| ).

      IF ls_inst IS INITIAL.
        zcx_abapinst_exception=>raise( |Package { ls_deps-name } is a dependency and must be installed, first| ).
      ELSE.
        lv_comp = zcl_abapgit_version=>compare(
          is_a = ls_deps-sem_version
          is_b = ls_inst-sem_version ).
        IF lv_comp > 0.
          lv_msg = |Package { ls_deps-name } is a dependency and must be updated to { ls_deps-version }, first|.
          zcx_abapinst_exception=>raise( lv_msg ).
        ENDIF.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD _check_requirements.

    DATA:
      lv_met   TYPE c LENGTH 1,
      lx_error TYPE REF TO zcx_abapgit_exception.

    TRY.
        lv_met = zcl_abapinst_requirements=>is_requirements_met( gt_requirements ).

        IF lv_met = zif_abapgit_definitions=>c_no.
          zcx_abapinst_exception=>raise( |Minimum requirements for software components have not been met| ).
        ENDIF.
      CATCH zcx_abapgit_exception INTO lx_error.
        zcx_abapinst_exception=>raise( lx_error->get_text( ) ).
    ENDTRY.

  ENDMETHOD.

  METHOD _check_uninstalled.

    DATA:
      lv_msg   TYPE string,
      ls_tadir LIKE LINE OF it_tadir,
      lt_tadir LIKE it_tadir.

    CHECK it_tadir IS NOT INITIAL.

    SELECT pgmid object obj_name FROM tadir INTO CORRESPONDING FIELDS OF TABLE lt_tadir
      FOR ALL ENTRIES IN it_tadir
      WHERE pgmid    = it_tadir-pgmid
        AND object   = it_tadir-object
        AND obj_name = it_tadir-obj_name ##TOO_MANY_ITAB_FIELDS.
    IF sy-subrc = 0.
      LOOP AT lt_tadir INTO ls_tadir WHERE object <> 'DEVC'.
        EXIT.
      ENDLOOP.
      IF sy-subrc = 0.
        gs_inst-status = c_warning.
        lv_msg = |Some objects could not be uninstalled. Uninstall the remaining objects |
              && |of pacakge { gs_inst-pack } manually|.
      ELSE.
        lv_msg = |Release the transport and deleted the remaining pacakge { gs_inst-pack } manually|.
      ENDIF.
      MESSAGE lv_msg TYPE 'I'.
    ENDIF.

  ENDMETHOD.

  METHOD _check_version.

    DATA:
      lv_comp     TYPE i,
      lv_msg      TYPE string,
      lv_question TYPE string,
      lo_popup    TYPE REF TO zcl_abapinst_popups,
      lv_answer   TYPE c LENGTH 1.

    lv_comp = zcl_abapgit_version=>compare(
      is_a = is_new_version
      is_b = is_installed_version ).
    IF lv_comp <= 0.

      lv_msg = |{ gs_inst-name } is already installed (with same or newer version)|.
      lv_question = lv_msg  && '. Do you want to overwrite it?'.

      IF iv_force IS INITIAL.
        CREATE OBJECT lo_popup.

        lv_answer = lo_popup->popup_to_confirm(
          iv_title          = sy-title
          iv_question       = lv_question
          iv_default_button = '2' ).

        IF lv_answer <> '1'.
          zcx_abapinst_exception=>raise( lv_msg ).
        ENDIF.
      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD _clear.
    CLEAR: gs_inst, gs_packaging, go_dot.
  ENDMETHOD.

  METHOD _confirm_messages.

    " Temporarily suppress certain messages that are not relevant for installation

    CONSTANTS lc_toolflag_set TYPE funcname VALUE 'SCWG_TOOLFLAG_SET'.

    DATA ls_clmcus TYPE clmcus.

    " Set tool flag to avoid messages
    TRY.
        CALL FUNCTION lc_toolflag_set.
      CATCH cx_root ##NO_HANDLER.
    ENDTRY.

    " Confirm message about modification mode (DT, CLM_INFORMATION)
    " and backup old state (see _restore_messages)
    SELECT * FROM clmcus INTO TABLE gt_clmcus WHERE username = sy-uname ##SUBRC_OK.
    CHECK sy-subrc >= 0. "abaplint
    ls_clmcus-username = sy-uname.
    ls_clmcus-obj_type = 'CLAS'.
    INSERT clmcus FROM ls_clmcus ##SUBRC_OK.
    CHECK sy-subrc >= 0. "abaplint
    ls_clmcus-obj_type = 'INTF'.
    INSERT clmcus FROM ls_clmcus ##SUBRC_OK.
    CHECK sy-subrc >= 0. "abaplint
    ls_clmcus-obj_type = 'METH'.
    INSERT clmcus FROM ls_clmcus ##SUBRC_OK.
    CHECK sy-subrc >= 0. "abaplint

  ENDMETHOD.

  METHOD _delete.

    go_db->delete(
      iv_name = gs_inst-name
      iv_pack = gs_inst-pack ).

  ENDMETHOD.

  METHOD _deserialize_data.

    DATA:
      lo_support   TYPE REF TO lcl_abapgit_data_supporter,
      lo_inject    TYPE REF TO zcl_abapgit_data_injector,
      li_config    TYPE REF TO zif_abapgit_data_config,
      li_deser     TYPE REF TO zif_abapgit_data_deserializer,
      ls_checks    TYPE zif_abapgit_definitions=>ty_deserialize_checks,
      ls_overwrite TYPE LINE OF zif_abapgit_definitions=>ty_deserialize_checks-overwrite,
      ls_result    TYPE LINE OF zif_abapgit_data_deserializer=>ty_results,
      lt_result    TYPE zif_abapgit_data_deserializer=>ty_results.

    CREATE OBJECT lo_support.
    CREATE OBJECT lo_inject.
    lo_inject->set_supporter( lo_support ).

    li_config = _find_remote_data_config( ).

    li_deser = zcl_abapgit_data_factory=>get_deserializer( ).

    lt_result = li_deser->deserialize(
      ii_config = li_config
      it_files  = gt_remote ).

    LOOP AT lt_result INTO ls_result.
      CLEAR ls_overwrite.
      ls_overwrite-obj_type = ls_result-type.
      ls_overwrite-obj_name = ls_result-name.
      ls_overwrite-decision = zif_abapgit_definitions=>c_yes.
      COLLECT ls_overwrite INTO ls_checks-overwrite.
    ENDLOOP.

    li_deser->actualize(
      is_checks = ls_checks
      it_result = lt_result ).

  ENDMETHOD.

  METHOD _deserialize_objects.

    zcl_abapinst_objects=>deserialize(
      iv_package   = gs_inst-pack
      iv_language  = gs_inst-installed_langu
      iv_transport = gs_inst-transport
      it_remote    = gt_remote
      io_dot       = go_dot
      ii_log       = gi_log ).

  ENDMETHOD.

  METHOD _files.

    DATA:
      li_progress TYPE REF TO zif_abapgit_progress,
      lv_xstr     TYPE xstring,
      lt_files    TYPE zcl_tar=>ty_tar_files,
      ls_remote   LIKE LINE OF gt_remote,
      lo_tar      TYPE REF TO zcl_tar.

    FIELD-SYMBOLS <ls_file> LIKE LINE OF lt_files.

    li_progress = zcl_abapgit_progress=>get_instance( 100 ).

    li_progress->show(
      iv_text    = 'Uploading package'
      iv_current = 5 ).

    " Load abapGit ZIP File
    gs_inst-source_name = iv_name.

    CASE iv_enum_zip.
      WHEN c_enum_zip-internet.
        gs_inst-source_type = 'INTERNET'.
        lv_xstr = zcl_abapinst_file=>load_internet(
                    iv_url            = |{ iv_name }|
                    iv_user           = |{ iv_user }|
                    iv_password       = |{ iv_password }|
                    iv_proxy_host     = |{ iv_proxy_host }|
                    iv_proxy_port     = |{ iv_proxy_service }|
                    iv_proxy_user     = |{ iv_proxy_user }|
                    iv_proxy_password = |{ iv_proxy_password }| ).
      WHEN c_enum_zip-local.
        gs_inst-source_type = 'LOCAL'.
        lv_xstr = zcl_abapinst_file=>load_local( iv_name ).
      WHEN c_enum_zip-server.
        gs_inst-source_type = 'SERVER'.
        lv_xstr = zcl_abapinst_file=>load_server( iv_name ).
      WHEN c_enum_zip-data.
        gs_inst-source_type = 'DATA'.
        lv_xstr = iv_data.
      WHEN c_enum_zip-registry.
        gs_inst-source_type = 'REGISTRY'.
        lv_xstr = iv_data.
      WHEN OTHERS.
        zcx_abapinst_exception=>raise( |Unknown source for { gv_name }| ).
    ENDCASE.

    " Scan for viruses and unzip
    li_progress->show(
      iv_text    = 'Scanning package for viruses'
      iv_current = 10 ).

    zcl_abapinst_file=>virus_scan( lv_xstr ).

    li_progress->show(
      iv_text    = 'Unzipping files from package'
      iv_current = 20 ).

    IF iv_enum_zip = c_enum_zip-registry.
      DATA lx_error TYPE REF TO zcx_error.

      TRY.
          lo_tar = zcl_tar=>new( )->load( zcl_tar=>new( )->gunzip( lv_xstr ) ).
          lt_files = lo_tar->list( ).

          LOOP AT lt_files ASSIGNING <ls_file> WHERE typeflag = '0'.
            CLEAR ls_remote.
            IF <ls_file>-name CA '/'.
              FIND REGEX '(.*[\\/])?([^\\/]+)' IN <ls_file>-name
                SUBMATCHES ls_remote-path ls_remote-filename ##SUBRC_OK.
            ELSE.
              ls_remote-filename = <ls_file>-name.
            ENDIF.
            ls_remote-path = '/' && ls_remote-path.
            ls_remote-path = replace(
              val   = ls_remote-path
              sub   = '/package/'
              with  = '/' ). " packaged with npm
            ls_remote-data = lo_tar->get( <ls_file>-name ).
            TRY.
                ls_remote-sha1 = zcl_abapgit_hash=>sha1_raw( ls_remote-data ).
              CATCH zcx_abapgit_exception.
            ENDTRY.
            INSERT ls_remote INTO TABLE gt_remote.
          ENDLOOP.
        CATCH zcx_error INTO lx_error.
          zcx_abapinst_exception=>raise_with_text( lx_error ).
      ENDTRY.

    ELSE.
      gt_remote = zcl_abapinst_file=>unzip( lv_xstr ).
    ENDIF.

  ENDMETHOD.

  METHOD _final_message.

    DATA lv_msg TYPE string.

    CASE gs_inst-status.
      WHEN c_success.
        lv_msg = |{ iv_type } of "{ gs_inst-name }" successfully completed|.
        MESSAGE lv_msg TYPE c_success.
      WHEN c_warning.
        lv_msg = |{ iv_type } of "{ gs_inst-name }" finished with warnings|.
        MESSAGE lv_msg TYPE c_success DISPLAY LIKE c_warning.
      WHEN c_error.
        lv_msg = |{ iv_type } of "{ gs_inst-name }" finshed with errors|.
        MESSAGE lv_msg TYPE c_success DISPLAY LIKE c_error.
      WHEN OTHERS.
        ASSERT 1 = 2.
    ENDCASE.

  ENDMETHOD.

  METHOD _find_remote_data_config.

    FIELD-SYMBOLS: <ls_remote> LIKE LINE OF gt_remote.

    CREATE OBJECT ri_config TYPE zcl_abapgit_data_config.

    READ TABLE gt_remote ASSIGNING <ls_remote>
      WITH KEY path = zif_abapgit_data_config=>c_default_path ##PRIMKEY[FILE_PATH].
    IF sy-subrc = 0.
      ri_config->from_json( gt_remote ).
    ENDIF.

  ENDMETHOD.

  METHOD _find_remote_dot_abapgit.

    FIELD-SYMBOLS: <ls_remote> LIKE LINE OF it_remote.

    READ TABLE it_remote ASSIGNING <ls_remote> WITH TABLE KEY file_path COMPONENTS
      path     = zif_abapgit_definitions=>c_root_dir
      filename = zif_abapgit_definitions=>c_dot_abapgit.
    IF sy-subrc = 0.
      TRY.
          ro_dot = zcl_abapgit_dot_abapgit=>deserialize( <ls_remote>-data ).
        CATCH zcx_abapgit_exception.
          zcx_abapinst_exception=>raise( 'Error decoding .abapgit.xml' ).
      ENDTRY.
    ELSE.
      zcx_abapinst_exception=>raise( |Error finding .abapgit.xml - Is this an { gv_name }?| ).
    ENDIF.

  ENDMETHOD.

  METHOD _find_remote_dot_apack.

    FIELD-SYMBOLS: <ls_remote> LIKE LINE OF it_remote.

    READ TABLE it_remote ASSIGNING <ls_remote> WITH TABLE KEY file_path COMPONENTS
      path     = zif_abapgit_definitions=>c_root_dir
      filename = '.apack-manifest.xml'.
    IF sy-subrc = 0.
      zcx_abapinst_exception=>raise( |Please migrate APACK to { gv_name } setting| ).
    ENDIF.

  ENDMETHOD.

  METHOD _find_remote_namespaces.

    FIELD-SYMBOLS: <ls_remote> LIKE LINE OF gt_remote.

    LOOP AT gt_remote ASSIGNING <ls_remote> WHERE filename CP '*.nspc.xml'.
      INSERT <ls_remote> INTO TABLE rt_remote.
    ENDLOOP.

  ENDMETHOD.

  METHOD _folder_logic.

    CASE iv_enum_folder_logic.
      WHEN c_enum_folder_logic-default.
        gs_inst-folder_logic = go_dot->get_folder_logic( ).
      WHEN c_enum_folder_logic-prefix.
        gs_inst-folder_logic = zif_abapgit_dot_abapgit=>c_folder_logic-prefix.
      WHEN c_enum_folder_logic-mixed.
        gs_inst-folder_logic = zif_abapgit_dot_abapgit=>c_folder_logic-mixed.
      WHEN c_enum_folder_logic-full.
        gs_inst-folder_logic = zif_abapgit_dot_abapgit=>c_folder_logic-full.
      WHEN OTHERS.
        zcx_abapinst_exception=>raise( 'Unknown folder logic' ).
    ENDCASE.

  ENDMETHOD.

  METHOD _load.

    rs_inst = go_db->select(
      iv_name = iv_name
      iv_pack = iv_pack ).

  ENDMETHOD.

  METHOD _log_end.
    gs_inst-status = gi_log->get_status( ).
    IF gs_inst-status <> c_success.
      zcl_abapinst_log_viewer=>show_log( gi_log ).
    ENDIF.
  ENDMETHOD.

  METHOD _log_start.
    CREATE OBJECT gi_log TYPE zcl_abapgit_log.
    gi_log->set_title( |{ sy-title } Log| ).
  ENDMETHOD.

  METHOD _namespaces.

    DATA:
      lx_error  TYPE REF TO zcx_abapgit_exception,
      lt_remote TYPE zif_abapgit_git_definitions=>ty_files_tt.

    " Namespaces must be created upfront,
    " otherwise folder_logic->path_to_package will fail
    lt_remote = _find_remote_namespaces( ).

    IF lines( lt_remote ) > 0.
      TRY.
          zcl_abapinst_objects=>deserialize(
            iv_package   = gs_inst-pack
            iv_language  = gs_inst-installed_langu
            iv_transport = gs_inst-transport
            it_remote    = lt_remote
            io_dot       = go_dot
            ii_log       = gi_log ).

          COMMIT WORK.
        CATCH zcx_abapgit_exception INTO lx_error.
          zcx_abapinst_exception=>raise( lx_error->get_text( ) ).
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD _nothing_found.

    DATA lv_msg TYPE string.

    IF it_list IS INITIAL.
      lv_msg = |No { gv_names } found|.
      MESSAGE lv_msg TYPE c_success.
      rv_result = abap_true.
    ENDIF.

  ENDMETHOD.

  METHOD _packaging.

    DATA:
      lv_name  TYPE string,
      lo_popup TYPE REF TO zcl_abapinst_popups.

    go_dot = _find_remote_dot_abapgit( gt_remote ).

    " Check language
    gs_inst-installed_langu = go_dot->get_main_language( ).

    IF gs_inst-installed_langu <> sy-langu.
      zcx_abapinst_exception=>raise(
        |Unable to install. Logon in main language of package which is { gs_inst-installed_langu }| ).
    ENDIF.

    " Check requirements
    gt_requirements = go_dot->get_requirements( ).

    IF gs_apm IS NOT INITIAL.
      MOVE-CORRESPONDING gs_apm TO gs_inst.
      RETURN. ">>>>>
    ENDIF.

    TRY.
        gs_packaging = go_dot->get_packaging( ).
      CATCH zcx_abapgit_exception.
        CLEAR gs_packaging.
    ENDTRY.

    IF gs_packaging IS INITIAL.
      " Check if APACK file exists and ask migrate it abapGit settings
      _find_remote_dot_apack( gt_remote ).

      " Heuristic to get a name proposal
      TRY.
          lv_name = zcl_abapgit_url=>name( gs_inst-source_name ).
          IF lv_name CS 'URL error'.
            lv_name = gs_inst-source_name.
          ENDIF.
        CATCH zcx_abapgit_exception.
          lv_name = gs_inst-source_name.
      ENDTRY.
      REPLACE '.zip' IN lv_name WITH '' IGNORING CASE.
      REPLACE '.git' IN lv_name WITH '' IGNORING CASE.

      CREATE OBJECT lo_popup.
      gs_packaging = lo_popup->popup_to_enter_packaging(
                       iv_name    = lv_name
                       iv_version = '1.0.0' ).

      IF gs_packaging IS INITIAL.
        zcx_abapinst_exception=>raise( 'Unable to install without name and version details' ).
      ENDIF.
    ENDIF.

    MOVE-CORRESPONDING gs_packaging TO gs_inst.

  ENDMETHOD.

  METHOD _restore_messages.

    CONSTANTS lc_toolflag_reset TYPE funcname VALUE 'SCWG_TOOLFLAG_RESET'.

    " Reset tool flag
    TRY.
        CALL FUNCTION lc_toolflag_reset.
      CATCH cx_root ##NO_HANDLER.
    ENDTRY.

    DELETE FROM clmcus WHERE username = sy-uname ##SUBRC_OK.
    CHECK sy-subrc >= 0. "abaplint
    INSERT clmcus FROM TABLE gt_clmcus ##SUBRC_OK.
    CHECK sy-subrc >= 0. "abaplint

  ENDMETHOD.

  METHOD _sap_package.

    CASE iv_enum_package.
      WHEN c_enum_package-default.
        gs_inst-pack = gs_packaging-target_package.
      WHEN c_enum_package-local.
        IF iv_package(1) <> '$'.
          zcx_abapinst_exception=>raise( 'Local package must begin with $' ).
        ENDIF.
        gs_inst-pack = iv_package.
      WHEN c_enum_package-transportable.
        IF iv_package(1) = '$'.
          zcx_abapinst_exception=>raise( 'Transportable package must not begin with $' ).
        ENDIF.
        gs_inst-pack = iv_package.
      WHEN OTHERS.
        zcx_abapinst_exception=>raise( 'Unknown type of target package' ).
    ENDCASE.

  ENDMETHOD.

  METHOD _save.

    DATA:
      ls_inst      TYPE zif_abapinst_definitions=>ty_inst,
      lv_timestamp TYPE timestamp.

    GET TIME STAMP FIELD lv_timestamp.

    ls_inst = _load(
      iv_name = gs_inst-name
      iv_pack = gs_inst-pack ).

    IF ls_inst IS INITIAL.
      ls_inst-name            = gs_inst-name.
      ls_inst-pack            = gs_inst-pack.
      ls_inst-version         = gs_inst-version.
      ls_inst-sem_version     = gs_inst-sem_version.
      ls_inst-description     = gs_inst-description.
      ls_inst-source_type     = gs_inst-source_type.
      ls_inst-source_name     = gs_inst-source_name.
      ls_inst-transport       = gs_inst-transport.
      ls_inst-folder_logic    = gs_inst-folder_logic.
      ls_inst-installed_langu = gs_inst-installed_langu.
      ls_inst-installed_by    = sy-uname.
      ls_inst-installed_at    = lv_timestamp.
      ls_inst-status          = gs_inst-status.

      go_db->insert( ls_inst ).
    ELSE.
      ls_inst-version         = gs_inst-version.
      ls_inst-sem_version     = gs_inst-sem_version.
      ls_inst-description     = gs_inst-description.
      ls_inst-source_type     = gs_inst-source_type.
      ls_inst-source_name     = gs_inst-source_name.
      ls_inst-transport       = gs_inst-transport.
      ls_inst-folder_logic    = gs_inst-folder_logic.
      ls_inst-installed_langu = gs_inst-installed_langu.
      ls_inst-updated_by      = sy-uname.
      ls_inst-updated_at      = lv_timestamp.
      ls_inst-status          = gs_inst-status.

      go_db->update( ls_inst ).
    ENDIF.

  ENDMETHOD.

  METHOD _system_check.

    DATA:
      lv_systemedit         TYPE tadir-edtflag,
      lv_sys_cliinddep_edit TYPE t000-ccnocliind,
      lv_msg                TYPE string.

    CALL FUNCTION 'TR_SYS_PARAMS'
      IMPORTING
        systemedit         = lv_systemedit
        sys_cliinddep_edit = lv_sys_cliinddep_edit
      EXCEPTIONS
        no_systemname      = 1
        no_systemtype      = 2
        OTHERS             = 3.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise_t100( ).
    ENDIF.

    IF lv_systemedit = 'N'.
      MESSAGE e102(tk) INTO lv_msg.
      zcx_abapinst_exception=>raise_t100( ).
    ENDIF.
    IF lv_sys_cliinddep_edit CA '23'.
      MESSAGE e729(tk) INTO lv_msg.
      zcx_abapinst_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.

  METHOD _transport.

    CHECK gs_inst-pack(1) <> '$'.

    CASE iv_enum_transport.
      WHEN c_enum_transport-existing.
        gs_inst-transport = iv_transport.
      WHEN c_enum_transport-prompt.
        gs_inst-transport = zcl_abapinst_screen=>f4_transport(
          iv_package   = gs_inst-pack
          iv_transport = _transport_get( ) ).

        IF gs_inst-transport IS INITIAL.
          zcx_abapinst_exception=>raise( 'No transport selected. Installation cancelled' ).
        ENDIF.
    ENDCASE.

    _transport_check( ).

  ENDMETHOD.

  METHOD _transport_check.

    DATA:
      lv_text            TYPE as4text,
      ls_request_header  TYPE trwbo_request_header,
      lt_request_headers TYPE trwbo_request_headers.

    CHECK gs_inst-pack(1) <> '$'.

    lv_text = gs_inst-name && ':' && gs_inst-description.

    CALL FUNCTION 'TR_READ_REQUEST_WITH_TASKS'
      EXPORTING
        iv_trkorr          = gs_inst-transport
      IMPORTING
        et_request_headers = lt_request_headers
      EXCEPTIONS
        invalid_input      = 1
        OTHERS             = 2.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise_t100( ).
    ENDIF.

    " Request Type: Workbench
    READ TABLE lt_request_headers INTO ls_request_header
      WITH KEY trfunction = 'K' trstatus = 'D' korrdev = 'SYST'.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( |Transport { gs_inst-transport } is not a changeable "workbench request"| ).
    ENDIF.

    " Task Type: Unclassified (ok)
    READ TABLE lt_request_headers TRANSPORTING NO FIELDS
      WITH KEY trfunction = 'X' trstatus = 'D' korrdev = 'SYST'.
    IF sy-subrc = 0.
      RETURN.
    ENDIF.

    " Task Type: Development
    READ TABLE lt_request_headers TRANSPORTING NO FIELDS
      WITH KEY trfunction = 'S' trstatus = 'D' korrdev = 'SYST'.
    IF sy-subrc <> 0.
      CALL FUNCTION 'TRINT_INSERT_NEW_COMM'
        EXPORTING
          wi_kurztext   = lv_text
          wi_trfunction = 'S'
          wi_strkorr    = ls_request_header-trkorr
        EXCEPTIONS
          OTHERS        = 1.
      IF sy-subrc <> 0.
        zcx_abapinst_exception=>raise_t100( ).
      ENDIF.
    ENDIF.

    " Task Type: Repair (for namespaced projects)
    IF gs_inst-pack(1) = '/'.
      READ TABLE lt_request_headers TRANSPORTING NO FIELDS
        WITH KEY trfunction = 'R' trstatus = 'D' korrdev = 'SYST'.
      IF sy-subrc <> 0.
        CALL FUNCTION 'TRINT_INSERT_NEW_COMM'
          EXPORTING
            wi_kurztext   = lv_text
            wi_trfunction = 'R'
            wi_strkorr    = ls_request_header-trkorr
          EXCEPTIONS
            OTHERS        = 1.
        IF sy-subrc <> 0.
          zcx_abapinst_exception=>raise_t100( ).
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD _transport_get.

    DATA ls_request TYPE trwbo_request.

    " Get previously used transport
    rv_trkorr = go_db->select( iv_name = gs_inst-name
                               iv_pack = gs_inst-pack )-transport.

    IF rv_trkorr IS INITIAL.
      " Or last used transport
      rv_trkorr = go_db->last( )-transport.
    ENDIF.

    IF rv_trkorr IS NOT INITIAL.
      " Check if transport is still open
      CALL FUNCTION 'TR_READ_REQUEST'
        EXPORTING
          iv_read_attributes = 'X'
          iv_trkorr          = rv_trkorr
        CHANGING
          cs_request         = ls_request
        EXCEPTIONS
          error_occured      = 1
          no_authorization   = 2
          OTHERS             = 3.
      IF sy-subrc = 0 AND ls_request-h-trstatus = 'D'.
        RETURN.
      ENDIF.
    ENDIF.

    " Get default transport
    TRY.
        rv_trkorr = zcl_abapinst_factory=>get_default_transport( )->get( )-ordernum.
      CATCH zcx_abapgit_exception ##NO_HANDLER.
    ENDTRY.

  ENDMETHOD.

  METHOD _transport_reset.

    TRY.
        zcl_abapinst_factory=>get_default_transport( )->reset( ).
      CATCH zcx_abapgit_exception ##NO_HANDLER.
    ENDTRY.

  ENDMETHOD.

  METHOD _uninstall_sotr.

    " Necessary since older releases do not delete SOTR when package is deleted

    DATA:
      lv_use_korr  TYPE abap_bool,
      lt_sotr_head TYPE STANDARD TABLE OF sotr_head WITH DEFAULT KEY.

    FIELD-SYMBOLS:
      <ls_tadir>     LIKE LINE OF it_tadir,
      <ls_sotr_head> LIKE LINE OF lt_sotr_head.

    lv_use_korr = boolc( gs_inst-transport IS NOT INITIAL ).

    LOOP AT it_tadir ASSIGNING <ls_tadir> WHERE object = 'DEVC'.

      SELECT * FROM sotr_head INTO TABLE lt_sotr_head
        WHERE paket = <ls_tadir>-obj_name.
      IF sy-subrc = 0.

        LOOP AT lt_sotr_head ASSIGNING <ls_sotr_head>.
          DELETE FROM sotr_use WHERE concept = <ls_sotr_head>-concept.

          CALL FUNCTION 'BTFR_DELETE_SINGLE_TEXT'
            EXPORTING
              concept                  = <ls_sotr_head>-concept
              corr_num                 = gs_inst-transport
              use_korrnum_immediatedly = lv_use_korr
              flag_string              = abap_false
            EXCEPTIONS
              text_not_found           = 1
              invalid_package          = 2
              text_not_changeable      = 3
              text_enqueued            = 4
              no_correction            = 5
              parameter_error          = 6
              OTHERS                   = 7.
          IF sy-subrc <> 0.
            CONTINUE.
          ENDIF.
        ENDLOOP.

      ENDIF.

      CALL FUNCTION 'TR_TADIR_INTERFACE'
        EXPORTING
          wi_test_modus         = abap_false
          wi_delete_tadir_entry = abap_true
          wi_tadir_pgmid        = 'R3TR'
          wi_tadir_object       = 'SOTR'
          wi_tadir_obj_name     = <ls_tadir>-obj_name
        EXCEPTIONS
          OTHERS                = 1.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD _uninstall_sots.

    " Necessary since older releases do not delete SOTS when package is deleted

    DATA:
      lv_use_korr  TYPE abap_bool,
      lt_sotr_head TYPE STANDARD TABLE OF sotr_headu WITH DEFAULT KEY.

    FIELD-SYMBOLS:
      <ls_tadir>     LIKE LINE OF it_tadir,
      <ls_sotr_head> LIKE LINE OF lt_sotr_head.

    lv_use_korr = boolc( gs_inst-transport IS NOT INITIAL ).

    LOOP AT it_tadir ASSIGNING <ls_tadir> WHERE object = 'DEVC'.

      SELECT * FROM sotr_headu INTO TABLE lt_sotr_head
        WHERE paket = <ls_tadir>-obj_name.
      IF sy-subrc = 0.

        LOOP AT lt_sotr_head ASSIGNING <ls_sotr_head>.
          DELETE FROM sotr_useu WHERE concept = <ls_sotr_head>-concept.

          CALL FUNCTION 'BTFR_DELETE_SINGLE_TEXT'
            EXPORTING
              concept                  = <ls_sotr_head>-concept
              corr_num                 = gs_inst-transport
              use_korrnum_immediatedly = lv_use_korr
              flag_string              = abap_true
            EXCEPTIONS
              text_not_found           = 1
              invalid_package          = 2
              text_not_changeable      = 3
              text_enqueued            = 4
              no_correction            = 5
              parameter_error          = 6
              OTHERS                   = 7.
          IF sy-subrc <> 0.
            CONTINUE.
          ENDIF.
        ENDLOOP.

      ENDIF.

      CALL FUNCTION 'TR_TADIR_INTERFACE'
        EXPORTING
          wi_test_modus         = abap_false
          wi_delete_tadir_entry = abap_true
          wi_tadir_pgmid        = 'R3TR'
          wi_tadir_object       = 'SOTS'
          wi_tadir_obj_name     = <ls_tadir>-obj_name
        EXCEPTIONS
          OTHERS                = 1.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapinst_log_viewer IMPLEMENTATION.

  METHOD calculate_cell_type.

    FIELD-SYMBOLS: <ls_log> LIKE LINE OF gt_log.
    DATA: ls_cell_type LIKE LINE OF <ls_log>-cell_type.

    LOOP AT gt_log ASSIGNING <ls_log>.

      IF <ls_log>-longtext IS NOT INITIAL.
        ls_cell_type-columnname = `LONGTEXT`.
        ls_cell_type-value      = if_salv_c_cell_type=>hotspot.
        INSERT ls_cell_type INTO TABLE <ls_log>-cell_type.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD dispatch.

*** abapinst
    IF iv_column = `LONGTEXT`.

      show_longtext( is_log ).

    ENDIF.

  ENDMETHOD.

  METHOD on_link_click.

    DATA: lx_error TYPE REF TO zcx_abapgit_exception.
    FIELD-SYMBOLS: <ls_log> TYPE ty_log_out.

    IF row IS INITIAL
    OR column IS INITIAL.
      RETURN.
    ENDIF.

    READ TABLE gt_log ASSIGNING <ls_log>
                      INDEX row.
    ASSERT sy-subrc = 0.

    TRY.
        dispatch(
            is_log    = <ls_log>
            iv_column = column ).

      CATCH zcx_abapgit_exception INTO lx_error.
        MESSAGE lx_error TYPE 'S' DISPLAY LIKE 'E'.
    ENDTRY.

  ENDMETHOD.

  METHOD prepare_log_for_display.

    DATA: lt_message      TYPE zif_abapgit_log=>ty_log_outs,
          lr_message      TYPE REF TO zif_abapgit_log=>ty_log_out,
          ls_log          TYPE ty_log_out,
          li_t100_message TYPE REF TO if_t100_message,
          lx_abapgit      TYPE REF TO zcx_abapgit_exception.

    lt_message = ii_log->get_messages( ).

    LOOP AT lt_message REFERENCE INTO lr_message.

      CLEAR: ls_log.

      ls_log-msg = lr_message->text.
      ls_log-exception = lr_message->exception.

      CASE lr_message->type.
        WHEN 'E' OR 'A' OR 'X'.
          ls_log-type = icon_led_red.
        WHEN 'W'.
          ls_log-type = icon_led_yellow.
        WHEN 'I' OR 'S'.
          ls_log-type = icon_led_green.
        WHEN OTHERS.
          ls_log-type = icon_led_inactive.
      ENDCASE.

      IF lr_message->exception IS BOUND.

        TRY.
            li_t100_message ?= lr_message->exception.

            IF li_t100_message->t100key IS NOT INITIAL.
              ls_log-t100 = icon_message_information.
            ENDIF.

          CATCH cx_sy_move_cast_error ##NO_HANDLER.
        ENDTRY.

        TRY.
            lx_abapgit ?= lr_message->exception.

            IF lx_abapgit->mt_callstack IS NOT INITIAL.
              ls_log-longtext  = icon_system_help.
              ls_log-callstack = icon_stack.
              ls_log-source    = icon_abap.
            ENDIF.

          CATCH cx_sy_move_cast_error ##NO_HANDLER.
        ENDTRY.

      ENDIF.

      ls_log-obj_type = lr_message->obj_type.
      ls_log-obj_name = lr_message->obj_name.

      INSERT ls_log INTO TABLE rt_log_out.

    ENDLOOP.

  ENDMETHOD.

  METHOD show_log.

    DATA: lr_log         TYPE REF TO ty_log_out,
          lo_alv         TYPE REF TO cl_salv_table,
          lx_error       TYPE REF TO cx_salv_error,
          lo_form_header TYPE REF TO cl_salv_form_header_info,
          lo_columns     TYPE REF TO cl_salv_columns_table,
          lo_column      TYPE REF TO cl_salv_column,
          lo_functions   TYPE REF TO cl_salv_functions_list,
          lv_add_obj_col TYPE abap_bool,
          lo_event       TYPE REF TO cl_salv_events_table.

    gt_log = prepare_log_for_display( ii_log ).

    "check if log contains any object info
    LOOP AT gt_log REFERENCE INTO lr_log.
      IF lr_log->obj_type IS NOT INITIAL OR lr_log->obj_name IS NOT INITIAL.
        lv_add_obj_col = abap_true.
      ENDIF.
    ENDLOOP.

    TRY.
        cl_salv_table=>factory(
          IMPORTING
            r_salv_table = lo_alv
          CHANGING
            t_table      = gt_log ).

        lo_functions = lo_alv->get_functions( ).
        lo_functions->set_all( ).

        lo_columns = lo_alv->get_columns( ).

        lo_columns->set_optimize( ).
        lo_columns->set_cell_type_column( |CELL_TYPE| ).

        calculate_cell_type( ).

        lo_column = lo_columns->get_column( |TYPE| ).
        lo_column->set_medium_text( |Type| ).

        lo_column = lo_columns->get_column( |MSG| ).
        lo_column->set_medium_text( |Message| ).

        lo_column = lo_columns->get_column( |LONGTEXT| ).
        lo_column->set_medium_text( |Longtext| ).

        lo_column = lo_columns->get_column( |OBJ_TYPE| ).
        lo_column->set_medium_text( |Object Type| ).

        IF lv_add_obj_col = abap_false.
          lo_column->set_technical( abap_true ).
        ENDIF.

        lo_column = lo_columns->get_column( |OBJ_NAME| ).
        lo_column->set_medium_text( |Object Name| ).

        IF lv_add_obj_col = abap_false.
          lo_column->set_technical( abap_true ).
        ENDIF.

        lo_alv->set_screen_popup( start_column = 10
                                  end_column   = 180
                                  start_line   = 4
                                  end_line     = 25 ).

        CREATE OBJECT lo_form_header
          EXPORTING
            text = ii_log->get_title( ).

        lo_alv->set_top_of_list( lo_form_header ).

        lo_event = lo_alv->get_event( ).

        SET HANDLER on_link_click FOR lo_event.

        lo_alv->display( ).

      CATCH cx_salv_error INTO lx_error.
        MESSAGE lx_error TYPE 'S' DISPLAY LIKE 'E'.
    ENDTRY.

  ENDMETHOD.

  METHOD show_longtext.

    DATA: lx_abapgit TYPE REF TO zcx_abapgit_exception.

    DATA: lv_docu_object TYPE dokhl-object,
          lt_dummy1      TYPE TABLE OF dselc,
          lt_dummy2      TYPE TABLE OF dval,
          ls_help_info   TYPE help_info.

    IF is_log-exception IS NOT BOUND.
      RETURN.
    ENDIF.

    TRY.
        lx_abapgit ?= is_log-exception.
      CATCH cx_sy_move_cast_error.
        RETURN.
    ENDTRY.

    lv_docu_object   = lx_abapgit->if_t100_message~t100key-msgid.
    lv_docu_object+2 = lx_abapgit->if_t100_message~t100key-msgno.

    ls_help_info-call       = 'D'.
    ls_help_info-spras      = sy-langu.
    ls_help_info-messageid  = lx_abapgit->if_t100_message~t100key-msgid.
    ls_help_info-messagenr  = lx_abapgit->if_t100_message~t100key-msgno.
    ls_help_info-message    = is_log-msg.
    ls_help_info-title      = 'Longtext'.
    ls_help_info-docuid     = 'NA'.
    ls_help_info-docuobject = lv_docu_object.
    ls_help_info-msgv1      = lx_abapgit->msgv1.
    ls_help_info-msgv2      = lx_abapgit->msgv2.
    ls_help_info-msgv3      = lx_abapgit->msgv3.
    ls_help_info-msgv4      = lx_abapgit->msgv4.

    CALL FUNCTION 'HELP_START'
      EXPORTING
        help_infos   = ls_help_info
      TABLES
        dynpselect   = lt_dummy1
        dynpvaluetab = lt_dummy2
      EXCEPTIONS
        OTHERS       = 1.

    IF sy-subrc IS NOT INITIAL.
      zcx_abapgit_exception=>raise_t100( ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapinst_objects IMPLEMENTATION.

  METHOD change_package_assignments.

    CALL FUNCTION 'TR_TADIR_INTERFACE'
      EXPORTING
        wi_tadir_pgmid    = 'R3TR'
        wi_tadir_object   = is_item-obj_type
        wi_tadir_obj_name = is_item-obj_name
        wi_tadir_devclass = is_item-devclass
        wi_test_modus     = abap_false
      EXCEPTIONS
        OTHERS            = 1.
    IF sy-subrc = 0.
      ii_log->add_success( iv_msg  = |Object { is_item-obj_name } assigned to package { is_item-devclass }|
                           is_item = is_item ).
    ELSE.
      ii_log->add_error( iv_msg  = |Package change of object { is_item-obj_name } failed|
                         is_item = is_item ).
    ENDIF.

  ENDMETHOD.

  METHOD check_main_package.

    " check package restrictions, closed package, descriptive or
    " functional package
    cl_pak_object_types=>check_object_type(
      EXPORTING
        i_working_mode         = 'I'
        i_package_name         = iv_package
        i_pgmid                = 'R3TR'
        i_object_type          = iv_obj_type
      EXCEPTIONS
        wrong_object_type      = 1
        package_not_extensible = 2
        package_not_loaded     = 3
        OTHERS                 = 4 ).
    CASE sy-subrc.
      WHEN 0.
        RETURN.
      WHEN 2.
        zcx_abapgit_exception=>raise( |Object type { iv_obj_type } not allowed for package { iv_package }| ).
      WHEN OTHERS.
        zcx_abapgit_exception=>raise_t100( ).
    ENDCASE.

  ENDMETHOD.

  METHOD check_objects_locked.

    DATA: li_obj TYPE REF TO zif_abapgit_object.

    FIELD-SYMBOLS: <ls_item> LIKE LINE OF it_items.

    LOOP AT it_items ASSIGNING <ls_item>.

      " You should remember that we ignore not supported objects here,
      " because otherwise the process aborts which is not desired
      IF is_type_supported( <ls_item>-obj_type ) = abap_false.
        CONTINUE.
      ENDIF.

      li_obj = create_object( <ls_item> ).

      IF li_obj->is_locked( ) = abap_true.
        zcx_abapgit_exception=>raise( |Object { <ls_item>-obj_type } { <ls_item>-obj_name } |
                                   && |is locked. Action not possible.| ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD class_name.

    CONCATENATE 'ZCL_ABAPGIT_OBJECT_' is_item-obj_type INTO rv_class_name.

  ENDMETHOD.

  METHOD compare_remote_to_local.
* this method is used for comparing local with remote objects
* before pull, this is useful eg. when overwriting a TABL object.
* only the main XML file is used for comparison

    DATA: ls_remote_file    TYPE zif_abapgit_git_definitions=>ty_file,
          li_remote_version TYPE REF TO zif_abapgit_xml_input,
          lv_count          TYPE i,
          ls_result         TYPE zif_abapgit_comparator=>ty_result,
          lv_answer         TYPE string,
          li_comparator     TYPE REF TO zif_abapgit_comparator,
          ls_item           TYPE zif_abapgit_definitions=>ty_item.

    FIND ALL OCCURRENCES OF '.' IN is_result-filename MATCH COUNT lv_count.

    IF is_result-filename CS '.XML' AND lv_count = 2.
      IF ii_object->exists( ) = abap_false.
        RETURN.
      ENDIF.

      READ TABLE it_remote WITH KEY file
        COMPONENTS filename = is_result-filename INTO ls_remote_file.
      IF sy-subrc <> 0. "if file does not exist in remote, we don't need to validate
        RETURN.
      ENDIF.

      li_comparator = ii_object->get_comparator( ).
      IF li_comparator IS NOT BOUND.
        RETURN.
      ENDIF.

      CREATE OBJECT li_remote_version
        TYPE zcl_abapgit_xml_input
        EXPORTING
          iv_xml      = zcl_abapgit_convert=>xstring_to_string_utf8( ls_remote_file-data )
          iv_filename = ls_remote_file-filename.

      ls_result = li_comparator->compare( ii_remote = li_remote_version
                                          ii_log = ii_log ).
      IF ls_result-text IS INITIAL.
        RETURN.
      ENDIF.

      "log comparison result
      ls_item-obj_type = is_result-obj_type.
      ls_item-obj_name = is_result-obj_name.
      ii_log->add_warning( iv_msg = ls_result-text
                           is_item = ls_item ).

      "continue or abort?
      IF zcl_abapinst_factory=>get_frontend_services( )->gui_is_available( ) = abap_true.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar              = 'Warning'
            text_question         = ls_result-text
            text_button_1         = 'Abort'
            icon_button_1         = 'ICON_CANCEL'
            text_button_2         = 'Pull anyway'
            icon_button_2         = 'ICON_OKAY'
            default_button        = '2'
            display_cancel_button = abap_false
          IMPORTING
            answer                = lv_answer
          EXCEPTIONS
            text_not_found        = 1
            OTHERS                = 2.
        IF sy-subrc <> 0 OR lv_answer = 1.
          zcx_abapgit_exception=>raise( |Deserialization for object { is_result-obj_name } | &
                                        |(type { is_result-obj_type }) aborted by user| ).
        ENDIF.
      ELSE.
        zcx_abapgit_exception=>raise( |Deserialization for object { is_result-obj_name } | &
                                      |(type { is_result-obj_type }) aborted, user descision required| ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD create_object.

    DATA: lv_message            TYPE string,
          lv_class_name         TYPE string,
          ls_obj_serializer_map LIKE LINE OF gt_obj_serializer_map.

    " serialize & deserialize require files and i18n parameters,
    " other calls are good without them
    ASSERT io_files IS BOUND AND io_i18n_params IS BOUND OR
           io_files IS NOT BOUND AND io_i18n_params IS NOT BOUND.

    READ TABLE gt_obj_serializer_map
      INTO ls_obj_serializer_map WITH KEY item = is_item.
    IF sy-subrc = 0.
      lv_class_name = ls_obj_serializer_map-metadata-class.
    ELSEIF is_metadata IS NOT INITIAL.
*        Metadata is provided only on deserialization
*        Once this has been triggered, the same deserializer shall be used
*        for subsequent processes.
*        Thus, buffer the metadata afterwards
      ls_obj_serializer_map-item      = is_item.
      ls_obj_serializer_map-metadata  = is_metadata.
      INSERT ls_obj_serializer_map INTO TABLE gt_obj_serializer_map.
      lv_class_name = is_metadata-class.
    ELSE.
      lv_class_name = class_name( is_item ).
    ENDIF.

    REPLACE FIRST OCCURRENCE OF 'LCL' IN lv_class_name WITH 'ZCL_ABAPGIT'.

    IF zcl_abapinst_factory=>get_environment( )->is_merged( ) = abap_true.
      " Prevent accidental usage of object handlers in the developer version
      lv_class_name = |\\PROGRAM={ sy-repid }\\CLASS={ lv_class_name }|.
    ENDIF.

    TRY.
        IF io_files IS BOUND AND io_i18n_params IS BOUND.
          CREATE OBJECT ri_obj TYPE (lv_class_name)
            EXPORTING
              is_item        = is_item
              iv_language    = io_i18n_params->ms_params-main_language
              io_files       = io_files
              io_i18n_params = io_i18n_params.
        ELSE.
          CREATE OBJECT ri_obj TYPE (lv_class_name)
            EXPORTING
              is_item     = is_item
              iv_language = zif_abapgit_definitions=>c_english.
        ENDIF.
      CATCH cx_sy_create_object_error.
        lv_message = |Object type { is_item-obj_type } is not supported by this system|.
        IF iv_native_only = abap_false.
          TRY. " 2nd step, try looking for plugins
              IF io_files IS BOUND AND io_i18n_params IS BOUND.
                CREATE OBJECT ri_obj TYPE zcl_abapgit_objects_bridge
                  EXPORTING
                    is_item        = is_item
                    io_files       = io_files
                    io_i18n_params = io_i18n_params.
              ELSE.
                CREATE OBJECT ri_obj TYPE zcl_abapgit_objects_bridge
                  EXPORTING
                    is_item = is_item.
              ENDIF.
            CATCH cx_sy_create_object_error.
              zcx_abapgit_exception=>raise( lv_message ).
          ENDTRY.
        ELSE. " No native support? -> fail
          zcx_abapgit_exception=>raise( lv_message ).
        ENDIF.
    ENDTRY.

  ENDMETHOD.

  METHOD delete.

    DATA: ls_item     TYPE zif_abapgit_definitions=>ty_item,
          li_progress TYPE REF TO zif_abapgit_progress,
          lt_tadir    LIKE it_tadir,
          lt_deleted  LIKE it_tadir,
          lt_items    TYPE zif_abapgit_definitions=>ty_items_tt,
          lx_error    TYPE REF TO zcx_abapgit_exception,
          lv_count    TYPE i.

    FIELD-SYMBOLS: <ls_tadir> LIKE LINE OF it_tadir.

    IF it_tadir IS INITIAL.
      RETURN.
    ENDIF.

    lt_tadir = it_tadir.

    IF ii_log IS BOUND.
      IF lines( lt_tadir ) = 1.
        ii_log->add_info( |>>> Deleting 1 object| ).
      ELSE.
        ii_log->add_info( |>>> Deleting { lines( lt_tadir ) } objects| ).
      ENDIF.
    ENDIF.

    IF iv_transport IS NOT INITIAL.
      zcl_abapinst_factory=>get_default_transport( )->set( iv_transport ).
    ENDIF.

    TRY.
        zcl_abapgit_dependencies=>resolve( CHANGING ct_tadir = lt_tadir ).

        li_progress = zcl_abapgit_progress=>get_instance( lines( lt_tadir ) ).

        lt_items = map_tadir_to_items( lt_tadir ).

        check_objects_locked( lt_items ).

      CATCH zcx_abapgit_exception INTO lx_error.
        zcl_abapinst_factory=>get_default_transport( )->reset( ).
        RAISE EXCEPTION lx_error.
    ENDTRY.

    lv_count = 1.
    DO.
      CLEAR lt_deleted.
      LOOP AT lt_tadir ASSIGNING <ls_tadir>.
        li_progress->show( iv_current = lv_count
                           iv_text    = |Delete { <ls_tadir>-obj_name }| ).

        CLEAR ls_item.
        ls_item-obj_type = <ls_tadir>-object.
        ls_item-obj_name = <ls_tadir>-obj_name.

        TRY.
            delete_object(
              iv_package   = <ls_tadir>-devclass
              is_item      = ls_item
              iv_transport = iv_transport ).

            INSERT <ls_tadir> INTO TABLE lt_deleted.
            DELETE lt_tadir.
            lv_count = lv_count + 1.

            " make sure to save object deletions
            COMMIT WORK.

            IF ii_log IS BOUND.
              ii_log->add_info( iv_msg  = |Object { ls_item-obj_type } { ls_item-obj_name } deleted|
                                is_item = ls_item ).
            ENDIF.

          CATCH zcx_abapgit_exception INTO lx_error.
            IF ii_log IS BOUND.
              ii_log->add_exception( ix_exc  = lx_error
                                     is_item = ls_item ).
              ii_log->add_error( iv_msg = |Deletion of object { ls_item-obj_name } failed|
                                 is_item = ls_item ).
            ENDIF.
        ENDTRY.

      ENDLOOP.

      " Exit if done or nothing else was deleted
      IF lines( lt_tadir ) = 0 OR lines( lt_deleted ) = 0.
        EXIT.
      ENDIF.
    ENDDO.

    zcl_abapinst_factory=>get_default_transport( )->reset( ).

    IF lx_error IS BOUND AND lines( lt_tadir ) > 0.
      zcx_abapgit_exception=>raise( 'Error during uninstall. Check the log.' ).
    ENDIF.

    li_progress->off( ).

  ENDMETHOD.

  METHOD delete_object.

    DATA: li_obj TYPE REF TO zif_abapgit_object.

    " Nothing to do for unsupported objects
    IF is_type_supported( is_item-obj_type ) = abap_false.
      RETURN.
    ENDIF.

    li_obj = create_object( is_item ).
    li_obj->delete( iv_package   = iv_package
                    iv_transport = iv_transport ).

  ENDMETHOD.

  METHOD deserialize.

    DATA: ls_item     TYPE zif_abapgit_definitions=>ty_item,
          li_obj      TYPE REF TO zif_abapgit_object,
          lv_package  TYPE devclass,
          lo_files    TYPE REF TO zcl_abapgit_objects_files,
          ls_metadata TYPE zif_abapgit_definitions=>ty_metadata,
          lo_xml      TYPE REF TO zif_abapgit_xml_input,
          lt_results  TYPE zif_abapgit_definitions=>ty_results_tt,
          li_progress TYPE REF TO zif_abapgit_progress,
          lv_path     TYPE string,
          lt_items    TYPE zif_abapgit_definitions=>ty_items_tt,
          lt_steps_id TYPE zif_abapgit_objects=>ty_deserialization_step_tt,
          lt_steps    TYPE zif_abapgit_objects=>ty_step_data_tt,
          lx_exc      TYPE REF TO zcx_abapgit_exception.
    DATA lo_folder_logic TYPE REF TO zcl_abapgit_folder_logic.
    DATA lo_i18n_params TYPE REF TO zcl_abapgit_i18n_params.
    DATA lo_timer TYPE REF TO zcl_abapgit_timer.
    DATA lo_abap_language_vers TYPE REF TO zcl_abapgit_abap_language_vers.

    FIELD-SYMBOLS: <ls_result>  TYPE zif_abapgit_definitions=>ty_result,
                   <lv_step_id> TYPE LINE OF zif_abapgit_objects=>ty_deserialization_step_tt,
                   <ls_step>    TYPE LINE OF zif_abapgit_objects=>ty_step_data_tt,
                   <ls_deser>   TYPE LINE OF zif_abapgit_objects=>ty_deserialization_tt.

    lt_steps = get_deserialize_steps( ).

    IF iv_transport IS NOT INITIAL.
      zcl_abapinst_factory=>get_default_transport( )->set( iv_transport ).
    ENDIF.

    zcl_abapgit_objects_activation=>clear( ).

    lt_results = files_to_deserialize(
      iv_package         = iv_package
      it_local           = it_local
      it_local_checksums = it_local_checksums
      it_remote          = it_remote
      io_dot             = io_dot
      ii_log             = ii_log ).

    IF lt_results IS INITIAL.
      RETURN.
    ENDIF.

    li_progress = zcl_abapgit_progress=>get_instance( lines( lt_results ) ).

    lt_items = map_results_to_items( lt_results ).

    lo_timer = zcl_abapgit_timer=>create(
      iv_text  = 'Deserialize:'
      iv_count = lines( lt_items ) )->start( ).

    zcl_abapinst_factory=>get_cts_api( )->confirm_transport_messages( ).

    check_objects_locked( lt_items ).

    lo_i18n_params = zcl_abapgit_i18n_params=>new( is_params = determine_i18n_params(
      io_dot                = io_dot
      iv_main_language_only = abap_false ) ). "io_repo->get_local_settings( )-main_language_only

    IF lines( lt_items ) = 1.
      ii_log->add_info( |>>> Deserializing 1 object| ).
    ELSE.
      ii_log->add_info( |>>> Deserializing { lines( lt_items ) } objects| ).
    ENDIF.

    CREATE OBJECT lo_abap_language_vers
      EXPORTING
        io_dot_abapgit = io_dot.

    lo_folder_logic = zcl_abapgit_folder_logic=>get_instance( ).
    LOOP AT lt_results ASSIGNING <ls_result>.
      li_progress->show( iv_current = sy-tabix
                         iv_text    = |Prepare Deserialize: { <ls_result>-obj_type } { <ls_result>-obj_name }| ).

      CLEAR ls_item.
      CLEAR: lv_path, lv_package.

      ls_item-obj_type = <ls_result>-obj_type.
      ls_item-obj_name = <ls_result>-obj_name.

      "error handling & logging added
      TRY.
          IF ls_item-obj_type <> 'NSPC'.
            " If package does not exist yet, it will be created with this call
            lv_package = lo_folder_logic->path_to_package(
              iv_top  = iv_package
              io_dot  = io_dot
              iv_path = <ls_result>-path ).

            check_main_package(
              iv_package  = lv_package
              iv_obj_type = ls_item-obj_type ).
          ENDIF.

          IF ls_item-obj_type = 'DEVC'.
            " Packages have the same filename across different folders. The path needs to be supplied
            " to find the correct file.
            lv_path = <ls_result>-path.
          ENDIF.

          ls_item-devclass = lv_package.
          ls_item-abap_language_version = lo_abap_language_vers->get_abap_language_vers_by_objt(
                                                                    iv_object_type = ls_item-obj_type
                                                                    iv_package = lv_package ).

          IF <ls_result>-packmove = abap_true.
            " Move object to new package
            change_package_assignments( is_item = ls_item
                                        ii_log  = ii_log ).
            " No other changes required
            CONTINUE.
          ENDIF.

          " Create or update object
          lo_files = zcl_abapgit_objects_files=>new(
            is_item = ls_item
            iv_path = lv_path ).

          lo_files->set_files( it_remote ).

          IF lo_files->is_json_metadata( ) = abap_false.
            "analyze XML in order to instantiate the proper serializer
            lo_xml = lo_files->read_xml( ).
            ls_metadata = lo_xml->get_metadata( ).
          ELSE.
            " there's no XML and metadata for JSON format
            CLEAR: lo_xml, ls_metadata.
          ENDIF.

          li_obj = create_object(
            is_item        = ls_item
            is_metadata    = ls_metadata
            io_files       = lo_files
            io_i18n_params = lo_i18n_params ).

          compare_remote_to_local(
            ii_object = li_obj
            it_remote = it_remote
            is_result = <ls_result>
            ii_log    = ii_log ).

          "get required steps for deserialize the object
          lt_steps_id = li_obj->get_deserialize_steps( ).

          LOOP AT lt_steps_id ASSIGNING <lv_step_id>.
            READ TABLE lt_steps WITH KEY step_id = <lv_step_id> ASSIGNING <ls_step>.
            ASSERT sy-subrc = 0.
            IF <lv_step_id> = zif_abapgit_object=>gc_step_id-ddic AND
               zcl_abapgit_objects_activation=>is_ddic_type( ls_item-obj_type ) = abap_false.
              " DDIC only for DDIC objects
              zcx_abapgit_exception=>raise( |Step { <lv_step_id> } is only for DDIC objects| ).
            ENDIF.
            APPEND INITIAL LINE TO <ls_step>-objects ASSIGNING <ls_deser>.
            <ls_deser>-item    = ls_item.
            <ls_deser>-obj     = li_obj.
            <ls_deser>-xml     = lo_xml.
            <ls_deser>-package = lv_package.
          ENDLOOP.

          " LXE, TODO refactor and move below activation
          " LXE is not supported here

        CATCH zcx_abapgit_exception INTO lx_exc.
          ii_log->add_exception( ix_exc = lx_exc
                                 is_item = ls_item ).
          ii_log->add_error( iv_msg = |Import of object { ls_item-obj_name } failed|
                             is_item = ls_item ).
          "object should not be part of any deserialization step
          CONTINUE.
      ENDTRY.

    ENDLOOP.

    li_progress->off( ).

    "run deserialize for all steps and its objects
    deserialize_steps(
      EXPORTING
        it_steps     = lt_steps
        ii_log       = ii_log
        iv_transport = iv_transport
      CHANGING
        ct_files     = rt_accessed_files ).

    " TODO: LXE translations (objects has been activated by now)

    update_package_tree( iv_package ).

    zcl_abapinst_factory=>get_default_transport( )->reset( ).

    lo_timer->end( abap_true ).

  ENDMETHOD.

  METHOD deserialize_step.

    DATA: li_progress TYPE REF TO zif_abapgit_progress,
          lo_base     TYPE REF TO zcl_abapgit_objects_super,
          lx_exc      TYPE REF TO zcx_abapgit_exception.

    FIELD-SYMBOLS: <ls_obj> LIKE LINE OF is_step-objects.

    zcl_abapgit_objects_activation=>clear( ).

    ii_log->add_success( |>> Step { is_step-order } - { is_step-descr }| ).

    li_progress = zcl_abapgit_progress=>get_instance( lines( is_step-objects ) ).

    LOOP AT is_step-objects ASSIGNING <ls_obj>.
      li_progress->show(
        iv_current = sy-tabix
        iv_text    = |Step { is_step-order } - { is_step-descr }:| &&
                     | { <ls_obj>-item-obj_type } { <ls_obj>-item-obj_name }| ).

      TRY.
          <ls_obj>-obj->deserialize( iv_package   = <ls_obj>-package
                                     io_xml       = <ls_obj>-xml
                                     iv_step      = is_step-step_id
                                     ii_log       = ii_log
                                     iv_transport = iv_transport ).

          lo_base ?= <ls_obj>-obj.
          APPEND LINES OF lo_base->get_accessed_files( ) TO ct_files.

          ii_log->add_success( iv_msg = |Object { <ls_obj>-item-obj_name } imported|
                               is_item = <ls_obj>-item ).

        CATCH zcx_abapgit_exception INTO lx_exc.
          ii_log->add_exception( ix_exc = lx_exc
                                 is_item = <ls_obj>-item ).
          ii_log->add_error( iv_msg = |Import of object { <ls_obj>-item-obj_name } failed|
                             is_item = <ls_obj>-item ).
      ENDTRY.

    ENDLOOP.

    li_progress->show( iv_current = lines( is_step-objects )
                       iv_text    = |Step { is_step-order } - Activating Objects| ).

    CASE is_step-step_id.
      WHEN zif_abapgit_object=>gc_step_id-ddic.
        zcl_abapgit_objects_activation=>activate(
          iv_ddic = abap_true
          ii_log  = ii_log ).
      WHEN zif_abapgit_object=>gc_step_id-abap.
        zcl_abapgit_objects_activation=>activate(
          iv_ddic = abap_false
          ii_log  = ii_log ).
      WHEN zif_abapgit_object=>gc_step_id-late.
        " late can have both DDIC (like TABL with REF TO) and non-DDIC objects
        zcl_abapgit_objects_activation=>activate(
          iv_ddic = abap_true
          ii_log  = ii_log ).
        zcl_abapgit_objects_activation=>activate(
          iv_ddic = abap_false
          ii_log  = ii_log ).
    ENDCASE.

    li_progress->off( ).

  ENDMETHOD.

  METHOD deserialize_steps.

    FIELD-SYMBOLS <ls_step> LIKE LINE OF it_steps.

    LOOP AT it_steps ASSIGNING <ls_step>.
      deserialize_step(
        EXPORTING
          is_step      = <ls_step>
          ii_log       = ii_log
          iv_transport = iv_transport
        CHANGING
          ct_files     = ct_files ).
    ENDLOOP.

    SORT ct_files BY path ASCENDING filename ASCENDING.
    DELETE ADJACENT DUPLICATES FROM ct_files. " Just in case

  ENDMETHOD.

  METHOD determine_i18n_params.

    " TODO: unify with ZCL_ABAPGIT_SERIALIZE=>DETERMINE_I18N_PARAMS, same code

    IF io_dot IS BOUND.
      rs_i18n_params-main_language         = io_dot->get_main_language( ).
      rs_i18n_params-use_lxe               = io_dot->use_lxe( ).
      rs_i18n_params-main_language_only    = iv_main_language_only.
      rs_i18n_params-translation_languages = zcl_abapgit_lxe_texts=>get_translation_languages(
        iv_main_language  = io_dot->get_main_language( )
        it_i18n_languages = io_dot->get_i18n_languages( ) ).
    ENDIF.

    IF rs_i18n_params-main_language IS INITIAL.
      rs_i18n_params-main_language = sy-langu.
    ENDIF.

  ENDMETHOD.

  METHOD exists.

    DATA: li_obj TYPE REF TO zif_abapgit_object.

    " Might be called for objects without tadir entry
    IF is_item IS INITIAL.
      RETURN.
    ENDIF.

    " For unsupported objects, assume object exists
    IF is_type_supported( is_item-obj_type ) = abap_false.
      rv_bool = abap_true.
      RETURN.
    ENDIF.

    TRY.
        li_obj = create_object( is_item ).
        rv_bool = li_obj->exists( ).
      CATCH zcx_abapgit_exception.
        " Ignore errors and assume the object exists
        rv_bool = abap_true.
    ENDTRY.

  ENDMETHOD.

  METHOD files_to_deserialize.

    DATA lt_results TYPE zif_abapgit_definitions=>ty_results_tt.

    lt_results = zcl_abapinst_repo_status=>calculate(
      iv_package         = iv_package
      it_local           = it_local
      it_local_checksums = it_local_checksums
      it_remote          = it_remote
      io_dot             = io_dot
      ii_log             = ii_log ).

    rt_results = prioritize_deser(
                   filter_files_to_deserialize(
                     it_results = lt_results
                     ii_log     = ii_log ) ).

  ENDMETHOD.

  METHOD filter_files_to_deserialize.

    DATA lt_objects LIKE rt_results.
    DATA lr_object  TYPE REF TO zif_abapgit_definitions=>ty_result.
    DATA ls_item    TYPE zif_abapgit_definitions=>ty_item.
    DATA lv_tabix   TYPE sy-tabix.

    rt_results = it_results.

    "preparation for object logging, sort all file entries by objects
    IF ii_log IS BOUND.
      lt_objects = rt_results.
      SORT lt_objects
        BY obj_type
           obj_name.
      DELETE ADJACENT DUPLICATES FROM lt_objects COMPARING obj_type obj_name.
      DELETE lt_objects WHERE obj_type IS INITIAL AND obj_name IS INITIAL.
    ENDIF.

    "ignore objects w/o changes
    DELETE rt_results WHERE match = abap_true.     " Full match
    "log objects w/o changes
    IF sy-subrc = 0 AND ii_log IS BOUND.
      SORT rt_results BY obj_type obj_name.
      LOOP AT lt_objects REFERENCE INTO lr_object.
        lv_tabix = sy-tabix.
        READ TABLE rt_results WITH KEY obj_type = lr_object->obj_type
                                       obj_name = lr_object->obj_name
                              BINARY SEARCH TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          "all parts of the objects have not changed
          ls_item-devclass = lr_object->package.
          ls_item-obj_type = lr_object->obj_type.
          ls_item-obj_name = lr_object->obj_name.
          ii_log->add_success(
            iv_msg  = |Object { ls_item-obj_name } (type { ls_item-obj_type }) not changed; no import required|
            is_item = ls_item ).
          "ignore object for further messages
          DELETE lt_objects INDEX lv_tabix.
        ENDIF.
      ENDLOOP.
    ENDIF.

    "ignore objects w/o object type
    DELETE rt_results WHERE obj_type IS INITIAL.
    "log objects w/o object type
    IF sy-subrc = 0 AND ii_log IS BOUND.
      " Note: Moving the CHECK condition to the LOOP WHERE clause will lead to a
      " syntax warning in higher releases and syntax error in 702
      LOOP AT lt_objects REFERENCE INTO lr_object.
        CHECK lr_object->obj_type IS INITIAL AND lr_object->obj_name IS NOT INITIAL.
        ls_item-devclass = lr_object->package.
        ls_item-obj_type = lr_object->obj_type.
        ls_item-obj_name = lr_object->obj_name.
        ii_log->add_warning(
          iv_msg  = |Object type for { ls_item-obj_name } not defined - will be ignored by abapGit|
          is_item = ls_item ).
      ENDLOOP.
      DELETE lt_objects WHERE obj_type IS INITIAL.
    ENDIF.

    "ignore objects that exists only local
    DELETE rt_results WHERE lstate = zif_abapgit_definitions=>c_state-added AND rstate IS INITIAL.
    "ignore objects that where deleted remotely
    DELETE rt_results WHERE rstate = zif_abapgit_definitions=>c_state-deleted.
    "log objects that exists only local or where deleted remotely
    IF sy-subrc = 0 AND ii_log IS BOUND.
      SORT rt_results BY obj_type obj_name.
      LOOP AT lt_objects REFERENCE INTO lr_object.
        lv_tabix = sy-tabix.
        READ TABLE rt_results WITH KEY obj_type = lr_object->obj_type
                                       obj_name = lr_object->obj_name
                              BINARY SEARCH TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          "all parts exists only local
          "no log message; ignore object for further messages
          DELETE lt_objects INDEX lv_tabix.
        ENDIF.
      ENDLOOP.
    ENDIF.

    "ignore table content
    DELETE rt_results WHERE path = zif_abapgit_data_config=>c_default_path.

    SORT rt_results
      BY obj_type ASCENDING
         obj_name ASCENDING
         rstate   DESCENDING  " ensures that non-empty rstate is kept
         lstate   DESCENDING. " ensures that non-empty lstate is kept
    DELETE ADJACENT DUPLICATES FROM rt_results COMPARING obj_type obj_name.

  ENDMETHOD.

  METHOD get_deserialize_steps.
    FIELD-SYMBOLS: <ls_step>    TYPE LINE OF zif_abapgit_objects=>ty_step_data_tt.

    APPEND INITIAL LINE TO rt_steps ASSIGNING <ls_step>.
    <ls_step>-step_id      = zif_abapgit_object=>gc_step_id-early.
    <ls_step>-descr        = 'Pre-process Objects'.
    <ls_step>-syntax_check = abap_false.
    <ls_step>-order        = 1.

    APPEND INITIAL LINE TO rt_steps ASSIGNING <ls_step>.
    <ls_step>-step_id      = zif_abapgit_object=>gc_step_id-ddic.
    <ls_step>-descr        = 'Deserialize DDIC Objects'.
    <ls_step>-syntax_check = abap_false.
    <ls_step>-order        = 2.

    APPEND INITIAL LINE TO rt_steps ASSIGNING <ls_step>.
    <ls_step>-step_id      = zif_abapgit_object=>gc_step_id-abap.
    <ls_step>-descr        = 'Deserialize non-DDIC Objects'.
    <ls_step>-syntax_check = abap_false.
    <ls_step>-order        = 3.

    APPEND INITIAL LINE TO rt_steps ASSIGNING <ls_step>.
    <ls_step>-step_id      = zif_abapgit_object=>gc_step_id-late.
    <ls_step>-descr        = 'Post-process Objects'.
    <ls_step>-syntax_check = abap_true.
    <ls_step>-order        = 4.

    SORT rt_steps BY order. " ensure correct processing order
  ENDMETHOD.

  METHOD get_extra_from_filename.

    IF iv_filename IS NOT INITIAL.
      FIND REGEX '\..*\.([\-a-z0-9_%]*)\.' IN iv_filename SUBMATCHES rv_extra.
      IF sy-subrc = 0.
        rv_extra = cl_http_utility=>unescape_url( rv_extra ).
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD is_active.

    DATA: li_obj TYPE REF TO zif_abapgit_object.

    " For unsupported objects, assume active state
    IF is_type_supported( is_item-obj_type ) = abap_false.
      rv_active = abap_true.
      RETURN.
    ENDIF.

    TRY.
        li_obj = create_object( is_item ).
        rv_active = li_obj->is_active( ).
      CATCH cx_sy_dyn_call_illegal_method
            cx_sy_ref_is_initial
            zcx_abapgit_exception.
        " Ignore errors and assume active state
        rv_active = abap_true.
    ENDTRY.

  ENDMETHOD.

  METHOD is_supported.

    TRY.
        create_object(
          is_item        = is_item
          iv_native_only = iv_native_only ).
        rv_bool = abap_true.
      CATCH zcx_abapgit_exception.
        rv_bool = abap_false.
    ENDTRY.

  ENDMETHOD.

  METHOD is_type_supported.

    DATA: ls_item               TYPE zif_abapgit_definitions=>ty_item,
          ls_supported_obj_type TYPE ty_supported_types.

    FIELD-SYMBOLS <ls_supported_obj_type> TYPE ty_supported_types.

    IF iv_obj_type IS INITIAL.
      " empty object type should never exist
      RETURN.
    ENDIF.

    READ TABLE gt_supported_obj_types
      ASSIGNING <ls_supported_obj_type>
      WITH KEY obj_type = iv_obj_type.

    IF sy-subrc <> 0.

      ls_item-obj_type = iv_obj_type.

      ls_supported_obj_type-obj_type  = iv_obj_type.
      ls_supported_obj_type-supported = is_supported( ls_item ).

      INSERT ls_supported_obj_type INTO TABLE gt_supported_obj_types.

      rv_bool = ls_supported_obj_type-supported.
      RETURN.

    ENDIF.

    rv_bool = <ls_supported_obj_type>-supported.

  ENDMETHOD.

  METHOD map_results_to_items.

    DATA: ls_item LIKE LINE OF rt_items.
    FIELD-SYMBOLS: <ls_result> TYPE zif_abapgit_definitions=>ty_result.

    LOOP AT it_results ASSIGNING <ls_result>.

      ls_item-devclass = <ls_result>-package.
      ls_item-obj_type = <ls_result>-obj_type.
      ls_item-obj_name = <ls_result>-obj_name.
      INSERT ls_item INTO TABLE rt_items.

    ENDLOOP.

  ENDMETHOD.

  METHOD map_tadir_to_items.

    DATA: ls_item LIKE LINE OF rt_items.
    FIELD-SYMBOLS: <ls_tadir> TYPE zif_abapgit_definitions=>ty_tadir.

    LOOP AT it_tadir ASSIGNING <ls_tadir>.

      ls_item-devclass = <ls_tadir>-devclass.
      ls_item-obj_type = <ls_tadir>-object.
      ls_item-obj_name = <ls_tadir>-obj_name.
      INSERT ls_item INTO TABLE rt_items.

    ENDLOOP.

  ENDMETHOD.

  METHOD prioritize_deser.

    DATA lt_items    TYPE zif_abapgit_definitions=>ty_items_tt.
    DATA ls_item     LIKE LINE OF lt_items.
    DATA lt_requires TYPE zif_abapgit_definitions=>ty_items_tt.
    DATA ls_require  LIKE LINE OF lt_requires.
    DATA ls_result   LIKE LINE OF it_results.
    DATA lo_graph    TYPE REF TO zcl_abapgit_item_graph.

    lt_items = map_results_to_items( it_results ).

    CREATE OBJECT lo_graph EXPORTING it_items = lt_items.

    LOOP AT lt_items INTO ls_item.
      CLEAR lt_requires.

* TODO: BEGIN extract to object handler method in ZIF_ABAPGIT_OBJECT:
*    METHODS get_deserialize_order
*      IMPORTING
*        it_items TYPE ty_items_tt
*      RETURNING
*        VALUE(rt_requries) TYPE ty_items_tt

      CASE ls_item-obj_type.
        WHEN 'SPRX'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'WEBI'.
        WHEN 'CLAS'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'SPRX'
            AND obj_type <> 'INTF'
            AND obj_type <> 'XSLT'.
        WHEN 'PROG'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'XSLT'.
        WHEN 'INTF'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'SPRX'
            AND obj_type <> 'XSLT'.
        WHEN 'TABL'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'SPRX'.
        WHEN 'IARP'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'IASP'.
        WHEN 'IATU' OR 'IAXU' OR 'IAMU'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'IASP'
            AND obj_type <> 'PROG'
            AND obj_type <> 'IARP'.
        WHEN 'DCLS'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'DDLS'.
        WHEN 'ODSO'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'IOBJ'.
        WHEN 'SCP1'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'TOBJ'.
        WHEN 'CHAR'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'OTGR'.
        WHEN 'PINF'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'CLAS'
            AND obj_type <> 'INTF'
            AND obj_type <> 'TABL'
            AND obj_type <> 'DOMA'
            AND obj_type <> 'DTEL'.
        WHEN 'DEVC'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'PINF'.
        WHEN 'ENHC'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'ENHO'.
        WHEN 'ENHO'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'ENSC' AND obj_type <> 'ENHS'.
        WHEN 'ENSC'.
          lt_requires = lt_items.
          DELETE lt_requires WHERE obj_type <> 'ENHS'.
      ENDCASE.
* TODO: END extract to object handler method

      LOOP AT lt_requires INTO ls_require.
        lo_graph->add_edge(
          is_from = ls_require
          is_to   = ls_item ).
      ENDLOOP.
    ENDLOOP.

    WHILE lo_graph->has_vertices( ) = abap_true.
      ls_item = lo_graph->get_next( ii_log ).
      READ TABLE it_results INTO ls_result WITH KEY sec_key COMPONENTS
        obj_name = ls_item-obj_name
        obj_type = ls_item-obj_type.
      ASSERT sy-subrc = 0.
      APPEND ls_result TO rt_results.
    ENDWHILE.

  ENDMETHOD.

  METHOD supported_list.

    DATA lt_objects            TYPE STANDARD TABLE OF ko100.
    DATA ls_item               TYPE zif_abapgit_definitions=>ty_item.
    DATA ls_supported_obj_type TYPE ty_supported_types.
    DATA lt_types              TYPE zif_abapgit_exit=>ty_object_types.
    DATA lv_type               LIKE LINE OF lt_types.

    FIELD-SYMBOLS <ls_object> LIKE LINE OF lt_objects.
    FIELD-SYMBOLS <ls_supported_obj_type> TYPE ty_supported_types.

    IF gv_supported_obj_types_loaded = abap_true.
      LOOP AT gt_supported_obj_types ASSIGNING <ls_supported_obj_type> WHERE supported = abap_true.
        INSERT <ls_supported_obj_type>-obj_type INTO TABLE rt_types.
      ENDLOOP.
      RETURN.
    ENDIF.

    " delete content because it might be filled already by method IS_TYPE_SUPPORTED
    CLEAR gt_supported_obj_types.

    CALL FUNCTION 'TR_OBJECT_TABLE'
      TABLES
        wt_object_text = lt_objects
      EXCEPTIONS
        OTHERS         = 1 ##FM_SUBRC_OK.

    LOOP AT lt_objects ASSIGNING <ls_object> WHERE pgmid = 'R3TR'.
      INSERT <ls_object>-object INTO TABLE lt_types.
    ENDLOOP.

    LOOP AT lt_types INTO lv_type.
      ls_item-obj_type = lv_type.

      ls_supported_obj_type-obj_type  = lv_type.
      ls_supported_obj_type-supported = is_supported( ls_item ).

      INSERT ls_supported_obj_type INTO TABLE gt_supported_obj_types.

      IF ls_supported_obj_type-supported = abap_true.
        INSERT ls_supported_obj_type-obj_type INTO TABLE rt_types.
      ENDIF.
    ENDLOOP.

    gv_supported_obj_types_loaded = abap_true.

  ENDMETHOD.

  METHOD update_package_tree.

    DATA: lt_packages TYPE zif_abapgit_sap_package=>ty_devclass_tt,
          lv_package  LIKE LINE OF lt_packages,
          lv_tree     TYPE dirtree-tname.

    " Make sure all deserialized objects are committed
    COMMIT WORK AND WAIT.

    lt_packages = zcl_abapinst_factory=>get_sap_package( iv_package )->list_subpackages( ).
    APPEND iv_package TO lt_packages.

    LOOP AT lt_packages INTO lv_package.
      " Update package tree for SE80
      lv_tree = 'EU_' && lv_package.
      CALL FUNCTION 'WB_TREE_ACTUALIZE'
        EXPORTING
          tree_name              = lv_tree
          without_crossreference = abap_true
          with_tcode_index       = abap_true.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapinst_persistence IMPLEMENTATION.

  METHOD constructor.
    mv_tabname = iv_tabname.
    mv_lock    = iv_lock.
  ENDMETHOD.

  METHOD delete.

    _lock( iv_name = iv_name
           iv_pack = iv_pack ).

    DELETE FROM (mv_tabname)
      WHERE name = iv_name AND pack = iv_pack.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( 'DB delete failed' ).
    ENDIF.

    COMMIT WORK.

  ENDMETHOD.

  METHOD get_instance.

    IF go_db IS NOT BOUND.
      CREATE OBJECT go_db
        EXPORTING
          iv_tabname = iv_tabname
          iv_lock    = iv_lock.
    ENDIF.
    ro_db = go_db.

  ENDMETHOD.

  METHOD insert.

    DATA ls_content TYPE zif_abapinst_definitions=>ty_content.

    _lock( iv_name = is_inst-name
           iv_pack = is_inst-pack ).

    ls_content = _list_to_content( is_inst ).

    INSERT (mv_tabname) FROM ls_content.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( 'DB insert failed' ).
    ENDIF.

    COMMIT WORK.

  ENDMETHOD.

  METHOD last.

    DATA lt_list TYPE zif_abapinst_definitions=>ty_list.

    lt_list = list( ).

    IF lt_list IS INITIAL.
      RETURN.
    ENDIF.

    SORT lt_list BY updated_at DESCENDING installed_at DESCENDING.

    READ TABLE lt_list INTO rs_inst INDEX 1.
    ASSERT sy-subrc = 0.

  ENDMETHOD.

  METHOD list.

    DATA lt_content TYPE zif_abapinst_definitions=>ty_contents.

    SELECT * FROM (mv_tabname) INTO TABLE lt_content
      ORDER BY PRIMARY KEY.
    IF sy-subrc = 0.
      rt_list = _content_to_list( lt_content ).
    ENDIF.

  ENDMETHOD.

  METHOD list_by_name.

    DATA lt_content TYPE zif_abapinst_definitions=>ty_contents.

    IF iv_pack IS SUPPLIED.
      SELECT * FROM (mv_tabname) INTO TABLE lt_content
        WHERE name = iv_name AND pack = iv_pack
        ORDER BY PRIMARY KEY.
    ELSE.
      SELECT * FROM (mv_tabname) INTO TABLE lt_content
        WHERE name = iv_name
        ORDER BY PRIMARY KEY.
    ENDIF.

    IF sy-subrc = 0.
      rt_list = _content_to_list( lt_content ).
    ENDIF.

  ENDMETHOD.

  METHOD select.

    DATA ls_content TYPE zif_abapinst_definitions=>ty_content.

    IF iv_name IS NOT INITIAL AND iv_pack IS NOT INITIAL.
      SELECT SINGLE * FROM (mv_tabname) INTO ls_content
        WHERE name = iv_name AND pack = iv_pack.
    ELSEIF iv_name IS NOT INITIAL.
      SELECT SINGLE * FROM (mv_tabname) INTO ls_content
        WHERE name = iv_name.
    ELSE.
      SELECT SINGLE * FROM (mv_tabname) INTO ls_content
        WHERE pack = iv_pack.
    ENDIF.
    IF sy-subrc = 0.
      rs_inst = _content_to_inst( ls_content ).
    ENDIF.

  ENDMETHOD.

  METHOD update.

    DATA ls_content TYPE zif_abapinst_definitions=>ty_content.

    _lock( iv_name = is_inst-name
           iv_pack = is_inst-pack ).

    ls_content = _list_to_content( is_inst ).

    MODIFY (mv_tabname) FROM ls_content.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( 'DB modify failed' ).
    ENDIF.

    COMMIT WORK.

  ENDMETHOD.

  METHOD _content_to_inst.

    DATA:
      li_ajson TYPE REF TO zif_abapgit_ajson.

    TRY.
        li_ajson = zcl_abapgit_ajson=>parse( is_content-json ).
        li_ajson->to_abap( IMPORTING ev_container = rs_inst ).
      CATCH zcx_abapgit_ajson_error.
        zcx_abapinst_exception=>raise( 'Error converting JSON persistence' ).
    ENDTRY.

    " Validate name and package
    IF rs_inst-name <> is_content-name OR rs_inst-pack <> is_content-pack.
      zcx_abapinst_exception=>raise( 'Inconsistent JSON persistence' ).
    ENDIF.

  ENDMETHOD.

  METHOD _content_to_list.

    DATA ls_list LIKE LINE OF rt_list.

    FIELD-SYMBOLS <ls_content> LIKE LINE OF it_content.

    LOOP AT it_content ASSIGNING <ls_content>.
      ls_list = _content_to_inst( <ls_content> ).
      APPEND ls_list TO rt_list.
    ENDLOOP.

  ENDMETHOD.

  METHOD _list_to_content.

    DATA lo_json TYPE REF TO zcl_abapgit_ajson.

    TRY.
        lo_json = zcl_abapgit_ajson=>create_empty( iv_keep_item_order = abap_true ).
        lo_json->set( iv_path = '/'
                      iv_val  = is_inst ).

        rs_content-name = is_inst-name.
        rs_content-pack = is_inst-pack.
        rs_content-json = lo_json->stringify( 2 ).
      CATCH zcx_abapgit_ajson_error.
        zcx_abapinst_exception=>raise( 'Error converting JSON persistency' ).
    ENDTRY.

  ENDMETHOD.

  METHOD _lock.

    DATA:
      lv_lock_function         TYPE funcname,
      lv_dummy_update_function TYPE funcname.

    lv_lock_function = 'ENQUEUE_' && mv_lock.

    CALL FUNCTION lv_lock_function
      EXPORTING
        mode_zabapinst = iv_mode
        name           = iv_name
        pack           = iv_pack
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( |Could not aquire lock for { iv_name } { iv_pack }| ).
    ENDIF.

    lv_dummy_update_function = _update_function( ).

    " Trigger dummy update task to automatically release locks at commit
    CALL FUNCTION lv_dummy_update_function IN UPDATE TASK.

  ENDMETHOD.

  METHOD _update_function.

    IF mv_update_function IS INITIAL.
      mv_update_function = 'CALL_V1_PING'.

      CALL FUNCTION 'FUNCTION_EXISTS'
        EXPORTING
          funcname = mv_update_function
        EXCEPTIONS
          OTHERS   = 2.

      IF sy-subrc <> 0.
        mv_update_function = 'BANK_OBJ_WORKL_RELEASE_LOCKS'.
      ENDIF.
    ENDIF.

    rv_funcname = mv_update_function.

  ENDMETHOD.
ENDCLASS.

CLASS lcl_status_consistency_checks DEFINITION FINAL.
  PUBLIC SECTION.

    METHODS constructor
      IMPORTING
        iv_root_package TYPE devclass
        io_dot          TYPE REF TO zcl_abapgit_dot_abapgit.

    METHODS run_checks
      IMPORTING
        it_results    TYPE zif_abapgit_definitions=>ty_results_tt
      RETURNING
        VALUE(ri_log) TYPE REF TO zif_abapgit_log
      RAISING
        zcx_abapgit_exception .

  PRIVATE SECTION.

    DATA mv_root_package TYPE devclass.
    DATA mo_dot          TYPE REF TO zcl_abapgit_dot_abapgit.
    DATA mi_log          TYPE REF TO zif_abapgit_log.

    METHODS check_package_move
      IMPORTING
        !it_results TYPE zif_abapgit_definitions=>ty_results_tt
      RAISING
        zcx_abapgit_exception .
    METHODS check_files_folder
      IMPORTING
        !it_results TYPE zif_abapgit_definitions=>ty_results_tt
      RAISING
        zcx_abapgit_exception .
    METHODS check_package_sub_package
      IMPORTING
        !it_results TYPE zif_abapgit_definitions=>ty_results_tt
        !iv_top     TYPE devclass
      RAISING
        zcx_abapgit_exception .
    METHODS check_package_folder
      IMPORTING
        !it_results TYPE zif_abapgit_definitions=>ty_results_tt
        !io_dot     TYPE REF TO zcl_abapgit_dot_abapgit
        !iv_top     TYPE devclass
      RAISING
        zcx_abapgit_exception .
    METHODS check_multiple_files
      IMPORTING
        !it_results TYPE zif_abapgit_definitions=>ty_results_tt
      RAISING
        zcx_abapgit_exception .
    METHODS check_namespace
      IMPORTING
        !it_results      TYPE zif_abapgit_definitions=>ty_results_tt
      RAISING
        zcx_abapgit_exception .

ENDCLASS.

CLASS lcl_status_consistency_checks IMPLEMENTATION.

  METHOD constructor.
    mv_root_package = iv_root_package.
    mo_dot          = io_dot.
  ENDMETHOD.

  METHOD run_checks.

    CREATE OBJECT mi_log TYPE zcl_abapgit_log.

    " Find all objects which were assigned to a different package
    check_package_move( it_results ).

    " Check files for one object is in the same folder
    check_files_folder( it_results ).

    " Check that sub packages are included in the package hierarchy
    check_package_sub_package(
      it_results = it_results
      iv_top     = mv_root_package ).

    " Check that objects are created in package corresponding to folder
    check_package_folder(
      it_results = it_results
      io_dot     = mo_dot
      iv_top     = mv_root_package ).

    " Check for multiple files with same filename
    check_multiple_files( it_results ).

    " Check if namespaces exist already
    check_namespace( it_results ).

    ri_log = mi_log.

  ENDMETHOD.

  METHOD check_files_folder.

    DATA:
      ls_item     TYPE zif_abapgit_definitions=>ty_item,
      lt_res_sort LIKE it_results,
      lt_item_idx LIKE it_results.

    FIELD-SYMBOLS:
      <ls_result>     LIKE LINE OF it_results,
      <ls_result_idx> LIKE LINE OF it_results.

    " TODO optimize ?
    " sort by obj, path
    " loop, and compare to first object record

    " Collect object index
    lt_res_sort = it_results.
    SORT lt_res_sort BY obj_type ASCENDING obj_name ASCENDING.

    LOOP AT it_results ASSIGNING <ls_result> WHERE NOT obj_type IS INITIAL AND packmove = abap_false.

      IF NOT ( <ls_result>-obj_type = ls_item-obj_type
          AND <ls_result>-obj_name = ls_item-obj_name ).
        APPEND INITIAL LINE TO lt_item_idx ASSIGNING <ls_result_idx>.
        <ls_result_idx>-obj_type = <ls_result>-obj_type.
        <ls_result_idx>-obj_name = <ls_result>-obj_name.
        <ls_result_idx>-path     = <ls_result>-path.
        MOVE-CORRESPONDING <ls_result> TO ls_item.
      ENDIF.

    ENDLOOP.

    LOOP AT it_results ASSIGNING <ls_result>
      WHERE NOT obj_type IS INITIAL AND obj_type <> 'DEVC' AND packmove = abap_false.

      READ TABLE lt_item_idx ASSIGNING <ls_result_idx>
        WITH KEY obj_type = <ls_result>-obj_type obj_name = <ls_result>-obj_name
        BINARY SEARCH. " Sorted above

      IF sy-subrc <> 0 OR <ls_result>-path <> <ls_result_idx>-path. " All paths are same
        mi_log->add_warning( |Files for object { <ls_result>-obj_type } { <ls_result>-obj_name }|
         && | are not placed in the same folder| ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD check_multiple_files.

    DATA:
      lt_res_sort LIKE it_results,
      ls_file     TYPE zif_abapgit_git_definitions=>ty_file_signature.

    FIELD-SYMBOLS <ls_result> LIKE LINE OF it_results.

    lt_res_sort = it_results.
    SORT lt_res_sort BY filename ASCENDING.

    LOOP AT lt_res_sort ASSIGNING <ls_result> WHERE obj_type <> 'DEVC' AND packmove = abap_false.
      IF <ls_result>-filename IS NOT INITIAL AND <ls_result>-filename = ls_file-filename.
        mi_log->add_warning( |Multiple files with same filename, { <ls_result>-filename }| ).
      ENDIF.

      IF <ls_result>-filename IS INITIAL.
        mi_log->add_warning( |Filename is empty for object { <ls_result>-obj_type } { <ls_result>-obj_name }| ).
      ENDIF.

      MOVE-CORRESPONDING <ls_result> TO ls_file.
    ENDLOOP.

  ENDMETHOD.

  METHOD check_namespace.

    DATA:
      li_namespace TYPE REF TO zif_abapgit_sap_namespace,
      lv_namespace TYPE namespace,
      lt_namespace TYPE TABLE OF namespace.

    FIELD-SYMBOLS <ls_result> LIKE LINE OF it_results.

    " Collect all namespaces based on name of xml- and json-files
    LOOP AT it_results ASSIGNING <ls_result>.
      FIND REGEX '^#([a-zA-Z0-9]+)#.*\..*\.xml$' IN <ls_result>-filename SUBMATCHES lv_namespace.
      IF sy-subrc = 0.
        lv_namespace = '/' && to_upper( lv_namespace ) && '/'.
        COLLECT lv_namespace INTO lt_namespace.
      ENDIF.
      FIND REGEX '^\(([a-zA-Z0-9]+)\).*\..*\.json$' IN <ls_result>-filename SUBMATCHES lv_namespace.
      IF sy-subrc = 0.
        lv_namespace = '/' && to_upper( lv_namespace ) && '/'.
        COLLECT lv_namespace INTO lt_namespace.
      ENDIF.
    ENDLOOP.

    li_namespace = zcl_abapinst_factory=>get_sap_namespace( ).

    LOOP AT lt_namespace INTO lv_namespace.
      IF li_namespace->exists( lv_namespace ) = abap_false.
        mi_log->add_warning( |Namespace { lv_namespace } does not exist.|
          && | Pull it first (or create it in transaction SE03)| ).
      ELSEIF li_namespace->is_editable( lv_namespace ) = abap_false.
        mi_log->add_warning( |Namespace { lv_namespace } is not modifiable. Check it in transaction SE03| ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD check_package_folder.

    DATA:
      lv_path         TYPE string,
      lv_object       TYPE string,
      lo_folder_logic TYPE REF TO zcl_abapgit_folder_logic.

    FIELD-SYMBOLS <ls_result> LIKE LINE OF it_results.

    lo_folder_logic = zcl_abapgit_folder_logic=>get_instance( ).

    LOOP AT it_results ASSIGNING <ls_result>
      WHERE NOT package IS INITIAL AND NOT path IS INITIAL AND packmove = abap_false.

      lv_path = lo_folder_logic->package_to_path(
        iv_top     = iv_top
        io_dot     = io_dot
        iv_package = <ls_result>-package ).

      lv_object = |{ <ls_result>-obj_type } { <ls_result>-obj_name }|.

      IF lv_path IS INITIAL.
        mi_log->add_error( |{ lv_object } already exists outside of { iv_top } package hierarchy| ).
      ELSEIF lv_path <> <ls_result>-path.
        mi_log->add_warning( |Package and path do not match for object { lv_object }| ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD check_package_move.

    DATA lt_move_idx LIKE it_results.

    FIELD-SYMBOLS:
      <ls_result>      LIKE LINE OF it_results,
      <ls_result_move> LIKE LINE OF it_results.

    " TODO: optimize ?
    " delete where packmove = false, delete adj duplicates and fire messages ?
    LOOP AT it_results ASSIGNING <ls_result>
      WHERE lstate = zif_abapgit_definitions=>c_state-added AND packmove = abap_true.

      READ TABLE lt_move_idx TRANSPORTING NO FIELDS
        WITH KEY
          obj_type = <ls_result>-obj_type
          obj_name = <ls_result>-obj_name
        BINARY SEARCH. " Sorted since it_result is sorted
      IF sy-subrc <> 0.
        mi_log->add_warning( |Changed package assignment for object|
          && | { <ls_result>-obj_type } { <ls_result>-obj_name }| ).
        APPEND INITIAL LINE TO lt_move_idx ASSIGNING <ls_result_move>.
        <ls_result_move>-obj_type = <ls_result>-obj_type.
        <ls_result_move>-obj_name = <ls_result>-obj_name.
        <ls_result_move>-path     = <ls_result>-path.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD check_package_sub_package.

    DATA lv_msg TYPE string.

    FIELD-SYMBOLS <ls_result> LIKE LINE OF it_results.

    LOOP AT it_results ASSIGNING <ls_result> USING KEY sec_key
                       WHERE package IS INITIAL AND obj_type = 'DEVC'.

      IF zcl_abapinst_factory=>get_sap_package( |{ <ls_result>-obj_name }| )->exists( ) = abap_true.
        " If package already exist but is not included in the package hierarchy of
        " the package assigned to the repository, then a manual change of the package
        " is required i.e. setting a parent package to the repo package (or one of its
        " subpackages). We don't do this automatically since it's not clear where in the
        " hierarchy the new package should be located or whether the sub package shall be
        " removed from the repo.
        lv_msg = |Package { <ls_result>-obj_name } already exists but is not a sub-package of { iv_top }. |
              && |Check your package and folder logic, and either assign { <ls_result>-obj_name } |
              && |to the package hierarchy of { iv_top } or remove package { <ls_result>-obj_name } |
              && |from the repository.|.
        mi_log->add_warning( lv_msg ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

ENDCLASS.

CLASS zcl_abapinst_repo_status IMPLEMENTATION.

  METHOD build_existing.

    DATA ls_file_sig LIKE LINE OF it_state.

    " Item
    rs_result-obj_type  = is_local-item-obj_type.
    rs_result-obj_name  = is_local-item-obj_name.
    rs_result-package   = is_local-item-devclass.
    rs_result-srcsystem = is_local-item-srcsystem.
    rs_result-origlang  = is_local-item-origlang.
    rs_result-inactive  = is_local-item-inactive.

    " File
    rs_result-path     = is_local-file-path.
    rs_result-filename = is_local-file-filename.

    rs_result-match    = boolc( is_local-file-sha1 = is_remote-sha1 ).
    IF rs_result-match = abap_true.
      RETURN.
    ENDIF.

    " Match against current state
    READ TABLE it_state INTO ls_file_sig
      WITH KEY
        path     = is_local-file-path
        filename = is_local-file-filename
      BINARY SEARCH.

    IF sy-subrc = 0.
      IF ls_file_sig-sha1 <> is_local-file-sha1.
        rs_result-lstate = zif_abapgit_definitions=>c_state-modified.
      ENDIF.
      IF ls_file_sig-sha1 <> is_remote-sha1.
        rs_result-rstate = zif_abapgit_definitions=>c_state-modified.
      ENDIF.
    ELSE.
      " This is a strange situation. As both local and remote exist
      " the state should also be present. Maybe this is a first run of the code.
      " In this case just compare hashes directly and mark both changed
      " the user will presumably decide what to do after checking the actual diff
      rs_result-lstate = zif_abapgit_definitions=>c_state-modified.
      rs_result-rstate = zif_abapgit_definitions=>c_state-modified.
    ENDIF.

  ENDMETHOD.

  METHOD build_new_local.

    " Item
    rs_result-obj_type  = is_local-item-obj_type.
    rs_result-obj_name  = is_local-item-obj_name.
    rs_result-package   = is_local-item-devclass.
    rs_result-srcsystem = is_local-item-srcsystem.
    rs_result-origlang  = is_local-item-origlang.
    rs_result-inactive  = is_local-item-inactive.

    " File
    rs_result-path     = is_local-file-path.
    rs_result-filename = is_local-file-filename.

    " Match
    rs_result-match    = abap_false.
    rs_result-lstate   = zif_abapgit_definitions=>c_state-added.

  ENDMETHOD.

  METHOD build_new_remote.

    DATA ls_item     LIKE LINE OF it_items_idx.
    DATA ls_file_sig LIKE LINE OF it_state_idx.

    " Common and default part
    rs_result-path     = is_remote-path.
    rs_result-filename = is_remote-filename.
    rs_result-match    = abap_false.
    rs_result-rstate   = zif_abapgit_definitions=>c_state-added.

    zcl_abapgit_filename_logic=>file_to_object(
      EXPORTING
        iv_filename = is_remote-filename
        iv_path     = is_remote-path
        iv_devclass = mv_root_package
        io_dot      = mo_dot
      IMPORTING
        es_item     = ls_item ).

    " Check if in item index + get package
    READ TABLE it_items_idx INTO ls_item
      WITH KEY
        obj_type = ls_item-obj_type
        obj_name = ls_item-obj_name.

    IF sy-subrc = 0.

      " Completely new (xml, abap) and new file in an existing object
      rs_result-obj_type  = ls_item-obj_type.
      rs_result-obj_name  = ls_item-obj_name.
      rs_result-package   = ls_item-devclass.
      rs_result-srcsystem = sy-sysid.
      rs_result-origlang  = sy-langu.

      READ TABLE it_state_idx INTO ls_file_sig
        WITH KEY
          path     = is_remote-path
          filename = is_remote-filename.

      " Existing file but from another package
      " was not added during local file proc as was not in tadir for repo package
      IF sy-subrc = 0.
        IF ls_file_sig-sha1 = is_remote-sha1.
          rs_result-match = abap_true.
          CLEAR rs_result-rstate.
        ELSE.
          rs_result-rstate = zif_abapgit_definitions=>c_state-modified.
        ENDIF.

        " Item is in state and in cache but with no package - it was deleted
        " OR devclass is the same as repo package (see #532)
        IF ls_item-devclass IS INITIAL OR ls_item-devclass = mv_root_package.
          rs_result-match  = abap_false.
          rs_result-lstate = zif_abapgit_definitions=>c_state-deleted.
        ENDIF.
      ENDIF.

    ELSE. " Completely unknown file, probably non-abapgit
      ASSERT 1 = 1. " No action, just follow defaults
    ENDIF.

  ENDMETHOD.

  METHOD calculate.

    DATA lo_instance TYPE REF TO zcl_abapinst_repo_status.
    DATA lo_consistency_checks TYPE REF TO lcl_status_consistency_checks.

    CREATE OBJECT lo_instance
      EXPORTING
        iv_root_package = iv_package
        io_dot          = io_dot.

    rt_results = lo_instance->calculate_status(
      it_local     = it_local
      it_remote    = it_remote
      it_cur_state = it_local_checksums ).

    IF ii_log IS BOUND.
      " This method just adds messages to the log. No log, nothing to do here
      CREATE OBJECT lo_consistency_checks
        EXPORTING
          iv_root_package = iv_package
          io_dot          = io_dot.
      ii_log->merge_with( lo_consistency_checks->run_checks( rt_results ) ).
    ENDIF.

  ENDMETHOD.

  METHOD calculate_status.

    DATA:
      lt_remote        LIKE it_remote,
      lt_items         TYPE zif_abapgit_definitions=>ty_items_tt,
      lt_items_by_obj  TYPE zif_abapgit_definitions=>ty_items_ts, " Sorted by obj_type+obj_name
      lt_state_by_file TYPE zif_abapgit_git_definitions=>ty_file_signatures_ts. " Sorted by path+filename

    lt_state_by_file = ensure_state( " Index by file
      it_cur_state = it_cur_state
      it_local     = it_local ).
    lt_remote        = it_remote.

    " Process local files and new local files
    process_local(
      EXPORTING
        it_local     = it_local
        it_state_idx = lt_state_by_file
      CHANGING
        ct_remote    = lt_remote
        ct_items     = lt_items
        ct_results   = rt_results ).

    " Remove processed remotes (with cleared SHA1)
    DELETE lt_remote WHERE sha1 IS INITIAL.

    " Complete item index for unmarked remote files
    process_items( " TODO: rename ?
      EXPORTING
        it_unprocessed_remote = lt_remote
      CHANGING
        ct_items              = lt_items ).

    " The item list was not unique by now, just collected as "mention" list
    SORT lt_items DESCENDING. " Default key - type, name, pkg, ...
    DELETE ADJACENT DUPLICATES FROM lt_items COMPARING obj_type obj_name.
    lt_items_by_obj = lt_items.

    " Process new remote files (marked above with empty SHA1)
    process_remote(
      EXPORTING
        it_local              = it_local
        it_unprocessed_remote = lt_remote
        it_state_idx          = lt_state_by_file
        it_items_idx          = lt_items_by_obj
      CHANGING
        ct_results            = rt_results ).

    SORT rt_results BY
      obj_type ASCENDING
      obj_name ASCENDING
      filename ASCENDING
      path ASCENDING.

  ENDMETHOD.

  METHOD check_local_remote_consistency.
    IF is_remote-sha1 IS INITIAL.
      IF is_local-file-filename = zcl_abapgit_filename_logic=>c_package_file.
        zcx_abapgit_exception=>raise(
          |Package name conflict { is_local-item-obj_type } { is_local-item-obj_name }. | &&
          |Rename package or use FULL folder logic| ).
      ELSE.
        zcx_abapgit_exception=>raise(
          |Checksum conflict { is_local-item-obj_type } { is_local-item-obj_name }. | &&
          |Please create an issue on Github| ).
      ENDIF.
    ENDIF.
  ENDMETHOD.

  METHOD constructor.
    mv_root_package = iv_root_package.
    mo_dot          = io_dot.
  ENDMETHOD.

  METHOD ensure_state.

    FIELD-SYMBOLS <ls_state> LIKE LINE OF rt_state.
    FIELD-SYMBOLS <ls_local> LIKE LINE OF it_local.

    IF lines( it_cur_state ) = 0.
      " Empty state is usually not expected. Maybe for new repos.
      " In this case suppose the local state is unchanged
      LOOP AT it_local ASSIGNING <ls_local>.
        APPEND INITIAL LINE TO rt_state ASSIGNING <ls_state>.
        MOVE-CORRESPONDING <ls_local>-file TO <ls_state>.
      ENDLOOP.
    ELSE.
      rt_state = it_cur_state.
    ENDIF.

  ENDMETHOD.

  METHOD get_object_package.
    DATA: lv_name    TYPE devclass,
          li_package TYPE REF TO zif_abapgit_sap_package.

    rv_devclass = zcl_abapinst_factory=>get_tadir( )->get_object_package(
      iv_object   = iv_object
      iv_obj_name = iv_obj_name ).
    IF rv_devclass IS INITIAL AND iv_object = 'DEVC' AND iv_obj_name(1) = '$'.
      " local packages usually have no tadir entry
      lv_name = iv_obj_name.
      li_package = zcl_abapinst_factory=>get_sap_package( lv_name ).
      IF li_package->exists( ) = abap_true.
        rv_devclass = lv_name.
      ENDIF.
    ENDIF.
  ENDMETHOD.

  METHOD process_items.

    DATA:
      ls_item         LIKE LINE OF ct_items,
      lv_is_xml       TYPE abap_bool,
      lv_is_json      TYPE abap_bool,
      lv_sub_fetched  TYPE abap_bool,
      lt_sub_packages TYPE SORTED TABLE OF devclass WITH UNIQUE KEY table_line.

    FIELD-SYMBOLS <ls_remote> LIKE LINE OF it_unprocessed_remote.

    LOOP AT it_unprocessed_remote ASSIGNING <ls_remote>
      WHERE filename <> 'package.abap.json' AND filename <> '.abapgit.xml'. "apm
      " Skip ignored files
      CHECK mo_dot->is_ignored(
        iv_path     = <ls_remote>-path
        iv_filename = <ls_remote>-filename ) = abap_false.

      zcl_abapgit_filename_logic=>file_to_object(
        EXPORTING
          iv_filename = <ls_remote>-filename
          iv_path     = <ls_remote>-path
          io_dot      = mo_dot
          iv_devclass = mv_root_package
        IMPORTING
          es_item     = ls_item
          ev_is_xml   = lv_is_xml
          ev_is_json  = lv_is_json ).

      CHECK lv_is_xml = abap_true OR lv_is_json = abap_true. " only object definitions

      ls_item-devclass = get_object_package(
        iv_object   = ls_item-obj_type
        iv_obj_name = ls_item-obj_name ).

      IF ls_item-devclass IS NOT INITIAL AND mv_root_package <> ls_item-devclass.
        IF lv_sub_fetched = abap_false.
          lt_sub_packages = zcl_abapinst_factory=>get_sap_package( mv_root_package )->list_subpackages( ).
          lv_sub_fetched  = abap_true.
        ENDIF.

        " Make sure the package is under the repo main package
        READ TABLE lt_sub_packages TRANSPORTING NO FIELDS
          WITH KEY table_line = ls_item-devclass.
        IF sy-subrc <> 0 AND ls_item-obj_type = 'DEVC'.
          CLEAR ls_item-devclass.
        ENDIF.
      ENDIF.

      APPEND ls_item TO ct_items.
    ENDLOOP.

  ENDMETHOD.

  METHOD process_local.

    FIELD-SYMBOLS:
      <ls_remote> LIKE LINE OF ct_remote,
      <ls_result> LIKE LINE OF ct_results,
      <ls_state>  LIKE LINE OF it_state_idx,
      <ls_local>  LIKE LINE OF it_local.

    LOOP AT it_local ASSIGNING <ls_local>.
      " Skip ignored files
      CHECK mo_dot->is_ignored(
        iv_path     = <ls_local>-file-path
        iv_filename = <ls_local>-file-filename ) = abap_false.

      IF <ls_local>-item IS NOT INITIAL
        AND zcl_abapgit_filename_logic=>is_obj_definition_file( <ls_local>-file-filename ) = abap_true.
        " Collect for item index
        APPEND <ls_local>-item TO ct_items.
      ENDIF.

      APPEND INITIAL LINE TO ct_results ASSIGNING <ls_result>.

      " Find a match in remote
      READ TABLE ct_remote ASSIGNING <ls_remote>
        WITH KEY file_path
        COMPONENTS
          path     = <ls_local>-file-path
          filename = <ls_local>-file-filename.
      IF sy-subrc = 0.  " Both local and remote exist
        check_local_remote_consistency(
          is_local  = <ls_local>
          is_remote = <ls_remote> ).
        <ls_result> = build_existing(
          is_local  = <ls_local>
          is_remote = <ls_remote>
          it_state  = it_state_idx ).
        CLEAR <ls_remote>-sha1. " Mark as processed
      ELSE. " Only local exists
        <ls_result> = build_new_local( <ls_local> ).
        " Check if same file exists in different location
        READ TABLE ct_remote ASSIGNING <ls_remote>
          WITH KEY file
          COMPONENTS filename = <ls_local>-file-filename.
        IF sy-subrc = 0 AND <ls_local>-file-sha1 = <ls_remote>-sha1.
          " If yes, then it was probably moved
          <ls_result>-packmove = abap_true.
        ELSEIF sy-subrc = 4.
          " Check if file existed before and was deleted remotely
          READ TABLE it_state_idx ASSIGNING <ls_state>
            WITH KEY
              path     = <ls_local>-file-path
              filename = <ls_local>-file-filename.
          IF sy-subrc = 0.
            IF <ls_local>-file-sha1 = <ls_state>-sha1.
              <ls_result>-lstate = zif_abapgit_definitions=>c_state-unchanged.
            ELSE.
              <ls_result>-lstate = zif_abapgit_definitions=>c_state-modified.
            ENDIF.
            <ls_result>-rstate = zif_abapgit_definitions=>c_state-deleted. " ??
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD process_remote.

    FIELD-SYMBOLS:
      <ls_remote> LIKE LINE OF it_unprocessed_remote,
      <ls_result> LIKE LINE OF ct_results,
      <ls_local>  LIKE LINE OF it_local.

    LOOP AT it_unprocessed_remote ASSIGNING <ls_remote>
      WHERE filename <> 'package.abap.json' AND filename <> '.abapgit.xml'. "apm
      " Skip ignored files
      CHECK mo_dot->is_ignored(
        iv_path     = <ls_remote>-path
        iv_filename = <ls_remote>-filename ) = abap_false.

      APPEND INITIAL LINE TO ct_results ASSIGNING <ls_result>.

      <ls_result> = build_new_remote(
        is_remote   = <ls_remote>
        it_items_idx = it_items_idx
        it_state_idx = it_state_idx ).

      " Check if same file exists in different location (not for generic package files)
      READ TABLE it_local ASSIGNING <ls_local>
        WITH KEY file-filename = <ls_remote>-filename.
      IF sy-subrc = 0 AND <ls_remote>-filename <> zcl_abapgit_filename_logic=>c_package_file.
        <ls_result>-match = abap_false.
        <ls_result>-lstate = zif_abapgit_definitions=>c_state-deleted.
        <ls_result>-rstate = zif_abapgit_definitions=>c_state-unchanged.
        IF <ls_local>-file-sha1 = <ls_remote>-sha1.
          <ls_result>-packmove = abap_true.
        ENDIF.
      ELSE.
        " Check if file existed before and was deleted locally
        READ TABLE it_state_idx TRANSPORTING NO FIELDS
          WITH KEY
            path     = <ls_remote>-path
            filename = <ls_remote>-filename.
        IF sy-subrc = 0.
          <ls_result>-match  = abap_false.
          <ls_result>-lstate = zif_abapgit_definitions=>c_state-deleted.
        ENDIF.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapinst_requirements IMPLEMENTATION.

  METHOD get_requirement_met_status.

    DATA: lt_installed TYPE STANDARD TABLE OF cvers_sdu.

    FIELD-SYMBOLS: <ls_requirement>    TYPE zif_abapgit_dot_abapgit=>ty_requirement,
                   <ls_status>         TYPE ty_requirement_status,
                   <ls_installed_comp> TYPE cvers_sdu.

    CALL FUNCTION 'DELIVERY_GET_INSTALLED_COMPS'
      TABLES
        tt_comptab       = lt_installed
      EXCEPTIONS
        no_release_found = 1
        OTHERS           = 2.
    IF sy-subrc <> 0.
      zcx_abapgit_exception=>raise( |Error from DELIVERY_GET_INSTALLED_COMPS { sy-subrc }| ).
    ENDIF.

    LOOP AT it_requirements ASSIGNING <ls_requirement>.
      APPEND INITIAL LINE TO rt_status ASSIGNING <ls_status>.
      <ls_status>-component = <ls_requirement>-component.
      <ls_status>-required_release = <ls_requirement>-min_release.
      <ls_status>-required_patch = <ls_requirement>-min_patch.

      READ TABLE lt_installed WITH KEY component = <ls_requirement>-component
                              ASSIGNING <ls_installed_comp>.
      IF sy-subrc = 0.
        " Component is installed, requirement is met if the installed version is greater or equal
        " to the required one.
        <ls_status>-installed_release = <ls_installed_comp>-release.
        <ls_status>-installed_patch = <ls_installed_comp>-extrelease.
        <ls_status>-description = <ls_installed_comp>-desc_text.
        <ls_status>-met = version_greater_or_equal( <ls_status> ).
      ELSE.
        " Component is not installed at all
        <ls_status>-met = abap_false.
      ENDIF.

      UNASSIGN <ls_installed_comp>.
    ENDLOOP.

  ENDMETHOD.

  METHOD is_requirements_met.

    DATA: lt_met_status TYPE ty_requirement_status_tt.

    lt_met_status = get_requirement_met_status( it_requirements ).

    READ TABLE lt_met_status TRANSPORTING NO FIELDS WITH KEY met = abap_false.
    IF sy-subrc = 0.
      rv_status = zif_abapgit_definitions=>c_no.
    ELSE.
      rv_status = zif_abapgit_definitions=>c_yes.
    ENDIF.

  ENDMETHOD.

  METHOD version_greater_or_equal.

    DATA:
      lv_installed_release TYPE n LENGTH 4,
      lv_installed_patch   TYPE n LENGTH 4,
      lv_required_release  TYPE n LENGTH 4,
      lv_required_patch    TYPE n LENGTH 4.

    TRY.
        MOVE EXACT: is_status-installed_release TO lv_installed_release,
                    is_status-installed_patch   TO lv_installed_patch,
                    is_status-required_release  TO lv_required_release,
                    is_status-required_patch    TO lv_required_patch.
      CATCH cx_sy_conversion_error.
        " Cannot compare by number, assume requirement not fullfilled (user can force install
        " anyways if this was an error)
        rv_true = abap_false.
        RETURN.
    ENDTRY.

    " Versions are comparable by number, compare release and if necessary patch level
    IF lv_installed_release > lv_required_release
        OR ( lv_installed_release = lv_required_release
         AND ( lv_required_patch = 0
            OR lv_installed_patch >= lv_required_patch ) ).

      rv_true = abap_true.

    ENDIF.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapinst_screen IMPLEMENTATION.

  METHOD banner.

    DATA:
      lv_base           TYPE string,
      lt_base           TYPE TABLE OF string ##NEEDED,
      lv_xstr           TYPE xstring,
      lv_content_type   TYPE w3param-cont_type,
      lv_content_lenght TYPE w3param-cont_len,
      ls_pic            TYPE w3mime,
      lt_pic            TYPE TABLE OF w3mime,
      ls_query          TYPE w3query,
      lt_query          TYPE TABLE OF w3query,
      lt_html           TYPE TABLE OF w3html,
      lv_return_code    TYPE w3param-ret_code.

    IF go_banner IS BOUND AND iv_show IS INITIAL.
      go_banner->clear_picture( ).
      go_banner->free( ).
      FREE go_banner.
      RETURN.
    ENDIF.

    IF go_banner IS NOT BOUND.
      CREATE OBJECT go_banner EXPORTING parent = go_banner_dock.

      go_banner->set_3d_border( border = 0 ).

      go_banner->set_display_mode( display_mode = cl_gui_picture=>display_mode_normal ).
    ENDIF.

    go_banner->set_position( height = 21
                             left   = iv_left
                             top    = iv_top
                             width  = 500 ).             "#EC NUMBER_OK

    IF gv_banner_url IS INITIAL.
      IF iv_id IS INITIAL.
        lv_base = concat_lines_of( it_base ).
        lv_xstr = cl_http_utility=>decode_x_base64( lv_base ).
        WHILE xstrlen( lv_xstr ) > 255.
          ls_pic-line = lv_xstr(255).
          APPEND ls_pic TO lt_pic.
          lv_xstr = lv_xstr+255(*).
        ENDWHILE.
        IF xstrlen( lv_xstr ) > 0.
          ls_pic-line = lv_xstr(255).
          APPEND ls_pic TO lt_pic.
        ENDIF.
      ELSE.
        ls_query-name  = '_OBJECT_ID'.
        ls_query-value = iv_id.
        APPEND ls_query TO lt_query.

        CALL FUNCTION 'WWW_GET_MIME_OBJECT'
          TABLES
            query_string        = lt_query
            html                = lt_html
            mime                = lt_pic
          CHANGING
            return_code         = lv_return_code
            content_type        = lv_content_type
            content_length      = lv_content_lenght
          EXCEPTIONS
            object_not_found    = 1
            parameter_not_found = 2
            OTHERS              = 3 ##FM_OLDED.
        IF sy-subrc <> 0.
          RETURN.
        ENDIF.

        " Convert to base64 (not used, just fyi in case you want to paste it somewhere)
        LOOP AT lt_pic INTO ls_pic.
          lv_xstr = lv_xstr && ls_pic-line.
        ENDLOOP.
        lv_base = cl_http_utility=>encode_x_base64( lv_xstr ).
        WHILE strlen( lv_base ) > 80.
          APPEND lv_base(80) TO lt_base.
          SHIFT lv_base LEFT BY 80 PLACES.
        ENDWHILE.
        IF strlen( lv_base ) > 0.
          APPEND lv_base TO lt_base.
        ENDIF.
      ENDIF.

      CALL FUNCTION 'DP_CREATE_URL'
        EXPORTING
          type     = 'IMAGE'
          subtype  = cndp_sap_subtype_unknown
          size     = lv_content_lenght
          lifetime = cndp_lifetime_transaction
        TABLES
          data     = lt_pic
        CHANGING
          url      = gv_banner_url
        EXCEPTIONS
          OTHERS   = 1 ##FM_SUBRC_OK.
    ENDIF.

    go_banner->load_picture_from_url( url = gv_banner_url ).

  ENDMETHOD.

  METHOD browser.
    cl_gui_frontend_services=>execute(
      EXPORTING
        document               = |{ iv_url }|
      EXCEPTIONS
        cntl_error             = 1
        error_no_gui           = 2
        bad_parameter          = 3
        file_not_found         = 4
        path_not_found         = 5
        file_extension_unknown = 6
        error_execute_failed   = 7
        synchronous_failed     = 8
        not_supported_by_gui   = 9
        OTHERS                 = 10 ).
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
        DISPLAY LIKE 'E'.
    ENDIF.
  ENDMETHOD.

  METHOD copyright.
    " Avoid scan by ClearlyDefined
    rv_copyright = 'Copyright'.
    rv_copyright = rv_copyright && | { sy-datum(4) } Marc Bernard|.
  ENDMETHOD.

  METHOD default_layer.

    DATA:
      ls_layer TYPE triwb_s_trlayer,
      lt_layer TYPE triwb_t_trlayer.

    CALL FUNCTION 'TRINT_TCE_READ_CONFIG'
      IMPORTING
        et_trlayer              = lt_layer
      EXCEPTIONS
        configuration_not_found = 1
        configuration_empty     = 2
        OTHERS                  = 3.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    " Return transport layer if there's exactly one non-SAP layer defined
    DELETE lt_layer WHERE translayer = 'SAP' OR translayer IS INITIAL.

    IF lines( lt_layer ) = 1.
      READ TABLE lt_layer INTO ls_layer INDEX 1.
      ASSERT sy-subrc = 0.
      rv_layer = ls_layer-translayer.
    ENDIF.

  ENDMETHOD.

  METHOD f4_file.

    DATA:
      lt_file_table TYPE filetable,
      ls_file_table LIKE LINE OF lt_file_table,
      lv_filter     TYPE string,
      lv_action     TYPE i,
      lv_rc         TYPE i.

    lv_filter = 'ZIP Files (*.ZIP)|*.ZIP|' && cl_gui_frontend_services=>filetype_all.

    cl_gui_frontend_services=>file_open_dialog(
      EXPORTING
        window_title            = 'abapGit Package'
        default_filename        = '*.zip'
        file_filter             = lv_filter
      CHANGING
        file_table              = lt_file_table
        rc                      = lv_rc
        user_action             = lv_action
      EXCEPTIONS
        file_open_dialog_failed = 1
        cntl_error              = 2
        error_no_gui            = 3
        not_supported_by_gui    = 4
        OTHERS                  = 5 ).
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
        DISPLAY LIKE 'E'.
      RETURN.
    ENDIF.

    IF lv_action = cl_gui_frontend_services=>action_cancel.
      RETURN.
    ENDIF.

    READ TABLE lt_file_table INDEX 1 INTO ls_file_table.
    ASSERT sy-subrc = 0.

    rv_file = ls_file_table-filename.

  ENDMETHOD.

  METHOD f4_transport.

    DATA:
      lv_obj_name   TYPE trobj_name,
      lv_order_type TYPE trfunction,
      lv_task_type  TYPE trfunction,
      lv_tarsystem  TYPE tr_target,
      lt_e071       TYPE TABLE OF e071,
      lt_e071k      TYPE TABLE OF e071k.

    lv_obj_name = iv_package.

    CALL FUNCTION 'TRINT_GET_REQUEST_TYPE'
      EXPORTING
        iv_pgmid                   = 'R3TR'
        iv_object                  = 'DEVC'
        iv_obj_name                = lv_obj_name
      IMPORTING
        ev_request_type            = lv_order_type
        ev_task_type               = lv_task_type
        ev_target                  = lv_tarsystem
      EXCEPTIONS
        internal_error             = 1
        no_request_needed          = 2
        cts_initialization_failure = 3
        OTHERS                     = 4.
    IF sy-subrc <> 0.
      lv_order_type = 'K'.
      lv_task_type  = 'S'.

      IF iv_layer IS INITIAL.
        CALL FUNCTION 'TR_GET_TRANSPORT_TARGET'
          EXPORTING
            iv_use_default             = abap_true
          IMPORTING
            ev_target                  = lv_tarsystem
          EXCEPTIONS
            wrong_call                 = 1
            invalid_input              = 2
            cts_initialization_failure = 3
            OTHERS                     = 4.
      ELSE.
        CALL FUNCTION 'TR_GET_TRANSPORT_TARGET'
          EXPORTING
            iv_transport_layer         = iv_layer
          IMPORTING
            ev_target                  = lv_tarsystem
          EXCEPTIONS
            wrong_call                 = 1
            invalid_input              = 2
            cts_initialization_failure = 3
            OTHERS                     = 4.
      ENDIF.
      IF sy-subrc <> 0.
        RETURN. " Ignore
      ENDIF.
    ENDIF.

    CALL FUNCTION 'TRINT_ORDER_CHOICE'
      EXPORTING
        wi_order_type          = lv_order_type
        wi_task_type           = lv_task_type
        wi_client              = sy-mandt
        wi_order               = iv_transport
        iv_tarsystem           = lv_tarsystem
      IMPORTING
        we_order               = rv_transport
      TABLES
        wt_e071                = lt_e071
        wt_e071k               = lt_e071k
      EXCEPTIONS
        no_correction_selected = 1
        display_mode           = 2
        object_append_error    = 3
        recursive_call         = 4
        wrong_order_type       = 5
        OTHERS                 = 6.
    IF sy-subrc <> 0.
      RETURN. " Ignore
    ENDIF.

  ENDMETHOD.

  METHOD header.
    WRITE iv_icon AS ICON TO rv_header.
    rv_header+6 = iv_text.
  ENDMETHOD.

  METHOD icon.

    DATA lv_info TYPE string.

    IF iv_info IS INITIAL.
      lv_info = iv_text.
    ELSE.
      lv_info = iv_info.
    ENDIF.

    CALL FUNCTION 'ICON_CREATE'
      EXPORTING
        name   = iv_name
        text   = iv_text
        info   = lv_info
      IMPORTING
        result = rv_icon.

  ENDMETHOD.

  METHOD modify.

    DATA:
      lv_show     TYPE abap_bool,
      lv_input    TYPE abap_bool,
      lv_password TYPE abap_bool.

    LOOP AT SCREEN.
      lv_show = abap_true.
      lv_input = abap_true.
      lv_password = abap_false.

      IF screen-name = 'P_FILE_F'.
        screen-length = 60.
      ENDIF.

      CASE screen-group1.
        WHEN 'T02'. " SAP Package
          lv_show = boolc( iv_options = abap_true AND iv_mbt = abap_false ).
        WHEN 'T03'. " Transport
          lv_show = abap_true. "boolc( iv_options = abap_true AND iv_mbt = abap_false )
        WHEN 'T04'. " Authentication
          lv_show = boolc( iv_zip_i = abap_true ).
        WHEN 'T05'. " Uninstall (only for SUBMIT)
          lv_show = abap_false.
        WHEN 'T08'. " Options
          lv_show = boolc( iv_options = abap_true AND iv_mbt = abap_false ).
        WHEN 'C11'.
          lv_input = boolc( iv_zip_i = abap_true ).
        WHEN 'C12'.
          lv_input = boolc( iv_zip_f = abap_true ).
        WHEN 'C13'.
          lv_input = boolc( iv_zip_s = abap_true ).
        WHEN 'C21'.
          lv_input = boolc( iv_sap_l = abap_true ).
        WHEN 'C22'.
          lv_input = boolc( iv_sap_t = abap_true ).
        WHEN 'C31'.
          lv_input = boolc( iv_tsp_e = abap_true ).
        WHEN 'C40'.
          lv_input = boolc( iv_conn_o = abap_true ).
        WHEN 'C41'.
          lv_input = boolc( iv_prox_o = abap_true ).
        WHEN 'P40'.
          lv_input = boolc( iv_conn_o = abap_true ).
          lv_password = abap_true.
        WHEN 'P41'.
          lv_input = boolc( iv_prox_o = abap_true ).
          lv_password = abap_true.
      ENDCASE.

      IF lv_show = abap_true.
        screen-active    = '1'.
        screen-invisible = '0'.
      ELSE.
        screen-active    = '0'.
        screen-invisible = '1'.
      ENDIF.

      IF lv_input = abap_true.
        screen-input = '1'.
      ELSE.
        screen-input = '0'.
      ENDIF.

      IF lv_password = abap_true.
        screen-invisible = '1'.
      ENDIF.

      MODIFY SCREEN.
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapinst_setup IMPLEMENTATION.

  METHOD run.

    gv_tabname = iv_tabname.
    gv_lock    = iv_lock.
    gv_text    = iv_text.

    IF _table_exists( ) = abap_false.
      _table_create( ).
    ENDIF.

    IF _lock_exists( ) = abap_false.
      _lock_create( ).
    ENDIF.

  ENDMETHOD.

  METHOD _get_package.

    IF sy-cprog CA '/'.
      " Fallback for namespaced installer
      rv_package = '$TMP'.
    ELSE.
      " Get package of main program
      SELECT SINGLE devclass FROM tadir INTO rv_package
        WHERE pgmid = 'R3TR' AND object = 'PROG' AND obj_name = sy-cprog.
      IF sy-subrc <> 0.
        rv_package = '$TMP'. " Fallback
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD _lock_create.

    DATA:
      lv_name  TYPE tadir-obj_name,
      lv_pack  TYPE devclass,
      ls_dd25v TYPE dd25v,
      lt_dd26e TYPE STANDARD TABLE OF dd26e WITH DEFAULT KEY,
      lt_dd27p TYPE STANDARD TABLE OF dd27p WITH DEFAULT KEY.

    FIELD-SYMBOLS:
      <ls_dd26e> LIKE LINE OF lt_dd26e,
      <ls_dd27p> LIKE LINE OF lt_dd27p.

    ls_dd25v-viewname   = gv_lock.
    ls_dd25v-aggtype    = 'E'.
    ls_dd25v-roottab    = gv_tabname.
    ls_dd25v-ddlanguage = zif_abapinst_definitions=>c_english.
    ls_dd25v-ddtext     = gv_text && ' - Lock'.

    APPEND INITIAL LINE TO lt_dd26e ASSIGNING <ls_dd26e>.
    <ls_dd26e>-viewname   = ls_dd25v-viewname.
    <ls_dd26e>-tabname    = ls_dd25v-roottab.
    <ls_dd26e>-tabpos     = '0001'.
    <ls_dd26e>-fortabname = ls_dd25v-roottab.
    <ls_dd26e>-enqmode    = 'E'.

    APPEND INITIAL LINE TO lt_dd27p ASSIGNING <ls_dd27p>.
    <ls_dd27p>-viewname  = ls_dd25v-viewname.
    <ls_dd27p>-objpos    = '0001'.
    <ls_dd27p>-viewfield = 'NAME'.
    <ls_dd27p>-tabname   = ls_dd25v-roottab.
    <ls_dd27p>-fieldname = 'NAME'.
    <ls_dd27p>-keyflag   = abap_true.

    APPEND INITIAL LINE TO lt_dd27p ASSIGNING <ls_dd27p>.
    <ls_dd27p>-viewname  = ls_dd25v-viewname.
    <ls_dd27p>-objpos    = '0002'.
    <ls_dd27p>-viewfield = 'PACK'.
    <ls_dd27p>-tabname   = ls_dd25v-roottab.
    <ls_dd27p>-fieldname = 'PACK'.
    <ls_dd27p>-keyflag   = abap_true.

    CALL FUNCTION 'DDIF_ENQU_PUT'
      EXPORTING
        name              = ls_dd25v-viewname
        dd25v_wa          = ls_dd25v
      TABLES
        dd26e_tab         = lt_dd26e
        dd27p_tab         = lt_dd27p
      EXCEPTIONS
        enqu_not_found    = 1
        name_inconsistent = 2
        enqu_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( |Setup failed: Creating enqueue { ls_dd25v-viewname }| ).
    ENDIF.

    lv_name = ls_dd25v-viewname.
    lv_pack = _get_package( ).

    CALL FUNCTION 'TR_TADIR_INTERFACE'
      EXPORTING
        wi_tadir_pgmid    = 'R3TR'
        wi_tadir_object   = 'ENQU'
        wi_tadir_obj_name = lv_name
        wi_set_genflag    = abap_true
        wi_test_modus     = abap_false
        wi_tadir_devclass = lv_pack
      EXCEPTIONS
        OTHERS            = 1.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( |Setup failed: TADIR for { ls_dd25v-viewname }| ).
    ENDIF.

    CALL FUNCTION 'DDIF_ENQU_ACTIVATE'
      EXPORTING
        name        = ls_dd25v-viewname
      EXCEPTIONS
        not_found   = 1
        put_failure = 2
        OTHERS      = 3.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( |Setup failed: Activating enqueue { ls_dd25v-viewname }| ).
    ENDIF.

  ENDMETHOD.

  METHOD _lock_exists.

    DATA: lv_viewname TYPE dd25l-viewname.

    SELECT SINGLE viewname FROM dd25l INTO lv_viewname WHERE viewname = gv_lock ##WARN_OK.
    rv_exists = boolc( sy-subrc = 0 ).

  ENDMETHOD.

  METHOD _table_create.

    DATA:
      lv_name  TYPE tadir-obj_name,
      lv_pack  TYPE devclass,
      lv_rc    TYPE sy-subrc,
      ls_dd02v TYPE dd02v,
      ls_dd09l TYPE dd09l,
      lt_dd03p TYPE STANDARD TABLE OF dd03p WITH DEFAULT KEY.

    FIELD-SYMBOLS:
      <ls_dd03p> LIKE LINE OF lt_dd03p.

    ls_dd02v-tabname    = gv_tabname.
    ls_dd02v-ddlanguage = zif_abapinst_definitions=>c_english.
    ls_dd02v-tabclass   = 'TRANSP'.
    ls_dd02v-ddtext     = gv_text && ' - Persistence'.
    ls_dd02v-contflag   = 'A'.
    ls_dd02v-exclass    = '1'.

    ls_dd09l-tabname  = ls_dd02v-tabname.
    ls_dd09l-as4local = 'A'.
    ls_dd09l-tabkat   = '1'.
    ls_dd09l-tabart   = 'APPL1'.
    ls_dd09l-bufallow = 'N'.

    APPEND INITIAL LINE TO lt_dd03p ASSIGNING <ls_dd03p>.
    <ls_dd03p>-tabname   = ls_dd02v-tabname.
    <ls_dd03p>-fieldname = 'NAME'.
    <ls_dd03p>-position  = '0001'.
    <ls_dd03p>-keyflag   = abap_true.
    <ls_dd03p>-notnull   = abap_true.
    <ls_dd03p>-datatype  = 'CHAR'.
    <ls_dd03p>-leng      = zif_abapinst_definitions=>c_name_length.

    APPEND INITIAL LINE TO lt_dd03p ASSIGNING <ls_dd03p>.
    <ls_dd03p>-tabname   = ls_dd02v-tabname.
    <ls_dd03p>-fieldname = 'PACK'.
    <ls_dd03p>-position  = '0002'.
    <ls_dd03p>-keyflag   = abap_true.
    <ls_dd03p>-notnull   = abap_true.
    <ls_dd03p>-rollname  = 'DEVCLASS'.

    APPEND INITIAL LINE TO lt_dd03p ASSIGNING <ls_dd03p>.
    <ls_dd03p>-tabname   = ls_dd02v-tabname.
    <ls_dd03p>-fieldname = 'JSON'.
    <ls_dd03p>-position  = '0003'.
    <ls_dd03p>-datatype  = 'STRG'.

    CALL FUNCTION 'DDIF_TABL_PUT'
      EXPORTING
        name              = ls_dd02v-tabname
        dd02v_wa          = ls_dd02v
        dd09l_wa          = ls_dd09l
      TABLES
        dd03p_tab         = lt_dd03p
      EXCEPTIONS
        tabl_not_found    = 1
        name_inconsistent = 2
        tabl_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( |Setup failed: Creating table { ls_dd02v-tabname }| ).
    ENDIF.

    lv_name = ls_dd02v-tabname.
    lv_pack = _get_package( ).

    CALL FUNCTION 'TR_TADIR_INTERFACE'
      EXPORTING
        wi_tadir_pgmid    = 'R3TR'
        wi_tadir_object   = 'TABL'
        wi_tadir_obj_name = lv_name
        wi_set_genflag    = abap_true
        wi_test_modus     = abap_false
        wi_tadir_devclass = lv_pack
      EXCEPTIONS
        OTHERS            = 1.
    IF sy-subrc <> 0.
      zcx_abapinst_exception=>raise( |Setup failed: TADIR for { ls_dd02v-tabname }| ).
    ENDIF.

    CALL FUNCTION 'DDIF_TABL_ACTIVATE'
      EXPORTING
        name        = ls_dd02v-tabname
        auth_chk    = abap_false
      IMPORTING
        rc          = lv_rc
      EXCEPTIONS
        not_found   = 1
        put_failure = 2
        OTHERS      = 3.
    IF sy-subrc <> 0 OR lv_rc <> 0.
      zcx_abapinst_exception=>raise( |Setup failed: Activating table { ls_dd02v-tabname }| ).
    ENDIF.

  ENDMETHOD.

  METHOD _table_exists.

    DATA: lv_tabname TYPE dd02l-tabname.

    SELECT SINGLE tabname FROM dd02l INTO lv_tabname WHERE tabname = gv_tabname ##WARN_OK.
    rv_exists = boolc( sy-subrc = 0 ).

  ENDMETHOD.
ENDCLASS.

CLASS zcl_abapinst_textpool IMPLEMENTATION.

  METHOD constructor.
    mv_program = iv_program.
    _load( ).
  ENDMETHOD.

  METHOD save.
    IF mt_text_new <> mt_text_old.
      INSERT TEXTPOOL mv_program FROM mt_text_new LANGUAGE sy-langu.
    ENDIF.
  ENDMETHOD.

  METHOD set.

    DATA:
      ls_param TYPE textpool,
      ls_text  TYPE textpool.

    SPLIT iv_param AT ',' INTO ls_param-id ls_param-key ls_param-entry.
    ASSERT sy-subrc = 0.

    READ TABLE mt_text_new INTO ls_text WITH KEY id = ls_param-id key = ls_param-key.
    IF sy-subrc = 0.
      DELETE mt_text_new WHERE id = ls_param-id AND key = ls_param-key.
    ENDIF.

    CLEAR ls_text.
    ls_text-id = ls_param-id.
    ls_text-key = ls_param-key.
    IF ls_param-id = 'S'.
      ls_text-entry+8 = ls_param-entry.
    ELSE.
      ls_text-entry = ls_param-entry.
    ENDIF.
    ls_text-length = strlen( ls_text-entry ).
    APPEND ls_text TO mt_text_new.

  ENDMETHOD.

  METHOD _load.
    READ TEXTPOOL mv_program INTO mt_text_old LANGUAGE sy-langu.
    mt_text_new = mt_text_old.
  ENDMETHOD.
ENDCLASS.

*&---------------------------------------------------------------------*
*&  Include           /MBTOOLS/MBT_TEMPLATE_1_DEFS
*&---------------------------------------------------------------------*
* Copyright 2021 Marc Bernard <https://marcbernardtools.com/>
* SPDX-License-Identifier: MIT

TABLES:
  sscrfields.

DATA:
  gv_options  TYPE abap_bool,
  gx_error    TYPE REF TO zcx_abapinst_exception,
  go_textpool TYPE REF TO zcl_abapinst_textpool,
  gs_inst     TYPE zif_abapinst_definitions=>ty_inst,
  gt_banner   TYPE zif_abapinst_definitions=>ty_base_tab.

*&---------------------------------------------------------------------*
*&  Include           /MBTOOLS/MBT_TEMPLATE_2_BANNER
*&---------------------------------------------------------------------*
* Copyright 2021 Marc Bernard <https://marcbernardtools.com/>
* SPDX-License-Identifier: MIT

CONSTANTS:
  c_banner_id   TYPE string VALUE '/MBTOOLS/MBT_INSTALLER',
  c_title       TYPE string VALUE 'MBT Installer',
  c_url_docs    TYPE string VALUE 'https://marcbernardtools.com/docs/marc-bernard-tools/installation/',
  c_url_license TYPE string VALUE 'https://marcbernardtools.com/company/terms-software/',
  c_url_home    TYPE string VALUE 'https://marcbernardtools.com/'.

CONSTANTS:
  c_tabname TYPE tabname  VALUE 'ZMBTINST',
  c_lock    TYPE viewname VALUE 'EZMBTINST'.

FORM banner.
  INSERT 'iVBORw0KGgoAAAANSUhEUgAAAMgAAAAdCAIAAABgybRVAAAALHRFWHRDcmVhdGlvbiBUaW1lAEZyaSAy' INTO TABLE gt_banner.
  INSERT 'NyBOb3YgMjAyMCAyMDoyNjoxOCAtMDUwMAhjuEsAAAAHdElNRQfkCxwBHSIH0G3NAAAACXBIWXMAAAsS' INTO TABLE gt_banner.
  INSERT 'AAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAAZ0Uk5TAO4A7gDuHYxM+gAABeBJREFUeNrtmzFM41YY' INTO TABLE gt_banner.
  INSERT 'x30IxMJwMFCdmJwERYroUKVeUjFhEXFZDql4QrK6BC8kZIhOsuhEFXHKEI4shgVZuslLuqQnX8MU3S1u' INTO TABLE gt_banner.
  INSERT 'VIYoUtoknhiOISwsLLR+thM/J3Gwk5dLAv4NyHnv8fdnv4/v+94HvPD5fLVaDUPK8fHx4uIiWs2ZmZmH' INTO TABLE gt_banner.
  INSERT 'hweEgoqFJEmiNdKlzSxyr8LUPUOuqXhVNBpFKHh+fo7cSJc2M+M2wOVp4jqWy0hwHctlJMyO24Bnj1zg' INTO TABLE gt_banner.
  INSERT 'TvNVcOWPxBgSR6uFUt0RFo4Vip4cJuNbPu1T7eN7+vXBl1D0D/4MGkv/dnD+xfadbi4/XPx1bTW78mNk' INTO TABLE gt_banner.
  INSERT '8/u15WVHxt/+fXlZv7WxcDH488aA71TmEkyuol4GkmJmBMfIWo7nJXBB+JWtR62FUt0JvRwrdPLv57gP' INTO TABLE gt_banner.
  INSERT 'GvBtxT//FzcvUsbOtiKBn1YPbPvWdaPRsJprNLJFwbO+/3Z3zYn5t81m08ayoQ6pFUlSdwYLDKPy3Oiu' INTO TABLE gt_banner.
  INSERT 'sUInvMmr+uGL8ychdMY0itl3lzfjfiUuKOiKWNHDtluBbPd7JfDGyIlg8P1eGhrzxQ+jB68ddoQ8nvWV' INTO TABLE gt_banner.
  INSERT 'FdPIdbGoBbOG8Km8YTtqvfR6vVA0ur2t6wFsackL99KWXo7j3T5rOh0rFFjVr2pqXaVcnJexdmr8uLd6' INTO TABLE gt_banner.
  INSERT 'cG4eWw0oMct+qQVYiex2+s7mq3e/CqpvFa/Ku2v2PGsR/8FUOsmX9T81x1oMbgxaVD2GUg6LGAPKFVku' INTO TABLE gt_banner.
  INSERT 'iKdprQALbCdjYRLvuidYI+ar1c5xfyzD4KCAO61WJH1Myp0mqp1LoPsmmDSvZ2WMoFNJvRhXJkSvaand' INTO TABLE gt_banner.
  INSERT 'B4EFYUXzY6ofCmI+X+1plwXOToW1f8pDb0xvlr9TQlhjeJ1vQC3HsrkqHajoVbGKJFE8q+wNB710mQsH' INTO TABLE gt_banner.
  INSERT 'Wam3CB3JYDhWr/I8bwxKsKK+xEJJ4llww5SQrFIUTwvtpfYoJMIUbzatpVgStScAj1n1lSJ5pmMlZFcf' INTO TABLE gt_banner.
  INSERT 'JqPdcFP+kC/q155Xzo6GY8HsAsYoG8R8Te3oWEhYepUz+vinxFLUQIIUb2GaxAYTrSfAMJ4K8vZ1TYzF' INTO TABLE gt_banner.
  INSERT 'sYrZvaLV3HpkYwocqw1IIBFfLZ9m9a3iqURE2RiZS7e2hCDoQNeB0u8FX71+mqaNyEfQdKBzicwxrClb' INTO TABLE gt_banner.
  INSERT 'hZXhupKCWX4wt4UFFUWBi3kx8TTI6uYSqVjPpoRhm2bXY0xGxGrhoY6ctRvGSztvkCQZ9rfiCp8vZEjj' INTO TABLE gt_banner.
  INSERT '5dN9ul84k8nIXEUvdIjt7upFFnMtL6CFtpDyfdANHQEJtswvJFpeBe7Ro36ihVLGaW91sn6l0xAupqjd' INTO TABLE gt_banner.
  INSERT 'QGyHjbeNh7cJ/bJSkzHc14o9PLUUhkgkuIJs/x71atuvImb3xJkkPYDRkGAS+JCaF/XnSZV6/QiAGOb8' INTO TABLE gt_banner.
  INSERT 'IDSWiLW+f7Rpync3ny6yWr/BWbthgiEjNNYqzCUJrvKV+gyqkfsj1yr6FdGdgbx+xZUdxqwOQSgv9g5W' INTO TABLE gt_banner.
  INSERT 'AzOmiLVsZm33F8qjTxWvRnXy/LaQmVKKsJqUWIazE7eMwNcDI/jYBxasG+cLi2A1BJNVYz0tcEZsMnKh' INTO TABLE gt_banner.
  INSERT 'UIfGamlK20upqgyDCKFutXkIoh2VpJwoM6a+lnE8cIIhaJwo9WBV4DgvgypqjcWxrr+WzVHp61VeaDWx' INTO TABLE gt_banner.
  INSERT 'pqLdYANZ1kKS12vKYYGu7GUkTZ4KY+opTQUH7VZQurGS5ghBMNtuijKDNTMMQR0tWAFB0IPIYfZy9KOM' INTO TABLE gt_banner.
  INSERT 'xbEaQjZrNTdl7QYrlOKl/5kNqpnIWIrg9TgGdY5oAfSTQI3O6uW1EmSC7LCWwYKaaHCJhT9BfawhmKxT' INTO TABLE gt_banner.
  INSERT '4ZS1GwaHSHFQXFBypkBb1mP9ijWCtv4+S/oLCmiKrYlxLM86tX/09klEq0dQ9q473ZAZsSSkaKLnhiuO' INTO TABLE gt_banner.
  INSERT 'p06aVIBMU8xkuJRz1wLVX6nTl1VFZH9x9mIUr+7s7GwUssj/S2dnZ2cUdo4SrXLDcXSNAfSKKu6pcLpA' INTO TABLE gt_banner.
  INSERT '7gAjUFSZmFTo8rRwHctlJLiO5TISZhcWFu7u7tCK3t/fz8/PI7cV7T/Fz83NIbfQpc3/q1uUaEN2fD4A' INTO TABLE gt_banner.
  INSERT 'AAAASUVORK5CYIIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' INTO TABLE gt_banner.
  INSERT 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA                    ' INTO TABLE gt_banner.
ENDFORM.

*&---------------------------------------------------------------------*
*&  Include           /MBTOOLS/MBT_TEMPLATE_3_SCREEN
*&---------------------------------------------------------------------*
* Copyright 2021 Marc Bernard <https://marcbernardtools.com/>
* SPDX-License-Identifier: MIT

" Function Keys
SELECTION-SCREEN FUNCTION KEY: 1, 2.

*-----------------------------------------------------------------------

" Source Package
SELECTION-SCREEN BEGIN OF SCREEN 100 AS SUBSCREEN.

SELECTION-SCREEN BEGIN OF BLOCK b100 WITH FRAME.
SELECTION-SCREEN COMMENT:
   /1(77) sc_t100,
   /1(77) sc_t101.
SELECTION-SCREEN END OF BLOCK b100.

SELECTION-SCREEN BEGIN OF BLOCK b110 WITH FRAME.

PARAMETERS:
  p_zip_f RADIOBUTTON GROUP g1 DEFAULT 'X' USER-COMMAND c100.
SELECTION-SCREEN: SKIP, BEGIN OF LINE, POSITION 4,
  COMMENT (22) sc_t103 FOR FIELD p_file_f.
PARAMETERS:
  p_file_f TYPE string LOWER CASE
    DEFAULT 'C:\Tmp\MBT-Package-Manager-main.zip' MODIF ID c12.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN SKIP 2.
PARAMETERS:
  p_zip_s RADIOBUTTON GROUP g1.
SELECTION-SCREEN: SKIP, BEGIN OF LINE, POSITION 4,
  COMMENT (22) sc_t104 FOR FIELD p_file_s.
PARAMETERS:
  p_file_s TYPE string LOWER CASE
    DEFAULT 'MBT-Package-Manager-main.zip' MODIF ID c13.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN SKIP 2.
PARAMETERS:
  p_zip_i RADIOBUTTON GROUP g1.
SELECTION-SCREEN: SKIP, BEGIN OF LINE, POSITION 4,
  COMMENT (22) sc_t102 FOR FIELD p_file_i.
PARAMETERS:
  p_file_i TYPE string LOWER CASE
    DEFAULT 'https://github.com/Marc-Bernard-Tools/MBT-Package-Manager/archive/main.zip' MODIF ID c11.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END OF BLOCK b110.

SELECTION-SCREEN END OF SCREEN 100.

*-----------------------------------------------------------------------

" Target Package
SELECTION-SCREEN BEGIN OF SCREEN 200 AS SUBSCREEN.

SELECTION-SCREEN BEGIN OF BLOCK b200 WITH FRAME.
SELECTION-SCREEN COMMENT:
   /1(77) sc_t200,
   /1(77) sc_t201.
SELECTION-SCREEN END OF BLOCK b200.

SELECTION-SCREEN BEGIN OF BLOCK b210 WITH FRAME.

PARAMETERS:
  p_sap_d RADIOBUTTON GROUP g2 DEFAULT 'X' USER-COMMAND c200.

SELECTION-SCREEN SKIP 2.
PARAMETERS:
  p_sap_l RADIOBUTTON GROUP g2.
SELECTION-SCREEN: SKIP, BEGIN OF LINE, POSITION 4.
PARAMETERS:
  p_pack_l TYPE devclass DEFAULT '' MODIF ID c21.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN SKIP 2.
PARAMETERS:
  p_sap_t RADIOBUTTON GROUP g2.
SELECTION-SCREEN: SKIP, BEGIN OF LINE, POSITION 4.
PARAMETERS:
  p_pack_t TYPE pbpackdata-devclass  DEFAULT '' MODIF ID c22,
  p_soft_t TYPE pbpackdata-dlvunit   DEFAULT '' MODIF ID c22,
  p_layr_t TYPE pbpackdata-pdevclass DEFAULT '' MODIF ID c22.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN SKIP 2.
SELECTION-SCREEN END OF BLOCK b210.

SELECTION-SCREEN END OF SCREEN 200.

*-----------------------------------------------------------------------

" Transport
SELECTION-SCREEN BEGIN OF SCREEN 300 AS SUBSCREEN.

SELECTION-SCREEN BEGIN OF BLOCK b300 WITH FRAME.
SELECTION-SCREEN COMMENT:
   /1(77) sc_t300,
   /1(77) sc_t301.
SELECTION-SCREEN END OF BLOCK b300.

SELECTION-SCREEN BEGIN OF BLOCK b310 WITH FRAME.

PARAMETERS:
  p_tsp_n RADIOBUTTON GROUP g3 USER-COMMAND c300.

SELECTION-SCREEN SKIP 2.
PARAMETERS:
  p_tsp_e RADIOBUTTON GROUP g3.
SELECTION-SCREEN: SKIP, BEGIN OF LINE, POSITION 4.
PARAMETERS:
  p_req_e TYPE trkorr MODIF ID c31.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN SKIP.

SELECTION-SCREEN SKIP 6.
SELECTION-SCREEN END OF BLOCK b310.

SELECTION-SCREEN END OF SCREEN 300.

*-----------------------------------------------------------------------

" Authentication
SELECTION-SCREEN BEGIN OF SCREEN 400 AS SUBSCREEN.

SELECTION-SCREEN BEGIN OF BLOCK b400 WITH FRAME.
SELECTION-SCREEN COMMENT:
   /1(77) sc_t400,
   /1(77) sc_t401.
SELECTION-SCREEN END OF BLOCK b400.

SELECTION-SCREEN BEGIN OF BLOCK b410 WITH FRAME.

PARAMETERS:
  p_conn_o AS CHECKBOX USER-COMMAND c400.
SELECTION-SCREEN: SKIP, BEGIN OF LINE, POSITION 4,
  COMMENT (22) sc_t402 FOR FIELD p_conn_u.
PARAMETERS:
  p_conn_u TYPE string LOWER CASE MODIF ID c40.
SELECTION-SCREEN: END OF LINE, BEGIN OF LINE, POSITION 4,
  COMMENT (22) sc_t403 FOR FIELD p_conn_p.
PARAMETERS:
  p_conn_p TYPE string LOWER CASE MODIF ID p40.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN SKIP 2.

PARAMETERS:
  p_prox_o AS CHECKBOX USER-COMMAND c410.
SELECTION-SCREEN: SKIP, BEGIN OF LINE, POSITION 4,
  COMMENT (22) sc_t404 FOR FIELD p_prox_h.
PARAMETERS:
  p_prox_h TYPE string LOWER CASE MODIF ID c41.
SELECTION-SCREEN: END OF LINE, BEGIN OF LINE, POSITION 4,
  COMMENT (22) sc_t405 FOR FIELD p_prox_s.
PARAMETERS:
  p_prox_s TYPE char5 MODIF ID c41.
SELECTION-SCREEN: END OF LINE, BEGIN OF LINE, POSITION 4,
  COMMENT (22) sc_t406 FOR FIELD p_prox_u.
PARAMETERS:
  p_prox_u TYPE string LOWER CASE MODIF ID c41.
SELECTION-SCREEN: END OF LINE, BEGIN OF LINE, POSITION 4,
  COMMENT (22) sc_t407 FOR FIELD p_prox_p.
PARAMETERS:
  p_prox_p TYPE string LOWER CASE MODIF ID p41.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN SKIP 1.
SELECTION-SCREEN END OF BLOCK b410.

SELECTION-SCREEN END OF SCREEN 400.

*-----------------------------------------------------------------------

" Uninstall (hidden)
SELECTION-SCREEN BEGIN OF SCREEN 500 AS SUBSCREEN.

SELECTION-SCREEN BEGIN OF BLOCK b500 WITH FRAME.
SELECTION-SCREEN COMMENT:
      /1(77) sc_t500,
      /1(77) sc_t501.
SELECTION-SCREEN END OF BLOCK b500.

SELECTION-SCREEN BEGIN OF BLOCK b510 WITH FRAME.

SELECTION-SCREEN COMMENT:
   /1(77) sc_t510.
SELECTION-SCREEN SKIP.
PARAMETERS:
  p_drop_n TYPE zif_abapinst_definitions=>ty_name.
SELECTION-SCREEN SKIP.
PARAMETERS:
  p_drop_p TYPE zif_abapinst_definitions=>ty_pack.

SELECTION-SCREEN SKIP 8.
SELECTION-SCREEN END OF BLOCK b510.

SELECTION-SCREEN END OF SCREEN 500.

*-----------------------------------------------------------------------

" Options
SELECTION-SCREEN BEGIN OF SCREEN 800 AS SUBSCREEN.

SELECTION-SCREEN BEGIN OF BLOCK b800 WITH FRAME.
SELECTION-SCREEN COMMENT:
      /1(77) sc_t800,
      /1(77) sc_t801.
SELECTION-SCREEN END OF BLOCK b800.

SELECTION-SCREEN BEGIN OF BLOCK b810 WITH FRAME.

SELECTION-SCREEN COMMENT:
   /1(77) sc_t810.
SELECTION-SCREEN SKIP.
PARAMETERS:
  p_fold_d RADIOBUTTON GROUP g8 DEFAULT 'X'.
SELECTION-SCREEN SKIP.
PARAMETERS:
  p_fold_p RADIOBUTTON GROUP g8.
SELECTION-SCREEN SKIP.
PARAMETERS:
  p_fold_f RADIOBUTTON GROUP g8.

SELECTION-SCREEN SKIP 4.
SELECTION-SCREEN END OF BLOCK b810.

SELECTION-SCREEN END OF SCREEN 800.

*-----------------------------------------------------------------------

" About
SELECTION-SCREEN:
  BEGIN OF SCREEN 900 AS SUBSCREEN,
    BEGIN OF BLOCK b900 WITH FRAME,
      COMMENT /1(50) sc_t900,
      COMMENT 60(25) sc_t901,
      SKIP,
      COMMENT /1(77) sc_t902,
    END OF BLOCK b900,
    BEGIN OF BLOCK b910 WITH FRAME,
      PUSHBUTTON /1(55) b_docu USER-COMMAND docu,
      SKIP,
      PUSHBUTTON /1(55) b_lice USER-COMMAND lice,
      SKIP,
      PUSHBUTTON /1(55) b_home USER-COMMAND home,
    END OF BLOCK b910,
  END OF SCREEN 900.

*-----------------------------------------------------------------------

" Header
SELECTION-SCREEN:
  BEGIN OF BLOCK sc_header,
    SKIP,
    SKIP,
    COMMENT /3(77) sc_t001 FOR FIELD p_zip_f,
    SKIP,
  END OF BLOCK sc_header,
  BEGIN OF TABBED BLOCK sc_tab FOR 19 LINES,
    TAB (40) sc_tab1 USER-COMMAND sc_push1
      DEFAULT SCREEN 0100 MODIF ID t01,
    TAB (40) sc_tab2 USER-COMMAND sc_push2
      DEFAULT SCREEN 0200 MODIF ID t02,
    TAB (40) sc_tab3 USER-COMMAND sc_push3
      DEFAULT SCREEN 0300 MODIF ID t03,
    TAB (40) sc_tab4 USER-COMMAND sc_push4
      DEFAULT SCREEN 0400 MODIF ID t04,
    TAB (40) sc_tab5 USER-COMMAND sc_push5
      DEFAULT SCREEN 0500 MODIF ID t05,
    TAB (40) sc_tab8 USER-COMMAND sc_push8
      DEFAULT SCREEN 0800 MODIF ID t08,
    TAB (40) sc_tab9 USER-COMMAND sc_push9
      DEFAULT SCREEN 0900,
  END OF BLOCK sc_tab.

*&---------------------------------------------------------------------*
*&  Include           /MBTOOLS/MBT_TEMPLATE_4_INIT
*&---------------------------------------------------------------------*
* Copyright 2021 Marc Bernard <https://marcbernardtools.com/>
* SPDX-License-Identifier: MIT

INITIALIZATION.

* Setup
  TRY.
      zcl_abapinst_setup=>run(
        iv_tabname = c_tabname
        iv_lock    = c_lock
        iv_text    = |Generated by { c_title }| ).

      zcl_abapinst_installer=>init(
        iv_tabname = c_tabname
        iv_lock    = c_lock
        iv_name    = 'Marc Bernard Tool'
        iv_names   = 'Marc Bernard Tools' ).
    CATCH zcx_abapinst_exception INTO gx_error.
      MESSAGE gx_error TYPE 'E' DISPLAY LIKE 'I'.
      STOP.
  ENDTRY.

* Textpool
  CREATE OBJECT go_textpool EXPORTING iv_program = sy-cprog.

  go_textpool->set( 'R,,' && c_title ).
  go_textpool->set( 'S,P_CONN_O,Internet Server' ).
  go_textpool->set( 'S,P_CONN_P,Password' ).
  go_textpool->set( 'S,P_CONN_U,User' ).
  go_textpool->set( 'S,P_DROP_N,abapGit Package' ).
  go_textpool->set( 'S,P_DROP_P,SAP Package' ).
  go_textpool->set( 'S,P_FILE_F,Your Computer' ).
  go_textpool->set( 'S,P_FILE_I,Internet' ).
  go_textpool->set( 'S,P_FILE_S,Application Server' ).
  go_textpool->set( 'S,P_FOLD_D,Default (from abapGit Package)' ).
  go_textpool->set( 'S,P_FOLD_F,Full' ).
  go_textpool->set( 'S,P_FOLD_P,Prefix' ).
  go_textpool->set( 'S,P_LAYR_T,Transport Layer' ).
  go_textpool->set( 'S,P_PACK_L,Local Package' ).
  go_textpool->set( 'S,P_PACK_T,Transportable Package' ).
  go_textpool->set( 'S,P_PROX_H,Host' ).
  go_textpool->set( 'S,P_PROX_O,Internet Proxy' ).
  go_textpool->set( 'S,P_PROX_P,Password' ).
  go_textpool->set( 'S,P_PROX_S,Port' ).
  go_textpool->set( 'S,P_PROX_U,User' ).
  go_textpool->set( 'S,P_REQ_E,Transport Request' ).
  go_textpool->set( 'S,P_SAP_D,Default (from abapGit Package)' ).
  go_textpool->set( 'S,P_SAP_L,Local Package' ).
  go_textpool->set( 'S,P_SAP_T,Transportable Package' ).
  go_textpool->set( 'S,P_SOFT_T,Software Component' ).
  go_textpool->set( 'S,P_TSP_E,Use Existing Transport' ).
  go_textpool->set( 'S,P_TSP_N,Create New Transport' ).
  go_textpool->set( 'S,P_ZIP_F,Local File' ).
  go_textpool->set( 'S,P_ZIP_I,Internet' ).
  go_textpool->set( 'S,P_ZIP_S,Application Server' ).

  go_textpool->save( ).

*-----------------------------------------------------------------------

* Function Keys
  sscrfields-functxt_01 = icon_install_package && 'List Packages'.
  sscrfields-functxt_02 = icon_delete && 'Uninstall Package'.

* Header
  sc_t001 = 'An Installer for Marc Bernard Tools'.

*-----------------------------------------------------------------------

* Source Tab
  sc_tab1 = zcl_abapinst_screen=>header( iv_icon = icon_install_package
                                          iv_text = 'MBT Package' ).

  sc_t100 =
  'Select the source of your MBT installation package.'.
  sc_t101 =
  'The package must be a zip file that contains code and objects of the tool.'.

  sc_t102 = 'URL'.
  sc_t103 = 'File name'.
  sc_t104 = 'File name (EPS Inbox)'.

*-----------------------------------------------------------------------

* Target Tab
  sc_tab2 = zcl_abapinst_screen=>header( iv_icon = icon_package_standard
                                          iv_text = 'SAP Package' ).

  sc_t200 =
  'Select the target SAP package for your installation.'.
  sc_t201 =
  'If the package does not exist, it will be created automatically.'.

*-----------------------------------------------------------------------

* Transport Tab
  sc_tab3 = zcl_abapinst_screen=>header( iv_icon = icon_transport
                                          iv_text = 'Transport' ).

  sc_t300 =
  'When installing into a transportable package, decide if you want to create'.
  sc_t301 =
  'a new transport request or select an existing one.'.

*-----------------------------------------------------------------------

* Authentication Tab
  sc_tab4 = zcl_abapinst_screen=>header( iv_icon = icon_connect
                                          iv_text = 'Authentication' ).

  sc_t400 =
  'When downloading the MBT package from the Internet, you might have to'.
  sc_t401 =
  'authenticate yourself at the server and/or your proxy.'.

  sc_t402 = 'User'.
  sc_t403 = 'Password'.
  sc_t404 = 'Proxy Host'.
  sc_t405 = 'Proxy Port'.
  sc_t406 = 'Proxy User'.
  sc_t407 = 'Proxy Password'.

*-----------------------------------------------------------------------

* Uninstall Tab
  sc_tab5 = zcl_abapinst_screen=>header( iv_icon = icon_delete
                                          iv_text = 'Uninstall' ).

  sc_t500 =
  'Select the MBT package that you want to uninstall'.
  sc_t501 =
  ''.

  sc_t510 = 'Uninstall Options:'.

*-----------------------------------------------------------------------

* Options Tab
  sc_tab8 = zcl_abapinst_screen=>header( iv_icon = icon_icon_list
                                          iv_text = 'Options' ).

  sc_t800 =
  'You can select the folder logic to be used and whether you want only'.
  sc_t801 =
  'the main language of the package to be installed.'.

  sc_t810 = 'Folder Logic:'.

*-----------------------------------------------------------------------

* About Tab
  sc_tab9 = zcl_abapinst_screen=>header( iv_icon = icon_system_help
                                          iv_text = 'About' ).

  sc_t900 = |{ c_title }|.
  sc_t901 = |Version { c_version }|.
  sc_t902 = |Copyright { sy-datum(4) } Marc Bernard Tools|.

  b_docu = zcl_abapinst_screen=>icon( iv_name = icon_system_extended_help
                                      iv_text = 'Documentation'
                                      iv_info = c_github ).
  b_lice = zcl_abapinst_screen=>icon( iv_name = icon_legal_reg
                                      iv_text = 'License Terms'
                                      iv_info = c_github ).
  b_home = zcl_abapinst_screen=>icon( iv_name = icon_url
                                      iv_text = 'MarcBernardTools.com'
                                      iv_info = 'MBT Website' ).

*&---------------------------------------------------------------------*
*&  Include           /MBTOOLS/MBT_TEMPLATE_5_AT
*&---------------------------------------------------------------------*
* Copyright 2021 Marc Bernard <https://marcbernardtools.com/>
* SPDX-License-Identifier: MIT

AT SELECTION-SCREEN.

  zcl_abapinst_screen=>modify(
    iv_options = gv_options
    iv_zip_i   = p_zip_i
    iv_zip_f   = p_zip_f
    iv_zip_s   = p_zip_s
    iv_sap_l   = p_sap_l
    iv_sap_t   = p_sap_t
    iv_tsp_e   = p_tsp_e
    iv_conn_o  = p_conn_o
    iv_prox_o  = p_prox_o
    iv_mbt     = abap_true ).

  CHECK sy-dynnr <> '1000'.

  CASE sscrfields-ucomm.

*   Function Keys
    WHEN 'FC01'. " List Packages
      zcl_abapinst_screen=>banner( iv_show = abap_false ).
      TRY.
          zcl_abapinst_installer=>list( ).

        CATCH zcx_abapinst_exception INTO gx_error.
          MESSAGE gx_error TYPE 'S' DISPLAY LIKE 'E'.
      ENDTRY.

    WHEN 'FC02'. " Uninstall Package
      zcl_abapinst_screen=>banner( iv_show = abap_false ).
      TRY.
          gs_inst = zcl_abapinst_installer=>f4( ).

          IF gs_inst IS NOT INITIAL.
            zcl_abapinst_installer=>uninstall(
              iv_name = gs_inst-name
              iv_pack = gs_inst-pack ).
          ENDIF.

        CATCH zcx_abapinst_exception INTO gx_error.
          MESSAGE gx_error TYPE 'S' DISPLAY LIKE 'E'.
      ENDTRY.

*   About
    WHEN 'DOCU'. " Documentation
      zcl_abapinst_screen=>browser( c_url_docs ).

    WHEN 'LICE'. " License
      zcl_abapinst_screen=>browser( c_url_license ).

    WHEN 'HOME'. " Website
      zcl_abapinst_screen=>browser( c_url_home ).

  ENDCASE.

AT SELECTION-SCREEN OUTPUT.

  PERFORM banner.

*  zcl_abapinst_screen=>banner( iv_id = c_banner_id )
  zcl_abapinst_screen=>banner( it_base = gt_banner ).

  zcl_abapinst_screen=>modify(
    iv_options = gv_options
    iv_zip_i   = p_zip_i
    iv_zip_f   = p_zip_f
    iv_zip_s   = p_zip_s
    iv_sap_l   = p_sap_l
    iv_sap_t   = p_sap_t
    iv_tsp_e   = p_tsp_e
    iv_conn_o  = p_conn_o
    iv_prox_o  = p_prox_o
    iv_mbt     = abap_true ).

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_file_f.

  p_file_f = zcl_abapinst_screen=>f4_file( ).

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_req_e.

  p_req_e = zcl_abapinst_screen=>f4_transport(
              iv_package = p_pack_t
              iv_layer   = p_layr_t ).

*&---------------------------------------------------------------------*
*&  Include           /MBTOOLS/MBT_TEMPLATE_6_START
*&---------------------------------------------------------------------*
* Copyright 2021 Marc Bernard <https://marcbernardtools.com/>
* SPDX-License-Identifier: MIT

START-OF-SELECTION.

  DATA:
    lv_enum_zip          TYPE i,
    lv_name              TYPE char255,
    lv_package           TYPE devclass,
    lv_enum_package      TYPE i,
    lv_enum_transport    TYPE i,
    lv_enum_folder_logic TYPE i.

  CASE abap_true.
    WHEN p_zip_f.
      lv_enum_zip = zcl_abapinst_installer=>c_enum_zip-local.
      lv_name     = p_file_f.
    WHEN p_zip_i.
      lv_enum_zip = zcl_abapinst_installer=>c_enum_zip-internet.
      lv_name     = p_file_i.
    WHEN p_zip_s.
      lv_enum_zip = zcl_abapinst_installer=>c_enum_zip-server.
      lv_name     = p_file_s.
  ENDCASE.

  CASE abap_true.
    WHEN p_sap_d.
      lv_enum_package = zcl_abapinst_installer=>c_enum_package-default.
    WHEN p_sap_l.
      lv_enum_package = zcl_abapinst_installer=>c_enum_package-local.
      lv_package      = p_pack_l.
    WHEN p_sap_t.
      lv_enum_package = zcl_abapinst_installer=>c_enum_package-transportable.
      lv_package      = p_pack_t.
  ENDCASE.

  CASE abap_true.
    WHEN p_tsp_n.
      lv_enum_transport = zcl_abapinst_installer=>c_enum_transport-prompt.
    WHEN p_tsp_e.
      lv_enum_transport = zcl_abapinst_installer=>c_enum_transport-existing.
  ENDCASE.

  IF p_conn_o = abap_false.
    CLEAR: p_conn_u, p_conn_p.
  ENDIF.

  IF p_prox_o = abap_false.
    CLEAR: p_prox_h, p_prox_s, p_prox_u, p_prox_p.
  ENDIF.

  CASE abap_true.
    WHEN p_fold_d.
      lv_enum_folder_logic = zcl_abapinst_installer=>c_enum_folder_logic-default.
    WHEN p_fold_p.
      lv_enum_folder_logic = zcl_abapinst_installer=>c_enum_folder_logic-prefix.
    WHEN p_fold_f.
      lv_enum_folder_logic = zcl_abapinst_installer=>c_enum_folder_logic-full.
  ENDCASE.

  zcl_abapinst_screen=>banner( iv_show = abap_false ).

  TRY.
      IF p_drop_n IS INITIAL.

        zcl_abapinst_installer=>install(
          iv_enum_zip          = lv_enum_zip
          iv_name              = lv_name
          iv_enum_package      = lv_enum_package
          iv_package           = lv_package
          iv_dlvunit           = p_soft_t
          iv_devlayer          = p_layr_t
          iv_enum_transport    = lv_enum_transport
          iv_transport         = p_req_e
          iv_user              = |{ p_conn_u }|
          iv_password          = |{ p_conn_p }|
          iv_proxy_host        = |{ p_prox_h }|
          iv_proxy_service     = |{ p_prox_s }|
          iv_proxy_user        = |{ p_prox_u }|
          iv_proxy_password    = |{ p_prox_p }|
          iv_enum_folder_logic = lv_enum_folder_logic ).

      ELSE.

        zcl_abapinst_installer=>uninstall(
          iv_name = p_drop_n
          iv_pack = p_drop_p ).

      ENDIF.
    CATCH zcx_abapinst_exception INTO gx_error.
      MESSAGE gx_error TYPE 'S' DISPLAY LIKE 'E'.
  ENDTRY.

